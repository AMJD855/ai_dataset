{"repo": "sqlite", "file": "btmutex.c", "lang": "C++", "code": "/*\n** 2007 August 27\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains code used to implement mutexes on Btree objects.\n** This code really belongs in btree.c.  But btree.c is getting too\n** big and we want to break it down some.  This packaged seemed like\n** a good breakout.\n*/\n#include \"btreeInt.h\"\n#ifndef SQLITE_OMIT_SHARED_CACHE\n#if SQLITE_THREADSAFE\n\n/*\n** Obtain the BtShared mutex associated with B-Tree handle p. Also,\n** set BtShared.db to the database handle associated with p and the\n** p->locked boolean to true.\n*/\nstatic void lockBtreeMutex(Btree *p){\n  assert( p->locked==0 );\n  assert( sqlite3_mutex_notheld(p->pBt->mutex) );\n  assert( sqlite3_mutex_held(p->db->mutex) );\n\n  sqlite3_mutex_enter(p->pBt->mutex);\n  p->pBt->db = p->db;\n  p->locked = 1;\n}\n\n/*\n** Release the BtShared mutex associated with B-Tree handle p and\n** clear the p->locked boolean.\n*/\nstatic void SQLITE_NOINLINE unlockBtreeMutex(Btree *p){\n  BtShared *pBt = p->pBt;\n  assert( p->locked==1 );\n  assert( sqlite3_mutex_held(pBt->mutex) );\n  assert( sqlite3_mutex_held(p->db->mutex) );\n  assert( p->db==pBt->db );\n\n  sqlite3_mutex_leave(pBt->mutex);\n  p->locked = 0;\n}\n\n/* Forward reference */\nstatic void SQLITE_NOINLINE btreeLockCarefully(Btree *p);\n\n/*\n** Enter a mutex on the given BTree object.\n**\n** If the object is not sharable, then no mutex is ever required\n** and this routine is a no-op.  The underlying mutex is non-recursive.\n** But we keep a reference count in Btree.wantToLock so the behavior\n** of this interface is recursive.\n**\n** To avoid deadlocks, multiple Btrees are locked in the same order\n** by all database connections.  The p->pNext is a list of other\n** Btrees belonging to the same database connection as the p Btree\n** which need to be locked after p.  If we cannot get a lock on\n** p, then first unlock all of the others on p->pNext, then wait\n** for the lock to become available on p, then relock all of the\n** subsequent Btrees that desire a lock.\n*/\nvoid sqlite3BtreeEnter(Btree *p){\n  /* Some basic sanity checking on the Btree.  The list of Btrees\n  ** connected by pNext and pPrev should be in sorted order by\n  ** Btree.pBt value. All elements of the list should belong to\n  ** the same connection. Only shared Btrees are on the list. */\n  assert( p->pNext==0 || p->pNext->pBt>p->pBt );\n  assert( p->pPrev==0 || p->pPrev->pBt<p->pBt );\n  assert( p->pNext==0 || p->pNext->db==p->db );\n  assert( p->pPrev==0 || p->pPrev->db==p->db );\n  assert( p->sharable || (p->pNext==0 && p->pPrev==0) );\n\n  /* Check for locking consistency */\n  assert( !p->locked || p->wantToLock>0 );\n  assert( p->sharable || p->wantToLock==0 );\n\n  /* We should already hold a lock on the database connection */\n  assert( sqlite3_mutex_held(p->db->mutex) );\n\n  /* Unless the database is sharable and unlocked, then BtShared.db\n  ** should already be set correctly. */\n  assert( (p->locked==0 && p->sharable) || p->pBt->db==p->db );\n\n  if( !p->sharable ) return;\n  p->wantToLock++;\n  if( p->locked ) return;\n  btreeLockCarefully(p);\n}\n\n/* This is a helper function for sqlite3BtreeLock(). By moving\n** complex, but seldom used logic, out of sqlite3BtreeLock() and\n** into this routine, we avoid unnecessary stack pointer changes\n** and thus help the sqlite3BtreeLock() routine to run much faster\n** in the common case.\n*/\nstatic void SQLITE_NOINLINE btreeLockCarefully(Btree *p){\n  Btree *pLater;\n\n  /* In most cases, we should be able to acquire the lock we\n  ** want without having to go through the ascending lock\n  ** procedure that follows.  Just be sure not to block.\n  */\n  if( sqlite3_mutex_try(p->pBt->mutex)==SQLITE_OK ){\n    p->pBt->db = p->db;\n    p->locked = 1;\n    return;\n  }\n\n  /* To avoid deadlock, first release all locks with a larger\n  ** BtShared address.  Then acquire our lock.  Then reacquire\n  ** the other BtShared locks that we used to hold in ascending\n  ** order.\n  */\n  for(pLater=p->pNext; pLater; pLater=pLater->pNext){\n    assert( pLater->sharable );\n    assert( pLater->pNext==0 || pLater->pNext->pBt>pLater->pBt );\n    assert( !pLater->locked || pLater->wantToLock>0 );\n    if( pLater->locked ){\n      unlockBtreeMutex(pLater);\n    }\n  }\n  lockBtreeMutex(p);\n  for(pLater=p->pNext; pLater; pLater=pLater->pNext){\n    if( pLater->wantToLock ){\n      lockBtreeMutex(pLater);\n    }\n  }\n}\n\n\n/*\n** Exit the recursive mutex on a Btree.\n*/\nvoid sqlite3BtreeLeave(Btree *p){\n  assert( sqlite3_mutex_held(p->db->mutex) );\n  if( p->sharable ){\n    assert( p->wantToLock>0 );\n    p->wantToLock--;\n    if( p->wantToLock==0 ){\n      unlockBtreeMutex(p);\n    }\n  }\n}\n\n#ifndef NDEBUG\n/*\n** Return true if the BtShared mutex is held on the btree, or if the\n** B-Tree is not marked as sharable.\n**\n** This routine is used only from within assert() statements.\n*/\nint sqlite3BtreeHoldsMutex(Btree *p){\n  assert( p->sharable==0 || p->locked==0 || p->wantToLock>0 );\n  assert( p->sharable==0 || p->locked==0 || p->db==p->pBt->db );\n  assert( p->sharable==0 || p->locked==0 || sqlite3_mutex_held(p->pBt->mutex) );\n  assert( p->sharable==0 || p->locked==0 || sqlite3_mutex_held(p->db->mutex) );\n\n  return (p->sharable==0 || p->locked);\n}\n#endif\n\n\n/*\n** Enter the mutex on every Btree associated with a database\n** connection.  This is needed (for example) prior to parsing\n** a statement since we will be comparing table and column names\n** against all schemas and we do not want those schemas being\n** reset out from under us.\n**\n** There is a corresponding leave-all procedures.\n**\n** Enter the mutexes in ascending order by BtShared pointer address\n** to avoid the possibility of deadlock when two threads with\n** two or more btrees in common both try to lock all their btrees\n** at the same instant.\n*/\nstatic void SQLITE_NOINLINE btreeEnterAll(sqlite3 *db){\n  int i;\n  u8 skipOk = 1;\n  Btree *p;\n  assert( sqlite3_mutex_held(db->mutex) );\n  for(i=0; i<db->nDb; i++){\n    p = db->aDb[i].pBt;\n    if( p && p->sharable ){\n      sqlite3BtreeEnter(p);\n      skipOk = 0;\n    }\n  }\n  db->noSharedCache = skipOk;\n}\nvoid sqlite3BtreeEnterAll(sqlite3 *db){\n  if( db->noSharedCache==0 ) btreeEnterAll(db);\n}\nstatic void SQLITE_NOINLINE btreeLeaveAll(sqlite3 *db){\n  int i;\n  Btree *p;\n  assert( sqlite3_mutex_held(db->mutex) );\n  for(i=0; i<db->nDb; i++){\n    p = db->aDb[i].pBt;\n    if( p ) sqlite3BtreeLeave(p);\n  }\n}\nvoid sqlite3BtreeLeaveAll(sqlite3 *db){\n  if( db->noSharedCache==0 ) btreeLeaveAll(db);\n}\n\n#ifndef NDEBUG\n/*\n** Return true if the current thread holds the database connection\n** mutex and all required BtShared mutexes.\n**\n** This routine is used inside assert() statements only.\n*/\nint sqlite3BtreeHoldsAllMutexes(sqlite3 *db){\n  int i;\n  if( !sqlite3_mutex_held(db->mutex) ){\n    return 0;\n  }\n  for(i=0; i<db->nDb; i++){\n    Btree *p;\n    p = db->aDb[i].pBt;\n    if( p && p->sharable &&\n         (p->wantToLock==0 || !sqlite3_mutex_held(p->pBt->mutex)) ){\n      return 0;\n    }\n  }\n  return 1;\n}\n#endif /* NDEBUG */\n\n#ifndef NDEBUG\n/*\n** Return true if the correct mutexes are held for accessing the\n** db->aDb[iDb].pSchema structure.  The mutexes required for schema\n** access are:\n**\n**   (1) The mutex on db\n**   (2) if iDb!=1, then the mutex on db->aDb[iDb].pBt.\n**\n** If pSchema is not NULL, then iDb is computed from pSchema and\n** db using sqlite3SchemaToIndex().\n*/\nint sqlite3SchemaMutexHeld(sqlite3 *db, int iDb, Schema *pSchema){\n  Btree *p;\n  assert( db!=0 );\n  if( db->pVfs==0 && db->nDb==0 ) return 1;\n  if( pSchema ) iDb = sqlite3SchemaToIndex(db, pSchema);\n  assert( iDb>=0 && iDb<db->nDb );\n  if( !sqlite3_mutex_held(db->mutex) ) return 0;\n  if( iDb==1 ) return 1;\n  p = db->aDb[iDb].pBt;\n  assert( p!=0 );\n  return p->sharable==0 || p->locked==1;\n}\n#endif /* NDEBUG */\n\n#else /* SQLITE_THREADSAFE>0 above.  SQLITE_THREADSAFE==0 below */\n/*\n** The following are special cases for mutex enter routines for use\n** in single threaded applications that use shared cache.  Except for\n** these two routines, all mutex operations are no-ops in that case and\n** are null #defines in btree.h.\n**\n** If shared cache is disabled, then all btree mutex routines, including\n** the ones below, are no-ops and are null #defines in btree.h.\n*/\n\nvoid sqlite3BtreeEnter(Btree *p){\n  p->pBt->db = p->db;\n}\nvoid sqlite3BtreeEnterAll(sqlite3 *db){\n  int i;\n  for(i=0; i<db->nDb; i++){\n    Btree *p = db->aDb[i].pBt;\n    if( p ){\n      p->pBt->db = p->db;\n    }\n  }\n}\n#endif /* if SQLITE_THREADSAFE */\n\n#ifndef SQLITE_OMIT_INCRBLOB\n/*\n** Enter a mutex on a Btree given a cursor owned by that Btree. \n**\n** These entry points are used by incremental I/O only. Enter() is required \n** any time OMIT_SHARED_CACHE is not defined, regardless of whether or not \n** the build is threadsafe. Leave() is only required by threadsafe builds.\n*/\nvoid sqlite3BtreeEnterCursor(BtCursor *pCur){\n  sqlite3BtreeEnter(pCur->pBtree);\n}\n# if SQLITE_THREADSAFE\nvoid sqlite3BtreeLeaveCursor(BtCursor *pCur){\n  sqlite3BtreeLeave(pCur->pBtree);\n}\n# endif\n#endif /* ifndef SQLITE_OMIT_INCRBLOB */\n\n#endif /* ifndef SQLITE_OMIT_SHARED_CACHE */\n"}
{"repo": "sqlite", "file": "memjournal.c", "lang": "C++", "code": "/*\n** 2008 October 7\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains code use to implement an in-memory rollback journal.\n** The in-memory rollback journal is used to journal transactions for\n** \":memory:\" databases and when the journal_mode=MEMORY pragma is used.\n**\n** Update:  The in-memory journal is also used to temporarily cache\n** smaller journals that are not critical for power-loss recovery.\n** For example, statement journals that are not too big will be held\n** entirely in memory, thus reducing the number of file I/O calls, and\n** more importantly, reducing temporary file creation events.  If these\n** journals become too large for memory, they are spilled to disk.  But\n** in the common case, they are usually small and no file I/O needs to\n** occur.\n*/\n#include \"sqliteInt.h\"\n\n/* Forward references to internal structures */\ntypedef struct MemJournal MemJournal;\ntypedef struct FilePoint FilePoint;\ntypedef struct FileChunk FileChunk;\n\n/*\n** The rollback journal is composed of a linked list of these structures.\n**\n** The zChunk array is always at least 8 bytes in size - usually much more.\n** Its actual size is stored in the MemJournal.nChunkSize variable.\n*/\nstruct FileChunk {\n  FileChunk *pNext;               /* Next chunk in the journal */\n  u8 zChunk[8];                   /* Content of this chunk */\n};\n\n/*\n** By default, allocate this many bytes of memory for each FileChunk object.\n*/\n#define MEMJOURNAL_DFLT_FILECHUNKSIZE 1024\n\n/*\n** For chunk size nChunkSize, return the number of bytes that should\n** be allocated for each FileChunk structure.\n*/\n#define fileChunkSize(nChunkSize) (sizeof(FileChunk) + ((nChunkSize)-8))\n\n/*\n** An instance of this object serves as a cursor into the rollback journal.\n** The cursor can be either for reading or writing.\n*/\nstruct FilePoint {\n  sqlite3_int64 iOffset;          /* Offset from the beginning of the file */\n  FileChunk *pChunk;              /* Specific chunk into which cursor points */\n};\n\n/*\n** This structure is a subclass of sqlite3_file. Each open memory-journal\n** is an instance of this class.\n*/\nstruct MemJournal {\n  const sqlite3_io_methods *pMethod; /* Parent class. MUST BE FIRST */\n  int nChunkSize;                 /* In-memory chunk-size */\n\n  int nSpill;                     /* Bytes of data before flushing */\n  FileChunk *pFirst;              /* Head of in-memory chunk-list */\n  FilePoint endpoint;             /* Pointer to the end of the file */\n  FilePoint readpoint;            /* Pointer to the end of the last xRead() */\n\n  int flags;                      /* xOpen flags */\n  sqlite3_vfs *pVfs;              /* The \"real\" underlying VFS */\n  const char *zJournal;           /* Name of the journal file */\n};\n\n/*\n** Read data from the in-memory journal file.  This is the implementation\n** of the sqlite3_vfs.xRead method.\n*/\nstatic int memjrnlRead(\n  sqlite3_file *pJfd,    /* The journal file from which to read */\n  void *zBuf,            /* Put the results here */\n  int iAmt,              /* Number of bytes to read */\n  sqlite_int64 iOfst     /* Begin reading at this offset */\n){\n  MemJournal *p = (MemJournal *)pJfd;\n  u8 *zOut = zBuf;\n  int nRead = iAmt;\n  int iChunkOffset;\n  FileChunk *pChunk;\n\n  if( (iAmt+iOfst)>p->endpoint.iOffset ){\n    return SQLITE_IOERR_SHORT_READ;\n  }\n  assert( p->readpoint.iOffset==0 || p->readpoint.pChunk!=0 );\n  if( p->readpoint.iOffset!=iOfst || iOfst==0 ){\n    sqlite3_int64 iOff = 0;\n    for(pChunk=p->pFirst; \n        ALWAYS(pChunk) && (iOff+p->nChunkSize)<=iOfst;\n        pChunk=pChunk->pNext\n    ){\n      iOff += p->nChunkSize;\n    }\n  }else{\n    pChunk = p->readpoint.pChunk;\n    assert( pChunk!=0 );\n  }\n\n  iChunkOffset = (int)(iOfst%p->nChunkSize);\n  do {\n    int iSpace = p->nChunkSize - iChunkOffset;\n    int nCopy = MIN(nRead, (p->nChunkSize - iChunkOffset));\n    memcpy(zOut, (u8*)pChunk->zChunk + iChunkOffset, nCopy);\n    zOut += nCopy;\n    nRead -= iSpace;\n    iChunkOffset = 0;\n  } while( nRead>=0 && (pChunk=pChunk->pNext)!=0 && nRead>0 );\n  p->readpoint.iOffset = pChunk ? iOfst+iAmt : 0;\n  p->readpoint.pChunk = pChunk;\n\n  return SQLITE_OK;\n}\n\n/*\n** Free the list of FileChunk structures headed at MemJournal.pFirst.\n*/\nstatic void memjrnlFreeChunks(FileChunk *pFirst){\n  FileChunk *pIter;\n  FileChunk *pNext;\n  for(pIter=pFirst; pIter; pIter=pNext){\n    pNext = pIter->pNext;\n    sqlite3_free(pIter);\n  } \n}\n\n/*\n** Flush the contents of memory to a real file on disk.\n*/\nstatic int memjrnlCreateFile(MemJournal *p){\n  int rc;\n  sqlite3_file *pReal = (sqlite3_file*)p;\n  MemJournal copy = *p;\n\n  memset(p, 0, sizeof(MemJournal));\n  rc = sqlite3OsOpen(copy.pVfs, copy.zJournal, pReal, copy.flags, 0);\n  if( rc==SQLITE_OK ){\n    int nChunk = copy.nChunkSize;\n    i64 iOff = 0;\n    FileChunk *pIter;\n    for(pIter=copy.pFirst; pIter; pIter=pIter->pNext){\n      if( iOff + nChunk > copy.endpoint.iOffset ){\n        nChunk = copy.endpoint.iOffset - iOff;\n      }\n      rc = sqlite3OsWrite(pReal, (u8*)pIter->zChunk, nChunk, iOff);\n      if( rc ) break;\n      iOff += nChunk;\n    }\n    if( rc==SQLITE_OK ){\n      /* No error has occurred. Free the in-memory buffers. */\n      memjrnlFreeChunks(copy.pFirst);\n    }\n  }\n  if( rc!=SQLITE_OK ){\n    /* If an error occurred while creating or writing to the file, restore\n    ** the original before returning. This way, SQLite uses the in-memory\n    ** journal data to roll back changes made to the internal page-cache\n    ** before this function was called.  */\n    sqlite3OsClose(pReal);\n    *p = copy;\n  }\n  return rc;\n}\n\n\n/* Forward reference */\nstatic int memjrnlTruncate(sqlite3_file *pJfd, sqlite_int64 size);\n\n/*\n** Write data to the file.\n*/\nstatic int memjrnlWrite(\n  sqlite3_file *pJfd,    /* The journal file into which to write */\n  const void *zBuf,      /* Take data to be written from here */\n  int iAmt,              /* Number of bytes to write */\n  sqlite_int64 iOfst     /* Begin writing at this offset into the file */\n){\n  MemJournal *p = (MemJournal *)pJfd;\n  int nWrite = iAmt;\n  u8 *zWrite = (u8 *)zBuf;\n\n  /* If the file should be created now, create it and write the new data\n  ** into the file on disk. */\n  if( p->nSpill>0 && (iAmt+iOfst)>p->nSpill ){\n    int rc = memjrnlCreateFile(p);\n    if( rc==SQLITE_OK ){\n      rc = sqlite3OsWrite(pJfd, zBuf, iAmt, iOfst);\n    }\n    return rc;\n  }\n\n  /* If the contents of this write should be stored in memory */\n  else{\n    /* An in-memory journal file should only ever be appended to. Random\n    ** access writes are not required. The only exception to this is when\n    ** the in-memory journal is being used by a connection using the\n    ** atomic-write optimization. In this case the first 28 bytes of the\n    ** journal file may be written as part of committing the transaction. */\n    assert( iOfst<=p->endpoint.iOffset );\n    if( iOfst>0 && iOfst!=p->endpoint.iOffset ){\n      memjrnlTruncate(pJfd, iOfst);\n    }\n    if( iOfst==0 && p->pFirst ){\n      assert( p->nChunkSize>iAmt );\n      memcpy((u8*)p->pFirst->zChunk, zBuf, iAmt);\n    }else{\n      while( nWrite>0 ){\n        FileChunk *pChunk = p->endpoint.pChunk;\n        int iChunkOffset = (int)(p->endpoint.iOffset%p->nChunkSize);\n        int iSpace = MIN(nWrite, p->nChunkSize - iChunkOffset);\n\n        assert( pChunk!=0 || iChunkOffset==0 );\n        if( iChunkOffset==0 ){\n          /* New chunk is required to extend the file. */\n          FileChunk *pNew = sqlite3_malloc(fileChunkSize(p->nChunkSize));\n          if( !pNew ){\n            return SQLITE_IOERR_NOMEM_BKPT;\n          }\n          pNew->pNext = 0;\n          if( pChunk ){\n            assert( p->pFirst );\n            pChunk->pNext = pNew;\n          }else{\n            assert( !p->pFirst );\n            p->pFirst = pNew;\n          }\n          pChunk = p->endpoint.pChunk = pNew;\n        }\n\n        assert( pChunk!=0 );\n        memcpy((u8*)pChunk->zChunk + iChunkOffset, zWrite, iSpace);\n        zWrite += iSpace;\n        nWrite -= iSpace;\n        p->endpoint.iOffset += iSpace;\n      }\n    }\n  }\n\n  return SQLITE_OK;\n}\n\n/*\n** Truncate the in-memory file.\n*/\nstatic int memjrnlTruncate(sqlite3_file *pJfd, sqlite_int64 size){\n  MemJournal *p = (MemJournal *)pJfd;\n  assert( p->endpoint.pChunk==0 || p->endpoint.pChunk->pNext==0 );\n  if( size<p->endpoint.iOffset ){\n    FileChunk *pIter = 0;\n    if( size==0 ){\n      memjrnlFreeChunks(p->pFirst);\n      p->pFirst = 0;\n    }else{\n      i64 iOff = p->nChunkSize;\n      for(pIter=p->pFirst; ALWAYS(pIter) && iOff<size; pIter=pIter->pNext){\n        iOff += p->nChunkSize;\n      }\n      if( ALWAYS(pIter) ){\n        memjrnlFreeChunks(pIter->pNext);\n        pIter->pNext = 0;\n      }\n    }\n\n    p->endpoint.pChunk = pIter;\n    p->endpoint.iOffset = size;\n    p->readpoint.pChunk = 0;\n    p->readpoint.iOffset = 0;\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Close the file.\n*/\nstatic int memjrnlClose(sqlite3_file *pJfd){\n  MemJournal *p = (MemJournal *)pJfd;\n  memjrnlFreeChunks(p->pFirst);\n  return SQLITE_OK;\n}\n\n/*\n** Sync the file.\n**\n** If the real file has been created, call its xSync method. Otherwise, \n** syncing an in-memory journal is a no-op. \n*/\nstatic int memjrnlSync(sqlite3_file *pJfd, int flags){\n  UNUSED_PARAMETER2(pJfd, flags);\n  return SQLITE_OK;\n}\n\n/*\n** Query the size of the file in bytes.\n*/\nstatic int memjrnlFileSize(sqlite3_file *pJfd, sqlite_int64 *pSize){\n  MemJournal *p = (MemJournal *)pJfd;\n  *pSize = (sqlite_int64) p->endpoint.iOffset;\n  return SQLITE_OK;\n}\n\n/*\n** Table of methods for MemJournal sqlite3_file object.\n*/\nstatic const struct sqlite3_io_methods MemJournalMethods = {\n  1,                /* iVersion */\n  memjrnlClose,     /* xClose */\n  memjrnlRead,      /* xRead */\n  memjrnlWrite,     /* xWrite */\n  memjrnlTruncate,  /* xTruncate */\n  memjrnlSync,      /* xSync */\n  memjrnlFileSize,  /* xFileSize */\n  0,                /* xLock */\n  0,                /* xUnlock */\n  0,                /* xCheckReservedLock */\n  0,                /* xFileControl */\n  0,                /* xSectorSize */\n  0,                /* xDeviceCharacteristics */\n  0,                /* xShmMap */\n  0,                /* xShmLock */\n  0,                /* xShmBarrier */\n  0,                /* xShmUnmap */\n  0,                /* xFetch */\n  0                 /* xUnfetch */\n};\n\n/* \n** Open a journal file. \n**\n** The behaviour of the journal file depends on the value of parameter \n** nSpill. If nSpill is 0, then the journal file is always create and \n** accessed using the underlying VFS. If nSpill is less than zero, then\n** all content is always stored in main-memory. Finally, if nSpill is a\n** positive value, then the journal file is initially created in-memory\n** but may be flushed to disk later on. In this case the journal file is\n** flushed to disk either when it grows larger than nSpill bytes in size,\n** or when sqlite3JournalCreate() is called.\n*/\nint sqlite3JournalOpen(\n  sqlite3_vfs *pVfs,         /* The VFS to use for actual file I/O */\n  const char *zName,         /* Name of the journal file */\n  sqlite3_file *pJfd,        /* Preallocated, blank file handle */\n  int flags,                 /* Opening flags */\n  int nSpill                 /* Bytes buffered before opening the file */\n){\n  MemJournal *p = (MemJournal*)pJfd;\n\n  assert( zName || nSpill<0 || (flags & SQLITE_OPEN_EXCLUSIVE) );\n\n  /* Zero the file-handle object. If nSpill was passed zero, initialize\n  ** it using the sqlite3OsOpen() function of the underlying VFS. In this\n  ** case none of the code in this module is executed as a result of calls\n  ** made on the journal file-handle.  */\n  memset(p, 0, sizeof(MemJournal));\n  if( nSpill==0 ){\n    return sqlite3OsOpen(pVfs, zName, pJfd, flags, 0);\n  }\n\n  if( nSpill>0 ){\n    p->nChunkSize = nSpill;\n  }else{\n    p->nChunkSize = 8 + MEMJOURNAL_DFLT_FILECHUNKSIZE - sizeof(FileChunk);\n    assert( MEMJOURNAL_DFLT_FILECHUNKSIZE==fileChunkSize(p->nChunkSize) );\n  }\n\n  pJfd->pMethods = (const sqlite3_io_methods*)&MemJournalMethods;\n  p->nSpill = nSpill;\n  p->flags = flags;\n  p->zJournal = zName;\n  p->pVfs = pVfs;\n  return SQLITE_OK;\n}\n\n/*\n** Open an in-memory journal file.\n*/\nvoid sqlite3MemJournalOpen(sqlite3_file *pJfd){\n  sqlite3JournalOpen(0, 0, pJfd, 0, -1);\n}\n\n#if defined(SQLITE_ENABLE_ATOMIC_WRITE) \\\n || defined(SQLITE_ENABLE_BATCH_ATOMIC_WRITE)\n/*\n** If the argument p points to a MemJournal structure that is not an \n** in-memory-only journal file (i.e. is one that was opened with a +ve\n** nSpill parameter or as SQLITE_OPEN_MAIN_JOURNAL), and the underlying \n** file has not yet been created, create it now.\n*/\nint sqlite3JournalCreate(sqlite3_file *pJfd){\n  int rc = SQLITE_OK;\n  MemJournal *p = (MemJournal*)pJfd;\n  if( pJfd->pMethods==&MemJournalMethods && (\n#ifdef SQLITE_ENABLE_ATOMIC_WRITE\n     p->nSpill>0\n#else\n     /* While this appears to not be possible without ATOMIC_WRITE, the\n     ** paths are complex, so it seems prudent to leave the test in as\n     ** a NEVER(), in case our analysis is subtly flawed. */\n     NEVER(p->nSpill>0)\n#endif\n#ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE\n     || (p->flags & SQLITE_OPEN_MAIN_JOURNAL)\n#endif\n  )){\n    rc = memjrnlCreateFile(p);\n  }\n  return rc;\n}\n#endif\n\n/*\n** The file-handle passed as the only argument is open on a journal file.\n** Return true if this \"journal file\" is currently stored in heap memory,\n** or false otherwise.\n*/\nint sqlite3JournalIsInMemory(sqlite3_file *p){\n  return p->pMethods==&MemJournalMethods;\n}\n\n/* \n** Return the number of bytes required to store a JournalFile that uses vfs\n** pVfs to create the underlying on-disk files.\n*/\nint sqlite3JournalSize(sqlite3_vfs *pVfs){\n  return MAX(pVfs->szOsFile, (int)sizeof(MemJournal));\n}\n"}
{"repo": "sqlite", "file": "vdbetrace.c", "lang": "C++", "code": "/*\n** 2009 November 25\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains code used to insert the values of host parameters\n** (aka \"wildcards\") into the SQL text output by sqlite3_trace().\n**\n** The Vdbe parse-tree explainer is also found here.\n*/\n#include \"sqliteInt.h\"\n#include \"vdbeInt.h\"\n\n#ifndef SQLITE_OMIT_TRACE\n\n/*\n** zSql is a zero-terminated string of UTF-8 SQL text.  Return the number of\n** bytes in this text up to but excluding the first character in\n** a host parameter.  If the text contains no host parameters, return\n** the total number of bytes in the text.\n*/\nstatic i64 findNextHostParameter(const char *zSql, i64 *pnToken){\n  int tokenType;\n  i64 nTotal = 0;\n  i64 n;\n\n  *pnToken = 0;\n  while( zSql[0] ){\n    n = sqlite3GetToken((u8*)zSql, &tokenType);\n    assert( n>0 && tokenType!=TK_ILLEGAL );\n    if( tokenType==TK_VARIABLE ){\n      *pnToken = n;\n      break;\n    }\n    nTotal += n;\n    zSql += n;\n  }\n  return nTotal;\n}\n\n/*\n** This function returns a pointer to a nul-terminated string in memory\n** obtained from sqlite3DbMalloc(). If sqlite3.nVdbeExec is 1, then the\n** string contains a copy of zRawSql but with host parameters expanded to \n** their current bindings. Or, if sqlite3.nVdbeExec is greater than 1, \n** then the returned string holds a copy of zRawSql with \"-- \" prepended\n** to each line of text.\n**\n** If the SQLITE_TRACE_SIZE_LIMIT macro is defined to an integer, then\n** then long strings and blobs are truncated to that many bytes.  This\n** can be used to prevent unreasonably large trace strings when dealing\n** with large (multi-megabyte) strings and blobs.\n**\n** The calling function is responsible for making sure the memory returned\n** is eventually freed.\n**\n** ALGORITHM:  Scan the input string looking for host parameters in any of\n** these forms:  ?, ?N, $A, @A, :A.  Take care to avoid text within\n** string literals, quoted identifier names, and comments.  For text forms,\n** the host parameter index is found by scanning the prepared\n** statement for the corresponding OP_Variable opcode.  Once the host\n** parameter index is known, locate the value in p->aVar[].  Then render\n** the value as a literal in place of the host parameter name.\n*/\nchar *sqlite3VdbeExpandSql(\n  Vdbe *p,                 /* The prepared statement being evaluated */\n  const char *zRawSql      /* Raw text of the SQL statement */\n){\n  sqlite3 *db;             /* The database connection */\n  int idx = 0;             /* Index of a host parameter */\n  int nextIndex = 1;       /* Index of next ? host parameter */\n  i64 n;                   /* Length of a token prefix */\n  i64 nToken;              /* Length of the parameter token */\n  int i;                   /* Loop counter */\n  Mem *pVar;               /* Value of a host parameter */\n  StrAccum out;            /* Accumulate the output here */\n#ifndef SQLITE_OMIT_UTF16\n  Mem utf8;                /* Used to convert UTF16 into UTF8 for display */\n#endif\n\n  db = p->db;\n  sqlite3StrAccumInit(&out, 0, 0, 0, db->aLimit[SQLITE_LIMIT_LENGTH]);\n  if( db->nVdbeExec>1 ){\n    while( *zRawSql ){\n      const char *zStart = zRawSql;\n      while( *(zRawSql++)!='\\n' && *zRawSql );\n      sqlite3_str_append(&out, \"-- \", 3);\n      assert( (zRawSql - zStart) > 0 );\n      sqlite3_str_append(&out, zStart, (int)(zRawSql-zStart));\n    }\n  }else if( p->nVar==0 ){\n    sqlite3_str_append(&out, zRawSql, sqlite3Strlen30(zRawSql));\n  }else{\n    while( zRawSql[0] ){\n      n = findNextHostParameter(zRawSql, &nToken);\n      assert( n>0 );\n      sqlite3_str_append(&out, zRawSql, n);\n      zRawSql += n;\n      assert( zRawSql[0] || nToken==0 );\n      if( nToken==0 ) break;\n      if( zRawSql[0]=='?' ){\n        if( nToken>1 ){\n          assert( sqlite3Isdigit(zRawSql[1]) );\n          sqlite3GetInt32(&zRawSql[1], &idx);\n        }else{\n          idx = nextIndex;\n        }\n      }else{\n        assert( zRawSql[0]==':' || zRawSql[0]=='$' ||\n                zRawSql[0]=='@' || zRawSql[0]=='#' );\n        testcase( zRawSql[0]==':' );\n        testcase( zRawSql[0]=='$' );\n        testcase( zRawSql[0]=='@' );\n        testcase( zRawSql[0]=='#' );\n        idx = sqlite3VdbeParameterIndex(p, zRawSql, nToken);\n        assert( idx>0 );\n      }\n      zRawSql += nToken;\n      nextIndex = MAX(idx + 1, nextIndex);\n      assert( idx>0 && idx<=p->nVar );\n      pVar = &p->aVar[idx-1];\n      if( pVar->flags & MEM_Null ){\n        sqlite3_str_append(&out, \"NULL\", 4);\n      }else if( pVar->flags & (MEM_Int|MEM_IntReal) ){\n        sqlite3_str_appendf(&out, \"%lld\", pVar->u.i);\n      }else if( pVar->flags & MEM_Real ){\n        sqlite3_str_appendf(&out, \"%!.15g\", pVar->u.r);\n      }else if( pVar->flags & MEM_Str ){\n        int nOut;  /* Number of bytes of the string text to include in output */\n#ifndef SQLITE_OMIT_UTF16\n        u8 enc = ENC(db);\n        if( enc!=SQLITE_UTF8 ){\n          memset(&utf8, 0, sizeof(utf8));\n          utf8.db = db;\n          sqlite3VdbeMemSetStr(&utf8, pVar->z, pVar->n, enc, SQLITE_STATIC);\n          if( SQLITE_NOMEM==sqlite3VdbeChangeEncoding(&utf8, SQLITE_UTF8) ){\n            out.accError = SQLITE_NOMEM;\n            out.nAlloc = 0;\n          }\n          pVar = &utf8;\n        }\n#endif\n        nOut = pVar->n;\n#ifdef SQLITE_TRACE_SIZE_LIMIT\n        if( nOut>SQLITE_TRACE_SIZE_LIMIT ){\n          nOut = SQLITE_TRACE_SIZE_LIMIT;\n          while( nOut<pVar->n && (pVar->z[nOut]&0xc0)==0x80 ){ nOut++; }\n        }\n#endif    \n        sqlite3_str_appendf(&out, \"'%.*q'\", nOut, pVar->z);\n#ifdef SQLITE_TRACE_SIZE_LIMIT\n        if( nOut<pVar->n ){\n          sqlite3_str_appendf(&out, \"/*+%d bytes*/\", pVar->n-nOut);\n        }\n#endif\n#ifndef SQLITE_OMIT_UTF16\n        if( enc!=SQLITE_UTF8 ) sqlite3VdbeMemRelease(&utf8);\n#endif\n      }else if( pVar->flags & MEM_Zero ){\n        sqlite3_str_appendf(&out, \"zeroblob(%d)\", pVar->u.nZero);\n      }else{\n        int nOut;  /* Number of bytes of the blob to include in output */\n        assert( pVar->flags & MEM_Blob );\n        sqlite3_str_append(&out, \"x'\", 2);\n        nOut = pVar->n;\n#ifdef SQLITE_TRACE_SIZE_LIMIT\n        if( nOut>SQLITE_TRACE_SIZE_LIMIT ) nOut = SQLITE_TRACE_SIZE_LIMIT;\n#endif\n        for(i=0; i<nOut; i++){\n          sqlite3_str_appendf(&out, \"%02x\", pVar->z[i]&0xff);\n        }\n        sqlite3_str_append(&out, \"'\", 1);\n#ifdef SQLITE_TRACE_SIZE_LIMIT\n        if( nOut<pVar->n ){\n          sqlite3_str_appendf(&out, \"/*+%d bytes*/\", pVar->n-nOut);\n        }\n#endif\n      }\n    }\n  }\n  if( out.accError ) sqlite3_str_reset(&out);\n  return sqlite3StrAccumFinish(&out);\n}\n\n#endif /* #ifndef SQLITE_OMIT_TRACE */\n"}
{"repo": "sqlite", "file": "vtab.c", "lang": "C++", "code": "/*\n** 2006 June 10\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains code used to help implement virtual tables.\n*/\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n#include \"sqliteInt.h\"\n\n/*\n** Before a virtual table xCreate() or xConnect() method is invoked, the\n** sqlite3.pVtabCtx member variable is set to point to an instance of\n** this struct allocated on the stack. It is used by the implementation of\n** the sqlite3_declare_vtab() and sqlite3_vtab_config() APIs, both of which\n** are invoked only from within xCreate and xConnect methods.\n*/\nstruct VtabCtx {\n  VTable *pVTable;    /* The virtual table being constructed */\n  Table *pTab;        /* The Table object to which the virtual table belongs */\n  VtabCtx *pPrior;    /* Parent context (if any) */\n  int bDeclared;      /* True after sqlite3_declare_vtab() is called */\n};\n\n/*\n** Construct and install a Module object for a virtual table.  When this\n** routine is called, it is guaranteed that all appropriate locks are held\n** and the module is not already part of the connection.\n**\n** If there already exists a module with zName, replace it with the new one.\n** If pModule==0, then delete the module zName if it exists.\n*/\nModule *sqlite3VtabCreateModule(\n  sqlite3 *db,                    /* Database in which module is registered */\n  const char *zName,              /* Name assigned to this module */\n  const sqlite3_module *pModule,  /* The definition of the module */\n  void *pAux,                     /* Context pointer for xCreate/xConnect */\n  void (*xDestroy)(void *)        /* Module destructor function */\n){\n  Module *pMod;\n  Module *pDel;\n  char *zCopy;\n  if( pModule==0 ){\n    zCopy = (char*)zName;\n    pMod = 0;\n  }else{\n    int nName = sqlite3Strlen30(zName);\n    pMod = (Module *)sqlite3Malloc(sizeof(Module) + nName + 1);\n    if( pMod==0 ){\n      sqlite3OomFault(db);\n      return 0;\n    }\n    zCopy = (char *)(&pMod[1]);\n    memcpy(zCopy, zName, nName+1);\n    pMod->zName = zCopy;\n    pMod->pModule = pModule;\n    pMod->pAux = pAux;\n    pMod->xDestroy = xDestroy;\n    pMod->pEpoTab = 0;\n    pMod->nRefModule = 1;\n  }\n  pDel = (Module *)sqlite3HashInsert(&db->aModule,zCopy,(void*)pMod);\n  if( pDel ){\n    if( pDel==pMod ){\n      sqlite3OomFault(db);\n      sqlite3DbFree(db, pDel);\n      pMod = 0;\n    }else{\n      sqlite3VtabEponymousTableClear(db, pDel);\n      sqlite3VtabModuleUnref(db, pDel);\n    }\n  }\n  return pMod;\n}\n\n/*\n** The actual function that does the work of creating a new module.\n** This function implements the sqlite3_create_module() and\n** sqlite3_create_module_v2() interfaces.\n*/\nstatic int createModule(\n  sqlite3 *db,                    /* Database in which module is registered */\n  const char *zName,              /* Name assigned to this module */\n  const sqlite3_module *pModule,  /* The definition of the module */\n  void *pAux,                     /* Context pointer for xCreate/xConnect */\n  void (*xDestroy)(void *)        /* Module destructor function */\n){\n  int rc = SQLITE_OK;\n\n  sqlite3_mutex_enter(db->mutex);\n  (void)sqlite3VtabCreateModule(db, zName, pModule, pAux, xDestroy);\n  rc = sqlite3ApiExit(db, rc);\n  if( rc!=SQLITE_OK && xDestroy ) xDestroy(pAux);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n\n/*\n** External API function used to create a new virtual-table module.\n*/\nint sqlite3_create_module(\n  sqlite3 *db,                    /* Database in which module is registered */\n  const char *zName,              /* Name assigned to this module */\n  const sqlite3_module *pModule,  /* The definition of the module */\n  void *pAux                      /* Context pointer for xCreate/xConnect */\n){\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( !sqlite3SafetyCheckOk(db) || zName==0 ) return SQLITE_MISUSE_BKPT;\n#endif\n  return createModule(db, zName, pModule, pAux, 0);\n}\n\n/*\n** External API function used to create a new virtual-table module.\n*/\nint sqlite3_create_module_v2(\n  sqlite3 *db,                    /* Database in which module is registered */\n  const char *zName,              /* Name assigned to this module */\n  const sqlite3_module *pModule,  /* The definition of the module */\n  void *pAux,                     /* Context pointer for xCreate/xConnect */\n  void (*xDestroy)(void *)        /* Module destructor function */\n){\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( !sqlite3SafetyCheckOk(db) || zName==0 ) return SQLITE_MISUSE_BKPT;\n#endif\n  return createModule(db, zName, pModule, pAux, xDestroy);\n}\n\n/*\n** External API to drop all virtual-table modules, except those named\n** on the azNames list.\n*/\nint sqlite3_drop_modules(sqlite3 *db, const char** azNames){\n  HashElem *pThis, *pNext;\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n#endif\n  for(pThis=sqliteHashFirst(&db->aModule); pThis; pThis=pNext){\n    Module *pMod = (Module*)sqliteHashData(pThis);\n    pNext = sqliteHashNext(pThis);\n    if( azNames ){\n      int ii;\n      for(ii=0; azNames[ii]!=0 && strcmp(azNames[ii],pMod->zName)!=0; ii++){}\n      if( azNames[ii]!=0 ) continue;\n    }\n    createModule(db, pMod->zName, 0, 0, 0);\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Decrement the reference count on a Module object.  Destroy the\n** module when the reference count reaches zero.\n*/\nvoid sqlite3VtabModuleUnref(sqlite3 *db, Module *pMod){\n  assert( pMod->nRefModule>0 );\n  pMod->nRefModule--;\n  if( pMod->nRefModule==0 ){\n    if( pMod->xDestroy ){\n      pMod->xDestroy(pMod->pAux);\n    }\n    assert( pMod->pEpoTab==0 );\n    sqlite3DbFree(db, pMod);\n  }\n}\n\n/*\n** Lock the virtual table so that it cannot be disconnected.\n** Locks nest.  Every lock should have a corresponding unlock.\n** If an unlock is omitted, resources leaks will occur.\n**\n** If a disconnect is attempted while a virtual table is locked,\n** the disconnect is deferred until all locks have been removed.\n*/\nvoid sqlite3VtabLock(VTable *pVTab){\n  pVTab->nRef++;\n}\n\n\n/*\n** pTab is a pointer to a Table structure representing a virtual-table.\n** Return a pointer to the VTable object used by connection db to access\n** this virtual-table, if one has been created, or NULL otherwise.\n*/\nVTable *sqlite3GetVTable(sqlite3 *db, Table *pTab){\n  VTable *pVtab;\n  assert( IsVirtual(pTab) );\n  for(pVtab=pTab->u.vtab.p; pVtab && pVtab->db!=db; pVtab=pVtab->pNext);\n  return pVtab;\n}\n\n/*\n** Decrement the ref-count on a virtual table object. When the ref-count\n** reaches zero, call the xDisconnect() method to delete the object.\n*/\nvoid sqlite3VtabUnlock(VTable *pVTab){\n  sqlite3 *db = pVTab->db;\n\n  assert( db );\n  assert( pVTab->nRef>0 );\n  assert( db->eOpenState==SQLITE_STATE_OPEN\n       || db->eOpenState==SQLITE_STATE_ZOMBIE );\n\n  pVTab->nRef--;\n  if( pVTab->nRef==0 ){\n    sqlite3_vtab *p = pVTab->pVtab;\n    if( p ){\n      p->pModule->xDisconnect(p);\n    }\n    sqlite3VtabModuleUnref(pVTab->db, pVTab->pMod);\n    sqlite3DbFree(db, pVTab);\n  }\n}\n\n/*\n** Table p is a virtual table. This function moves all elements in the\n** p->u.vtab.p list to the sqlite3.pDisconnect lists of their associated\n** database connections to be disconnected at the next opportunity.\n** Except, if argument db is not NULL, then the entry associated with\n** connection db is left in the p->u.vtab.p list.\n*/\nstatic VTable *vtabDisconnectAll(sqlite3 *db, Table *p){\n  VTable *pRet = 0;\n  VTable *pVTable;\n\n  assert( IsVirtual(p) );\n  pVTable = p->u.vtab.p;\n  p->u.vtab.p = 0;\n\n  /* Assert that the mutex (if any) associated with the BtShared database\n  ** that contains table p is held by the caller. See header comments\n  ** above function sqlite3VtabUnlockList() for an explanation of why\n  ** this makes it safe to access the sqlite3.pDisconnect list of any\n  ** database connection that may have an entry in the p->u.vtab.p list.\n  */\n  assert( db==0 || sqlite3SchemaMutexHeld(db, 0, p->pSchema) );\n\n  while( pVTable ){\n    sqlite3 *db2 = pVTable->db;\n    VTable *pNext = pVTable->pNext;\n    assert( db2 );\n    if( db2==db ){\n      pRet = pVTable;\n      p->u.vtab.p = pRet;\n      pRet->pNext = 0;\n    }else{\n      pVTable->pNext = db2->pDisconnect;\n      db2->pDisconnect = pVTable;\n    }\n    pVTable = pNext;\n  }\n\n  assert( !db || pRet );\n  return pRet;\n}\n\n/*\n** Table *p is a virtual table. This function removes the VTable object\n** for table *p associated with database connection db from the linked\n** list in p->pVTab. It also decrements the VTable ref count. This is\n** used when closing database connection db to free all of its VTable\n** objects without disturbing the rest of the Schema object (which may\n** be being used by other shared-cache connections).\n*/\nvoid sqlite3VtabDisconnect(sqlite3 *db, Table *p){\n  VTable **ppVTab;\n\n  assert( IsVirtual(p) );\n  assert( sqlite3BtreeHoldsAllMutexes(db) );\n  assert( sqlite3_mutex_held(db->mutex) );\n\n  for(ppVTab=&p->u.vtab.p; *ppVTab; ppVTab=&(*ppVTab)->pNext){\n    if( (*ppVTab)->db==db  ){\n      VTable *pVTab = *ppVTab;\n      *ppVTab = pVTab->pNext;\n      sqlite3VtabUnlock(pVTab);\n      break;\n    }\n  }\n}\n\n\n/*\n** Disconnect all the virtual table objects in the sqlite3.pDisconnect list.\n**\n** This function may only be called when the mutexes associated with all\n** shared b-tree databases opened using connection db are held by the\n** caller. This is done to protect the sqlite3.pDisconnect list. The\n** sqlite3.pDisconnect list is accessed only as follows:\n**\n**   1) By this function. In this case, all BtShared mutexes and the mutex\n**      associated with the database handle itself must be held.\n**\n**   2) By function vtabDisconnectAll(), when it adds a VTable entry to\n**      the sqlite3.pDisconnect list. In this case either the BtShared mutex\n**      associated with the database the virtual table is stored in is held\n**      or, if the virtual table is stored in a non-sharable database, then\n**      the database handle mutex is held.\n**\n** As a result, a sqlite3.pDisconnect cannot be accessed simultaneously\n** by multiple threads. It is thread-safe.\n*/\nvoid sqlite3VtabUnlockList(sqlite3 *db){\n  VTable *p = db->pDisconnect;\n\n  assert( sqlite3BtreeHoldsAllMutexes(db) );\n  assert( sqlite3_mutex_held(db->mutex) );\n\n  if( p ){\n    db->pDisconnect = 0;\n    do {\n      VTable *pNext = p->pNext;\n      sqlite3VtabUnlock(p);\n      p = pNext;\n    }while( p );\n  }\n}\n\n/*\n** Clear any and all virtual-table information from the Table record.\n** This routine is called, for example, just before deleting the Table\n** record.\n**\n** Since it is a virtual-table, the Table structure contains a pointer\n** to the head of a linked list of VTable structures. Each VTable\n** structure is associated with a single sqlite3* user of the schema.\n** The reference count of the VTable structure associated with database\n** connection db is decremented immediately (which may lead to the\n** structure being xDisconnected and free). Any other VTable structures\n** in the list are moved to the sqlite3.pDisconnect list of the associated\n** database connection.\n*/\nvoid sqlite3VtabClear(sqlite3 *db, Table *p){\n  assert( IsVirtual(p) );\n  assert( db!=0 );\n  if( db->pnBytesFreed==0 ) vtabDisconnectAll(0, p);\n  if( p->u.vtab.azArg ){\n    int i;\n    for(i=0; i<p->u.vtab.nArg; i++){\n      if( i!=1 ) sqlite3DbFree(db, p->u.vtab.azArg[i]);\n    }\n    sqlite3DbFree(db, p->u.vtab.azArg);\n  }\n}\n\n/*\n** Add a new module argument to pTable->u.vtab.azArg[].\n** The string is not copied - the pointer is stored.  The\n** string will be freed automatically when the table is\n** deleted.\n*/\nstatic void addModuleArgument(Parse *pParse, Table *pTable, char *zArg){\n  sqlite3_int64 nBytes;\n  char **azModuleArg;\n  sqlite3 *db = pParse->db;\n\n  assert( IsVirtual(pTable) );\n  nBytes = sizeof(char *)*(2+pTable->u.vtab.nArg);\n  if( pTable->u.vtab.nArg+3>=db->aLimit[SQLITE_LIMIT_COLUMN] ){\n    sqlite3ErrorMsg(pParse, \"too many columns on %s\", pTable->zName);\n  }\n  azModuleArg = sqlite3DbRealloc(db, pTable->u.vtab.azArg, nBytes);\n  if( azModuleArg==0 ){\n    sqlite3DbFree(db, zArg);\n  }else{\n    int i = pTable->u.vtab.nArg++;\n    azModuleArg[i] = zArg;\n    azModuleArg[i+1] = 0;\n    pTable->u.vtab.azArg = azModuleArg;\n  }\n}\n\n/*\n** The parser calls this routine when it first sees a CREATE VIRTUAL TABLE\n** statement.  The module name has been parsed, but the optional list\n** of parameters that follow the module name are still pending.\n*/\nvoid sqlite3VtabBeginParse(\n  Parse *pParse,        /* Parsing context */\n  Token *pName1,        /* Name of new table, or database name */\n  Token *pName2,        /* Name of new table or NULL */\n  Token *pModuleName,   /* Name of the module for the virtual table */\n  int ifNotExists       /* No error if the table already exists */\n){\n  Table *pTable;        /* The new virtual table */\n  sqlite3 *db;          /* Database connection */\n\n  sqlite3StartTable(pParse, pName1, pName2, 0, 0, 1, ifNotExists);\n  pTable = pParse->pNewTable;\n  if( pTable==0 ) return;\n  assert( 0==pTable->pIndex );\n  pTable->eTabType = TABTYP_VTAB;\n\n  db = pParse->db;\n\n  assert( pTable->u.vtab.nArg==0 );\n  addModuleArgument(pParse, pTable, sqlite3NameFromToken(db, pModuleName));\n  addModuleArgument(pParse, pTable, 0);\n  addModuleArgument(pParse, pTable, sqlite3DbStrDup(db, pTable->zName));\n  assert( (pParse->sNameToken.z==pName2->z && pName2->z!=0)\n       || (pParse->sNameToken.z==pName1->z && pName2->z==0)\n  );\n  pParse->sNameToken.n = (int)(\n      &pModuleName->z[pModuleName->n] - pParse->sNameToken.z\n  );\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  /* Creating a virtual table invokes the authorization callback twice.\n  ** The first invocation, to obtain permission to INSERT a row into the\n  ** sqlite_schema table, has already been made by sqlite3StartTable().\n  ** The second call, to obtain permission to create the table, is made now.\n  */\n  if( pTable->u.vtab.azArg ){\n    int iDb = sqlite3SchemaToIndex(db, pTable->pSchema);\n    assert( iDb>=0 ); /* The database the table is being created in */\n    sqlite3AuthCheck(pParse, SQLITE_CREATE_VTABLE, pTable->zName,\n            pTable->u.vtab.azArg[0], pParse->db->aDb[iDb].zDbSName);\n  }\n#endif\n}\n\n/*\n** This routine takes the module argument that has been accumulating\n** in pParse->zArg[] and appends it to the list of arguments on the\n** virtual table currently under construction in pParse->pTable.\n*/\nstatic void addArgumentToVtab(Parse *pParse){\n  if( pParse->sArg.z && pParse->pNewTable ){\n    const char *z = (const char*)pParse->sArg.z;\n    int n = pParse->sArg.n;\n    sqlite3 *db = pParse->db;\n    addModuleArgument(pParse, pParse->pNewTable, sqlite3DbStrNDup(db, z, n));\n  }\n}\n\n/*\n** The parser calls this routine after the CREATE VIRTUAL TABLE statement\n** has been completely parsed.\n*/\nvoid sqlite3VtabFinishParse(Parse *pParse, Token *pEnd){\n  Table *pTab = pParse->pNewTable;  /* The table being constructed */\n  sqlite3 *db = pParse->db;         /* The database connection */\n\n  if( pTab==0 ) return;\n  assert( IsVirtual(pTab) );\n  addArgumentToVtab(pParse);\n  pParse->sArg.z = 0;\n  if( pTab->u.vtab.nArg<1 ) return;\n\n  /* If the CREATE VIRTUAL TABLE statement is being entered for the\n  ** first time (in other words if the virtual table is actually being\n  ** created now instead of just being read out of sqlite_schema) then\n  ** do additional initialization work and store the statement text\n  ** in the sqlite_schema table.\n  */\n  if( !db->init.busy ){\n    char *zStmt;\n    char *zWhere;\n    int iDb;\n    int iReg;\n    Vdbe *v;\n\n    sqlite3MayAbort(pParse);\n\n    /* Compute the complete text of the CREATE VIRTUAL TABLE statement */\n    if( pEnd ){\n      pParse->sNameToken.n = (int)(pEnd->z - pParse->sNameToken.z) + pEnd->n;\n    }\n    zStmt = sqlite3MPrintf(db, \"CREATE VIRTUAL TABLE %T\", &pParse->sNameToken);\n\n    /* A slot for the record has already been allocated in the\n    ** schema table.  We just need to update that slot with all\n    ** the information we've collected.\n    **\n    ** The VM register number pParse->u1.cr.regRowid holds the rowid of an\n    ** entry in the sqlite_schema table that was created for this vtab\n    ** by sqlite3StartTable().\n    */\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    assert( pParse->isCreate );\n    sqlite3NestedParse(pParse,\n      \"UPDATE %Q.\" LEGACY_SCHEMA_TABLE \" \"\n         \"SET type='table', name=%Q, tbl_name=%Q, rootpage=0, sql=%Q \"\n       \"WHERE rowid=#%d\",\n      db->aDb[iDb].zDbSName,\n      pTab->zName,\n      pTab->zName,\n      zStmt,\n      pParse->u1.cr.regRowid\n    );\n    v = sqlite3GetVdbe(pParse);\n    sqlite3ChangeCookie(pParse, iDb);\n\n    sqlite3VdbeAddOp0(v, OP_Expire);\n    zWhere = sqlite3MPrintf(db, \"name=%Q AND sql=%Q\", pTab->zName, zStmt);\n    sqlite3VdbeAddParseSchemaOp(v, iDb, zWhere, 0);\n    sqlite3DbFree(db, zStmt);\n\n    iReg = ++pParse->nMem;\n    sqlite3VdbeLoadString(v, iReg, pTab->zName);\n    sqlite3VdbeAddOp2(v, OP_VCreate, iDb, iReg);\n  }else{\n    /* If we are rereading the sqlite_schema table create the in-memory\n    ** record of the table. */\n    Table *pOld;\n    Schema *pSchema = pTab->pSchema;\n    const char *zName = pTab->zName;\n    assert( zName!=0 );\n    sqlite3MarkAllShadowTablesOf(db, pTab);\n    pOld = sqlite3HashInsert(&pSchema->tblHash, zName, pTab);\n    if( pOld ){\n      sqlite3OomFault(db);\n      assert( pTab==pOld );  /* Malloc must have failed inside HashInsert() */\n      return;\n    }\n    pParse->pNewTable = 0;\n  }\n}\n\n/*\n** The parser calls this routine when it sees the first token\n** of an argument to the module name in a CREATE VIRTUAL TABLE statement.\n*/\nvoid sqlite3VtabArgInit(Parse *pParse){\n  addArgumentToVtab(pParse);\n  pParse->sArg.z = 0;\n  pParse->sArg.n = 0;\n}\n\n/*\n** The parser calls this routine for each token after the first token\n** in an argument to the module name in a CREATE VIRTUAL TABLE statement.\n*/\nvoid sqlite3VtabArgExtend(Parse *pParse, Token *p){\n  Token *pArg = &pParse->sArg;\n  if( pArg->z==0 ){\n    pArg->z = p->z;\n    pArg->n = p->n;\n  }else{\n    assert(pArg->z <= p->z);\n    pArg->n = (int)(&p->z[p->n] - pArg->z);\n  }\n}\n\n/*\n** Invoke a virtual table constructor (either xCreate or xConnect). The\n** pointer to the function to invoke is passed as the fourth parameter\n** to this procedure.\n*/\nstatic int vtabCallConstructor(\n  sqlite3 *db,\n  Table *pTab,\n  Module *pMod,\n  int (*xConstruct)(sqlite3*,void*,int,const char*const*,sqlite3_vtab**,char**),\n  char **pzErr\n){\n  VtabCtx sCtx;\n  VTable *pVTable;\n  int rc;\n  const char *const*azArg;\n  int nArg = pTab->u.vtab.nArg;\n  char *zErr = 0;\n  char *zModuleName;\n  int iDb;\n  VtabCtx *pCtx;\n\n  assert( IsVirtual(pTab) );\n  azArg = (const char *const*)pTab->u.vtab.azArg;\n\n  /* Check that the virtual-table is not already being initialized */\n  for(pCtx=db->pVtabCtx; pCtx; pCtx=pCtx->pPrior){\n    if( pCtx->pTab==pTab ){\n      *pzErr = sqlite3MPrintf(db,\n          \"vtable constructor called recursively: %s\", pTab->zName\n      );\n      return SQLITE_LOCKED;\n    }\n  }\n\n  zModuleName = sqlite3DbStrDup(db, pTab->zName);\n  if( !zModuleName ){\n    return SQLITE_NOMEM_BKPT;\n  }\n\n  pVTable = sqlite3MallocZero(sizeof(VTable));\n  if( !pVTable ){\n    sqlite3OomFault(db);\n    sqlite3DbFree(db, zModuleName);\n    return SQLITE_NOMEM_BKPT;\n  }\n  pVTable->db = db;\n  pVTable->pMod = pMod;\n  pVTable->eVtabRisk = SQLITE_VTABRISK_Normal;\n\n  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n  pTab->u.vtab.azArg[1] = db->aDb[iDb].zDbSName;\n\n  /* Invoke the virtual table constructor */\n  assert( &db->pVtabCtx );\n  assert( xConstruct );\n  sCtx.pTab = pTab;\n  sCtx.pVTable = pVTable;\n  sCtx.pPrior = db->pVtabCtx;\n  sCtx.bDeclared = 0;\n  db->pVtabCtx = &sCtx;\n  pTab->nTabRef++;\n  rc = xConstruct(db, pMod->pAux, nArg, azArg, &pVTable->pVtab, &zErr);\n  assert( pTab!=0 );\n  assert( pTab->nTabRef>1 || rc!=SQLITE_OK );\n  sqlite3DeleteTable(db, pTab);\n  db->pVtabCtx = sCtx.pPrior;\n  if( rc==SQLITE_NOMEM ) sqlite3OomFault(db);\n  assert( sCtx.pTab==pTab );\n\n  if( SQLITE_OK!=rc ){\n    if( zErr==0 ){\n      *pzErr = sqlite3MPrintf(db, \"vtable constructor failed: %s\", zModuleName);\n    }else {\n      *pzErr = sqlite3MPrintf(db, \"%s\", zErr);\n      sqlite3_free(zErr);\n    }\n    sqlite3DbFree(db, pVTable);\n  }else if( ALWAYS(pVTable->pVtab) ){\n    /* Justification of ALWAYS():  A correct vtab constructor must allocate\n    ** the sqlite3_vtab object if successful.  */\n    memset(pVTable->pVtab, 0, sizeof(pVTable->pVtab[0]));\n    pVTable->pVtab->pModule = pMod->pModule;\n    pMod->nRefModule++;\n    pVTable->nRef = 1;\n    if( sCtx.bDeclared==0 ){\n      const char *zFormat = \"vtable constructor did not declare schema: %s\";\n      *pzErr = sqlite3MPrintf(db, zFormat, zModuleName);\n      sqlite3VtabUnlock(pVTable);\n      rc = SQLITE_ERROR;\n    }else{\n      int iCol;\n      u16 oooHidden = 0;\n      /* If everything went according to plan, link the new VTable structure\n      ** into the linked list headed by pTab->u.vtab.p. Then loop through the\n      ** columns of the table to see if any of them contain the token \"hidden\".\n      ** If so, set the Column COLFLAG_HIDDEN flag and remove the token from\n      ** the type string.  */\n      pVTable->pNext = pTab->u.vtab.p;\n      pTab->u.vtab.p = pVTable;\n\n      for(iCol=0; iCol<pTab->nCol; iCol++){\n        char *zType = sqlite3ColumnType(&pTab->aCol[iCol], \"\");\n        int nType;\n        int i = 0;\n        nType = sqlite3Strlen30(zType);\n        for(i=0; i<nType; i++){\n          if( 0==sqlite3StrNICmp(\"hidden\", &zType[i], 6)\n           && (i==0 || zType[i-1]==' ')\n           && (zType[i+6]=='\\0' || zType[i+6]==' ')\n          ){\n            break;\n          }\n        }\n        if( i<nType ){\n          int j;\n          int nDel = 6 + (zType[i+6] ? 1 : 0);\n          for(j=i; (j+nDel)<=nType; j++){\n            zType[j] = zType[j+nDel];\n          }\n          if( zType[i]=='\\0' && i>0 ){\n            assert(zType[i-1]==' ');\n            zType[i-1] = '\\0';\n          }\n          pTab->aCol[iCol].colFlags |= COLFLAG_HIDDEN;\n          pTab->tabFlags |= TF_HasHidden;\n          oooHidden = TF_OOOHidden;\n        }else{\n          pTab->tabFlags |= oooHidden;\n        }\n      }\n    }\n  }\n\n  sqlite3DbFree(db, zModuleName);\n  return rc;\n}\n\n/*\n** This function is invoked by the parser to call the xConnect() method\n** of the virtual table pTab. If an error occurs, an error code is returned\n** and an error left in pParse.\n**\n** This call is a no-op if table pTab is not a virtual table.\n*/\nint sqlite3VtabCallConnect(Parse *pParse, Table *pTab){\n  sqlite3 *db = pParse->db;\n  const char *zMod;\n  Module *pMod;\n  int rc;\n\n  assert( pTab );\n  assert( IsVirtual(pTab) );\n  if( sqlite3GetVTable(db, pTab) ){\n    return SQLITE_OK;\n  }\n\n  /* Locate the required virtual table module */\n  zMod = pTab->u.vtab.azArg[0];\n  pMod = (Module*)sqlite3HashFind(&db->aModule, zMod);\n\n  if( !pMod ){\n    const char *zModule = pTab->u.vtab.azArg[0];\n    sqlite3ErrorMsg(pParse, \"no such module: %s\", zModule);\n    rc = SQLITE_ERROR;\n  }else{\n    char *zErr = 0;\n    rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xConnect, &zErr);\n    if( rc!=SQLITE_OK ){\n      sqlite3ErrorMsg(pParse, \"%s\", zErr);\n      pParse->rc = rc;\n    }\n    sqlite3DbFree(db, zErr);\n  }\n\n  return rc;\n}\n/*\n** Grow the db->aVTrans[] array so that there is room for at least one\n** more v-table. Return SQLITE_NOMEM if a malloc fails, or SQLITE_OK otherwise.\n*/\nstatic int growVTrans(sqlite3 *db){\n  const int ARRAY_INCR = 5;\n\n  /* Grow the sqlite3.aVTrans array if required */\n  if( (db->nVTrans%ARRAY_INCR)==0 ){\n    VTable **aVTrans;\n    sqlite3_int64 nBytes = sizeof(sqlite3_vtab*)*\n                                 ((sqlite3_int64)db->nVTrans + ARRAY_INCR);\n    aVTrans = sqlite3DbRealloc(db, (void *)db->aVTrans, nBytes);\n    if( !aVTrans ){\n      return SQLITE_NOMEM_BKPT;\n    }\n    memset(&aVTrans[db->nVTrans], 0, sizeof(sqlite3_vtab *)*ARRAY_INCR);\n    db->aVTrans = aVTrans;\n  }\n\n  return SQLITE_OK;\n}\n\n/*\n** Add the virtual table pVTab to the array sqlite3.aVTrans[]. Space should\n** have already been reserved using growVTrans().\n*/\nstatic void addToVTrans(sqlite3 *db, VTable *pVTab){\n  /* Add pVtab to the end of sqlite3.aVTrans */\n  db->aVTrans[db->nVTrans++] = pVTab;\n  sqlite3VtabLock(pVTab);\n}\n\n/*\n** This function is invoked by the vdbe to call the xCreate method\n** of the virtual table named zTab in database iDb.\n**\n** If an error occurs, *pzErr is set to point to an English language\n** description of the error and an SQLITE_XXX error code is returned.\n** In this case the caller must call sqlite3DbFree(db, ) on *pzErr.\n*/\nint sqlite3VtabCallCreate(sqlite3 *db, int iDb, const char *zTab, char **pzErr){\n  int rc = SQLITE_OK;\n  Table *pTab;\n  Module *pMod;\n  const char *zMod;\n\n  pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zDbSName);\n  assert( pTab && IsVirtual(pTab) && !pTab->u.vtab.p );\n\n  /* Locate the required virtual table module */\n  zMod = pTab->u.vtab.azArg[0];\n  pMod = (Module*)sqlite3HashFind(&db->aModule, zMod);\n\n  /* If the module has been registered and includes a Create method,\n  ** invoke it now. If the module has not been registered, return an\n  ** error. Otherwise, do nothing.\n  */\n  if( pMod==0 || pMod->pModule->xCreate==0 || pMod->pModule->xDestroy==0 ){\n    *pzErr = sqlite3MPrintf(db, \"no such module: %s\", zMod);\n    rc = SQLITE_ERROR;\n  }else{\n    rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xCreate, pzErr);\n  }\n\n  /* Justification of ALWAYS():  The xConstructor method is required to\n  ** create a valid sqlite3_vtab if it returns SQLITE_OK. */\n  if( rc==SQLITE_OK && ALWAYS(sqlite3GetVTable(db, pTab)) ){\n    rc = growVTrans(db);\n    if( rc==SQLITE_OK ){\n      addToVTrans(db, sqlite3GetVTable(db, pTab));\n    }\n  }\n\n  return rc;\n}\n\n/*\n** This function is used to set the schema of a virtual table.  It is only\n** valid to call this function from within the xCreate() or xConnect() of a\n** virtual table module.\n*/\nint sqlite3_declare_vtab(sqlite3 *db, const char *zCreateTable){\n  VtabCtx *pCtx;\n  int rc = SQLITE_OK;\n  Table *pTab;\n  Parse sParse;\n  int initBusy;\n  int i;\n  const unsigned char *z;\n  static const u8 aKeyword[] = { TK_CREATE, TK_TABLE, 0 };\n\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( !sqlite3SafetyCheckOk(db) || zCreateTable==0 ){\n    return SQLITE_MISUSE_BKPT;\n  }\n#endif\n\n  /* Verify that the first two keywords in the CREATE TABLE statement\n  ** really are \"CREATE\" and \"TABLE\".  If this is not the case, then\n  ** sqlite3_declare_vtab() is being misused.\n  */\n  z = (const unsigned char*)zCreateTable;\n  for(i=0; aKeyword[i]; i++){\n    int tokenType = 0;\n    do{\n      z += sqlite3GetToken(z, &tokenType);\n    }while( tokenType==TK_SPACE || tokenType==TK_COMMENT );\n    if( tokenType!=aKeyword[i] ){\n      sqlite3ErrorWithMsg(db, SQLITE_ERROR, \"syntax error\");\n      return SQLITE_ERROR;\n    }\n  }\n \n  sqlite3_mutex_enter(db->mutex);\n  pCtx = db->pVtabCtx;\n  if( !pCtx || pCtx->bDeclared ){\n    sqlite3Error(db, SQLITE_MISUSE_BKPT);\n    sqlite3_mutex_leave(db->mutex);\n    return SQLITE_MISUSE_BKPT;\n  }\n\n  pTab = pCtx->pTab;\n  assert( IsVirtual(pTab) );\n\n  sqlite3ParseObjectInit(&sParse, db);\n  sParse.eParseMode = PARSE_MODE_DECLARE_VTAB;\n  sParse.disableTriggers = 1;\n  /* We should never be able to reach this point while loading the\n  ** schema.  Nevertheless, defend against that (turn off db->init.busy)\n  ** in case a bug arises. */\n  assert( db->init.busy==0 );\n  initBusy = db->init.busy;\n  db->init.busy = 0;\n  sParse.nQueryLoop = 1;\n  if( SQLITE_OK==sqlite3RunParser(&sParse, zCreateTable) ){\n    assert( sParse.pNewTable!=0 );\n    assert( !db->mallocFailed );\n    assert( IsOrdinaryTable(sParse.pNewTable) );\n    assert( sParse.zErrMsg==0 );\n    if( !pTab->aCol ){\n      Table *pNew = sParse.pNewTable;\n      Index *pIdx;\n      pTab->aCol = pNew->aCol;\n      assert( IsOrdinaryTable(pNew) );\n      sqlite3ExprListDelete(db, pNew->u.tab.pDfltList);\n      pTab->nNVCol = pTab->nCol = pNew->nCol;\n      pTab->tabFlags |= pNew->tabFlags & (TF_WithoutRowid|TF_NoVisibleRowid);\n      pNew->nCol = 0;\n      pNew->aCol = 0;\n      assert( pTab->pIndex==0 );\n      assert( HasRowid(pNew) || sqlite3PrimaryKeyIndex(pNew)!=0 );\n      if( !HasRowid(pNew)\n       && pCtx->pVTable->pMod->pModule->xUpdate!=0\n       && sqlite3PrimaryKeyIndex(pNew)->nKeyCol!=1\n      ){\n        /* WITHOUT ROWID virtual tables must either be read-only (xUpdate==0)\n        ** or else must have a single-column PRIMARY KEY */\n        rc = SQLITE_ERROR;\n      }\n      pIdx = pNew->pIndex;\n      if( pIdx ){\n        assert( pIdx->pNext==0 );\n        pTab->pIndex = pIdx;\n        pNew->pIndex = 0;\n        pIdx->pTable = pTab;\n      }\n    }\n    pCtx->bDeclared = 1;\n  }else{\n    sqlite3ErrorWithMsg(db, SQLITE_ERROR,\n          (sParse.zErrMsg ? \"%s\" : 0), sParse.zErrMsg);\n    sqlite3DbFree(db, sParse.zErrMsg);\n    rc = SQLITE_ERROR;\n  }\n  sParse.eParseMode = PARSE_MODE_NORMAL;\n\n  if( sParse.pVdbe ){\n    sqlite3VdbeFinalize(sParse.pVdbe);\n  }\n  sqlite3DeleteTable(db, sParse.pNewTable);\n  sqlite3ParseObjectReset(&sParse);\n  db->init.busy = initBusy;\n\n  assert( (rc&0xff)==rc );\n  rc = sqlite3ApiExit(db, rc);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n/*\n** This function is invoked by the vdbe to call the xDestroy method\n** of the virtual table named zTab in database iDb. This occurs\n** when a DROP TABLE is mentioned.\n**\n** This call is a no-op if zTab is not a virtual table.\n*/\nint sqlite3VtabCallDestroy(sqlite3 *db, int iDb, const char *zTab){\n  int rc = SQLITE_OK;\n  Table *pTab;\n\n  pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zDbSName);\n  if( ALWAYS(pTab!=0)\n   && ALWAYS(IsVirtual(pTab))\n   && ALWAYS(pTab->u.vtab.p!=0)\n  ){\n    VTable *p;\n    int (*xDestroy)(sqlite3_vtab *);\n    for(p=pTab->u.vtab.p; p; p=p->pNext){\n      assert( p->pVtab );\n      if( p->pVtab->nRef>0 ){\n        return SQLITE_LOCKED;\n      }\n    }\n    p = vtabDisconnectAll(db, pTab);\n    xDestroy = p->pMod->pModule->xDestroy;\n    if( xDestroy==0 ) xDestroy = p->pMod->pModule->xDisconnect;\n    assert( xDestroy!=0 );\n    pTab->nTabRef++;\n    rc = xDestroy(p->pVtab);\n    /* Remove the sqlite3_vtab* from the aVTrans[] array, if applicable */\n    if( rc==SQLITE_OK ){\n      assert( pTab->u.vtab.p==p && p->pNext==0 );\n      p->pVtab = 0;\n      pTab->u.vtab.p = 0;\n      sqlite3VtabUnlock(p);\n    }\n    sqlite3DeleteTable(db, pTab);\n  }\n\n  return rc;\n}\n\n/*\n** This function invokes either the xRollback or xCommit method\n** of each of the virtual tables in the sqlite3.aVTrans array. The method\n** called is identified by the second argument, \"offset\", which is\n** the offset of the method to call in the sqlite3_module structure.\n**\n** The array is cleared after invoking the callbacks.\n*/\nstatic void callFinaliser(sqlite3 *db, int offset){\n  int i;\n  if( db->aVTrans ){\n    VTable **aVTrans = db->aVTrans;\n    db->aVTrans = 0;\n    for(i=0; i<db->nVTrans; i++){\n      VTable *pVTab = aVTrans[i];\n      sqlite3_vtab *p = pVTab->pVtab;\n      if( p ){\n        int (*x)(sqlite3_vtab *);\n        x = *(int (**)(sqlite3_vtab *))((char *)p->pModule + offset);\n        if( x ) x(p);\n      }\n      pVTab->iSavepoint = 0;\n      sqlite3VtabUnlock(pVTab);\n    }\n    sqlite3DbFree(db, aVTrans);\n    db->nVTrans = 0;\n  }\n}\n\n/*\n** Invoke the xSync method of all virtual tables in the sqlite3.aVTrans\n** array. Return the error code for the first error that occurs, or\n** SQLITE_OK if all xSync operations are successful.\n**\n** If an error message is available, leave it in p->zErrMsg.\n*/\nint sqlite3VtabSync(sqlite3 *db, Vdbe *p){\n  int i;\n  int rc = SQLITE_OK;\n  VTable **aVTrans = db->aVTrans;\n\n  db->aVTrans = 0;\n  for(i=0; rc==SQLITE_OK && i<db->nVTrans; i++){\n    int (*x)(sqlite3_vtab *);\n    sqlite3_vtab *pVtab = aVTrans[i]->pVtab;\n    if( pVtab && (x = pVtab->pModule->xSync)!=0 ){\n      rc = x(pVtab);\n      sqlite3VtabImportErrmsg(p, pVtab);\n    }\n  }\n  db->aVTrans = aVTrans;\n  return rc;\n}\n\n/*\n** Invoke the xRollback method of all virtual tables in the\n** sqlite3.aVTrans array. Then clear the array itself.\n*/\nint sqlite3VtabRollback(sqlite3 *db){\n  callFinaliser(db, offsetof(sqlite3_module,xRollback));\n  return SQLITE_OK;\n}\n\n/*\n** Invoke the xCommit method of all virtual tables in the\n** sqlite3.aVTrans array. Then clear the array itself.\n*/\nint sqlite3VtabCommit(sqlite3 *db){\n  callFinaliser(db, offsetof(sqlite3_module,xCommit));\n  return SQLITE_OK;\n}\n\n/*\n** If the virtual table pVtab supports the transaction interface\n** (xBegin/xRollback/xCommit and optionally xSync) and a transaction is\n** not currently open, invoke the xBegin method now.\n**\n** If the xBegin call is successful, place the sqlite3_vtab pointer\n** in the sqlite3.aVTrans array.\n*/\nint sqlite3VtabBegin(sqlite3 *db, VTable *pVTab){\n  int rc = SQLITE_OK;\n  const sqlite3_module *pModule;\n\n  /* Special case: If db->aVTrans is NULL and db->nVTrans is greater\n  ** than zero, then this function is being called from within a\n  ** virtual module xSync() callback. It is illegal to write to\n  ** virtual module tables in this case, so return SQLITE_LOCKED.\n  */\n  if( sqlite3VtabInSync(db) ){\n    return SQLITE_LOCKED;\n  }\n  if( !pVTab ){\n    return SQLITE_OK;\n  }\n  pModule = pVTab->pVtab->pModule;\n\n  if( pModule->xBegin ){\n    int i;\n\n    /* If pVtab is already in the aVTrans array, return early */\n    for(i=0; i<db->nVTrans; i++){\n      if( db->aVTrans[i]==pVTab ){\n        return SQLITE_OK;\n      }\n    }\n\n    /* Invoke the xBegin method. If successful, add the vtab to the\n    ** sqlite3.aVTrans[] array. */\n    rc = growVTrans(db);\n    if( rc==SQLITE_OK ){\n      rc = pModule->xBegin(pVTab->pVtab);\n      if( rc==SQLITE_OK ){\n        int iSvpt = db->nStatement + db->nSavepoint;\n        addToVTrans(db, pVTab);\n        if( iSvpt && pModule->xSavepoint ){\n          pVTab->iSavepoint = iSvpt;\n          rc = pModule->xSavepoint(pVTab->pVtab, iSvpt-1);\n        }\n      }\n    }\n  }\n  return rc;\n}\n\n/*\n** Invoke either the xSavepoint, xRollbackTo or xRelease method of all\n** virtual tables that currently have an open transaction. Pass iSavepoint\n** as the second argument to the virtual table method invoked.\n**\n** If op is SAVEPOINT_BEGIN, the xSavepoint method is invoked. If it is\n** SAVEPOINT_ROLLBACK, the xRollbackTo method. Otherwise, if op is\n** SAVEPOINT_RELEASE, then the xRelease method of each virtual table with\n** an open transaction is invoked.\n**\n** If any virtual table method returns an error code other than SQLITE_OK,\n** processing is abandoned and the error returned to the caller of this\n** function immediately. If all calls to virtual table methods are successful,\n** SQLITE_OK is returned.\n*/\nint sqlite3VtabSavepoint(sqlite3 *db, int op, int iSavepoint){\n  int rc = SQLITE_OK;\n\n  assert( op==SAVEPOINT_RELEASE||op==SAVEPOINT_ROLLBACK||op==SAVEPOINT_BEGIN );\n  assert( iSavepoint>=-1 );\n  if( db->aVTrans ){\n    int i;\n    for(i=0; rc==SQLITE_OK && i<db->nVTrans; i++){\n      VTable *pVTab = db->aVTrans[i];\n      const sqlite3_module *pMod = pVTab->pMod->pModule;\n      if( pVTab->pVtab && pMod->iVersion>=2 ){\n        int (*xMethod)(sqlite3_vtab *, int);\n        sqlite3VtabLock(pVTab);\n        switch( op ){\n          case SAVEPOINT_BEGIN:\n            xMethod = pMod->xSavepoint;\n            pVTab->iSavepoint = iSavepoint+1;\n            break;\n          case SAVEPOINT_ROLLBACK:\n            xMethod = pMod->xRollbackTo;\n            break;\n          default:\n            xMethod = pMod->xRelease;\n            break;\n        }\n        if( xMethod && pVTab->iSavepoint>iSavepoint ){\n          u64 savedFlags = (db->flags & SQLITE_Defensive);\n          db->flags &= ~(u64)SQLITE_Defensive;\n          rc = xMethod(pVTab->pVtab, iSavepoint);\n          db->flags |= savedFlags;\n        }\n        sqlite3VtabUnlock(pVTab);\n      }\n    }\n  }\n  return rc;\n}\n\n/*\n** The first parameter (pDef) is a function implementation.  The\n** second parameter (pExpr) is the first argument to this function.\n** If pExpr is a column in a virtual table, then let the virtual\n** table implementation have an opportunity to overload the function.\n**\n** This routine is used to allow virtual table implementations to\n** overload MATCH, LIKE, GLOB, and REGEXP operators.\n**\n** Return either the pDef argument (indicating no change) or a\n** new FuncDef structure that is marked as ephemeral using the\n** SQLITE_FUNC_EPHEM flag.\n*/\nFuncDef *sqlite3VtabOverloadFunction(\n  sqlite3 *db,    /* Database connection for reporting malloc problems */\n  FuncDef *pDef,  /* Function to possibly overload */\n  int nArg,       /* Number of arguments to the function */\n  Expr *pExpr     /* First argument to the function */\n){\n  Table *pTab;\n  sqlite3_vtab *pVtab;\n  sqlite3_module *pMod;\n  void (*xSFunc)(sqlite3_context*,int,sqlite3_value**) = 0;\n  void *pArg = 0;\n  FuncDef *pNew;\n  int rc = 0;\n\n  /* Check to see the left operand is a column in a virtual table */\n  if( NEVER(pExpr==0) ) return pDef;\n  if( pExpr->op!=TK_COLUMN ) return pDef;\n  assert( ExprUseYTab(pExpr) );\n  pTab = pExpr->y.pTab;\n  if( NEVER(pTab==0) ) return pDef;\n  if( !IsVirtual(pTab) ) return pDef;\n  pVtab = sqlite3GetVTable(db, pTab)->pVtab;\n  assert( pVtab!=0 );\n  assert( pVtab->pModule!=0 );\n  pMod = (sqlite3_module *)pVtab->pModule;\n  if( pMod->xFindFunction==0 ) return pDef;\n\n  /* Call the xFindFunction method on the virtual table implementation\n  ** to see if the implementation wants to overload this function.\n  **\n  ** Though undocumented, we have historically always invoked xFindFunction\n  ** with an all lower-case function name.  Continue in this tradition to\n  ** avoid any chance of an incompatibility.\n  */\n#ifdef SQLITE_DEBUG\n  {\n    int i;\n    for(i=0; pDef->zName[i]; i++){\n      unsigned char x = (unsigned char)pDef->zName[i];\n      assert( x==sqlite3UpperToLower[x] );\n    }\n  }\n#endif\n  rc = pMod->xFindFunction(pVtab, nArg, pDef->zName, &xSFunc, &pArg);\n  if( rc==0 ){\n    return pDef;\n  }\n\n  /* Create a new ephemeral function definition for the overloaded\n  ** function */\n  pNew = sqlite3DbMallocZero(db, sizeof(*pNew)\n                             + sqlite3Strlen30(pDef->zName) + 1);\n  if( pNew==0 ){\n    return pDef;\n  }\n  *pNew = *pDef;\n  pNew->zName = (const char*)&pNew[1];\n  memcpy((char*)&pNew[1], pDef->zName, sqlite3Strlen30(pDef->zName)+1);\n  pNew->xSFunc = xSFunc;\n  pNew->pUserData = pArg;\n  pNew->funcFlags |= SQLITE_FUNC_EPHEM;\n  return pNew;\n}\n\n/*\n** Make sure virtual table pTab is contained in the pParse->apVirtualLock[]\n** array so that an OP_VBegin will get generated for it.  Add pTab to the\n** array if it is missing.  If pTab is already in the array, this routine\n** is a no-op.\n*/\nvoid sqlite3VtabMakeWritable(Parse *pParse, Table *pTab){\n  Parse *pToplevel = sqlite3ParseToplevel(pParse);\n  int i, n;\n  Table **apVtabLock;\n\n  assert( IsVirtual(pTab) );\n  for(i=0; i<pToplevel->nVtabLock; i++){\n    if( pTab==pToplevel->apVtabLock[i] ) return;\n  }\n  n = (pToplevel->nVtabLock+1)*sizeof(pToplevel->apVtabLock[0]);\n  apVtabLock = sqlite3Realloc(pToplevel->apVtabLock, n);\n  if( apVtabLock ){\n    pToplevel->apVtabLock = apVtabLock;\n    pToplevel->apVtabLock[pToplevel->nVtabLock++] = pTab;\n  }else{\n    sqlite3OomFault(pToplevel->db);\n  }\n}\n\n/*\n** Check to see if virtual table module pMod can be have an eponymous\n** virtual table instance.  If it can, create one if one does not already\n** exist. Return non-zero if either the eponymous virtual table instance\n** exists when this routine returns or if an attempt to create it failed\n** and an error message was left in pParse.\n**\n** An eponymous virtual table instance is one that is named after its\n** module, and more importantly, does not require a CREATE VIRTUAL TABLE\n** statement in order to come into existence.  Eponymous virtual table\n** instances always exist.  They cannot be DROP-ed.\n**\n** Any virtual table module for which xConnect and xCreate are the same\n** method can have an eponymous virtual table instance.\n*/\nint sqlite3VtabEponymousTableInit(Parse *pParse, Module *pMod){\n  const sqlite3_module *pModule = pMod->pModule;\n  Table *pTab;\n  char *zErr = 0;\n  int rc;\n  sqlite3 *db = pParse->db;\n  if( pMod->pEpoTab ) return 1;\n  if( pModule->xCreate!=0 && pModule->xCreate!=pModule->xConnect ) return 0;\n  pTab = sqlite3DbMallocZero(db, sizeof(Table));\n  if( pTab==0 ) return 0;\n  pTab->zName = sqlite3DbStrDup(db, pMod->zName);\n  if( pTab->zName==0 ){\n    sqlite3DbFree(db, pTab);\n    return 0;\n  }\n  pMod->pEpoTab = pTab;\n  pTab->nTabRef = 1;\n  pTab->eTabType = TABTYP_VTAB;\n  pTab->pSchema = db->aDb[0].pSchema;\n  assert( pTab->u.vtab.nArg==0 );\n  pTab->iPKey = -1;\n  pTab->tabFlags |= TF_Eponymous;\n  addModuleArgument(pParse, pTab, sqlite3DbStrDup(db, pTab->zName));\n  addModuleArgument(pParse, pTab, 0);\n  addModuleArgument(pParse, pTab, sqlite3DbStrDup(db, pTab->zName));\n  db->nSchemaLock++;\n  rc = vtabCallConstructor(db, pTab, pMod, pModule->xConnect, &zErr);\n  db->nSchemaLock--;\n  if( rc ){\n    sqlite3ErrorMsg(pParse, \"%s\", zErr);\n    pParse->rc = rc;\n    sqlite3DbFree(db, zErr);\n    sqlite3VtabEponymousTableClear(db, pMod);\n  }\n  return 1;\n}\n\n/*\n** Erase the eponymous virtual table instance associated with\n** virtual table module pMod, if it exists.\n*/\nvoid sqlite3VtabEponymousTableClear(sqlite3 *db, Module *pMod){\n  Table *pTab = pMod->pEpoTab;\n  if( pTab!=0 ){\n    /* Mark the table as Ephemeral prior to deleting it, so that the\n    ** sqlite3DeleteTable() routine will know that it is not stored in\n    ** the schema. */\n    pTab->tabFlags |= TF_Ephemeral;\n    sqlite3DeleteTable(db, pTab);\n    pMod->pEpoTab = 0;\n  }\n}\n\n/*\n** Return the ON CONFLICT resolution mode in effect for the virtual\n** table update operation currently in progress.\n**\n** The results of this routine are undefined unless it is called from\n** within an xUpdate method.\n*/\nint sqlite3_vtab_on_conflict(sqlite3 *db){\n  static const unsigned char aMap[] = {\n    SQLITE_ROLLBACK, SQLITE_ABORT, SQLITE_FAIL, SQLITE_IGNORE, SQLITE_REPLACE\n  };\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n#endif\n  assert( OE_Rollback==1 && OE_Abort==2 && OE_Fail==3 );\n  assert( OE_Ignore==4 && OE_Replace==5 );\n  assert( db->vtabOnConflict>=1 && db->vtabOnConflict<=5 );\n  return (int)aMap[db->vtabOnConflict-1];\n}\n\n/*\n** Call from within the xCreate() or xConnect() methods to provide\n** the SQLite core with additional information about the behavior\n** of the virtual table being implemented.\n*/\nint sqlite3_vtab_config(sqlite3 *db, int op, ...){\n  va_list ap;\n  int rc = SQLITE_OK;\n  VtabCtx *p;\n\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n#endif\n  sqlite3_mutex_enter(db->mutex);\n  p = db->pVtabCtx;\n  if( !p ){\n    rc = SQLITE_MISUSE_BKPT;\n  }else{\n    assert( p->pTab==0 || IsVirtual(p->pTab) );\n    va_start(ap, op);\n    switch( op ){\n      case SQLITE_VTAB_CONSTRAINT_SUPPORT: {\n        p->pVTable->bConstraint = (u8)va_arg(ap, int);\n        break;\n      }\n      case SQLITE_VTAB_INNOCUOUS: {\n        p->pVTable->eVtabRisk = SQLITE_VTABRISK_Low;\n        break;\n      }\n      case SQLITE_VTAB_DIRECTONLY: {\n        p->pVTable->eVtabRisk = SQLITE_VTABRISK_High;\n        break;\n      }\n      case SQLITE_VTAB_USES_ALL_SCHEMAS: {\n        p->pVTable->bAllSchemas = 1;\n        break;\n      }\n      default: {\n        rc = SQLITE_MISUSE_BKPT;\n        break;\n      }\n    }\n    va_end(ap);\n  }\n\n  if( rc!=SQLITE_OK ) sqlite3Error(db, rc);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n"}
{"repo": "sqlite", "file": "vdbeblob.c", "lang": "C++", "code": "/*\n** 2007 May 1\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains code used to implement incremental BLOB I/O.\n*/\n\n#include \"sqliteInt.h\"\n#include \"vdbeInt.h\"\n\n#ifndef SQLITE_OMIT_INCRBLOB\n\n/*\n** Valid sqlite3_blob* handles point to Incrblob structures.\n*/\ntypedef struct Incrblob Incrblob;\nstruct Incrblob {\n  int nByte;              /* Size of open blob, in bytes */\n  int iOffset;            /* Byte offset of blob in cursor data */\n  u16 iCol;               /* Table column this handle is open on */\n  BtCursor *pCsr;         /* Cursor pointing at blob row */\n  sqlite3_stmt *pStmt;    /* Statement holding cursor open */\n  sqlite3 *db;            /* The associated database */\n  char *zDb;              /* Database name */\n  Table *pTab;            /* Table object */\n};\n\n\n/*\n** This function is used by both blob_open() and blob_reopen(). It seeks\n** the b-tree cursor associated with blob handle p to point to row iRow.\n** If successful, SQLITE_OK is returned and subsequent calls to\n** sqlite3_blob_read() or sqlite3_blob_write() access the specified row.\n**\n** If an error occurs, or if the specified row does not exist or does not\n** contain a value of type TEXT or BLOB in the column nominated when the\n** blob handle was opened, then an error code is returned and *pzErr may\n** be set to point to a buffer containing an error message. It is the\n** responsibility of the caller to free the error message buffer using\n** sqlite3DbFree().\n**\n** If an error does occur, then the b-tree cursor is closed. All subsequent\n** calls to sqlite3_blob_read(), blob_write() or blob_reopen() will \n** immediately return SQLITE_ABORT.\n*/\nstatic int blobSeekToRow(Incrblob *p, sqlite3_int64 iRow, char **pzErr){\n  int rc;                         /* Error code */\n  char *zErr = 0;                 /* Error message */\n  Vdbe *v = (Vdbe *)p->pStmt;\n\n  /* Set the value of register r[1] in the SQL statement to integer iRow. \n  ** This is done directly as a performance optimization\n  */\n  sqlite3VdbeMemSetInt64(&v->aMem[1], iRow);\n\n  /* If the statement has been run before (and is paused at the OP_ResultRow)\n  ** then back it up to the point where it does the OP_NotExists.  This could\n  ** have been down with an extra OP_Goto, but simply setting the program\n  ** counter is faster. */\n  if( v->pc>4 ){\n    v->pc = 4;\n    assert( v->aOp[v->pc].opcode==OP_NotExists );\n    rc = sqlite3VdbeExec(v);\n  }else{\n    rc = sqlite3_step(p->pStmt);\n  }\n  if( rc==SQLITE_ROW ){\n    VdbeCursor *pC = v->apCsr[0];\n    u32 type;\n    assert( pC!=0 );\n    assert( pC->eCurType==CURTYPE_BTREE );\n    type = pC->nHdrParsed>p->iCol ? pC->aType[p->iCol] : 0;\n    testcase( pC->nHdrParsed==p->iCol );\n    testcase( pC->nHdrParsed==p->iCol+1 );\n    if( type<12 ){\n      zErr = sqlite3MPrintf(p->db, \"cannot open value of type %s\",\n          type==0?\"null\": type==7?\"real\": \"integer\"\n      );\n      rc = SQLITE_ERROR;\n      sqlite3_finalize(p->pStmt);\n      p->pStmt = 0;\n    }else{\n      p->iOffset = pC->aType[p->iCol + pC->nField];\n      p->nByte = sqlite3VdbeSerialTypeLen(type);\n      p->pCsr =  pC->uc.pCursor;\n      sqlite3BtreeIncrblobCursor(p->pCsr);\n    }\n  }\n\n  if( rc==SQLITE_ROW ){\n    rc = SQLITE_OK;\n  }else if( p->pStmt ){\n    rc = sqlite3_finalize(p->pStmt);\n    p->pStmt = 0;\n    if( rc==SQLITE_OK ){\n      zErr = sqlite3MPrintf(p->db, \"no such rowid: %lld\", iRow);\n      rc = SQLITE_ERROR;\n    }else{\n      zErr = sqlite3MPrintf(p->db, \"%s\", sqlite3_errmsg(p->db));\n    }\n  }\n\n  assert( rc!=SQLITE_OK || zErr==0 );\n  assert( rc!=SQLITE_ROW && rc!=SQLITE_DONE );\n\n  *pzErr = zErr;\n  return rc;\n}\n\n/*\n** Open a blob handle.\n*/\nint sqlite3_blob_open(\n  sqlite3* db,            /* The database connection */\n  const char *zDb,        /* The attached database containing the blob */\n  const char *zTable,     /* The table containing the blob */\n  const char *zColumn,    /* The column containing the blob */\n  sqlite_int64 iRow,      /* The row containing the glob */\n  int wrFlag,             /* True -> read/write access, false -> read-only */\n  sqlite3_blob **ppBlob   /* Handle for accessing the blob returned here */\n){\n  int nAttempt = 0;\n  int iCol;               /* Index of zColumn in row-record */\n  int rc = SQLITE_OK;\n  char *zErr = 0;\n  Table *pTab;\n  Incrblob *pBlob = 0;\n  int iDb;\n  Parse sParse;\n\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( ppBlob==0 ){\n    return SQLITE_MISUSE_BKPT;\n  }\n#endif\n  *ppBlob = 0;\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( !sqlite3SafetyCheckOk(db) || zTable==0 || zColumn==0 ){\n    return SQLITE_MISUSE_BKPT;\n  }\n#endif\n  wrFlag = !!wrFlag;                /* wrFlag = (wrFlag ? 1 : 0); */\n\n  sqlite3_mutex_enter(db->mutex);\n\n  pBlob = (Incrblob *)sqlite3DbMallocZero(db, sizeof(Incrblob));\n  while(1){\n    sqlite3ParseObjectInit(&sParse,db);\n    if( !pBlob ) goto blob_open_out;\n    sqlite3DbFree(db, zErr);\n    zErr = 0;\n\n    sqlite3BtreeEnterAll(db);\n    pTab = sqlite3LocateTable(&sParse, 0, zTable, zDb);\n    if( pTab && IsVirtual(pTab) ){\n      pTab = 0;\n      sqlite3ErrorMsg(&sParse, \"cannot open virtual table: %s\", zTable);\n    }\n    if( pTab && !HasRowid(pTab) ){\n      pTab = 0;\n      sqlite3ErrorMsg(&sParse, \"cannot open table without rowid: %s\", zTable);\n    }\n    if( pTab && (pTab->tabFlags&TF_HasGenerated)!=0 ){\n      pTab = 0;\n      sqlite3ErrorMsg(&sParse, \"cannot open table with generated columns: %s\",\n                      zTable);\n    }\n#ifndef SQLITE_OMIT_VIEW\n    if( pTab && IsView(pTab) ){\n      pTab = 0;\n      sqlite3ErrorMsg(&sParse, \"cannot open view: %s\", zTable);\n    }\n#endif\n    if( pTab==0\n     || ((iDb = sqlite3SchemaToIndex(db, pTab->pSchema))==1 &&\n         sqlite3OpenTempDatabase(&sParse))\n    ){\n      if( sParse.zErrMsg ){\n        sqlite3DbFree(db, zErr);\n        zErr = sParse.zErrMsg;\n        sParse.zErrMsg = 0;\n      }\n      rc = SQLITE_ERROR;\n      sqlite3BtreeLeaveAll(db);\n      goto blob_open_out;\n    }\n    pBlob->pTab = pTab;\n    pBlob->zDb = db->aDb[iDb].zDbSName;\n\n    /* Now search pTab for the exact column. */\n    iCol = sqlite3ColumnIndex(pTab, zColumn);\n    if( iCol<0 ){\n      sqlite3DbFree(db, zErr);\n      zErr = sqlite3MPrintf(db, \"no such column: \\\"%s\\\"\", zColumn);\n      rc = SQLITE_ERROR;\n      sqlite3BtreeLeaveAll(db);\n      goto blob_open_out;\n    }\n\n    /* If the value is being opened for writing, check that the\n    ** column is not indexed, and that it is not part of a foreign key. \n    */\n    if( wrFlag ){\n      const char *zFault = 0;\n      Index *pIdx;\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n      if( db->flags&SQLITE_ForeignKeys ){\n        /* Check that the column is not part of an FK child key definition. It\n        ** is not necessary to check if it is part of a parent key, as parent\n        ** key columns must be indexed. The check below will pick up this \n        ** case.  */\n        FKey *pFKey;\n        assert( IsOrdinaryTable(pTab) );\n        for(pFKey=pTab->u.tab.pFKey; pFKey; pFKey=pFKey->pNextFrom){\n          int j;\n          for(j=0; j<pFKey->nCol; j++){\n            if( pFKey->aCol[j].iFrom==iCol ){\n              zFault = \"foreign key\";\n            }\n          }\n        }\n      }\n#endif\n      for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n        int j;\n        for(j=0; j<pIdx->nKeyCol; j++){\n          /* FIXME: Be smarter about indexes that use expressions */\n          if( pIdx->aiColumn[j]==iCol || pIdx->aiColumn[j]==XN_EXPR ){\n            zFault = \"indexed\";\n          }\n        }\n      }\n      if( zFault ){\n        sqlite3DbFree(db, zErr);\n        zErr = sqlite3MPrintf(db, \"cannot open %s column for writing\", zFault);\n        rc = SQLITE_ERROR;\n        sqlite3BtreeLeaveAll(db);\n        goto blob_open_out;\n      }\n    }\n\n    pBlob->pStmt = (sqlite3_stmt *)sqlite3VdbeCreate(&sParse);\n    assert( pBlob->pStmt || db->mallocFailed );\n    if( pBlob->pStmt ){\n      \n      /* This VDBE program seeks a btree cursor to the identified \n      ** db/table/row entry. The reason for using a vdbe program instead\n      ** of writing code to use the b-tree layer directly is that the\n      ** vdbe program will take advantage of the various transaction,\n      ** locking and error handling infrastructure built into the vdbe.\n      **\n      ** After seeking the cursor, the vdbe executes an OP_ResultRow.\n      ** Code external to the Vdbe then \"borrows\" the b-tree cursor and\n      ** uses it to implement the blob_read(), blob_write() and \n      ** blob_bytes() functions.\n      **\n      ** The sqlite3_blob_close() function finalizes the vdbe program,\n      ** which closes the b-tree cursor and (possibly) commits the \n      ** transaction.\n      */\n      static const int iLn = VDBE_OFFSET_LINENO(2);\n      static const VdbeOpList openBlob[] = {\n        {OP_TableLock,      0, 0, 0},  /* 0: Acquire a read or write lock */\n        {OP_OpenRead,       0, 0, 0},  /* 1: Open a cursor */\n        /* blobSeekToRow() will initialize r[1] to the desired rowid */\n        {OP_NotExists,      0, 5, 1},  /* 2: Seek the cursor to rowid=r[1] */\n        {OP_Column,         0, 0, 1},  /* 3  */\n        {OP_ResultRow,      1, 0, 0},  /* 4  */\n        {OP_Halt,           0, 0, 0},  /* 5  */\n      };\n      Vdbe *v = (Vdbe *)pBlob->pStmt;\n      VdbeOp *aOp;\n\n      sqlite3VdbeAddOp4Int(v, OP_Transaction, iDb, wrFlag, \n                           pTab->pSchema->schema_cookie,\n                           pTab->pSchema->iGeneration);\n      sqlite3VdbeChangeP5(v, 1);\n      assert( sqlite3VdbeCurrentAddr(v)==2 || db->mallocFailed );\n      aOp = sqlite3VdbeAddOpList(v, ArraySize(openBlob), openBlob, iLn);\n\n      /* Make sure a mutex is held on the table to be accessed */\n      sqlite3VdbeUsesBtree(v, iDb); \n\n      if( db->mallocFailed==0 ){\n        assert( aOp!=0 );\n        /* Configure the OP_TableLock instruction */\n#ifdef SQLITE_OMIT_SHARED_CACHE\n        aOp[0].opcode = OP_Noop;\n#else\n        aOp[0].p1 = iDb;\n        aOp[0].p2 = pTab->tnum;\n        aOp[0].p3 = wrFlag;\n        sqlite3VdbeChangeP4(v, 2, pTab->zName, P4_TRANSIENT);\n      }\n      if( db->mallocFailed==0 ){\n#endif\n\n        /* Remove either the OP_OpenWrite or OpenRead. Set the P2 \n        ** parameter of the other to pTab->tnum.  */\n        if( wrFlag ) aOp[1].opcode = OP_OpenWrite;\n        aOp[1].p2 = pTab->tnum;\n        aOp[1].p3 = iDb;   \n\n        /* Configure the number of columns. Configure the cursor to\n        ** think that the table has one more column than it really\n        ** does. An OP_Column to retrieve this imaginary column will\n        ** always return an SQL NULL. This is useful because it means\n        ** we can invoke OP_Column to fill in the vdbe cursors type \n        ** and offset cache without causing any IO.\n        */\n        aOp[1].p4type = P4_INT32;\n        aOp[1].p4.i = pTab->nCol+1;\n        aOp[3].p2 = pTab->nCol;\n\n        sParse.nVar = 0;\n        sParse.nMem = 1;\n        sParse.nTab = 1;\n        sqlite3VdbeMakeReady(v, &sParse);\n      }\n    }\n   \n    pBlob->iCol = iCol;\n    pBlob->db = db;\n    sqlite3BtreeLeaveAll(db);\n    if( db->mallocFailed ){\n      goto blob_open_out;\n    }\n    rc = blobSeekToRow(pBlob, iRow, &zErr);\n    if( (++nAttempt)>=SQLITE_MAX_SCHEMA_RETRY || rc!=SQLITE_SCHEMA ) break;\n    sqlite3ParseObjectReset(&sParse);\n  }\n\nblob_open_out:\n  if( rc==SQLITE_OK && db->mallocFailed==0 ){\n    *ppBlob = (sqlite3_blob *)pBlob;\n  }else{\n    if( pBlob && pBlob->pStmt ) sqlite3VdbeFinalize((Vdbe *)pBlob->pStmt);\n    sqlite3DbFree(db, pBlob);\n  }\n  sqlite3ErrorWithMsg(db, rc, (zErr ? \"%s\" : (char*)0), zErr);\n  sqlite3DbFree(db, zErr);\n  sqlite3ParseObjectReset(&sParse);\n  rc = sqlite3ApiExit(db, rc);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n/*\n** Close a blob handle that was previously created using\n** sqlite3_blob_open().\n*/\nint sqlite3_blob_close(sqlite3_blob *pBlob){\n  Incrblob *p = (Incrblob *)pBlob;\n  int rc;\n  sqlite3 *db;\n\n  if( p ){\n    sqlite3_stmt *pStmt = p->pStmt;\n    db = p->db;\n    sqlite3_mutex_enter(db->mutex);\n    sqlite3DbFree(db, p);\n    sqlite3_mutex_leave(db->mutex);\n    rc = sqlite3_finalize(pStmt);\n  }else{\n    rc = SQLITE_OK;\n  }\n  return rc;\n}\n\n/*\n** Perform a read or write operation on a blob\n*/\nstatic int blobReadWrite(\n  sqlite3_blob *pBlob, \n  void *z, \n  int n, \n  int iOffset, \n  int (*xCall)(BtCursor*, u32, u32, void*)\n){\n  int rc = SQLITE_OK;\n  Incrblob *p = (Incrblob *)pBlob;\n  Vdbe *v;\n  sqlite3 *db;\n\n  if( p==0 ) return SQLITE_MISUSE_BKPT;\n  db = p->db;\n  sqlite3_mutex_enter(db->mutex);\n  v = (Vdbe*)p->pStmt;\n\n  if( n<0 || iOffset<0 || ((sqlite3_int64)iOffset+n)>p->nByte ){\n    /* Request is out of range. Return a transient error. */\n    rc = SQLITE_ERROR;\n  }else if( v==0 ){\n    /* If there is no statement handle, then the blob-handle has\n    ** already been invalidated. Return SQLITE_ABORT in this case.\n    */\n    rc = SQLITE_ABORT;\n  }else{\n    /* Call either BtreeData() or BtreePutData(). If SQLITE_ABORT is\n    ** returned, clean-up the statement handle.\n    */\n    assert( db == v->db );\n    sqlite3BtreeEnterCursor(p->pCsr);\n\n#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n    if( xCall==sqlite3BtreePutData && db->xPreUpdateCallback ){\n      /* If a pre-update hook is registered and this is a write cursor, \n      ** invoke it here. \n      ** \n      ** TODO: The preupdate-hook is passed SQLITE_DELETE, even though this\n      ** operation should really be an SQLITE_UPDATE. This is probably\n      ** incorrect, but is convenient because at this point the new.* values \n      ** are not easily obtainable. And for the sessions module, an \n      ** SQLITE_UPDATE where the PK columns do not change is handled in the \n      ** same way as an SQLITE_DELETE (the SQLITE_DELETE code is actually\n      ** slightly more efficient). Since you cannot write to a PK column\n      ** using the incremental-blob API, this works. For the sessions module\n      ** anyhow.\n      */\n      if( sqlite3BtreeCursorIsValidNN(p->pCsr)==0 ){\n        /* If the cursor is not currently valid, try to reseek it. This \n        ** always either fails or finds the correct row - the cursor will\n        ** have been marked permanently CURSOR_INVALID if the open row has\n        ** been deleted.  */\n        int bDiff = 0;\n        rc = sqlite3BtreeCursorRestore(p->pCsr, &bDiff);\n        assert( bDiff==0 || sqlite3BtreeCursorIsValidNN(p->pCsr)==0 );\n      }\n      if( sqlite3BtreeCursorIsValidNN(p->pCsr) ){\n        sqlite3_int64 iKey;\n        iKey = sqlite3BtreeIntegerKey(p->pCsr);\n        assert( v->apCsr[0]!=0 );\n        assert( v->apCsr[0]->eCurType==CURTYPE_BTREE );\n        sqlite3VdbePreUpdateHook(\n            v, v->apCsr[0], SQLITE_DELETE, p->zDb, p->pTab, iKey, -1, p->iCol\n        );\n      }\n    }\n    if( rc==SQLITE_OK ){\n      rc = xCall(p->pCsr, iOffset+p->iOffset, n, z);\n    }\n#else\n    rc = xCall(p->pCsr, iOffset+p->iOffset, n, z);\n#endif\n\n    sqlite3BtreeLeaveCursor(p->pCsr);\n    if( rc==SQLITE_ABORT ){\n      sqlite3VdbeFinalize(v);\n      p->pStmt = 0;\n    }else{\n      v->rc = rc;\n    }\n  }\n  sqlite3Error(db, rc);\n  rc = sqlite3ApiExit(db, rc);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n/*\n** Read data from a blob handle.\n*/\nint sqlite3_blob_read(sqlite3_blob *pBlob, void *z, int n, int iOffset){\n  return blobReadWrite(pBlob, z, n, iOffset, sqlite3BtreePayloadChecked);\n}\n\n/*\n** Write data to a blob handle.\n*/\nint sqlite3_blob_write(sqlite3_blob *pBlob, const void *z, int n, int iOffset){\n  return blobReadWrite(pBlob, (void *)z, n, iOffset, sqlite3BtreePutData);\n}\n\n/*\n** Query a blob handle for the size of the data.\n**\n** The Incrblob.nByte field is fixed for the lifetime of the Incrblob\n** so no mutex is required for access.\n*/\nint sqlite3_blob_bytes(sqlite3_blob *pBlob){\n  Incrblob *p = (Incrblob *)pBlob;\n  return (p && p->pStmt) ? p->nByte : 0;\n}\n\n/*\n** Move an existing blob handle to point to a different row of the same\n** database table.\n**\n** If an error occurs, or if the specified row does not exist or does not\n** contain a blob or text value, then an error code is returned and the\n** database handle error code and message set. If this happens, then all \n** subsequent calls to sqlite3_blob_xxx() functions (except blob_close()) \n** immediately return SQLITE_ABORT.\n*/\nint sqlite3_blob_reopen(sqlite3_blob *pBlob, sqlite3_int64 iRow){\n  int rc;\n  Incrblob *p = (Incrblob *)pBlob;\n  sqlite3 *db;\n\n  if( p==0 ) return SQLITE_MISUSE_BKPT;\n  db = p->db;\n  sqlite3_mutex_enter(db->mutex);\n\n  if( p->pStmt==0 ){\n    /* If there is no statement handle, then the blob-handle has\n    ** already been invalidated. Return SQLITE_ABORT in this case.\n    */\n    rc = SQLITE_ABORT;\n  }else{\n    char *zErr;\n    ((Vdbe*)p->pStmt)->rc = SQLITE_OK;\n    rc = blobSeekToRow(p, iRow, &zErr);\n    if( rc!=SQLITE_OK ){\n      sqlite3ErrorWithMsg(db, rc, (zErr ? \"%s\" : (char*)0), zErr);\n      sqlite3DbFree(db, zErr);\n    }\n    assert( rc!=SQLITE_SCHEMA );\n  }\n\n  rc = sqlite3ApiExit(db, rc);\n  assert( rc==SQLITE_OK || p->pStmt==0 );\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n#endif /* #ifndef SQLITE_OMIT_INCRBLOB */\n"}
{"repo": "sqlite", "file": "test_pcache.c", "lang": "C++", "code": "/*\n** 2008 November 18\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains code used for testing the SQLite system.\n** None of the code in this file goes into a deliverable build.\n**\n** This file contains an application-defined pager cache\n** implementation that can be plugged in in place of the\n** default pcache.  This alternative pager cache will throw\n** some errors that the default cache does not.\n**\n** This pagecache implementation is designed for simplicity\n** not speed.\n*/\n#include \"sqlite3.h\"\n#include <string.h>\n#include <assert.h>\n\n/*\n** Global data used by this test implementation.  There is no\n** mutexing, which means this page cache will not work in a\n** multi-threaded test.\n*/\ntypedef struct testpcacheGlobalType testpcacheGlobalType;\nstruct testpcacheGlobalType {\n  void *pDummy;             /* Dummy allocation to simulate failures */\n  int nInstance;            /* Number of current instances */\n  unsigned discardChance;   /* Chance of discarding on an unpin (0-100) */\n  unsigned prngSeed;        /* Seed for the PRNG */\n  unsigned highStress;      /* Call xStress aggressively */\n};\nstatic testpcacheGlobalType testpcacheGlobal;\n\n/*\n** Initializer.\n**\n** Verify that the initializer is only called when the system is\n** uninitialized.  Allocate some memory and report SQLITE_NOMEM if\n** the allocation fails.  This provides a means to test the recovery\n** from a failed initialization attempt.  It also verifies that the\n** the destructor always gets call - otherwise there would be a\n** memory leak.\n*/\nstatic int testpcacheInit(void *pArg){\n  assert( pArg==(void*)&testpcacheGlobal );\n  assert( testpcacheGlobal.pDummy==0 );\n  assert( testpcacheGlobal.nInstance==0 );\n  testpcacheGlobal.pDummy = sqlite3_malloc(10);\n  return testpcacheGlobal.pDummy==0 ? SQLITE_NOMEM : SQLITE_OK;\n}\n\n/*\n** Destructor\n**\n** Verify that this is only called after initialization.\n** Free the memory allocated by the initializer.\n*/\nstatic void testpcacheShutdown(void *pArg){\n  assert( pArg==(void*)&testpcacheGlobal );\n  assert( testpcacheGlobal.pDummy!=0 );\n  assert( testpcacheGlobal.nInstance==0 );\n  sqlite3_free( testpcacheGlobal.pDummy );\n  testpcacheGlobal.pDummy = 0;\n}\n\n/*\n** Number of pages in a cache.\n**\n** The number of pages is a hard upper bound in this test module.\n** If more pages are requested, sqlite3PcacheFetch() returns NULL.\n**\n** If testing with in-memory temp tables, provide a larger pcache.\n** Some of the test cases need this.\n*/\n#if defined(SQLITE_TEMP_STORE) && SQLITE_TEMP_STORE>=2\n# define TESTPCACHE_NPAGE    499\n#else\n# define TESTPCACHE_NPAGE    217\n#endif\n#define TESTPCACHE_RESERVE   17\n\n/*\n** Magic numbers used to determine validity of the page cache.\n*/\n#define TESTPCACHE_VALID  0x364585fd\n#define TESTPCACHE_CLEAR  0xd42670d4\n\n/*\n** Private implementation of a page cache.\n*/\ntypedef struct testpcache testpcache;\nstruct testpcache {\n  sqlite3_int64 szPage;     /* Size of each page.  Multiple of 8. */\n  int szExtra;              /* Size of extra data that accompanies each page */\n  int bPurgeable;           /* True if the page cache is purgeable */\n  int nFree;                /* Number of unused slots in a[] */\n  int nPinned;              /* Number of pinned slots in a[] */\n  unsigned iRand;           /* State of the PRNG */\n  unsigned iMagic;          /* Magic number for sanity checking */\n  struct testpcachePage {\n    sqlite3_pcache_page page;  /* Base class */\n    unsigned key;              /* The key for this page. 0 means unallocated */\n    int isPinned;              /* True if the page is pinned */\n  } a[TESTPCACHE_NPAGE];    /* All pages in the cache */\n};\n\n/*\n** Get a random number using the PRNG in the given page cache.\n*/\nstatic unsigned testpcacheRandom(testpcache *p){\n  unsigned x = 0;\n  int i;\n  for(i=0; i<4; i++){\n    p->iRand = (p->iRand*69069 + 5);\n    x = (x<<8) | ((p->iRand>>16)&0xff);\n  }\n  return x;\n}\n\n\n/*\n** Allocate a new page cache instance.\n*/\nstatic sqlite3_pcache *testpcacheCreate(\n  int szPage,\n  int szExtra,\n  int bPurgeable\n){\n  int nMem;\n  char *x;\n  testpcache *p;\n  int i;\n  assert( testpcacheGlobal.pDummy!=0 );\n  szPage = (szPage+7)&~7;\n  szExtra = (szPage+7)&~7;\n  nMem = sizeof(testpcache) + TESTPCACHE_NPAGE*(szPage+szExtra);\n  p = sqlite3_malloc( nMem );\n  if( p==0 ) return 0;\n  x = (char*)&p[1];\n  p->szPage = szPage;\n  p->szExtra = szExtra;\n  p->nFree = TESTPCACHE_NPAGE;\n  p->nPinned = 0;\n  p->iRand = testpcacheGlobal.prngSeed;\n  p->bPurgeable = bPurgeable;\n  p->iMagic = TESTPCACHE_VALID;\n  for(i=0; i<TESTPCACHE_NPAGE; i++, x += (szPage+szExtra)){\n    p->a[i].key = 0;\n    p->a[i].isPinned = 0;\n    p->a[i].page.pBuf = (void*)x;\n    p->a[i].page.pExtra = (void*)&x[szPage];\n  }\n  testpcacheGlobal.nInstance++;\n  return (sqlite3_pcache*)p;\n}\n\n/*\n** Set the cache size\n*/\nstatic void testpcacheCachesize(sqlite3_pcache *pCache, int newSize){\n  testpcache *p = (testpcache*)pCache;\n  assert( p->iMagic==TESTPCACHE_VALID );\n  assert( testpcacheGlobal.pDummy!=0 );\n  assert( testpcacheGlobal.nInstance>0 );\n}\n\n/*\n** Return the number of pages in the cache that are being used.\n** This includes both pinned and unpinned pages.\n*/\nstatic int testpcachePagecount(sqlite3_pcache *pCache){\n  testpcache *p = (testpcache*)pCache;\n  assert( p->iMagic==TESTPCACHE_VALID );\n  assert( testpcacheGlobal.pDummy!=0 );\n  assert( testpcacheGlobal.nInstance>0 );\n  return TESTPCACHE_NPAGE - p->nFree;\n}\n\n/*\n** Fetch a page.\n*/\nstatic sqlite3_pcache_page *testpcacheFetch(\n  sqlite3_pcache *pCache,\n  unsigned key,\n  int createFlag\n){\n  testpcache *p = (testpcache*)pCache;\n  int i, j;\n  assert( p->iMagic==TESTPCACHE_VALID );\n  assert( testpcacheGlobal.pDummy!=0 );\n  assert( testpcacheGlobal.nInstance>0 );\n\n  /* See if the page is already in cache.  Return immediately if it is */\n  for(i=0; i<TESTPCACHE_NPAGE; i++){\n    if( p->a[i].key==key ){\n      if( !p->a[i].isPinned ){\n        p->nPinned++;\n        assert( p->nPinned <= TESTPCACHE_NPAGE - p->nFree );\n        p->a[i].isPinned = 1;\n      }\n      return &p->a[i].page;\n    }\n  }\n\n  /* If createFlag is 0, never allocate a new page */\n  if( createFlag==0 ){\n    return 0;\n  }\n\n  /* If no pages are available, always fail */\n  if( p->nPinned==TESTPCACHE_NPAGE ){\n    return 0;\n  }\n\n  /* Do not allocate the last TESTPCACHE_RESERVE pages unless createFlag is 2 */\n  if( p->nPinned>=TESTPCACHE_NPAGE-TESTPCACHE_RESERVE && createFlag<2 ){\n    return 0;\n  }\n\n  /* Do not allocate if highStress is enabled and createFlag is not 2.\n  **\n  ** The highStress setting causes pagerStress() to be called much more\n  ** often, which exercises the pager logic more intensely.\n  */\n  if( testpcacheGlobal.highStress && createFlag<2 ){\n    return 0;\n  }\n\n  /* Find a free page to allocate if there are any free pages.\n  ** Withhold TESTPCACHE_RESERVE free pages until createFlag is 2.\n  */\n  if( p->nFree>TESTPCACHE_RESERVE || (createFlag==2 && p->nFree>0) ){\n    j = testpcacheRandom(p) % TESTPCACHE_NPAGE;\n    for(i=0; i<TESTPCACHE_NPAGE; i++, j = (j+1)%TESTPCACHE_NPAGE){\n      if( p->a[j].key==0 ){\n        p->a[j].key = key;\n        p->a[j].isPinned = 1;\n        memset(p->a[j].page.pBuf, 0, p->szPage);\n        memset(p->a[j].page.pExtra, 0, p->szExtra);\n        p->nPinned++;\n        p->nFree--;\n        assert( p->nPinned <= TESTPCACHE_NPAGE - p->nFree );\n        return &p->a[j].page;\n      }\n    }\n\n    /* The prior loop always finds a freepage to allocate */\n    assert( 0 );\n  }\n\n  /* If this cache is not purgeable then we have to fail.\n  */\n  if( p->bPurgeable==0 ){\n    return 0;\n  }\n\n  /* If there are no free pages, recycle a page.  The page to\n  ** recycle is selected at random from all unpinned pages.\n  */\n  j = testpcacheRandom(p) % TESTPCACHE_NPAGE;\n  for(i=0; i<TESTPCACHE_NPAGE; i++, j = (j+1)%TESTPCACHE_NPAGE){\n    if( p->a[j].key>0 && p->a[j].isPinned==0 ){\n      p->a[j].key = key;\n      p->a[j].isPinned = 1;\n      memset(p->a[j].page.pBuf, 0, p->szPage);\n      memset(p->a[j].page.pExtra, 0, p->szExtra);\n      p->nPinned++;\n      assert( p->nPinned <= TESTPCACHE_NPAGE - p->nFree );\n      return &p->a[j].page;\n    }\n  }\n\n  /* The previous loop always finds a page to recycle. */\n  assert(0);\n  return 0;\n}\n\n/*\n** Unpin a page.\n*/\nstatic void testpcacheUnpin(\n  sqlite3_pcache *pCache,\n  sqlite3_pcache_page *pOldPage,\n  int discard\n){\n  testpcache *p = (testpcache*)pCache;\n  int i;\n  assert( p->iMagic==TESTPCACHE_VALID );\n  assert( testpcacheGlobal.pDummy!=0 );\n  assert( testpcacheGlobal.nInstance>0 );\n\n  /* Randomly discard pages as they are unpinned according to the\n  ** discardChance setting.  If discardChance is 0, the random discard\n  ** never happens.  If discardChance is 100, it always happens.\n  */\n  if( p->bPurgeable\n  && (100-testpcacheGlobal.discardChance) <= (testpcacheRandom(p)%100)\n  ){\n    discard = 1;\n  }\n\n  for(i=0; i<TESTPCACHE_NPAGE; i++){\n    if( &p->a[i].page==pOldPage ){\n      /* The pOldPage pointer always points to a pinned page */\n      assert( p->a[i].isPinned );\n      p->a[i].isPinned = 0;\n      p->nPinned--;\n      assert( p->nPinned>=0 );\n      if( discard ){\n        p->a[i].key = 0;\n        p->nFree++;\n        assert( p->nFree<=TESTPCACHE_NPAGE );\n      }\n      return;\n    }\n  }\n\n  /* The pOldPage pointer always points to a valid page */\n  assert( 0 );\n}\n\n\n/*\n** Rekey a single page.\n*/\nstatic void testpcacheRekey(\n  sqlite3_pcache *pCache,\n  sqlite3_pcache_page *pOldPage,\n  unsigned oldKey,\n  unsigned newKey\n){\n  testpcache *p = (testpcache*)pCache;\n  int i;\n  assert( p->iMagic==TESTPCACHE_VALID );\n  assert( testpcacheGlobal.pDummy!=0 );\n  assert( testpcacheGlobal.nInstance>0 );\n\n  /* If there already exists another page at newKey, verify that\n  ** the other page is unpinned and discard it.\n  */\n  for(i=0; i<TESTPCACHE_NPAGE; i++){\n    if( p->a[i].key==newKey ){\n      /* The new key is never a page that is already pinned */\n      assert( p->a[i].isPinned==0 );\n      p->a[i].key = 0;\n      p->nFree++;\n      assert( p->nFree<=TESTPCACHE_NPAGE );\n      break;\n    }\n  }\n\n  /* Find the page to be rekeyed and rekey it.\n  */\n  for(i=0; i<TESTPCACHE_NPAGE; i++){\n    if( p->a[i].key==oldKey ){\n      /* The oldKey and pOldPage parameters match */\n      assert( &p->a[i].page==pOldPage );\n      /* Page to be rekeyed must be pinned */\n      assert( p->a[i].isPinned );\n      p->a[i].key = newKey;\n      return;\n    }\n  }\n\n  /* Rekey is always given a valid page to work with */\n  assert( 0 );\n}\n\n\n/*\n** Truncate the page cache.  Every page with a key of iLimit or larger\n** is discarded.\n*/\nstatic void testpcacheTruncate(sqlite3_pcache *pCache, unsigned iLimit){\n  testpcache *p = (testpcache*)pCache;\n  unsigned int i;\n  assert( p->iMagic==TESTPCACHE_VALID );\n  assert( testpcacheGlobal.pDummy!=0 );\n  assert( testpcacheGlobal.nInstance>0 );\n  for(i=0; i<TESTPCACHE_NPAGE; i++){\n    if( p->a[i].key>=iLimit ){\n      p->a[i].key = 0;\n      if( p->a[i].isPinned ){\n        p->nPinned--;\n        assert( p->nPinned>=0 );\n      }\n      p->nFree++;\n      assert( p->nFree<=TESTPCACHE_NPAGE );\n    }\n  }\n}\n\n/*\n** Destroy a page cache.\n*/\nstatic void testpcacheDestroy(sqlite3_pcache *pCache){\n  testpcache *p = (testpcache*)pCache;\n  assert( p->iMagic==TESTPCACHE_VALID );\n  assert( testpcacheGlobal.pDummy!=0 );\n  assert( testpcacheGlobal.nInstance>0 );\n  p->iMagic = TESTPCACHE_CLEAR;\n  sqlite3_free(p);\n  testpcacheGlobal.nInstance--;\n}\n\n\n/*\n** Invoke this routine to register or unregister the testing pager cache\n** implemented by this file.\n**\n** Install the test pager cache if installFlag is 1 and uninstall it if\n** installFlag is 0.\n**\n** When installing, discardChance is a number between 0 and 100 that\n** indicates the probability of discarding a page when unpinning the\n** page.  0 means never discard (unless the discard flag is set).\n** 100 means always discard.\n*/\nvoid installTestPCache(\n  int installFlag,            /* True to install.  False to uninstall. */\n  unsigned discardChance,     /* 0-100.  Chance to discard on unpin */\n  unsigned prngSeed,          /* Seed for the PRNG */\n  unsigned highStress         /* Call xStress aggressively */\n){\n  static const sqlite3_pcache_methods2 testPcache = {\n    1,\n    (void*)&testpcacheGlobal,\n    testpcacheInit,\n    testpcacheShutdown,\n    testpcacheCreate,\n    testpcacheCachesize,\n    testpcachePagecount,\n    testpcacheFetch,\n    testpcacheUnpin,\n    testpcacheRekey,\n    testpcacheTruncate,\n    testpcacheDestroy,\n  };\n  static sqlite3_pcache_methods2 defaultPcache;\n  static int isInstalled = 0;\n\n  assert( testpcacheGlobal.nInstance==0 );\n  assert( testpcacheGlobal.pDummy==0 );\n  assert( discardChance<=100 );\n  testpcacheGlobal.discardChance = discardChance;\n  testpcacheGlobal.prngSeed = prngSeed ^ (prngSeed<<16);\n  testpcacheGlobal.highStress = highStress;\n  if( installFlag!=isInstalled ){\n    if( installFlag ){\n      sqlite3_config(SQLITE_CONFIG_GETPCACHE2, &defaultPcache);\n      assert( defaultPcache.xCreate!=testpcacheCreate );\n      sqlite3_config(SQLITE_CONFIG_PCACHE2, &testPcache);\n    }else{\n      assert( defaultPcache.xCreate!=0 );\n      sqlite3_config(SQLITE_CONFIG_PCACHE2, &defaultPcache);\n    }\n    isInstalled = installFlag;\n  }\n}\n"}
{"repo": "sqlite", "file": "test_onefile.c", "lang": "C++", "code": "/*\n** 2007 September 14\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** OVERVIEW:\n**\n**   This file contains some example code demonstrating how the SQLite \n**   vfs feature can be used to have SQLite operate directly on an \n**   embedded media, without using an intermediate file system.\n**\n**   Because this is only a demo designed to run on a workstation, the\n**   underlying media is simulated using a regular file-system file. The\n**   size of the file is fixed when it is first created (default size 10 MB).\n**   From SQLite's point of view, this space is used to store a single\n**   database file and the journal file. \n**\n**   Any statement journal created is stored in volatile memory obtained \n**   from sqlite3_malloc(). Any attempt to create a temporary database file \n**   will fail (SQLITE_IOERR). To prevent SQLite from attempting this,\n**   it should be configured to store all temporary database files in \n**   main memory (see pragma \"temp_store\" or the SQLITE_TEMP_STORE compile \n**   time option).\n**\n** ASSUMPTIONS:\n**\n**   After it has been created, the blob file is accessed using the\n**   following three functions only:\n**\n**       mediaRead();            - Read a 512 byte block from the file.\n**       mediaWrite();           - Write a 512 byte block to the file.\n**       mediaSync();            - Tell the media hardware to sync.\n**\n**   It is assumed that these can be easily implemented by any \"real\"\n**   media vfs driver adapting this code.\n**\n** FILE FORMAT:\n**\n**   The basic principle is that the \"database file\" is stored at the\n**   beginning of the 10 MB blob and grows in a forward direction. The \n**   \"journal file\" is stored at the end of the 10MB blob and grows\n**   in the reverse direction. If, during a transaction, insufficient\n**   space is available to expand either the journal or database file,\n**   an SQLITE_FULL error is returned. The database file is never allowed\n**   to consume more than 90% of the blob space. If SQLite tries to\n**   create a file larger than this, SQLITE_FULL is returned.\n**\n**   No allowance is made for \"wear-leveling\", as is required by.\n**   embedded devices in the absence of equivalent hardware features.\n**\n**   The first 512 block byte of the file is reserved for storing the\n**   size of the \"database file\". It is updated as part of the sync()\n**   operation. On startup, it can only be trusted if no journal file\n**   exists. If a journal-file does exist, then it stores the real size\n**   of the database region. The second and subsequent blocks store the \n**   actual database content.\n**\n**   The size of the \"journal file\" is not stored persistently in the \n**   file. When the system is running, the size of the journal file is\n**   stored in volatile memory. When recovering from a crash, this vfs\n**   reports a very large size for the journal file. The normal journal\n**   header and checksum mechanisms serve to prevent SQLite from \n**   processing any data that lies past the logical end of the journal.\n**\n**   When SQLite calls OsDelete() to delete the journal file, the final\n**   512 bytes of the blob (the area containing the first journal header)\n**   are zeroed.\n**\n** LOCKING:\n**\n**   File locking is a no-op. Only one connection may be open at any one\n**   time using this demo vfs.\n*/\n\n#include \"sqlite3.h\"\n#include <assert.h>\n#include <string.h>\n\n/*\n** Maximum pathname length supported by the fs backend.\n*/\n#define BLOCKSIZE 512\n#define BLOBSIZE 10485760\n\n/*\n** Name used to identify this VFS.\n*/\n#define FS_VFS_NAME \"fs\"\n\ntypedef struct fs_real_file fs_real_file;\nstruct fs_real_file {\n  sqlite3_file *pFile;\n  const char *zName;\n  int nDatabase;              /* Current size of database region */\n  int nJournal;               /* Current size of journal region */\n  int nBlob;                  /* Total size of allocated blob */\n  int nRef;                   /* Number of pointers to this structure */\n  fs_real_file *pNext;\n  fs_real_file **ppThis;\n};\n\ntypedef struct fs_file fs_file;\nstruct fs_file {\n  sqlite3_file base;\n  int eType;\n  fs_real_file *pReal;\n};\n\ntypedef struct tmp_file tmp_file;\nstruct tmp_file {\n  sqlite3_file base;\n  int nSize;\n  int nAlloc;\n  char *zAlloc;\n};\n\n/* Values for fs_file.eType. */\n#define DATABASE_FILE   1\n#define JOURNAL_FILE    2\n\n/*\n** Method declarations for fs_file.\n*/\nstatic int fsClose(sqlite3_file*);\nstatic int fsRead(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);\nstatic int fsWrite(sqlite3_file*, const void*, int iAmt, sqlite3_int64 iOfst);\nstatic int fsTruncate(sqlite3_file*, sqlite3_int64 size);\nstatic int fsSync(sqlite3_file*, int flags);\nstatic int fsFileSize(sqlite3_file*, sqlite3_int64 *pSize);\nstatic int fsLock(sqlite3_file*, int);\nstatic int fsUnlock(sqlite3_file*, int);\nstatic int fsCheckReservedLock(sqlite3_file*, int *pResOut);\nstatic int fsFileControl(sqlite3_file*, int op, void *pArg);\nstatic int fsSectorSize(sqlite3_file*);\nstatic int fsDeviceCharacteristics(sqlite3_file*);\n\n/*\n** Method declarations for tmp_file.\n*/\nstatic int tmpClose(sqlite3_file*);\nstatic int tmpRead(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);\nstatic int tmpWrite(sqlite3_file*, const void*, int iAmt, sqlite3_int64 iOfst);\nstatic int tmpTruncate(sqlite3_file*, sqlite3_int64 size);\nstatic int tmpSync(sqlite3_file*, int flags);\nstatic int tmpFileSize(sqlite3_file*, sqlite3_int64 *pSize);\nstatic int tmpLock(sqlite3_file*, int);\nstatic int tmpUnlock(sqlite3_file*, int);\nstatic int tmpCheckReservedLock(sqlite3_file*, int *pResOut);\nstatic int tmpFileControl(sqlite3_file*, int op, void *pArg);\nstatic int tmpSectorSize(sqlite3_file*);\nstatic int tmpDeviceCharacteristics(sqlite3_file*);\n\n/*\n** Method declarations for fs_vfs.\n*/\nstatic int fsOpen(sqlite3_vfs*, const char *, sqlite3_file*, int , int *);\nstatic int fsDelete(sqlite3_vfs*, const char *zName, int syncDir);\nstatic int fsAccess(sqlite3_vfs*, const char *zName, int flags, int *);\nstatic int fsFullPathname(sqlite3_vfs*, const char *zName, int nOut,char *zOut);\nstatic void *fsDlOpen(sqlite3_vfs*, const char *zFilename);\nstatic void fsDlError(sqlite3_vfs*, int nByte, char *zErrMsg);\nstatic void (*fsDlSym(sqlite3_vfs*,void*, const char *zSymbol))(void);\nstatic void fsDlClose(sqlite3_vfs*, void*);\nstatic int fsRandomness(sqlite3_vfs*, int nByte, char *zOut);\nstatic int fsSleep(sqlite3_vfs*, int microseconds);\nstatic int fsCurrentTime(sqlite3_vfs*, double*);\n\n\ntypedef struct fs_vfs_t fs_vfs_t;\nstruct fs_vfs_t {\n  sqlite3_vfs base;\n  fs_real_file *pFileList;\n  sqlite3_vfs *pParent;\n};\n\nstatic fs_vfs_t fs_vfs = {\n  {\n    1,                                          /* iVersion */\n    0,                                          /* szOsFile */\n    0,                                          /* mxPathname */\n    0,                                          /* pNext */\n    FS_VFS_NAME,                                /* zName */\n    0,                                          /* pAppData */\n    fsOpen,                                     /* xOpen */\n    fsDelete,                                   /* xDelete */\n    fsAccess,                                   /* xAccess */\n    fsFullPathname,                             /* xFullPathname */\n    fsDlOpen,                                   /* xDlOpen */\n    fsDlError,                                  /* xDlError */\n    fsDlSym,                                    /* xDlSym */\n    fsDlClose,                                  /* xDlClose */\n    fsRandomness,                               /* xRandomness */\n    fsSleep,                                    /* xSleep */\n    fsCurrentTime,                              /* xCurrentTime */\n    0                                           /* xCurrentTimeInt64 */\n  }, \n  0,                                            /* pFileList */\n  0                                             /* pParent */\n};\n\nstatic sqlite3_io_methods fs_io_methods = {\n  1,                            /* iVersion */\n  fsClose,                      /* xClose */\n  fsRead,                       /* xRead */\n  fsWrite,                      /* xWrite */\n  fsTruncate,                   /* xTruncate */\n  fsSync,                       /* xSync */\n  fsFileSize,                   /* xFileSize */\n  fsLock,                       /* xLock */\n  fsUnlock,                     /* xUnlock */\n  fsCheckReservedLock,          /* xCheckReservedLock */\n  fsFileControl,                /* xFileControl */\n  fsSectorSize,                 /* xSectorSize */\n  fsDeviceCharacteristics,      /* xDeviceCharacteristics */\n  0,                            /* xShmMap */\n  0,                            /* xShmLock */\n  0,                            /* xShmBarrier */\n  0                             /* xShmUnmap */\n};\n\n\nstatic sqlite3_io_methods tmp_io_methods = {\n  1,                            /* iVersion */\n  tmpClose,                     /* xClose */\n  tmpRead,                      /* xRead */\n  tmpWrite,                     /* xWrite */\n  tmpTruncate,                  /* xTruncate */\n  tmpSync,                      /* xSync */\n  tmpFileSize,                  /* xFileSize */\n  tmpLock,                      /* xLock */\n  tmpUnlock,                    /* xUnlock */\n  tmpCheckReservedLock,         /* xCheckReservedLock */\n  tmpFileControl,               /* xFileControl */\n  tmpSectorSize,                /* xSectorSize */\n  tmpDeviceCharacteristics,     /* xDeviceCharacteristics */\n  0,                            /* xShmMap */\n  0,                            /* xShmLock */\n  0,                            /* xShmBarrier */\n  0                             /* xShmUnmap */\n};\n\n/* Useful macros used in several places */\n#define MIN(x,y) ((x)<(y)?(x):(y))\n#define MAX(x,y) ((x)>(y)?(x):(y))\n\n\n/*\n** Close a tmp-file.\n*/\nstatic int tmpClose(sqlite3_file *pFile){\n  tmp_file *pTmp = (tmp_file *)pFile;\n  sqlite3_free(pTmp->zAlloc);\n  return SQLITE_OK;\n}\n\n/*\n** Read data from a tmp-file.\n*/\nstatic int tmpRead(\n  sqlite3_file *pFile, \n  void *zBuf, \n  int iAmt, \n  sqlite_int64 iOfst\n){\n  tmp_file *pTmp = (tmp_file *)pFile;\n  if( (iAmt+iOfst)>pTmp->nSize ){\n    return SQLITE_IOERR_SHORT_READ;\n  }\n  memcpy(zBuf, &pTmp->zAlloc[iOfst], iAmt);\n  return SQLITE_OK;\n}\n\n/*\n** Write data to a tmp-file.\n*/\nstatic int tmpWrite(\n  sqlite3_file *pFile, \n  const void *zBuf, \n  int iAmt, \n  sqlite_int64 iOfst\n){\n  tmp_file *pTmp = (tmp_file *)pFile;\n  if( (iAmt+iOfst)>pTmp->nAlloc ){\n    int nNew = (int)(2*(iAmt+iOfst+pTmp->nAlloc));\n    char *zNew = sqlite3_realloc(pTmp->zAlloc, nNew);\n    if( !zNew ){\n      return SQLITE_NOMEM;\n    }\n    pTmp->zAlloc = zNew;\n    pTmp->nAlloc = nNew;\n  }\n  memcpy(&pTmp->zAlloc[iOfst], zBuf, iAmt);\n  pTmp->nSize = (int)MAX(pTmp->nSize, iOfst+iAmt);\n  return SQLITE_OK;\n}\n\n/*\n** Truncate a tmp-file.\n*/\nstatic int tmpTruncate(sqlite3_file *pFile, sqlite_int64 size){\n  tmp_file *pTmp = (tmp_file *)pFile;\n  pTmp->nSize = (int)MIN(pTmp->nSize, size);\n  return SQLITE_OK;\n}\n\n/*\n** Sync a tmp-file.\n*/\nstatic int tmpSync(sqlite3_file *pFile, int flags){\n  return SQLITE_OK;\n}\n\n/*\n** Return the current file-size of a tmp-file.\n*/\nstatic int tmpFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){\n  tmp_file *pTmp = (tmp_file *)pFile;\n  *pSize = pTmp->nSize;\n  return SQLITE_OK;\n}\n\n/*\n** Lock a tmp-file.\n*/\nstatic int tmpLock(sqlite3_file *pFile, int eLock){\n  return SQLITE_OK;\n}\n\n/*\n** Unlock a tmp-file.\n*/\nstatic int tmpUnlock(sqlite3_file *pFile, int eLock){\n  return SQLITE_OK;\n}\n\n/*\n** Check if another file-handle holds a RESERVED lock on a tmp-file.\n*/\nstatic int tmpCheckReservedLock(sqlite3_file *pFile, int *pResOut){\n  *pResOut = 0;\n  return SQLITE_OK;\n}\n\n/*\n** File control method. For custom operations on a tmp-file.\n*/\nstatic int tmpFileControl(sqlite3_file *pFile, int op, void *pArg){\n  return SQLITE_OK;\n}\n\n/*\n** Return the sector-size in bytes for a tmp-file.\n*/\nstatic int tmpSectorSize(sqlite3_file *pFile){\n  return 0;\n}\n\n/*\n** Return the device characteristic flags supported by a tmp-file.\n*/\nstatic int tmpDeviceCharacteristics(sqlite3_file *pFile){\n  return 0;\n}\n\n/*\n** Close an fs-file.\n*/\nstatic int fsClose(sqlite3_file *pFile){\n  int rc = SQLITE_OK;\n  fs_file *p = (fs_file *)pFile;\n  fs_real_file *pReal = p->pReal;\n\n  /* Decrement the real_file ref-count. */\n  pReal->nRef--;\n  assert(pReal->nRef>=0);\n\n  /* When the ref-count reaches 0, destroy the structure */\n  if( pReal->nRef==0 ){\n    *pReal->ppThis = pReal->pNext;\n    if( pReal->pNext ){\n      pReal->pNext->ppThis = pReal->ppThis;\n    }\n    rc = pReal->pFile->pMethods->xClose(pReal->pFile);\n    sqlite3_free(pReal);\n  }\n\n  return rc;\n}\n\n/*\n** Read data from an fs-file.\n*/\nstatic int fsRead(\n  sqlite3_file *pFile, \n  void *zBuf, \n  int iAmt, \n  sqlite_int64 iOfst\n){\n  int rc = SQLITE_OK;\n  fs_file *p = (fs_file *)pFile;\n  fs_real_file *pReal = p->pReal;\n  sqlite3_file *pF = pReal->pFile;\n\n  if( (p->eType==DATABASE_FILE && (iAmt+iOfst)>pReal->nDatabase)\n   || (p->eType==JOURNAL_FILE && (iAmt+iOfst)>pReal->nJournal)\n  ){\n    rc = SQLITE_IOERR_SHORT_READ;\n  }else if( p->eType==DATABASE_FILE ){\n    rc = pF->pMethods->xRead(pF, zBuf, iAmt, iOfst+BLOCKSIZE);\n  }else{\n    /* Journal file. */\n    int iRem = iAmt;\n    int iBuf = 0;\n    int ii = (int)iOfst;\n    while( iRem>0 && rc==SQLITE_OK ){\n      int iRealOff = pReal->nBlob - BLOCKSIZE*((ii/BLOCKSIZE)+1) + ii%BLOCKSIZE;\n      int iRealAmt = MIN(iRem, BLOCKSIZE - (iRealOff%BLOCKSIZE));\n\n      rc = pF->pMethods->xRead(pF, &((char *)zBuf)[iBuf], iRealAmt, iRealOff);\n      ii += iRealAmt;\n      iBuf += iRealAmt;\n      iRem -= iRealAmt;\n    }\n  }\n\n  return rc;\n}\n\n/*\n** Write data to an fs-file.\n*/\nstatic int fsWrite(\n  sqlite3_file *pFile, \n  const void *zBuf, \n  int iAmt, \n  sqlite_int64 iOfst\n){\n  int rc = SQLITE_OK;\n  fs_file *p = (fs_file *)pFile;\n  fs_real_file *pReal = p->pReal;\n  sqlite3_file *pF = pReal->pFile;\n\n  if( p->eType==DATABASE_FILE ){\n    if( (iAmt+iOfst+BLOCKSIZE)>(pReal->nBlob-pReal->nJournal) ){\n      rc = SQLITE_FULL;\n    }else{\n      rc = pF->pMethods->xWrite(pF, zBuf, iAmt, iOfst+BLOCKSIZE);\n      if( rc==SQLITE_OK ){\n        pReal->nDatabase = (int)MAX(pReal->nDatabase, iAmt+iOfst);\n      }\n    }\n  }else{\n    /* Journal file. */\n    int iRem = iAmt;\n    int iBuf = 0;\n    int ii = (int)iOfst;\n    while( iRem>0 && rc==SQLITE_OK ){\n      int iRealOff = pReal->nBlob - BLOCKSIZE*((ii/BLOCKSIZE)+1) + ii%BLOCKSIZE;\n      int iRealAmt = MIN(iRem, BLOCKSIZE - (iRealOff%BLOCKSIZE));\n\n      if( iRealOff<(pReal->nDatabase+BLOCKSIZE) ){\n        rc = SQLITE_FULL;\n      }else{\n        rc = pF->pMethods->xWrite(pF, &((char *)zBuf)[iBuf], iRealAmt,iRealOff);\n        ii += iRealAmt;\n        iBuf += iRealAmt;\n        iRem -= iRealAmt;\n      }\n    }\n    if( rc==SQLITE_OK ){\n      pReal->nJournal = (int)MAX(pReal->nJournal, iAmt+iOfst);\n    }\n  }\n\n  return rc;\n}\n\n/*\n** Truncate an fs-file.\n*/\nstatic int fsTruncate(sqlite3_file *pFile, sqlite_int64 size){\n  fs_file *p = (fs_file *)pFile;\n  fs_real_file *pReal = p->pReal;\n  if( p->eType==DATABASE_FILE ){\n    pReal->nDatabase = (int)MIN(pReal->nDatabase, size);\n  }else{\n    pReal->nJournal = (int)MIN(pReal->nJournal, size);\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Sync an fs-file.\n*/\nstatic int fsSync(sqlite3_file *pFile, int flags){\n  fs_file *p = (fs_file *)pFile;\n  fs_real_file *pReal = p->pReal;\n  sqlite3_file *pRealFile = pReal->pFile;\n  int rc = SQLITE_OK;\n\n  if( p->eType==DATABASE_FILE ){\n    unsigned char zSize[4];\n    zSize[0] = (pReal->nDatabase&0xFF000000)>>24;\n    zSize[1] = (unsigned char)((pReal->nDatabase&0x00FF0000)>>16);\n    zSize[2] = (pReal->nDatabase&0x0000FF00)>>8;\n    zSize[3] = (pReal->nDatabase&0x000000FF);\n    rc = pRealFile->pMethods->xWrite(pRealFile, zSize, 4, 0);\n  }\n  if( rc==SQLITE_OK ){\n    rc = pRealFile->pMethods->xSync(pRealFile, flags&(~SQLITE_SYNC_DATAONLY));\n  }\n\n  return rc;\n}\n\n/*\n** Return the current file-size of an fs-file.\n*/\nstatic int fsFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){\n  fs_file *p = (fs_file *)pFile;\n  fs_real_file *pReal = p->pReal;\n  if( p->eType==DATABASE_FILE ){\n    *pSize = pReal->nDatabase;\n  }else{\n    *pSize = pReal->nJournal;\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Lock an fs-file.\n*/\nstatic int fsLock(sqlite3_file *pFile, int eLock){\n  return SQLITE_OK;\n}\n\n/*\n** Unlock an fs-file.\n*/\nstatic int fsUnlock(sqlite3_file *pFile, int eLock){\n  return SQLITE_OK;\n}\n\n/*\n** Check if another file-handle holds a RESERVED lock on an fs-file.\n*/\nstatic int fsCheckReservedLock(sqlite3_file *pFile, int *pResOut){\n  *pResOut = 0;\n  return SQLITE_OK;\n}\n\n/*\n** File control method. For custom operations on an fs-file.\n*/\nstatic int fsFileControl(sqlite3_file *pFile, int op, void *pArg){\n  if( op==SQLITE_FCNTL_PRAGMA ) return SQLITE_NOTFOUND;\n  return SQLITE_OK;\n}\n\n/*\n** Return the sector-size in bytes for an fs-file.\n*/\nstatic int fsSectorSize(sqlite3_file *pFile){\n  return BLOCKSIZE;\n}\n\n/*\n** Return the device characteristic flags supported by an fs-file.\n*/\nstatic int fsDeviceCharacteristics(sqlite3_file *pFile){\n  return 0;\n}\n\n/*\n** Open an fs file handle.\n*/\nstatic int fsOpen(\n  sqlite3_vfs *pVfs,\n  const char *zName,\n  sqlite3_file *pFile,\n  int flags,\n  int *pOutFlags\n){\n  fs_vfs_t *pFsVfs = (fs_vfs_t *)pVfs;\n  fs_file *p = (fs_file *)pFile;\n  fs_real_file *pReal = 0;\n  int eType;\n  int nName;\n  int rc = SQLITE_OK;\n\n  if( 0==(flags&(SQLITE_OPEN_MAIN_DB|SQLITE_OPEN_MAIN_JOURNAL)) ){\n    tmp_file *p2 = (tmp_file *)pFile;\n    memset(p2, 0, sizeof(*p2));\n    p2->base.pMethods = &tmp_io_methods;\n    return SQLITE_OK;\n  }\n\n  eType = ((flags&(SQLITE_OPEN_MAIN_DB))?DATABASE_FILE:JOURNAL_FILE);\n  p->base.pMethods = &fs_io_methods;\n  p->eType = eType;\n\n  assert(strlen(\"-journal\")==8);\n  nName = (int)strlen(zName)-((eType==JOURNAL_FILE)?8:0);\n  pReal=pFsVfs->pFileList; \n  for(; pReal && strncmp(pReal->zName, zName, nName); pReal=pReal->pNext);\n\n  if( !pReal ){\n    int real_flags = (flags&~(SQLITE_OPEN_MAIN_DB))|SQLITE_OPEN_TEMP_DB;\n    sqlite3_int64 size;\n    sqlite3_file *pRealFile;\n    sqlite3_vfs *pParent = pFsVfs->pParent;\n    assert(eType==DATABASE_FILE);\n\n    pReal = (fs_real_file *)sqlite3_malloc(sizeof(*pReal)+pParent->szOsFile);\n    if( !pReal ){\n      rc = SQLITE_NOMEM;\n      goto open_out;\n    }\n    memset(pReal, 0, sizeof(*pReal)+pParent->szOsFile);\n    pReal->zName = zName;\n    pReal->pFile = (sqlite3_file *)(&pReal[1]);\n\n    rc = pParent->xOpen(pParent, zName, pReal->pFile, real_flags, pOutFlags);\n    if( rc!=SQLITE_OK ){\n      goto open_out;\n    }\n    pRealFile = pReal->pFile;\n\n    rc = pRealFile->pMethods->xFileSize(pRealFile, &size);\n    if( rc!=SQLITE_OK ){\n      goto open_out;\n    }\n    if( size==0 ){\n      rc = pRealFile->pMethods->xWrite(pRealFile, \"\\0\", 1, BLOBSIZE-1);\n      pReal->nBlob = BLOBSIZE;\n    }else{\n      unsigned char zS[4];\n      pReal->nBlob = (int)size;\n      rc = pRealFile->pMethods->xRead(pRealFile, zS, 4, 0);\n      pReal->nDatabase = (zS[0]<<24)+(zS[1]<<16)+(zS[2]<<8)+zS[3];\n      if( rc==SQLITE_OK ){\n        rc = pRealFile->pMethods->xRead(pRealFile, zS, 4, pReal->nBlob-4);\n        if( zS[0] || zS[1] || zS[2] || zS[3] ){\n          pReal->nJournal = pReal->nBlob;\n        }\n      }\n    }\n\n    if( rc==SQLITE_OK ){\n      pReal->pNext = pFsVfs->pFileList;\n      if( pReal->pNext ){\n        pReal->pNext->ppThis = &pReal->pNext;\n      }\n      pReal->ppThis = &pFsVfs->pFileList;\n      pFsVfs->pFileList = pReal;\n    }\n  }\n\nopen_out:\n  if( pReal ){\n    if( rc==SQLITE_OK ){\n      p->pReal = pReal;\n      pReal->nRef++;\n    }else{\n      if( pReal->pFile->pMethods ){\n        pReal->pFile->pMethods->xClose(pReal->pFile);\n      }\n      sqlite3_free(pReal);\n    }\n  }\n  return rc;\n}\n\n/*\n** Delete the file located at zPath. If the dirSync argument is true,\n** ensure the file-system modifications are synced to disk before\n** returning.\n*/\nstatic int fsDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){\n  int rc = SQLITE_OK;\n  fs_vfs_t *pFsVfs = (fs_vfs_t *)pVfs;\n  fs_real_file *pReal;\n  sqlite3_file *pF;\n  int nName = (int)strlen(zPath) - 8;\n\n  assert(strlen(\"-journal\")==8);\n  assert(strcmp(\"-journal\", &zPath[nName])==0);\n\n  pReal = pFsVfs->pFileList; \n  for(; pReal && strncmp(pReal->zName, zPath, nName); pReal=pReal->pNext);\n  if( pReal ){\n    pF = pReal->pFile;\n    rc = pF->pMethods->xWrite(pF, \"\\0\\0\\0\\0\", 4, pReal->nBlob-BLOCKSIZE);\n    if( rc==SQLITE_OK ){\n      pReal->nJournal = 0;\n    }\n  }\n  return rc;\n}\n\n/*\n** Test for access permissions. Return true if the requested permission\n** is available, or false otherwise.\n*/\nstatic int fsAccess(\n  sqlite3_vfs *pVfs, \n  const char *zPath, \n  int flags, \n  int *pResOut\n){\n  fs_vfs_t *pFsVfs = (fs_vfs_t *)pVfs;\n  fs_real_file *pReal;\n  int isJournal = 0;\n  int nName = (int)strlen(zPath);\n\n  if( flags!=SQLITE_ACCESS_EXISTS ){\n    sqlite3_vfs *pParent = ((fs_vfs_t *)pVfs)->pParent;\n    return pParent->xAccess(pParent, zPath, flags, pResOut);\n  }\n\n  assert(strlen(\"-journal\")==8);\n  if( nName>8 && strcmp(\"-journal\", &zPath[nName-8])==0 ){\n    nName -= 8;\n    isJournal = 1;\n  }\n\n  pReal = pFsVfs->pFileList; \n  for(; pReal && strncmp(pReal->zName, zPath, nName); pReal=pReal->pNext);\n\n  *pResOut = (pReal && (!isJournal || pReal->nJournal>0));\n  return SQLITE_OK;\n}\n\n/*\n** Populate buffer zOut with the full canonical pathname corresponding\n** to the pathname in zPath. zOut is guaranteed to point to a buffer\n** of at least (FS_MAX_PATHNAME+1) bytes.\n*/\nstatic int fsFullPathname(\n  sqlite3_vfs *pVfs,            /* Pointer to vfs object */\n  const char *zPath,            /* Possibly relative input path */\n  int nOut,                     /* Size of output buffer in bytes */\n  char *zOut                    /* Output buffer */\n){\n  sqlite3_vfs *pParent = ((fs_vfs_t *)pVfs)->pParent;\n  return pParent->xFullPathname(pParent, zPath, nOut, zOut);\n}\n\n/*\n** Open the dynamic library located at zPath and return a handle.\n*/\nstatic void *fsDlOpen(sqlite3_vfs *pVfs, const char *zPath){\n  sqlite3_vfs *pParent = ((fs_vfs_t *)pVfs)->pParent;\n  return pParent->xDlOpen(pParent, zPath);\n}\n\n/*\n** Populate the buffer zErrMsg (size nByte bytes) with a human readable\n** utf-8 string describing the most recent error encountered associated \n** with dynamic libraries.\n*/\nstatic void fsDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){\n  sqlite3_vfs *pParent = ((fs_vfs_t *)pVfs)->pParent;\n  pParent->xDlError(pParent, nByte, zErrMsg);\n}\n\n/*\n** Return a pointer to the symbol zSymbol in the dynamic library pHandle.\n*/\nstatic void (*fsDlSym(sqlite3_vfs *pVfs, void *pH, const char *zSym))(void){\n  sqlite3_vfs *pParent = ((fs_vfs_t *)pVfs)->pParent;\n  return pParent->xDlSym(pParent, pH, zSym);\n}\n\n/*\n** Close the dynamic library handle pHandle.\n*/\nstatic void fsDlClose(sqlite3_vfs *pVfs, void *pHandle){\n  sqlite3_vfs *pParent = ((fs_vfs_t *)pVfs)->pParent;\n  pParent->xDlClose(pParent, pHandle);\n}\n\n/*\n** Populate the buffer pointed to by zBufOut with nByte bytes of \n** random data.\n*/\nstatic int fsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){\n  sqlite3_vfs *pParent = ((fs_vfs_t *)pVfs)->pParent;\n  return pParent->xRandomness(pParent, nByte, zBufOut);\n}\n\n/*\n** Sleep for nMicro microseconds. Return the number of microseconds \n** actually slept.\n*/\nstatic int fsSleep(sqlite3_vfs *pVfs, int nMicro){\n  sqlite3_vfs *pParent = ((fs_vfs_t *)pVfs)->pParent;\n  return pParent->xSleep(pParent, nMicro);\n}\n\n/*\n** Return the current time as a Julian Day number in *pTimeOut.\n*/\nstatic int fsCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){\n  sqlite3_vfs *pParent = ((fs_vfs_t *)pVfs)->pParent;\n  return pParent->xCurrentTime(pParent, pTimeOut);\n}\n\n/*\n** This procedure registers the fs vfs with SQLite. If the argument is\n** true, the fs vfs becomes the new default vfs. It is the only publicly\n** available function in this file.\n*/\nint fs_register(void){\n  if( fs_vfs.pParent ) return SQLITE_OK;\n  fs_vfs.pParent = sqlite3_vfs_find(0);\n  fs_vfs.base.mxPathname = fs_vfs.pParent->mxPathname;\n  fs_vfs.base.szOsFile = MAX(sizeof(tmp_file), sizeof(fs_file));\n  return sqlite3_vfs_register(&fs_vfs.base, 0);\n}\n\n#ifdef SQLITE_TEST\n  int SqlitetestOnefile_Init() {return fs_register();}\n#endif\n"}
{"repo": "sqlite", "file": "btreeInt.h", "lang": "C++", "code": "/*\n** 2004 April 6\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file implements an external (disk-based) database using BTrees.\n** For a detailed discussion of BTrees, refer to\n**\n**     Donald E. Knuth, THE ART OF COMPUTER PROGRAMMING, Volume 3:\n**     \"Sorting And Searching\", pages 473-480. Addison-Wesley\n**     Publishing Company, Reading, Massachusetts.\n**\n** The basic idea is that each page of the file contains N database\n** entries and N+1 pointers to subpages.\n**\n**   ----------------------------------------------------------------\n**   |  Ptr(0) | Key(0) | Ptr(1) | Key(1) | ... | Key(N-1) | Ptr(N) |\n**   ----------------------------------------------------------------\n**\n** All of the keys on the page that Ptr(0) points to have values less\n** than Key(0).  All of the keys on page Ptr(1) and its subpages have\n** values greater than Key(0) and less than Key(1).  All of the keys\n** on Ptr(N) and its subpages have values greater than Key(N-1).  And\n** so forth.\n**\n** Finding a particular key requires reading O(log(M)) pages from the \n** disk where M is the number of entries in the tree.\n**\n** In this implementation, a single file can hold one or more separate \n** BTrees.  Each BTree is identified by the index of its root page.  The\n** key and data for any entry are combined to form the \"payload\".  A\n** fixed amount of payload can be carried directly on the database\n** page.  If the payload is larger than the preset amount then surplus\n** bytes are stored on overflow pages.  The payload for an entry\n** and the preceding pointer are combined to form a \"Cell\".  Each \n** page has a small header which contains the Ptr(N) pointer and other\n** information such as the size of key and data.\n**\n** FORMAT DETAILS\n**\n** The file is divided into pages.  The first page is called page 1,\n** the second is page 2, and so forth.  A page number of zero indicates\n** \"no such page\".  The page size can be any power of 2 between 512 and 65536.\n** Each page can be either a btree page, a freelist page, an overflow\n** page, or a pointer-map page.\n**\n** The first page is always a btree page.  The first 100 bytes of the first\n** page contain a special header (the \"file header\") that describes the file.\n** The format of the file header is as follows:\n**\n**   OFFSET   SIZE    DESCRIPTION\n**      0      16     Header string: \"SQLite format 3\\000\"\n**     16       2     Page size in bytes.  (1 means 65536)\n**     18       1     File format write version\n**     19       1     File format read version\n**     20       1     Bytes of unused space at the end of each page\n**     21       1     Max embedded payload fraction (must be 64)\n**     22       1     Min embedded payload fraction (must be 32)\n**     23       1     Min leaf payload fraction (must be 32)\n**     24       4     File change counter\n**     28       4     The size of the database in pages\n**     32       4     First freelist page\n**     36       4     Number of freelist pages in the file\n**     40      60     15 4-byte meta values passed to higher layers\n**\n**     40       4     Schema cookie\n**     44       4     File format of schema layer\n**     48       4     Size of page cache\n**     52       4     Largest root-page (auto/incr_vacuum)\n**     56       4     1=UTF-8 2=UTF16le 3=UTF16be\n**     60       4     User version\n**     64       4     Incremental vacuum mode\n**     68       4     Application-ID\n**     72      20     unused\n**     92       4     The version-valid-for number\n**     96       4     SQLITE_VERSION_NUMBER\n**\n** All of the integer values are big-endian (most significant byte first).\n**\n** The file change counter is incremented when the database is changed\n** This counter allows other processes to know when the file has changed\n** and thus when they need to flush their cache.\n**\n** The max embedded payload fraction is the amount of the total usable\n** space in a page that can be consumed by a single cell for standard\n** B-tree (non-LEAFDATA) tables.  A value of 255 means 100%.  The default\n** is to limit the maximum cell size so that at least 4 cells will fit\n** on one page.  Thus the default max embedded payload fraction is 64.\n**\n** If the payload for a cell is larger than the max payload, then extra\n** payload is spilled to overflow pages.  Once an overflow page is allocated,\n** as many bytes as possible are moved into the overflow pages without letting\n** the cell size drop below the min embedded payload fraction.\n**\n** The min leaf payload fraction is like the min embedded payload fraction\n** except that it applies to leaf nodes in a LEAFDATA tree.  The maximum\n** payload fraction for a LEAFDATA tree is always 100% (or 255) and it\n** not specified in the header.\n**\n** Each btree pages is divided into three sections:  The header, the\n** cell pointer array, and the cell content area.  Page 1 also has a 100-byte\n** file header that occurs before the page header.\n**\n**      |----------------|\n**      | file header    |   100 bytes.  Page 1 only.\n**      |----------------|\n**      | page header    |   8 bytes for leaves.  12 bytes for interior nodes\n**      |----------------|\n**      | cell pointer   |   |  2 bytes per cell.  Sorted order.\n**      | array          |   |  Grows downward\n**      |                |   v\n**      |----------------|\n**      | unallocated    |\n**      | space          |\n**      |----------------|   ^  Grows upwards\n**      | cell content   |   |  Arbitrary order interspersed with freeblocks.\n**      | area           |   |  and free space fragments.\n**      |----------------|\n**\n** The page headers looks like this:\n**\n**   OFFSET   SIZE     DESCRIPTION\n**      0       1      Flags. 1: intkey, 2: zerodata, 4: leafdata, 8: leaf\n**      1       2      byte offset to the first freeblock\n**      3       2      number of cells on this page\n**      5       2      first byte of the cell content area\n**      7       1      number of fragmented free bytes\n**      8       4      Right child (the Ptr(N) value).  Omitted on leaves.\n**\n** The flags define the format of this btree page.  The leaf flag means that\n** this page has no children.  The zerodata flag means that this page carries\n** only keys and no data.  The intkey flag means that the key is an integer\n** which is stored in the key size entry of the cell header rather than in\n** the payload area.\n**\n** The cell pointer array begins on the first byte after the page header.\n** The cell pointer array contains zero or more 2-byte numbers which are\n** offsets from the beginning of the page to the cell content in the cell\n** content area.  The cell pointers occur in sorted order.  The system strives\n** to keep free space after the last cell pointer so that new cells can\n** be easily added without having to defragment the page.\n**\n** Cell content is stored at the very end of the page and grows toward the\n** beginning of the page.\n**\n** Unused space within the cell content area is collected into a linked list of\n** freeblocks.  Each freeblock is at least 4 bytes in size.  The byte offset\n** to the first freeblock is given in the header.  Freeblocks occur in\n** increasing order.  Because a freeblock must be at least 4 bytes in size,\n** any group of 3 or fewer unused bytes in the cell content area cannot\n** exist on the freeblock chain.  A group of 3 or fewer free bytes is called\n** a fragment.  The total number of bytes in all fragments is recorded.\n** in the page header at offset 7.\n**\n**    SIZE    DESCRIPTION\n**      2     Byte offset of the next freeblock\n**      2     Bytes in this freeblock\n**\n** Cells are of variable length.  Cells are stored in the cell content area at\n** the end of the page.  Pointers to the cells are in the cell pointer array\n** that immediately follows the page header.  Cells is not necessarily\n** contiguous or in order, but cell pointers are contiguous and in order.\n**\n** Cell content makes use of variable length integers.  A variable\n** length integer is 1 to 9 bytes where the lower 7 bits of each \n** byte are used.  The integer consists of all bytes that have bit 8 set and\n** the first byte with bit 8 clear.  The most significant byte of the integer\n** appears first.  A variable-length integer may not be more than 9 bytes long.\n** As a special case, all 8 bits of the 9th byte are used as data.  This\n** allows a 64-bit integer to be encoded in 9 bytes.\n**\n**    0x00                      becomes  0x00000000\n**    0x7f                      becomes  0x0000007f\n**    0x81 0x00                 becomes  0x00000080\n**    0x82 0x00                 becomes  0x00000100\n**    0x80 0x7f                 becomes  0x0000007f\n**    0x81 0x91 0xd1 0xac 0x78  becomes  0x12345678\n**    0x81 0x81 0x81 0x81 0x01  becomes  0x10204081\n**\n** Variable length integers are used for rowids and to hold the number of\n** bytes of key and data in a btree cell.\n**\n** The content of a cell looks like this:\n**\n**    SIZE    DESCRIPTION\n**      4     Page number of the left child. Omitted if leaf flag is set.\n**     var    Number of bytes of data. Omitted if the zerodata flag is set.\n**     var    Number of bytes of key. Or the key itself if intkey flag is set.\n**      *     Payload\n**      4     First page of the overflow chain.  Omitted if no overflow\n**\n** Overflow pages form a linked list.  Each page except the last is completely\n** filled with data (pagesize - 4 bytes).  The last page can have as little\n** as 1 byte of data.\n**\n**    SIZE    DESCRIPTION\n**      4     Page number of next overflow page\n**      *     Data\n**\n** Freelist pages come in two subtypes: trunk pages and leaf pages.  The\n** file header points to the first in a linked list of trunk page.  Each trunk\n** page points to multiple leaf pages.  The content of a leaf page is\n** unspecified.  A trunk page looks like this:\n**\n**    SIZE    DESCRIPTION\n**      4     Page number of next trunk page\n**      4     Number of leaf pointers on this page\n**      *     zero or more pages numbers of leaves\n*/\n#include \"sqliteInt.h\"\n\n\n/* The following value is the maximum cell size assuming a maximum page\n** size give above.\n*/\n#define MX_CELL_SIZE(pBt)  ((int)(pBt->pageSize-8))\n\n/* The maximum number of cells on a single page of the database.  This\n** assumes a minimum cell size of 6 bytes  (4 bytes for the cell itself\n** plus 2 bytes for the index to the cell in the page header).  Such\n** small cells will be rare, but they are possible.\n*/\n#define MX_CELL(pBt) ((pBt->pageSize-8)/6)\n\n/* Forward declarations */\ntypedef struct MemPage MemPage;\ntypedef struct BtLock BtLock;\ntypedef struct CellInfo CellInfo;\n\n/*\n** This is a magic string that appears at the beginning of every\n** SQLite database in order to identify the file as a real database.\n**\n** You can change this value at compile-time by specifying a\n** -DSQLITE_FILE_HEADER=\"...\" on the compiler command-line.  The\n** header must be exactly 16 bytes including the zero-terminator so\n** the string itself should be 15 characters long.  If you change\n** the header, then your custom library will not be able to read \n** databases generated by the standard tools and the standard tools\n** will not be able to read databases created by your custom library.\n*/\n#ifndef SQLITE_FILE_HEADER /* 123456789 123456 */\n#  define SQLITE_FILE_HEADER \"SQLite format 3\"\n#endif\n\n/*\n** Page type flags.  An ORed combination of these flags appear as the\n** first byte of on-disk image of every BTree page.\n*/\n#define PTF_INTKEY    0x01\n#define PTF_ZERODATA  0x02\n#define PTF_LEAFDATA  0x04\n#define PTF_LEAF      0x08\n\n/*\n** An instance of this object stores information about each a single database\n** page that has been loaded into memory.  The information in this object\n** is derived from the raw on-disk page content.\n**\n** As each database page is loaded into memory, the pager allocates an\n** instance of this object and zeros the first 8 bytes.  (This is the\n** \"extra\" information associated with each page of the pager.)\n**\n** Access to all fields of this structure is controlled by the mutex\n** stored in MemPage.pBt->mutex.\n*/\nstruct MemPage {\n  u8 isInit;           /* True if previously initialized. MUST BE FIRST! */\n  u8 intKey;           /* True if table b-trees.  False for index b-trees */\n  u8 intKeyLeaf;       /* True if the leaf of an intKey table */\n  Pgno pgno;           /* Page number for this page */\n  /* Only the first 8 bytes (above) are zeroed by pager.c when a new page\n  ** is allocated. All fields that follow must be initialized before use */\n  u8 leaf;             /* True if a leaf page */\n  u8 hdrOffset;        /* 100 for page 1.  0 otherwise */\n  u8 childPtrSize;     /* 0 if leaf==1.  4 if leaf==0 */\n  u8 max1bytePayload;  /* min(maxLocal,127) */\n  u8 nOverflow;        /* Number of overflow cell bodies in aCell[] */\n  u16 maxLocal;        /* Copy of BtShared.maxLocal or BtShared.maxLeaf */\n  u16 minLocal;        /* Copy of BtShared.minLocal or BtShared.minLeaf */\n  u16 cellOffset;      /* Index in aData of first cell pointer */\n  int nFree;           /* Number of free bytes on the page. -1 for unknown */\n  u16 nCell;           /* Number of cells on this page, local and ovfl */\n  u16 maskPage;        /* Mask for page offset */\n  u16 aiOvfl[4];       /* Insert the i-th overflow cell before the aiOvfl-th\n                       ** non-overflow cell */\n  u8 *apOvfl[4];       /* Pointers to the body of overflow cells */\n  BtShared *pBt;       /* Pointer to BtShared that this page is part of */\n  u8 *aData;           /* Pointer to disk image of the page data */\n  u8 *aDataEnd;        /* One byte past the end of the entire page - not just\n                       ** the usable space, the entire page.  Used to prevent\n                       ** corruption-induced buffer overflow. */\n  u8 *aCellIdx;        /* The cell index area */\n  u8 *aDataOfst;       /* Same as aData for leaves.  aData+4 for interior */\n  DbPage *pDbPage;     /* Pager page handle */\n  u16 (*xCellSize)(MemPage*,u8*);             /* cellSizePtr method */\n  void (*xParseCell)(MemPage*,u8*,CellInfo*); /* btreeParseCell method */\n};\n\n/*\n** A linked list of the following structures is stored at BtShared.pLock.\n** Locks are added (or upgraded from READ_LOCK to WRITE_LOCK) when a cursor \n** is opened on the table with root page BtShared.iTable. Locks are removed\n** from this list when a transaction is committed or rolled back, or when\n** a btree handle is closed.\n*/\nstruct BtLock {\n  Btree *pBtree;        /* Btree handle holding this lock */\n  Pgno iTable;          /* Root page of table */\n  u8 eLock;             /* READ_LOCK or WRITE_LOCK */\n  BtLock *pNext;        /* Next in BtShared.pLock list */\n};\n\n/* Candidate values for BtLock.eLock */\n#define READ_LOCK     1\n#define WRITE_LOCK    2\n\n/* A Btree handle\n**\n** A database connection contains a pointer to an instance of\n** this object for every database file that it has open.  This structure\n** is opaque to the database connection.  The database connection cannot\n** see the internals of this structure and only deals with pointers to\n** this structure.\n**\n** For some database files, the same underlying database cache might be \n** shared between multiple connections.  In that case, each connection\n** has it own instance of this object.  But each instance of this object\n** points to the same BtShared object.  The database cache and the\n** schema associated with the database file are all contained within\n** the BtShared object.\n**\n** All fields in this structure are accessed under sqlite3.mutex.\n** The pBt pointer itself may not be changed while there exists cursors \n** in the referenced BtShared that point back to this Btree since those\n** cursors have to go through this Btree to find their BtShared and\n** they often do so without holding sqlite3.mutex.\n*/\nstruct Btree {\n  sqlite3 *db;       /* The database connection holding this btree */\n  BtShared *pBt;     /* Sharable content of this btree */\n  u8 inTrans;        /* TRANS_NONE, TRANS_READ or TRANS_WRITE */\n  u8 sharable;       /* True if we can share pBt with another db */\n  u8 locked;         /* True if db currently has pBt locked */\n  u8 hasIncrblobCur; /* True if there are one or more Incrblob cursors */\n  int wantToLock;    /* Number of nested calls to sqlite3BtreeEnter() */\n  int nBackup;       /* Number of backup operations reading this btree */\n  u32 iBDataVersion; /* Combines with pBt->pPager->iDataVersion */\n  Btree *pNext;      /* List of other sharable Btrees from the same db */\n  Btree *pPrev;      /* Back pointer of the same list */\n#ifdef SQLITE_DEBUG\n  u64 nSeek;         /* Calls to sqlite3BtreeMovetoUnpacked() */\n#endif\n#ifndef SQLITE_OMIT_SHARED_CACHE\n  BtLock lock;       /* Object used to lock page 1 */\n#endif\n};\n\n/*\n** Btree.inTrans may take one of the following values.\n**\n** If the shared-data extension is enabled, there may be multiple users\n** of the Btree structure. At most one of these may open a write transaction,\n** but any number may have active read transactions.\n**\n** These values must match SQLITE_TXN_NONE, SQLITE_TXN_READ, and\n** SQLITE_TXN_WRITE\n*/\n#define TRANS_NONE  0\n#define TRANS_READ  1\n#define TRANS_WRITE 2\n\n#if TRANS_NONE!=SQLITE_TXN_NONE\n# error wrong numeric code for no-transaction\n#endif\n#if TRANS_READ!=SQLITE_TXN_READ\n# error wrong numeric code for read-transaction\n#endif\n#if TRANS_WRITE!=SQLITE_TXN_WRITE\n# error wrong numeric code for write-transaction\n#endif\n\n\n/*\n** An instance of this object represents a single database file.\n** \n** A single database file can be in use at the same time by two\n** or more database connections.  When two or more connections are\n** sharing the same database file, each connection has it own\n** private Btree object for the file and each of those Btrees points\n** to this one BtShared object.  BtShared.nRef is the number of\n** connections currently sharing this database file.\n**\n** Fields in this structure are accessed under the BtShared.mutex\n** mutex, except for nRef and pNext which are accessed under the\n** global SQLITE_MUTEX_STATIC_MAIN mutex.  The pPager field\n** may not be modified once it is initially set as long as nRef>0.\n** The pSchema field may be set once under BtShared.mutex and\n** thereafter is unchanged as long as nRef>0.\n**\n** isPending:\n**\n**   If a BtShared client fails to obtain a write-lock on a database\n**   table (because there exists one or more read-locks on the table),\n**   the shared-cache enters 'pending-lock' state and isPending is\n**   set to true.\n**\n**   The shared-cache leaves the 'pending lock' state when either of\n**   the following occur:\n**\n**     1) The current writer (BtShared.pWriter) concludes its transaction, OR\n**     2) The number of locks held by other connections drops to zero.\n**\n**   while in the 'pending-lock' state, no connection may start a new\n**   transaction.\n**\n**   This feature is included to help prevent writer-starvation.\n*/\nstruct BtShared {\n  Pager *pPager;        /* The page cache */\n  sqlite3 *db;          /* Database connection currently using this Btree */\n  BtCursor *pCursor;    /* A list of all open cursors */\n  MemPage *pPage1;      /* First page of the database */\n  u8 openFlags;         /* Flags to sqlite3BtreeOpen() */\n#ifndef SQLITE_OMIT_AUTOVACUUM\n  u8 autoVacuum;        /* True if auto-vacuum is enabled */\n  u8 incrVacuum;        /* True if incr-vacuum is enabled */\n  u8 bDoTruncate;       /* True to truncate db on commit */\n#endif\n  u8 inTransaction;     /* Transaction state */\n  u8 max1bytePayload;   /* Maximum first byte of cell for a 1-byte payload */\n  u8 nReserveWanted;    /* Desired number of extra bytes per page */\n  u16 btsFlags;         /* Boolean parameters.  See BTS_* macros below */\n  u16 maxLocal;         /* Maximum local payload in non-LEAFDATA tables */\n  u16 minLocal;         /* Minimum local payload in non-LEAFDATA tables */\n  u16 maxLeaf;          /* Maximum local payload in a LEAFDATA table */\n  u16 minLeaf;          /* Minimum local payload in a LEAFDATA table */\n  u32 pageSize;         /* Total number of bytes on a page */\n  u32 usableSize;       /* Number of usable bytes on each page */\n  int nTransaction;     /* Number of open transactions (read + write) */\n  u32 nPage;            /* Number of pages in the database */\n  void *pSchema;        /* Pointer to space allocated by sqlite3BtreeSchema() */\n  void (*xFreeSchema)(void*);  /* Destructor for BtShared.pSchema */\n  sqlite3_mutex *mutex; /* Non-recursive mutex required to access this object */\n  Bitvec *pHasContent;  /* Set of pages moved to free-list this transaction */\n#ifndef SQLITE_OMIT_SHARED_CACHE\n  int nRef;             /* Number of references to this structure */\n  BtShared *pNext;      /* Next on a list of sharable BtShared structs */\n  BtLock *pLock;        /* List of locks held on this shared-btree struct */\n  Btree *pWriter;       /* Btree with currently open write transaction */\n#endif\n  u8 *pTmpSpace;        /* Temp space sufficient to hold a single cell */\n  int nPreformatSize;   /* Size of last cell written by TransferRow() */\n};\n\n/*\n** Allowed values for BtShared.btsFlags\n*/\n#define BTS_READ_ONLY        0x0001   /* Underlying file is readonly */\n#define BTS_PAGESIZE_FIXED   0x0002   /* Page size can no longer be changed */\n#define BTS_SECURE_DELETE    0x0004   /* PRAGMA secure_delete is enabled */\n#define BTS_OVERWRITE        0x0008   /* Overwrite deleted content with zeros */\n#define BTS_FAST_SECURE      0x000c   /* Combination of the previous two */\n#define BTS_INITIALLY_EMPTY  0x0010   /* Database was empty at trans start */\n#define BTS_NO_WAL           0x0020   /* Do not open write-ahead-log files */\n#define BTS_EXCLUSIVE        0x0040   /* pWriter has an exclusive lock */\n#define BTS_PENDING          0x0080   /* Waiting for read-locks to clear */\n\n/*\n** An instance of the following structure is used to hold information\n** about a cell.  The parseCellPtr() function fills in this structure\n** based on information extract from the raw disk page.\n*/\nstruct CellInfo {\n  i64 nKey;      /* The key for INTKEY tables, or nPayload otherwise */\n  u8 *pPayload;  /* Pointer to the start of payload */\n  u32 nPayload;  /* Bytes of payload */\n  u16 nLocal;    /* Amount of payload held locally, not on overflow */\n  u16 nSize;     /* Size of the cell content on the main b-tree page */\n};\n\n/*\n** Maximum depth of an SQLite B-Tree structure. Any B-Tree deeper than\n** this will be declared corrupt. This value is calculated based on a\n** maximum database size of 2^31 pages a minimum fanout of 2 for a\n** root-node and 3 for all other internal nodes.\n**\n** If a tree that appears to be taller than this is encountered, it is\n** assumed that the database is corrupt.\n*/\n#define BTCURSOR_MAX_DEPTH 20\n\n/*\n** Maximum amount of storage local to a database page, regardless of\n** page size.\n*/\n#define BT_MAX_LOCAL  65501  /* 65536 - 35 */\n\n/*\n** A cursor is a pointer to a particular entry within a particular\n** b-tree within a database file.\n**\n** The entry is identified by its MemPage and the index in\n** MemPage.aCell[] of the entry.\n**\n** A single database file can be shared by two more database connections,\n** but cursors cannot be shared.  Each cursor is associated with a\n** particular database connection identified BtCursor.pBtree.db.\n**\n** Fields in this structure are accessed under the BtShared.mutex\n** found at self->pBt->mutex. \n**\n** skipNext meaning:\n** The meaning of skipNext depends on the value of eState:\n**\n**   eState            Meaning of skipNext\n**   VALID             skipNext is meaningless and is ignored\n**   INVALID           skipNext is meaningless and is ignored\n**   SKIPNEXT          sqlite3BtreeNext() is a no-op if skipNext>0 and\n**                     sqlite3BtreePrevious() is no-op if skipNext<0.\n**   REQUIRESEEK       restoreCursorPosition() restores the cursor to\n**                     eState=SKIPNEXT if skipNext!=0\n**   FAULT             skipNext holds the cursor fault error code.\n*/\nstruct BtCursor {\n  u8 eState;                /* One of the CURSOR_XXX constants (see below) */\n  u8 curFlags;              /* zero or more BTCF_* flags defined below */\n  u8 curPagerFlags;         /* Flags to send to sqlite3PagerGet() */\n  u8 hints;                 /* As configured by CursorSetHints() */\n  int skipNext;    /* Prev() is noop if negative. Next() is noop if positive.\n                   ** Error code if eState==CURSOR_FAULT */\n  Btree *pBtree;            /* The Btree to which this cursor belongs */\n  Pgno *aOverflow;          /* Cache of overflow page locations */\n  void *pKey;               /* Saved key that was cursor last known position */\n  /* All fields above are zeroed when the cursor is allocated.  See\n  ** sqlite3BtreeCursorZero().  Fields that follow must be manually\n  ** initialized. */\n#define BTCURSOR_FIRST_UNINIT pBt   /* Name of first uninitialized field */\n  BtShared *pBt;            /* The BtShared this cursor points to */\n  BtCursor *pNext;          /* Forms a linked list of all cursors */\n  CellInfo info;            /* A parse of the cell we are pointing at */\n  i64 nKey;                 /* Size of pKey, or last integer key */\n  Pgno pgnoRoot;            /* The root page of this tree */\n  i8 iPage;                 /* Index of current page in apPage */\n  u8 curIntKey;             /* Value of apPage[0]->intKey */\n  u16 ix;                   /* Current index for apPage[iPage] */\n  u16 aiIdx[BTCURSOR_MAX_DEPTH-1];     /* Current index in apPage[i] */\n  struct KeyInfo *pKeyInfo;            /* Arg passed to comparison function */\n  MemPage *pPage;                        /* Current page */\n  MemPage *apPage[BTCURSOR_MAX_DEPTH-1]; /* Stack of parents of current page */\n};\n\n/*\n** Legal values for BtCursor.curFlags\n*/\n#define BTCF_WriteFlag    0x01   /* True if a write cursor */\n#define BTCF_ValidNKey    0x02   /* True if info.nKey is valid */\n#define BTCF_ValidOvfl    0x04   /* True if aOverflow is valid */\n#define BTCF_AtLast       0x08   /* Cursor is pointing to the last entry */\n#define BTCF_Incrblob     0x10   /* True if an incremental I/O handle */\n#define BTCF_Multiple     0x20   /* Maybe another cursor on the same btree */\n#define BTCF_Pinned       0x40   /* Cursor is busy and cannot be moved */\n\n/*\n** Potential values for BtCursor.eState.\n**\n** CURSOR_INVALID:\n**   Cursor does not point to a valid entry. This can happen (for example) \n**   because the table is empty or because BtreeCursorFirst() has not been\n**   called.\n**\n** CURSOR_VALID:\n**   Cursor points to a valid entry. getPayload() etc. may be called.\n**\n** CURSOR_SKIPNEXT:\n**   Cursor is valid except that the Cursor.skipNext field is non-zero\n**   indicating that the next sqlite3BtreeNext() or sqlite3BtreePrevious()\n**   operation should be a no-op.\n**\n** CURSOR_REQUIRESEEK:\n**   The table that this cursor was opened on still exists, but has been \n**   modified since the cursor was last used. The cursor position is saved\n**   in variables BtCursor.pKey and BtCursor.nKey. When a cursor is in \n**   this state, restoreCursorPosition() can be called to attempt to\n**   seek the cursor to the saved position.\n**\n** CURSOR_FAULT:\n**   An unrecoverable error (an I/O error or a malloc failure) has occurred\n**   on a different connection that shares the BtShared cache with this\n**   cursor.  The error has left the cache in an inconsistent state.\n**   Do nothing else with this cursor.  Any attempt to use the cursor\n**   should return the error code stored in BtCursor.skipNext\n*/\n#define CURSOR_VALID             0\n#define CURSOR_INVALID           1\n#define CURSOR_SKIPNEXT          2\n#define CURSOR_REQUIRESEEK       3\n#define CURSOR_FAULT             4\n\n/* \n** The database page the PENDING_BYTE occupies. This page is never used.\n*/\n#define PENDING_BYTE_PAGE(pBt)  ((Pgno)((PENDING_BYTE/((pBt)->pageSize))+1))\n\n/*\n** These macros define the location of the pointer-map entry for a \n** database page. The first argument to each is the number of usable\n** bytes on each page of the database (often 1024). The second is the\n** page number to look up in the pointer map.\n**\n** PTRMAP_PAGENO returns the database page number of the pointer-map\n** page that stores the required pointer. PTRMAP_PTROFFSET returns\n** the offset of the requested map entry.\n**\n** If the pgno argument passed to PTRMAP_PAGENO is a pointer-map page,\n** then pgno is returned. So (pgno==PTRMAP_PAGENO(pgsz, pgno)) can be\n** used to test if pgno is a pointer-map page. PTRMAP_ISPAGE implements\n** this test.\n*/\n#define PTRMAP_PAGENO(pBt, pgno) ptrmapPageno(pBt, pgno)\n#define PTRMAP_PTROFFSET(pgptrmap, pgno) (5*(pgno-pgptrmap-1))\n#define PTRMAP_ISPAGE(pBt, pgno) (PTRMAP_PAGENO((pBt),(pgno))==(pgno))\n\n/*\n** The pointer map is a lookup table that identifies the parent page for\n** each child page in the database file.  The parent page is the page that\n** contains a pointer to the child.  Every page in the database contains\n** 0 or 1 parent pages.  (In this context 'database page' refers\n** to any page that is not part of the pointer map itself.)  Each pointer map\n** entry consists of a single byte 'type' and a 4 byte parent page number.\n** The PTRMAP_XXX identifiers below are the valid types.\n**\n** The purpose of the pointer map is to facility moving pages from one\n** position in the file to another as part of autovacuum.  When a page\n** is moved, the pointer in its parent must be updated to point to the\n** new location.  The pointer map is used to locate the parent page quickly.\n**\n** PTRMAP_ROOTPAGE: The database page is a root-page. The page-number is not\n**                  used in this case.\n**\n** PTRMAP_FREEPAGE: The database page is an unused (free) page. The page-number \n**                  is not used in this case.\n**\n** PTRMAP_OVERFLOW1: The database page is the first page in a list of \n**                   overflow pages. The page number identifies the page that\n**                   contains the cell with a pointer to this overflow page.\n**\n** PTRMAP_OVERFLOW2: The database page is the second or later page in a list of\n**                   overflow pages. The page-number identifies the previous\n**                   page in the overflow page list.\n**\n** PTRMAP_BTREE: The database page is a non-root btree page. The page number\n**               identifies the parent page in the btree.\n*/\n#define PTRMAP_ROOTPAGE 1\n#define PTRMAP_FREEPAGE 2\n#define PTRMAP_OVERFLOW1 3\n#define PTRMAP_OVERFLOW2 4\n#define PTRMAP_BTREE 5\n\n/* A bunch of assert() statements to check the transaction state variables\n** of handle p (type Btree*) are internally consistent.\n*/\n#define btreeIntegrity(p) \\\n  assert( p->pBt->inTransaction!=TRANS_NONE || p->pBt->nTransaction==0 ); \\\n  assert( p->pBt->inTransaction>=p->inTrans ); \n\n\n/*\n** The ISAUTOVACUUM macro is used within balance_nonroot() to determine\n** if the database supports auto-vacuum or not. Because it is used\n** within an expression that is an argument to another macro \n** (sqliteMallocRaw), it is not possible to use conditional compilation.\n** So, this macro is defined instead.\n*/\n#ifndef SQLITE_OMIT_AUTOVACUUM\n#define ISAUTOVACUUM(pBt) (pBt->autoVacuum)\n#else\n#define ISAUTOVACUUM(pBt) 0\n#endif\n\n\n/*\n** This structure is passed around through all the PRAGMA integrity_check\n** checking routines in order to keep track of some global state information.\n**\n** The aRef[] array is allocated so that there is 1 bit for each page in\n** the database. As the integrity-check proceeds, for each page used in\n** the database the corresponding bit is set. This allows integrity-check to \n** detect pages that are used twice and orphaned pages (both of which \n** indicate corruption).\n*/\ntypedef struct IntegrityCk IntegrityCk;\nstruct IntegrityCk {\n  BtShared *pBt;    /* The tree being checked out */\n  Pager *pPager;    /* The associated pager.  Also accessible by pBt->pPager */\n  u8 *aPgRef;       /* 1 bit per page in the db (see above) */\n  Pgno nCkPage;     /* Pages in the database.  0 for partial check */\n  int mxErr;        /* Stop accumulating errors when this reaches zero */\n  int nErr;         /* Number of messages written to zErrMsg so far */\n  int rc;           /* SQLITE_OK, SQLITE_NOMEM, or SQLITE_INTERRUPT */\n  u32 nStep;        /* Number of steps into the integrity_check process */\n  const char *zPfx; /* Error message prefix */\n  Pgno v0;          /* Value for first %u substitution in zPfx (root page) */\n  Pgno v1;          /* Value for second %u substitution in zPfx (current pg) */\n  int v2;           /* Value for third %d substitution in zPfx */\n  StrAccum errMsg;  /* Accumulate the error message text here */\n  u32 *heap;        /* Min-heap used for analyzing cell coverage */\n  sqlite3 *db;      /* Database connection running the check */\n  i64 nRow;         /* Number of rows visited in current tree */\n};\n\n/*\n** Routines to read or write a two- and four-byte big-endian integer values.\n*/\n#define get2byte(x)   ((x)[0]<<8 | (x)[1])\n#define put2byte(p,v) ((p)[0] = (u8)((v)>>8), (p)[1] = (u8)(v))\n#define get4byte sqlite3Get4byte\n#define put4byte sqlite3Put4byte\n\n/*\n** get2byteAligned(), unlike get2byte(), requires that its argument point to a\n** two-byte aligned address.  get2byteAligned() is only used for accessing the\n** cell addresses in a btree header.\n*/\n#if SQLITE_BYTEORDER==4321\n# define get2byteAligned(x)  (*(u16*)(x))\n#elif SQLITE_BYTEORDER==1234 && GCC_VERSION>=4008000\n# define get2byteAligned(x)  __builtin_bswap16(*(u16*)(x))\n#elif SQLITE_BYTEORDER==1234 && MSVC_VERSION>=1300\n# define get2byteAligned(x)  _byteswap_ushort(*(u16*)(x))\n#else\n# define get2byteAligned(x)  ((x)[0]<<8 | (x)[1])\n#endif\n"}
{"repo": "sqlite", "file": "wal.c", "lang": "C++", "code": "/*\n** 2010 February 1\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains the implementation of a write-ahead log (WAL) used in\n** \"journal_mode=WAL\" mode.\n**\n** WRITE-AHEAD LOG (WAL) FILE FORMAT\n**\n** A WAL file consists of a header followed by zero or more \"frames\".\n** Each frame records the revised content of a single page from the\n** database file.  All changes to the database are recorded by writing\n** frames into the WAL.  Transactions commit when a frame is written that\n** contains a commit marker.  A single WAL can and usually does record\n** multiple transactions.  Periodically, the content of the WAL is\n** transferred back into the database file in an operation called a\n** \"checkpoint\".\n**\n** A single WAL file can be used multiple times.  In other words, the\n** WAL can fill up with frames and then be checkpointed and then new\n** frames can overwrite the old ones.  A WAL always grows from beginning\n** toward the end.  Checksums and counters attached to each frame are\n** used to determine which frames within the WAL are valid and which\n** are leftovers from prior checkpoints.\n**\n** The WAL header is 32 bytes in size and consists of the following eight\n** big-endian 32-bit unsigned integer values:\n**\n**     0: Magic number.  0x377f0682 or 0x377f0683\n**     4: File format version.  Currently 3007000\n**     8: Database page size.  Example: 1024\n**    12: Checkpoint sequence number\n**    16: Salt-1, random integer incremented with each checkpoint\n**    20: Salt-2, a different random integer changing with each ckpt\n**    24: Checksum-1 (first part of checksum for first 24 bytes of header).\n**    28: Checksum-2 (second part of checksum for first 24 bytes of header).\n**\n** Immediately following the wal-header are zero or more frames. Each\n** frame consists of a 24-byte frame-header followed by <page-size> bytes\n** of page data. The frame-header is six big-endian 32-bit unsigned\n** integer values, as follows:\n**\n**     0: Page number.\n**     4: For commit records, the size of the database image in pages\n**        after the commit. For all other records, zero.\n**     8: Salt-1 (copied from the header)\n**    12: Salt-2 (copied from the header)\n**    16: Checksum-1.\n**    20: Checksum-2.\n**\n** A frame is considered valid if and only if the following conditions are\n** true:\n**\n**    (1) The salt-1 and salt-2 values in the frame-header match\n**        salt values in the wal-header\n**\n**    (2) The checksum values in the final 8 bytes of the frame-header\n**        exactly match the checksum computed consecutively on the\n**        WAL header and the first 8 bytes and the content of all frames\n**        up to and including the current frame.\n**\n** The checksum is computed using 32-bit big-endian integers if the\n** magic number in the first 4 bytes of the WAL is 0x377f0683 and it\n** is computed using little-endian if the magic number is 0x377f0682.\n** The checksum values are always stored in the frame header in a\n** big-endian format regardless of which byte order is used to compute\n** the checksum.  The checksum is computed by interpreting the input as\n** an even number of unsigned 32-bit integers: x[0] through x[N].  The\n** algorithm used for the checksum is as follows:\n**\n**   for i from 0 to n-1 step 2:\n**     s0 += x[i] + s1;\n**     s1 += x[i+1] + s0;\n**   endfor\n**\n** Note that s0 and s1 are both weighted checksums using fibonacci weights\n** in reverse order (the largest fibonacci weight occurs on the first element\n** of the sequence being summed.)  The s1 value spans all 32-bit\n** terms of the sequence whereas s0 omits the final term.\n**\n** On a checkpoint, the WAL is first VFS.xSync-ed, then valid content of the\n** WAL is transferred into the database, then the database is VFS.xSync-ed.\n** The VFS.xSync operations serve as write barriers - all writes launched\n** before the xSync must complete before any write that launches after the\n** xSync begins.\n**\n** After each checkpoint, the salt-1 value is incremented and the salt-2\n** value is randomized.  This prevents old and new frames in the WAL from\n** being considered valid at the same time and being checkpointing together\n** following a crash.\n**\n** READER ALGORITHM\n**\n** To read a page from the database (call it page number P), a reader\n** first checks the WAL to see if it contains page P.  If so, then the\n** last valid instance of page P that is a followed by a commit frame\n** or is a commit frame itself becomes the value read.  If the WAL\n** contains no copies of page P that are valid and which are a commit\n** frame or are followed by a commit frame, then page P is read from\n** the database file.\n**\n** To start a read transaction, the reader records the index of the last\n** valid frame in the WAL.  The reader uses this recorded \"mxFrame\" value\n** for all subsequent read operations.  New transactions can be appended\n** to the WAL, but as long as the reader uses its original mxFrame value\n** and ignores the newly appended content, it will see a consistent snapshot\n** of the database from a single point in time.  This technique allows\n** multiple concurrent readers to view different versions of the database\n** content simultaneously.\n**\n** The reader algorithm in the previous paragraphs works correctly, but\n** because frames for page P can appear anywhere within the WAL, the\n** reader has to scan the entire WAL looking for page P frames.  If the\n** WAL is large (multiple megabytes is typical) that scan can be slow,\n** and read performance suffers.  To overcome this problem, a separate\n** data structure called the wal-index is maintained to expedite the\n** search for frames of a particular page.\n**\n** WAL-INDEX FORMAT\n**\n** Conceptually, the wal-index is shared memory, though VFS implementations\n** might choose to implement the wal-index using a mmapped file.  Because\n** the wal-index is shared memory, SQLite does not support journal_mode=WAL\n** on a network filesystem.  All users of the database must be able to\n** share memory.\n**\n** In the default unix and windows implementation, the wal-index is a mmapped\n** file whose name is the database name with a \"-shm\" suffix added.  For that\n** reason, the wal-index is sometimes called the \"shm\" file.\n**\n** The wal-index is transient.  After a crash, the wal-index can (and should\n** be) reconstructed from the original WAL file.  In fact, the VFS is required\n** to either truncate or zero the header of the wal-index when the last\n** connection to it closes.  Because the wal-index is transient, it can\n** use an architecture-specific format; it does not have to be cross-platform.\n** Hence, unlike the database and WAL file formats which store all values\n** as big endian, the wal-index can store multi-byte values in the native\n** byte order of the host computer.\n**\n** The purpose of the wal-index is to answer this question quickly:  Given\n** a page number P and a maximum frame index M, return the index of the\n** last frame in the wal before frame M for page P in the WAL, or return\n** NULL if there are no frames for page P in the WAL prior to M.\n**\n** The wal-index consists of a header region, followed by an one or\n** more index blocks.\n**\n** The wal-index header contains the total number of frames within the WAL\n** in the mxFrame field.\n**\n** Each index block except for the first contains information on\n** HASHTABLE_NPAGE frames. The first index block contains information on\n** HASHTABLE_NPAGE_ONE frames. The values of HASHTABLE_NPAGE_ONE and\n** HASHTABLE_NPAGE are selected so that together the wal-index header and\n** first index block are the same size as all other index blocks in the\n** wal-index.  The values are:\n**\n**   HASHTABLE_NPAGE      4096\n**   HASHTABLE_NPAGE_ONE  4062\n**\n** Each index block contains two sections, a page-mapping that contains the\n** database page number associated with each wal frame, and a hash-table\n** that allows readers to query an index block for a specific page number.\n** The page-mapping is an array of HASHTABLE_NPAGE (or HASHTABLE_NPAGE_ONE\n** for the first index block) 32-bit page numbers. The first entry in the\n** first index-block contains the database page number corresponding to the\n** first frame in the WAL file. The first entry in the second index block\n** in the WAL file corresponds to the (HASHTABLE_NPAGE_ONE+1)th frame in\n** the log, and so on.\n**\n** The last index block in a wal-index usually contains less than the full\n** complement of HASHTABLE_NPAGE (or HASHTABLE_NPAGE_ONE) page-numbers,\n** depending on the contents of the WAL file. This does not change the\n** allocated size of the page-mapping array - the page-mapping array merely\n** contains unused entries.\n**\n** Even without using the hash table, the last frame for page P\n** can be found by scanning the page-mapping sections of each index block\n** starting with the last index block and moving toward the first, and\n** within each index block, starting at the end and moving toward the\n** beginning.  The first entry that equals P corresponds to the frame\n** holding the content for that page.\n**\n** The hash table consists of HASHTABLE_NSLOT 16-bit unsigned integers.\n** HASHTABLE_NSLOT = 2*HASHTABLE_NPAGE, and there is one entry in the\n** hash table for each page number in the mapping section, so the hash\n** table is never more than half full.  The expected number of collisions\n** prior to finding a match is 1.  Each entry of the hash table is an\n** 1-based index of an entry in the mapping section of the same\n** index block.   Let K be the 1-based index of the largest entry in\n** the mapping section.  (For index blocks other than the last, K will\n** always be exactly HASHTABLE_NPAGE (4096) and for the last index block\n** K will be (mxFrame%HASHTABLE_NPAGE).)  Unused slots of the hash table\n** contain a value of 0.\n**\n** To look for page P in the hash table, first compute a hash iKey on\n** P as follows:\n**\n**      iKey = (P * 383) % HASHTABLE_NSLOT\n**\n** Then start scanning entries of the hash table, starting with iKey\n** (wrapping around to the beginning when the end of the hash table is\n** reached) until an unused hash slot is found. Let the first unused slot\n** be at index iUnused.  (iUnused might be less than iKey if there was\n** wrap-around.) Because the hash table is never more than half full,\n** the search is guaranteed to eventually hit an unused entry.  Let\n** iMax be the value between iKey and iUnused, closest to iUnused,\n** where aHash[iMax]==P.  If there is no iMax entry (if there exists\n** no hash slot such that aHash[i]==p) then page P is not in the\n** current index block.  Otherwise the iMax-th mapping entry of the\n** current index block corresponds to the last entry that references\n** page P.\n**\n** A hash search begins with the last index block and moves toward the\n** first index block, looking for entries corresponding to page P.  On\n** average, only two or three slots in each index block need to be\n** examined in order to either find the last entry for page P, or to\n** establish that no such entry exists in the block.  Each index block\n** holds over 4000 entries.  So two or three index blocks are sufficient\n** to cover a typical 10 megabyte WAL file, assuming 1K pages.  8 or 10\n** comparisons (on average) suffice to either locate a frame in the\n** WAL or to establish that the frame does not exist in the WAL.  This\n** is much faster than scanning the entire 10MB WAL.\n**\n** Note that entries are added in order of increasing K.  Hence, one\n** reader might be using some value K0 and a second reader that started\n** at a later time (after additional transactions were added to the WAL\n** and to the wal-index) might be using a different value K1, where K1>K0.\n** Both readers can use the same hash table and mapping section to get\n** the correct result.  There may be entries in the hash table with\n** K>K0 but to the first reader, those entries will appear to be unused\n** slots in the hash table and so the first reader will get an answer as\n** if no values greater than K0 had ever been inserted into the hash table\n** in the first place - which is what reader one wants.  Meanwhile, the\n** second reader using K1 will see additional values that were inserted\n** later, which is exactly what reader two wants.\n**\n** When a rollback occurs, the value of K is decreased. Hash table entries\n** that correspond to frames greater than the new K value are removed\n** from the hash table at this point.\n*/\n#ifndef SQLITE_OMIT_WAL\n\n#include \"wal.h\"\n\n/*\n** Trace output macros\n*/\n#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)\nint sqlite3WalTrace = 0;\n# define WALTRACE(X)  if(sqlite3WalTrace) sqlite3DebugPrintf X\n#else\n# define WALTRACE(X)\n#endif\n\n/*\n** The maximum (and only) versions of the wal and wal-index formats\n** that may be interpreted by this version of SQLite.\n**\n** If a client begins recovering a WAL file and finds that (a) the checksum\n** values in the wal-header are correct and (b) the version field is not\n** WAL_MAX_VERSION, recovery fails and SQLite returns SQLITE_CANTOPEN.\n**\n** Similarly, if a client successfully reads a wal-index header (i.e. the\n** checksum test is successful) and finds that the version field is not\n** WALINDEX_MAX_VERSION, then no read-transaction is opened and SQLite\n** returns SQLITE_CANTOPEN.\n*/\n#define WAL_MAX_VERSION      3007000\n#define WALINDEX_MAX_VERSION 3007000\n\n/*\n** Index numbers for various locking bytes.   WAL_NREADER is the number\n** of available reader locks and should be at least 3.  The default\n** is SQLITE_SHM_NLOCK==8 and  WAL_NREADER==5.\n**\n** Technically, the various VFSes are free to implement these locks however\n** they see fit.  However, compatibility is encouraged so that VFSes can\n** interoperate.  The standard implementation used on both unix and windows\n** is for the index number to indicate a byte offset into the\n** WalCkptInfo.aLock[] array in the wal-index header.  In other words, all\n** locks are on the shm file.  The WALINDEX_LOCK_OFFSET constant (which\n** should be 120) is the location in the shm file for the first locking\n** byte.\n*/\n#define WAL_WRITE_LOCK         0\n#define WAL_ALL_BUT_WRITE      1\n#define WAL_CKPT_LOCK          1\n#define WAL_RECOVER_LOCK       2\n#define WAL_READ_LOCK(I)       (3+(I))\n#define WAL_NREADER            (SQLITE_SHM_NLOCK-3)\n\n\n/* Object declarations */\ntypedef struct WalIndexHdr WalIndexHdr;\ntypedef struct WalIterator WalIterator;\ntypedef struct WalCkptInfo WalCkptInfo;\n\n\n/*\n** The following object holds a copy of the wal-index header content.\n**\n** The actual header in the wal-index consists of two copies of this\n** object followed by one instance of the WalCkptInfo object.\n** For all versions of SQLite through 3.10.0 and probably beyond,\n** the locking bytes (WalCkptInfo.aLock) start at offset 120 and\n** the total header size is 136 bytes.\n**\n** The szPage value can be any power of 2 between 512 and 32768, inclusive.\n** Or it can be 1 to represent a 65536-byte page.  The latter case was\n** added in 3.7.1 when support for 64K pages was added.\n*/\nstruct WalIndexHdr {\n  u32 iVersion;                   /* Wal-index version */\n  u32 unused;                     /* Unused (padding) field */\n  u32 iChange;                    /* Counter incremented each transaction */\n  u8 isInit;                      /* 1 when initialized */\n  u8 bigEndCksum;                 /* True if checksums in WAL are big-endian */\n  u16 szPage;                     /* Database page size in bytes. 1==64K */\n  u32 mxFrame;                    /* Index of last valid frame in the WAL */\n  u32 nPage;                      /* Size of database in pages */\n  u32 aFrameCksum[2];             /* Checksum of last frame in log */\n  u32 aSalt[2];                   /* Two salt values copied from WAL header */\n  u32 aCksum[2];                  /* Checksum over all prior fields */\n};\n\n/*\n** A copy of the following object occurs in the wal-index immediately\n** following the second copy of the WalIndexHdr.  This object stores\n** information used by checkpoint.\n**\n** nBackfill is the number of frames in the WAL that have been written\n** back into the database. (We call the act of moving content from WAL to\n** database \"backfilling\".)  The nBackfill number is never greater than\n** WalIndexHdr.mxFrame.  nBackfill can only be increased by threads\n** holding the WAL_CKPT_LOCK lock (which includes a recovery thread).\n** However, a WAL_WRITE_LOCK thread can move the value of nBackfill from\n** mxFrame back to zero when the WAL is reset.\n**\n** nBackfillAttempted is the largest value of nBackfill that a checkpoint\n** has attempted to achieve.  Normally nBackfill==nBackfillAtempted, however\n** the nBackfillAttempted is set before any backfilling is done and the\n** nBackfill is only set after all backfilling completes.  So if a checkpoint\n** crashes, nBackfillAttempted might be larger than nBackfill.  The\n** WalIndexHdr.mxFrame must never be less than nBackfillAttempted.\n**\n** The aLock[] field is a set of bytes used for locking.  These bytes should\n** never be read or written.\n**\n** There is one entry in aReadMark[] for each reader lock.  If a reader\n** holds read-lock K, then the value in aReadMark[K] is no greater than\n** the mxFrame for that reader.  The value READMARK_NOT_USED (0xffffffff)\n** for any aReadMark[] means that entry is unused.  aReadMark[0] is\n** a special case; its value is never used and it exists as a place-holder\n** to avoid having to offset aReadMark[] indexes by one.  Readers holding\n** WAL_READ_LOCK(0) always ignore the entire WAL and read all content\n** directly from the database.\n**\n** The value of aReadMark[K] may only be changed by a thread that\n** is holding an exclusive lock on WAL_READ_LOCK(K).  Thus, the value of\n** aReadMark[K] cannot changed while there is a reader is using that mark\n** since the reader will be holding a shared lock on WAL_READ_LOCK(K).\n**\n** The checkpointer may only transfer frames from WAL to database where\n** the frame numbers are less than or equal to every aReadMark[] that is\n** in use (that is, every aReadMark[j] for which there is a corresponding\n** WAL_READ_LOCK(j)).  New readers (usually) pick the aReadMark[] with the\n** largest value and will increase an unused aReadMark[] to mxFrame if there\n** is not already an aReadMark[] equal to mxFrame.  The exception to the\n** previous sentence is when nBackfill equals mxFrame (meaning that everything\n** in the WAL has been backfilled into the database) then new readers\n** will choose aReadMark[0] which has value 0 and hence such reader will\n** get all their all content directly from the database file and ignore\n** the WAL.\n**\n** Writers normally append new frames to the end of the WAL.  However,\n** if nBackfill equals mxFrame (meaning that all WAL content has been\n** written back into the database) and if no readers are using the WAL\n** (in other words, if there are no WAL_READ_LOCK(i) where i>0) then\n** the writer will first \"reset\" the WAL back to the beginning and start\n** writing new content beginning at frame 1.\n**\n** We assume that 32-bit loads are atomic and so no locks are needed in\n** order to read from any aReadMark[] entries.\n*/\nstruct WalCkptInfo {\n  u32 nBackfill;                  /* Number of WAL frames backfilled into DB */\n  u32 aReadMark[WAL_NREADER];     /* Reader marks */\n  u8 aLock[SQLITE_SHM_NLOCK];     /* Reserved space for locks */\n  u32 nBackfillAttempted;         /* WAL frames perhaps written, or maybe not */\n  u32 notUsed0;                   /* Available for future enhancements */\n};\n#define READMARK_NOT_USED  0xffffffff\n\n/*\n** This is a schematic view of the complete 136-byte header of the\n** wal-index file (also known as the -shm file):\n**\n**      +-----------------------------+\n**   0: | iVersion                    | \\\n**      +-----------------------------+  |\n**   4: | (unused padding)            |  |\n**      +-----------------------------+  |\n**   8: | iChange                     |  |\n**      +-------+-------+-------------+  |\n**  12: | bInit |  bBig |   szPage    |  |\n**      +-------+-------+-------------+  |\n**  16: | mxFrame                     |  |  First copy of the\n**      +-----------------------------+  |  WalIndexHdr object\n**  20: | nPage                       |  |\n**      +-----------------------------+  |\n**  24: | aFrameCksum                 |  |\n**      |                             |  |\n**      +-----------------------------+  |\n**  32: | aSalt                       |  |\n**      |                             |  |\n**      +-----------------------------+  |\n**  40: | aCksum                      |  |\n**      |                             | /\n**      +-----------------------------+\n**  48: | iVersion                    | \\\n**      +-----------------------------+  |\n**  52: | (unused padding)            |  |\n**      +-----------------------------+  |\n**  56: | iChange                     |  |\n**      +-------+-------+-------------+  |\n**  60: | bInit |  bBig |   szPage    |  |\n**      +-------+-------+-------------+  |  Second copy of the\n**  64: | mxFrame                     |  |  WalIndexHdr\n**      +-----------------------------+  |\n**  68: | nPage                       |  |\n**      +-----------------------------+  |\n**  72: | aFrameCksum                 |  |\n**      |                             |  |\n**      +-----------------------------+  |\n**  80: | aSalt                       |  |\n**      |                             |  |\n**      +-----------------------------+  |\n**  88: | aCksum                      |  |\n**      |                             | /\n**      +-----------------------------+\n**  96: | nBackfill                   |\n**      +-----------------------------+\n** 100: | 5 read marks                |\n**      |                             |\n**      |                             |\n**      |                             |\n**      |                             |\n**      +-------+-------+------+------+\n** 120: | Write | Ckpt  | Rcvr | Rd0  | \\\n**      +-------+-------+------+------+  ) 8 lock bytes\n**      | Read1 | Read2 | Rd3  | Rd4  | /\n**      +-------+-------+------+------+\n** 128: | nBackfillAttempted          |\n**      +-----------------------------+\n** 132: | (unused padding)            |\n**      +-----------------------------+\n*/\n\n/* A block of WALINDEX_LOCK_RESERVED bytes beginning at\n** WALINDEX_LOCK_OFFSET is reserved for locks. Since some systems\n** only support mandatory file-locks, we do not read or write data\n** from the region of the file on which locks are applied.\n*/\n#define WALINDEX_LOCK_OFFSET (sizeof(WalIndexHdr)*2+offsetof(WalCkptInfo,aLock))\n#define WALINDEX_HDR_SIZE    (sizeof(WalIndexHdr)*2+sizeof(WalCkptInfo))\n\n/* Size of header before each frame in wal */\n#define WAL_FRAME_HDRSIZE 24\n\n/* Size of write ahead log header, including checksum. */\n#define WAL_HDRSIZE 32\n\n/* WAL magic value. Either this value, or the same value with the least\n** significant bit also set (WAL_MAGIC | 0x00000001) is stored in 32-bit\n** big-endian format in the first 4 bytes of a WAL file.\n**\n** If the LSB is set, then the checksums for each frame within the WAL\n** file are calculated by treating all data as an array of 32-bit\n** big-endian words. Otherwise, they are calculated by interpreting\n** all data as 32-bit little-endian words.\n*/\n#define WAL_MAGIC 0x377f0682\n\n/*\n** Return the offset of frame iFrame in the write-ahead log file,\n** assuming a database page size of szPage bytes. The offset returned\n** is to the start of the write-ahead log frame-header.\n*/\n#define walFrameOffset(iFrame, szPage) (                               \\\n  WAL_HDRSIZE + ((iFrame)-1)*(i64)((szPage)+WAL_FRAME_HDRSIZE)         \\\n)\n\n/*\n** An open write-ahead log file is represented by an instance of the\n** following object.\n**\n** writeLock:\n**   This is usually set to 1 whenever the WRITER lock is held. However,\n**   if it is set to 2, then the WRITER lock is held but must be released\n**   by walHandleException() if a SEH exception is thrown.\n*/\nstruct Wal {\n  sqlite3_vfs *pVfs;         /* The VFS used to create pDbFd */\n  sqlite3_file *pDbFd;       /* File handle for the database file */\n  sqlite3_file *pWalFd;      /* File handle for WAL file */\n  u32 iCallback;             /* Value to pass to log callback (or 0) */\n  i64 mxWalSize;             /* Truncate WAL to this size upon reset */\n  int nWiData;               /* Size of array apWiData */\n  int szFirstBlock;          /* Size of first block written to WAL file */\n  volatile u32 **apWiData;   /* Pointer to wal-index content in memory */\n  u32 szPage;                /* Database page size */\n  i16 readLock;              /* Which read lock is being held.  -1 for none */\n  u8 syncFlags;              /* Flags to use to sync header writes */\n  u8 exclusiveMode;          /* Non-zero if connection is in exclusive mode */\n  u8 writeLock;              /* True if in a write transaction */\n  u8 ckptLock;               /* True if holding a checkpoint lock */\n  u8 readOnly;               /* WAL_RDWR, WAL_RDONLY, or WAL_SHM_RDONLY */\n  u8 truncateOnCommit;       /* True to truncate WAL file on commit */\n  u8 syncHeader;             /* Fsync the WAL header if true */\n  u8 padToSectorBoundary;    /* Pad transactions out to the next sector */\n  u8 bShmUnreliable;         /* SHM content is read-only and unreliable */\n  WalIndexHdr hdr;           /* Wal-index header for current transaction */\n  u32 minFrame;              /* Ignore wal frames before this one */\n  u32 iReCksum;              /* On commit, recalculate checksums from here */\n  const char *zWalName;      /* Name of WAL file */\n  u32 nCkpt;                 /* Checkpoint sequence counter in the wal-header */\n#ifdef SQLITE_USE_SEH\n  u32 lockMask;              /* Mask of locks held */\n  void *pFree;               /* Pointer to sqlite3_free() if exception thrown */\n  u32 *pWiValue;             /* Value to write into apWiData[iWiPg] */\n  int iWiPg;                 /* Write pWiValue into apWiData[iWiPg] */\n  int iSysErrno;             /* System error code following exception */\n#endif\n#ifdef SQLITE_DEBUG\n  int nSehTry;               /* Number of nested SEH_TRY{} blocks */\n  u8 lockError;              /* True if a locking error has occurred */\n#endif\n#ifdef SQLITE_ENABLE_SNAPSHOT\n  WalIndexHdr *pSnapshot;    /* Start transaction here if not NULL */\n  int bGetSnapshot;          /* Transaction opened for sqlite3_get_snapshot() */\n#endif\n#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n  sqlite3 *db;\n#endif\n};\n\n/*\n** Candidate values for Wal.exclusiveMode.\n*/\n#define WAL_NORMAL_MODE     0\n#define WAL_EXCLUSIVE_MODE  1\n#define WAL_HEAPMEMORY_MODE 2\n\n/*\n** Possible values for WAL.readOnly\n*/\n#define WAL_RDWR        0    /* Normal read/write connection */\n#define WAL_RDONLY      1    /* The WAL file is readonly */\n#define WAL_SHM_RDONLY  2    /* The SHM file is readonly */\n\n/*\n** Each page of the wal-index mapping contains a hash-table made up of\n** an array of HASHTABLE_NSLOT elements of the following type.\n*/\ntypedef u16 ht_slot;\n\n/*\n** This structure is used to implement an iterator that loops through\n** all frames in the WAL in database page order. Where two or more frames\n** correspond to the same database page, the iterator visits only the\n** frame most recently written to the WAL (in other words, the frame with\n** the largest index).\n**\n** The internals of this structure are only accessed by:\n**\n**   walIteratorInit() - Create a new iterator,\n**   walIteratorNext() - Step an iterator,\n**   walIteratorFree() - Free an iterator.\n**\n** This functionality is used by the checkpoint code (see walCheckpoint()).\n*/\nstruct WalIterator {\n  u32 iPrior;                     /* Last result returned from the iterator */\n  int nSegment;                   /* Number of entries in aSegment[] */\n  struct WalSegment {\n    int iNext;                    /* Next slot in aIndex[] not yet returned */\n    ht_slot *aIndex;              /* i0, i1, i2... such that aPgno[iN] ascend */\n    u32 *aPgno;                   /* Array of page numbers. */\n    int nEntry;                   /* Nr. of entries in aPgno[] and aIndex[] */\n    int iZero;                    /* Frame number associated with aPgno[0] */\n  } aSegment[FLEXARRAY];          /* One for every 32KB page in the wal-index */\n};\n\n/* Size (in bytes) of a WalIterator object suitable for N or fewer segments */\n#define SZ_WALITERATOR(N)  \\\n     (offsetof(WalIterator,aSegment)+(N)*sizeof(struct WalSegment))\n\n/*\n** Define the parameters of the hash tables in the wal-index file. There\n** is a hash-table following every HASHTABLE_NPAGE page numbers in the\n** wal-index.\n**\n** Changing any of these constants will alter the wal-index format and\n** create incompatibilities.\n*/\n#define HASHTABLE_NPAGE      4096                 /* Must be power of 2 */\n#define HASHTABLE_HASH_1     383                  /* Should be prime */\n#define HASHTABLE_NSLOT      (HASHTABLE_NPAGE*2)  /* Must be a power of 2 */\n\n/*\n** The block of page numbers associated with the first hash-table in a\n** wal-index is smaller than usual. This is so that there is a complete\n** hash-table on each aligned 32KB page of the wal-index.\n*/\n#define HASHTABLE_NPAGE_ONE  (HASHTABLE_NPAGE - (WALINDEX_HDR_SIZE/sizeof(u32)))\n\n/* The wal-index is divided into pages of WALINDEX_PGSZ bytes each. */\n#define WALINDEX_PGSZ   (                                         \\\n    sizeof(ht_slot)*HASHTABLE_NSLOT + HASHTABLE_NPAGE*sizeof(u32) \\\n)\n\n/*\n** Structured Exception Handling (SEH) is a Windows-specific technique\n** for catching exceptions raised while accessing memory-mapped files.\n**\n** The -DSQLITE_USE_SEH compile-time option means to use SEH to catch and\n** deal with system-level errors that arise during WAL -shm file processing.\n** Without this compile-time option, any system-level faults that appear\n** while accessing the memory-mapped -shm file will cause a process-wide\n** signal to be deliver, which will more than likely cause the entire\n** process to exit.\n*/\n#ifdef SQLITE_USE_SEH\n#include <Windows.h>\n\n/* Beginning of a block of code in which an exception might occur */\n# define SEH_TRY    __try { \\\n   assert( walAssertLockmask(pWal) && pWal->nSehTry==0 ); \\\n   VVA_ONLY(pWal->nSehTry++);\n\n/* The end of a block of code in which an exception might occur */\n# define SEH_EXCEPT(X) \\\n   VVA_ONLY(pWal->nSehTry--); \\\n   assert( pWal->nSehTry==0 ); \\\n   } __except( sehExceptionFilter(pWal, GetExceptionCode(), GetExceptionInformation() ) ){ X }\n\n/* Simulate a memory-mapping fault in the -shm file for testing purposes */\n# define SEH_INJECT_FAULT sehInjectFault(pWal) \n\n/*\n** The second argument is the return value of GetExceptionCode() for the \n** current exception. Return EXCEPTION_EXECUTE_HANDLER if the exception code\n** indicates that the exception may have been caused by accessing the *-shm \n** file mapping. Or EXCEPTION_CONTINUE_SEARCH otherwise.\n*/\nstatic int sehExceptionFilter(Wal *pWal, int eCode, EXCEPTION_POINTERS *p){\n  VVA_ONLY(pWal->nSehTry--);\n  if( eCode==EXCEPTION_IN_PAGE_ERROR ){\n    if( p && p->ExceptionRecord && p->ExceptionRecord->NumberParameters>=3 ){\n      /* From MSDN: For this type of exception, the first element of the\n      ** ExceptionInformation[] array is a read-write flag - 0 if the exception\n      ** was thrown while reading, 1 if while writing. The second element is\n      ** the virtual address being accessed. The \"third array element specifies\n      ** the underlying NTSTATUS code that resulted in the exception\". */\n      pWal->iSysErrno = (int)p->ExceptionRecord->ExceptionInformation[2];\n    }\n    return EXCEPTION_EXECUTE_HANDLER;\n  }\n  return EXCEPTION_CONTINUE_SEARCH;\n}\n\n/*\n** If one is configured, invoke the xTestCallback callback with 650 as\n** the argument. If it returns true, throw the same exception that is\n** thrown by the system if the *-shm file mapping is accessed after it\n** has been invalidated.\n*/\nstatic void sehInjectFault(Wal *pWal){\n  int res;\n  assert( pWal->nSehTry>0 );\n\n  res = sqlite3FaultSim(650);\n  if( res!=0 ){\n    ULONG_PTR aArg[3];\n    aArg[0] = 0;\n    aArg[1] = 0;\n    aArg[2] = (ULONG_PTR)res;\n    RaiseException(EXCEPTION_IN_PAGE_ERROR, 0, 3, (const ULONG_PTR*)aArg);\n  }\n}\n\n/*\n** There are two ways to use this macro. To set a pointer to be freed\n** if an exception is thrown:\n**\n**   SEH_FREE_ON_ERROR(0, pPtr);\n**\n** and to cancel the same:\n**\n**   SEH_FREE_ON_ERROR(pPtr, 0);\n**\n** In the first case, there must not already be a pointer registered to\n** be freed. In the second case, pPtr must be the registered pointer.\n*/\n#define SEH_FREE_ON_ERROR(X,Y) \\\n  assert( (X==0 || Y==0) && pWal->pFree==X ); pWal->pFree = Y\n\n/*\n** There are two ways to use this macro. To arrange for pWal->apWiData[iPg]\n** to be set to pValue if an exception is thrown:\n**\n**   SEH_SET_ON_ERROR(iPg, pValue);\n**\n** and to cancel the same:\n**\n**   SEH_SET_ON_ERROR(0, 0);\n*/\n#define SEH_SET_ON_ERROR(X,Y)  pWal->iWiPg = X; pWal->pWiValue = Y\n\n#else\n# define SEH_TRY          VVA_ONLY(pWal->nSehTry++);\n# define SEH_EXCEPT(X)    VVA_ONLY(pWal->nSehTry--); assert( pWal->nSehTry==0 );\n# define SEH_INJECT_FAULT assert( pWal->nSehTry>0 );\n# define SEH_FREE_ON_ERROR(X,Y)\n# define SEH_SET_ON_ERROR(X,Y)\n#endif /* ifdef SQLITE_USE_SEH */\n\n\n/*\n** Obtain a pointer to the iPage'th page of the wal-index. The wal-index\n** is broken into pages of WALINDEX_PGSZ bytes. Wal-index pages are\n** numbered from zero.\n**\n** If the wal-index is currently smaller the iPage pages then the size\n** of the wal-index might be increased, but only if it is safe to do\n** so.  It is safe to enlarge the wal-index if pWal->writeLock is true\n** or pWal->exclusiveMode==WAL_HEAPMEMORY_MODE.\n**\n** Three possible result scenarios:\n**\n**   (1)  rc==SQLITE_OK    and *ppPage==Requested-Wal-Index-Page\n**   (2)  rc>=SQLITE_ERROR and *ppPage==NULL\n**   (3)  rc==SQLITE_OK    and *ppPage==NULL  // only if iPage==0\n**\n** Scenario (3) can only occur when pWal->writeLock is false and iPage==0\n*/\nstatic SQLITE_NOINLINE int walIndexPageRealloc(\n  Wal *pWal,               /* The WAL context */\n  int iPage,               /* The page we seek */\n  volatile u32 **ppPage    /* Write the page pointer here */\n){\n  int rc = SQLITE_OK;\n\n  /* Enlarge the pWal->apWiData[] array if required */\n  if( pWal->nWiData<=iPage ){\n    sqlite3_int64 nByte = sizeof(u32*)*(1+(i64)iPage);\n    volatile u32 **apNew;\n    apNew = (volatile u32 **)sqlite3Realloc((void *)pWal->apWiData, nByte);\n    if( !apNew ){\n      *ppPage = 0;\n      return SQLITE_NOMEM_BKPT;\n    }\n    memset((void*)&apNew[pWal->nWiData], 0,\n           sizeof(u32*)*(iPage+1-pWal->nWiData));\n    pWal->apWiData = apNew;\n    pWal->nWiData = iPage+1;\n  }\n\n  /* Request a pointer to the required page from the VFS */\n  assert( pWal->apWiData[iPage]==0 );\n  if( pWal->exclusiveMode==WAL_HEAPMEMORY_MODE ){\n    pWal->apWiData[iPage] = (u32 volatile *)sqlite3MallocZero(WALINDEX_PGSZ);\n    if( !pWal->apWiData[iPage] ) rc = SQLITE_NOMEM_BKPT;\n  }else{\n    rc = sqlite3OsShmMap(pWal->pDbFd, iPage, WALINDEX_PGSZ,\n        pWal->writeLock, (void volatile **)&pWal->apWiData[iPage]\n    );\n    assert( pWal->apWiData[iPage]!=0\n         || rc!=SQLITE_OK\n         || (pWal->writeLock==0 && iPage==0) );\n    testcase( pWal->apWiData[iPage]==0 && rc==SQLITE_OK );\n    if( rc==SQLITE_OK ){\n      if( iPage>0 && sqlite3FaultSim(600) ) rc = SQLITE_NOMEM;\n    }else if( (rc&0xff)==SQLITE_READONLY ){\n      pWal->readOnly |= WAL_SHM_RDONLY;\n      if( rc==SQLITE_READONLY ){\n        rc = SQLITE_OK;\n      }\n    }\n  }\n\n  *ppPage = pWal->apWiData[iPage];\n  assert( iPage==0 || *ppPage || rc!=SQLITE_OK );\n  return rc;\n}\nstatic int walIndexPage(\n  Wal *pWal,               /* The WAL context */\n  int iPage,               /* The page we seek */\n  volatile u32 **ppPage    /* Write the page pointer here */\n){\n  SEH_INJECT_FAULT;\n  if( pWal->nWiData<=iPage || (*ppPage = pWal->apWiData[iPage])==0 ){\n    return walIndexPageRealloc(pWal, iPage, ppPage);\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Return a pointer to the WalCkptInfo structure in the wal-index.\n*/\nstatic volatile WalCkptInfo *walCkptInfo(Wal *pWal){\n  assert( pWal->nWiData>0 && pWal->apWiData[0] );\n  SEH_INJECT_FAULT;\n  return (volatile WalCkptInfo*)&(pWal->apWiData[0][sizeof(WalIndexHdr)/2]);\n}\n\n/*\n** Return a pointer to the WalIndexHdr structure in the wal-index.\n*/\nstatic volatile WalIndexHdr *walIndexHdr(Wal *pWal){\n  assert( pWal->nWiData>0 && pWal->apWiData[0] );\n  SEH_INJECT_FAULT;\n  return (volatile WalIndexHdr*)pWal->apWiData[0];\n}\n\n/*\n** The argument to this macro must be of type u32. On a little-endian\n** architecture, it returns the u32 value that results from interpreting\n** the 4 bytes as a big-endian value. On a big-endian architecture, it\n** returns the value that would be produced by interpreting the 4 bytes\n** of the input value as a little-endian integer.\n*/\n#define BYTESWAP32(x) ( \\\n    (((x)&0x000000FF)<<24) + (((x)&0x0000FF00)<<8)  \\\n  + (((x)&0x00FF0000)>>8)  + (((x)&0xFF000000)>>24) \\\n)\n\n/*\n** Generate or extend an 8 byte checksum based on the data in\n** array aByte[] and the initial values of aIn[0] and aIn[1] (or\n** initial values of 0 and 0 if aIn==NULL).\n**\n** The checksum is written back into aOut[] before returning.\n**\n** nByte must be a positive multiple of 8.\n*/\nstatic void walChecksumBytes(\n  int nativeCksum, /* True for native byte-order, false for non-native */\n  u8 *a,           /* Content to be checksummed */\n  int nByte,       /* Bytes of content in a[].  Must be a multiple of 8. */\n  const u32 *aIn,  /* Initial checksum value input */\n  u32 *aOut        /* OUT: Final checksum value output */\n){\n  u32 s1, s2;\n  u32 *aData = (u32 *)a;\n  u32 *aEnd = (u32 *)&a[nByte];\n\n  if( aIn ){\n    s1 = aIn[0];\n    s2 = aIn[1];\n  }else{\n    s1 = s2 = 0;\n  }\n\n  /* nByte is a multiple of 8 between 8 and 65536 */\n  assert( nByte>=8 && (nByte&7)==0 && nByte<=65536 );\n\n  if( !nativeCksum ){\n    do {\n      s1 += BYTESWAP32(aData[0]) + s2;\n      s2 += BYTESWAP32(aData[1]) + s1;\n      aData += 2;\n    }while( aData<aEnd );\n  }else if( nByte%64==0 ){\n    do {\n      s1 += *aData++ + s2;\n      s2 += *aData++ + s1;\n      s1 += *aData++ + s2;\n      s2 += *aData++ + s1;\n      s1 += *aData++ + s2;\n      s2 += *aData++ + s1;\n      s1 += *aData++ + s2;\n      s2 += *aData++ + s1;\n      s1 += *aData++ + s2;\n      s2 += *aData++ + s1;\n      s1 += *aData++ + s2;\n      s2 += *aData++ + s1;\n      s1 += *aData++ + s2;\n      s2 += *aData++ + s1;\n      s1 += *aData++ + s2;\n      s2 += *aData++ + s1;\n    }while( aData<aEnd );\n  }else{\n    do {\n      s1 += *aData++ + s2;\n      s2 += *aData++ + s1;\n    }while( aData<aEnd );\n  }\n  assert( aData==aEnd );\n\n  aOut[0] = s1;\n  aOut[1] = s2;\n}\n\n/*\n** If there is the possibility of concurrent access to the SHM file\n** from multiple threads and/or processes, then do a memory barrier.\n*/\nstatic void walShmBarrier(Wal *pWal){\n  if( pWal->exclusiveMode!=WAL_HEAPMEMORY_MODE ){\n    sqlite3OsShmBarrier(pWal->pDbFd);\n  }\n}\n\n/*\n** Add the SQLITE_NO_TSAN as part of the return-type of a function\n** definition as a hint that the function contains constructs that\n** might give false-positive TSAN warnings.\n**\n** See tag-20200519-1.\n*/\n#if defined(__clang__) && !defined(SQLITE_NO_TSAN)\n# define SQLITE_NO_TSAN __attribute__((no_sanitize_thread))\n#else\n# define SQLITE_NO_TSAN\n#endif\n\n/*\n** Write the header information in pWal->hdr into the wal-index.\n**\n** The checksum on pWal->hdr is updated before it is written.\n*/\nstatic SQLITE_NO_TSAN void walIndexWriteHdr(Wal *pWal){\n  volatile WalIndexHdr *aHdr = walIndexHdr(pWal);\n  const int nCksum = offsetof(WalIndexHdr, aCksum);\n\n  assert( pWal->writeLock );\n  pWal->hdr.isInit = 1;\n  pWal->hdr.iVersion = WALINDEX_MAX_VERSION;\n  walChecksumBytes(1, (u8*)&pWal->hdr, nCksum, 0, pWal->hdr.aCksum);\n  /* Possible TSAN false-positive.  See tag-20200519-1 */\n  memcpy((void*)&aHdr[1], (const void*)&pWal->hdr, sizeof(WalIndexHdr));\n  walShmBarrier(pWal);\n  memcpy((void*)&aHdr[0], (const void*)&pWal->hdr, sizeof(WalIndexHdr));\n}\n\n/*\n** This function encodes a single frame header and writes it to a buffer\n** supplied by the caller. A frame-header is made up of a series of\n** 4-byte big-endian integers, as follows:\n**\n**     0: Page number.\n**     4: For commit records, the size of the database image in pages\n**        after the commit. For all other records, zero.\n**     8: Salt-1 (copied from the wal-header)\n**    12: Salt-2 (copied from the wal-header)\n**    16: Checksum-1.\n**    20: Checksum-2.\n*/\nstatic void walEncodeFrame(\n  Wal *pWal,                      /* The write-ahead log */\n  u32 iPage,                      /* Database page number for frame */\n  u32 nTruncate,                  /* New db size (or 0 for non-commit frames) */\n  u8 *aData,                      /* Pointer to page data */\n  u8 *aFrame                      /* OUT: Write encoded frame here */\n){\n  int nativeCksum;                /* True for native byte-order checksums */\n  u32 *aCksum = pWal->hdr.aFrameCksum;\n  assert( WAL_FRAME_HDRSIZE==24 );\n  sqlite3Put4byte(&aFrame[0], iPage);\n  sqlite3Put4byte(&aFrame[4], nTruncate);\n  if( pWal->iReCksum==0 ){\n    memcpy(&aFrame[8], pWal->hdr.aSalt, 8);\n\n    nativeCksum = (pWal->hdr.bigEndCksum==SQLITE_BIGENDIAN);\n    walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum);\n    walChecksumBytes(nativeCksum, aData, pWal->szPage, aCksum, aCksum);\n\n    sqlite3Put4byte(&aFrame[16], aCksum[0]);\n    sqlite3Put4byte(&aFrame[20], aCksum[1]);\n  }else{\n    memset(&aFrame[8], 0, 16);\n  }\n}\n\n/*\n** Check to see if the frame with header in aFrame[] and content\n** in aData[] is valid.  If it is a valid frame, fill *piPage and\n** *pnTruncate and return true.  Return if the frame is not valid.\n*/\nstatic int walDecodeFrame(\n  Wal *pWal,                      /* The write-ahead log */\n  u32 *piPage,                    /* OUT: Database page number for frame */\n  u32 *pnTruncate,                /* OUT: New db size (or 0 if not commit) */\n  u8 *aData,                      /* Pointer to page data (for checksum) */\n  u8 *aFrame                      /* Frame data */\n){\n  int nativeCksum;                /* True for native byte-order checksums */\n  u32 *aCksum = pWal->hdr.aFrameCksum;\n  u32 pgno;                       /* Page number of the frame */\n  assert( WAL_FRAME_HDRSIZE==24 );\n\n  /* A frame is only valid if the salt values in the frame-header\n  ** match the salt values in the wal-header.\n  */\n  if( memcmp(&pWal->hdr.aSalt, &aFrame[8], 8)!=0 ){\n    return 0;\n  }\n\n  /* A frame is only valid if the page number is greater than zero.\n  */\n  pgno = sqlite3Get4byte(&aFrame[0]);\n  if( pgno==0 ){\n    return 0;\n  }\n\n  /* A frame is only valid if a checksum of the WAL header,\n  ** all prior frames, the first 16 bytes of this frame-header,\n  ** and the frame-data matches the checksum in the last 8\n  ** bytes of this frame-header.\n  */\n  nativeCksum = (pWal->hdr.bigEndCksum==SQLITE_BIGENDIAN);\n  walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum);\n  walChecksumBytes(nativeCksum, aData, pWal->szPage, aCksum, aCksum);\n  if( aCksum[0]!=sqlite3Get4byte(&aFrame[16])\n   || aCksum[1]!=sqlite3Get4byte(&aFrame[20])\n  ){\n    /* Checksum failed. */\n    return 0;\n  }\n\n  /* If we reach this point, the frame is valid.  Return the page number\n  ** and the new database size.\n  */\n  *piPage = pgno;\n  *pnTruncate = sqlite3Get4byte(&aFrame[4]);\n  return 1;\n}\n\n\n#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)\n/*\n** Names of locks.  This routine is used to provide debugging output and is not\n** a part of an ordinary build.\n*/\nstatic const char *walLockName(int lockIdx){\n  if( lockIdx==WAL_WRITE_LOCK ){\n    return \"WRITE-LOCK\";\n  }else if( lockIdx==WAL_CKPT_LOCK ){\n    return \"CKPT-LOCK\";\n  }else if( lockIdx==WAL_RECOVER_LOCK ){\n    return \"RECOVER-LOCK\";\n  }else{\n    static char zName[15];\n    sqlite3_snprintf(sizeof(zName), zName, \"READ-LOCK[%d]\",\n                     lockIdx-WAL_READ_LOCK(0));\n    return zName;\n  }\n}\n#endif /*defined(SQLITE_TEST) || defined(SQLITE_DEBUG) */\n\n\n/*\n** Set or release locks on the WAL.  Locks are either shared or exclusive.\n** A lock cannot be moved directly between shared and exclusive - it must go\n** through the unlocked state first.\n**\n** In locking_mode=EXCLUSIVE, all of these routines become no-ops.\n*/\nstatic int walLockShared(Wal *pWal, int lockIdx){\n  int rc;\n  if( pWal->exclusiveMode ) return SQLITE_OK;\n  rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1,\n                        SQLITE_SHM_LOCK | SQLITE_SHM_SHARED);\n  WALTRACE((\"WAL%p: acquire SHARED-%s %s\\n\", pWal,\n            walLockName(lockIdx), rc ? \"failed\" : \"ok\"));\n  VVA_ONLY( pWal->lockError = (u8)(rc!=SQLITE_OK && (rc&0xFF)!=SQLITE_BUSY); )\n#ifdef SQLITE_USE_SEH\n  if( rc==SQLITE_OK ) pWal->lockMask |= (1 << lockIdx);\n#endif\n  return rc;\n}\nstatic void walUnlockShared(Wal *pWal, int lockIdx){\n  if( pWal->exclusiveMode ) return;\n  (void)sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1,\n                         SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED);\n#ifdef SQLITE_USE_SEH\n  pWal->lockMask &= ~(1 << lockIdx);\n#endif\n  WALTRACE((\"WAL%p: release SHARED-%s\\n\", pWal, walLockName(lockIdx)));\n}\nstatic int walLockExclusive(Wal *pWal, int lockIdx, int n){\n  int rc;\n  if( pWal->exclusiveMode ) return SQLITE_OK;\n  rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, n,\n                        SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE);\n  WALTRACE((\"WAL%p: acquire EXCLUSIVE-%s cnt=%d %s\\n\", pWal,\n            walLockName(lockIdx), n, rc ? \"failed\" : \"ok\"));\n  VVA_ONLY( pWal->lockError = (u8)(rc!=SQLITE_OK && (rc&0xFF)!=SQLITE_BUSY); )\n#ifdef SQLITE_USE_SEH\n  if( rc==SQLITE_OK ){\n    pWal->lockMask |= (((1<<n)-1) << (SQLITE_SHM_NLOCK+lockIdx));\n  }\n#endif\n  return rc;\n}\nstatic void walUnlockExclusive(Wal *pWal, int lockIdx, int n){\n  if( pWal->exclusiveMode ) return;\n  (void)sqlite3OsShmLock(pWal->pDbFd, lockIdx, n,\n                         SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE);\n#ifdef SQLITE_USE_SEH\n  pWal->lockMask &= ~(((1<<n)-1) << (SQLITE_SHM_NLOCK+lockIdx));\n#endif\n  WALTRACE((\"WAL%p: release EXCLUSIVE-%s cnt=%d\\n\", pWal,\n             walLockName(lockIdx), n));\n}\n\n/*\n** Compute a hash on a page number.  The resulting hash value must land\n** between 0 and (HASHTABLE_NSLOT-1).  The walHashNext() function advances\n** the hash to the next value in the event of a collision.\n*/\nstatic int walHash(u32 iPage){\n  assert( iPage>0 );\n  assert( (HASHTABLE_NSLOT & (HASHTABLE_NSLOT-1))==0 );\n  return (iPage*HASHTABLE_HASH_1) & (HASHTABLE_NSLOT-1);\n}\nstatic int walNextHash(int iPriorHash){\n  return (iPriorHash+1)&(HASHTABLE_NSLOT-1);\n}\n\n/*\n** An instance of the WalHashLoc object is used to describe the location\n** of a page hash table in the wal-index.  This becomes the return value\n** from walHashGet().\n*/\ntypedef struct WalHashLoc WalHashLoc;\nstruct WalHashLoc {\n  volatile ht_slot *aHash;  /* Start of the wal-index hash table */\n  volatile u32 *aPgno;      /* aPgno[1] is the page of first frame indexed */\n  u32 iZero;                /* One less than the frame number of first indexed*/\n};\n\n/*\n** Return pointers to the hash table and page number array stored on\n** page iHash of the wal-index. The wal-index is broken into 32KB pages\n** numbered starting from 0.\n**\n** Set output variable pLoc->aHash to point to the start of the hash table\n** in the wal-index file. Set pLoc->iZero to one less than the frame\n** number of the first frame indexed by this hash table. If a\n** slot in the hash table is set to N, it refers to frame number\n** (pLoc->iZero+N) in the log.\n**\n** Finally, set pLoc->aPgno so that pLoc->aPgno[0] is the page number of the\n** first frame indexed by the hash table, frame (pLoc->iZero).\n*/\nstatic int walHashGet(\n  Wal *pWal,                      /* WAL handle */\n  int iHash,                      /* Find the iHash'th table */\n  WalHashLoc *pLoc                /* OUT: Hash table location */\n){\n  int rc;                         /* Return code */\n\n  rc = walIndexPage(pWal, iHash, &pLoc->aPgno);\n  assert( rc==SQLITE_OK || iHash>0 );\n\n  if( pLoc->aPgno ){\n    pLoc->aHash = (volatile ht_slot *)&pLoc->aPgno[HASHTABLE_NPAGE];\n    if( iHash==0 ){\n      pLoc->aPgno = &pLoc->aPgno[WALINDEX_HDR_SIZE/sizeof(u32)];\n      pLoc->iZero = 0;\n    }else{\n      pLoc->iZero = HASHTABLE_NPAGE_ONE + (iHash-1)*HASHTABLE_NPAGE;\n    }\n  }else if( NEVER(rc==SQLITE_OK) ){\n    rc = SQLITE_ERROR;\n  }\n  return rc;\n}\n\n/*\n** Return the number of the wal-index page that contains the hash-table\n** and page-number array that contain entries corresponding to WAL frame\n** iFrame. The wal-index is broken up into 32KB pages. Wal-index pages\n** are numbered starting from 0.\n*/\nstatic int walFramePage(u32 iFrame){\n  int iHash = (iFrame+HASHTABLE_NPAGE-HASHTABLE_NPAGE_ONE-1) / HASHTABLE_NPAGE;\n  assert( (iHash==0 || iFrame>HASHTABLE_NPAGE_ONE)\n       && (iHash>=1 || iFrame<=HASHTABLE_NPAGE_ONE)\n       && (iHash<=1 || iFrame>(HASHTABLE_NPAGE_ONE+HASHTABLE_NPAGE))\n       && (iHash>=2 || iFrame<=HASHTABLE_NPAGE_ONE+HASHTABLE_NPAGE)\n       && (iHash<=2 || iFrame>(HASHTABLE_NPAGE_ONE+2*HASHTABLE_NPAGE))\n  );\n  assert( iHash>=0 );\n  return iHash;\n}\n\n/*\n** Return the page number associated with frame iFrame in this WAL.\n*/\nstatic u32 walFramePgno(Wal *pWal, u32 iFrame){\n  int iHash = walFramePage(iFrame);\n  SEH_INJECT_FAULT;\n  if( iHash==0 ){\n    return pWal->apWiData[0][WALINDEX_HDR_SIZE/sizeof(u32) + iFrame - 1];\n  }\n  return pWal->apWiData[iHash][(iFrame-1-HASHTABLE_NPAGE_ONE)%HASHTABLE_NPAGE];\n}\n\n/*\n** Remove entries from the hash table that point to WAL slots greater\n** than pWal->hdr.mxFrame.\n**\n** This function is called whenever pWal->hdr.mxFrame is decreased due\n** to a rollback or savepoint.\n**\n** At most only the hash table containing pWal->hdr.mxFrame needs to be\n** updated.  Any later hash tables will be automatically cleared when\n** pWal->hdr.mxFrame advances to the point where those hash tables are\n** actually needed.\n*/\nstatic void walCleanupHash(Wal *pWal){\n  WalHashLoc sLoc;                /* Hash table location */\n  int iLimit = 0;                 /* Zero values greater than this */\n  int nByte;                      /* Number of bytes to zero in aPgno[] */\n  int i;                          /* Used to iterate through aHash[] */\n\n  assert( pWal->writeLock );\n  testcase( pWal->hdr.mxFrame==HASHTABLE_NPAGE_ONE-1 );\n  testcase( pWal->hdr.mxFrame==HASHTABLE_NPAGE_ONE );\n  testcase( pWal->hdr.mxFrame==HASHTABLE_NPAGE_ONE+1 );\n\n  if( pWal->hdr.mxFrame==0 ) return;\n\n  /* Obtain pointers to the hash-table and page-number array containing\n  ** the entry that corresponds to frame pWal->hdr.mxFrame. It is guaranteed\n  ** that the page said hash-table and array reside on is already mapped.(1)\n  */\n  assert( pWal->nWiData>walFramePage(pWal->hdr.mxFrame) );\n  assert( pWal->apWiData[walFramePage(pWal->hdr.mxFrame)] );\n  i = walHashGet(pWal, walFramePage(pWal->hdr.mxFrame), &sLoc);\n  if( NEVER(i) ) return; /* Defense-in-depth, in case (1) above is wrong */\n\n  /* Zero all hash-table entries that correspond to frame numbers greater\n  ** than pWal->hdr.mxFrame.\n  */\n  iLimit = pWal->hdr.mxFrame - sLoc.iZero;\n  assert( iLimit>0 );\n  for(i=0; i<HASHTABLE_NSLOT; i++){\n    if( sLoc.aHash[i]>iLimit ){\n      sLoc.aHash[i] = 0;\n    }\n  }\n\n  /* Zero the entries in the aPgno array that correspond to frames with\n  ** frame numbers greater than pWal->hdr.mxFrame.\n  */\n  nByte = (int)((char *)sLoc.aHash - (char *)&sLoc.aPgno[iLimit]);\n  assert( nByte>=0 );\n  memset((void *)&sLoc.aPgno[iLimit], 0, nByte);\n\n#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT\n  /* Verify that the every entry in the mapping region is still reachable\n  ** via the hash table even after the cleanup.\n  */\n  if( iLimit ){\n    int j;           /* Loop counter */\n    int iKey;        /* Hash key */\n    for(j=0; j<iLimit; j++){\n      for(iKey=walHash(sLoc.aPgno[j]);sLoc.aHash[iKey];iKey=walNextHash(iKey)){\n        if( sLoc.aHash[iKey]==j+1 ) break;\n      }\n      assert( sLoc.aHash[iKey]==j+1 );\n    }\n  }\n#endif /* SQLITE_ENABLE_EXPENSIVE_ASSERT */\n}\n\n\n/*\n** Set an entry in the wal-index that will map database page number\n** pPage into WAL frame iFrame.\n*/\nstatic int walIndexAppend(Wal *pWal, u32 iFrame, u32 iPage){\n  int rc;                         /* Return code */\n  WalHashLoc sLoc;                /* Wal-index hash table location */\n\n  rc = walHashGet(pWal, walFramePage(iFrame), &sLoc);\n\n  /* Assuming the wal-index file was successfully mapped, populate the\n  ** page number array and hash table entry.\n  */\n  if( rc==SQLITE_OK ){\n    int iKey;                     /* Hash table key */\n    int idx;                      /* Value to write to hash-table slot */\n    int nCollide;                 /* Number of hash collisions */\n\n    idx = iFrame - sLoc.iZero;\n    assert( idx <= HASHTABLE_NSLOT/2 + 1 );\n\n    /* If this is the first entry to be added to this hash-table, zero the\n    ** entire hash table and aPgno[] array before proceeding.\n    */\n    if( idx==1 ){\n      int nByte = (int)((u8*)&sLoc.aHash[HASHTABLE_NSLOT] - (u8*)sLoc.aPgno);\n      assert( nByte>=0 );\n      memset((void*)sLoc.aPgno, 0, nByte);\n    }\n\n    /* If the entry in aPgno[] is already set, then the previous writer\n    ** must have exited unexpectedly in the middle of a transaction (after\n    ** writing one or more dirty pages to the WAL to free up memory).\n    ** Remove the remnants of that writers uncommitted transaction from\n    ** the hash-table before writing any new entries.\n    */\n    if( sLoc.aPgno[idx-1] ){\n      walCleanupHash(pWal);\n      assert( !sLoc.aPgno[idx-1] );\n    }\n\n    /* Write the aPgno[] array entry and the hash-table slot. */\n    nCollide = idx;\n    for(iKey=walHash(iPage); sLoc.aHash[iKey]; iKey=walNextHash(iKey)){\n      if( (nCollide--)==0 ) return SQLITE_CORRUPT_BKPT;\n    }\n    sLoc.aPgno[idx-1] = iPage;\n    AtomicStore(&sLoc.aHash[iKey], (ht_slot)idx);\n\n#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT\n    /* Verify that the number of entries in the hash table exactly equals\n    ** the number of entries in the mapping region.\n    */\n    {\n      int i;           /* Loop counter */\n      int nEntry = 0;  /* Number of entries in the hash table */\n      for(i=0; i<HASHTABLE_NSLOT; i++){ if( sLoc.aHash[i] ) nEntry++; }\n      assert( nEntry==idx );\n    }\n\n    /* Verify that the every entry in the mapping region is reachable\n    ** via the hash table.  This turns out to be a really, really expensive\n    ** thing to check, so only do this occasionally - not on every\n    ** iteration.\n    */\n    if( (idx&0x3ff)==0 ){\n      int i;           /* Loop counter */\n      for(i=0; i<idx; i++){\n        for(iKey=walHash(sLoc.aPgno[i]);\n            sLoc.aHash[iKey];\n            iKey=walNextHash(iKey)){\n          if( sLoc.aHash[iKey]==i+1 ) break;\n        }\n        assert( sLoc.aHash[iKey]==i+1 );\n      }\n    }\n#endif /* SQLITE_ENABLE_EXPENSIVE_ASSERT */\n  }\n\n  return rc;\n}\n\n\n/*\n** Recover the wal-index by reading the write-ahead log file.\n**\n** This routine first tries to establish an exclusive lock on the\n** wal-index to prevent other threads/processes from doing anything\n** with the WAL or wal-index while recovery is running.  The\n** WAL_RECOVER_LOCK is also held so that other threads will know\n** that this thread is running recovery.  If unable to establish\n** the necessary locks, this routine returns SQLITE_BUSY.\n*/\nstatic int walIndexRecover(Wal *pWal){\n  int rc;                         /* Return Code */\n  i64 nSize;                      /* Size of log file */\n  u32 aFrameCksum[2] = {0, 0};\n  int iLock;                      /* Lock offset to lock for checkpoint */\n\n  /* Obtain an exclusive lock on all byte in the locking range not already\n  ** locked by the caller. The caller is guaranteed to have locked the\n  ** WAL_WRITE_LOCK byte, and may have also locked the WAL_CKPT_LOCK byte.\n  ** If successful, the same bytes that are locked here are unlocked before\n  ** this function returns.\n  */\n  assert( pWal->ckptLock==1 || pWal->ckptLock==0 );\n  assert( WAL_ALL_BUT_WRITE==WAL_WRITE_LOCK+1 );\n  assert( WAL_CKPT_LOCK==WAL_ALL_BUT_WRITE );\n  assert( pWal->writeLock );\n  iLock = WAL_ALL_BUT_WRITE + pWal->ckptLock;\n  rc = walLockExclusive(pWal, iLock, WAL_READ_LOCK(0)-iLock);\n  if( rc ){\n    return rc;\n  }\n\n  WALTRACE((\"WAL%p: recovery begin...\\n\", pWal));\n\n  memset(&pWal->hdr, 0, sizeof(WalIndexHdr));\n\n  rc = sqlite3OsFileSize(pWal->pWalFd, &nSize);\n  if( rc!=SQLITE_OK ){\n    goto recovery_error;\n  }\n\n  if( nSize>WAL_HDRSIZE ){\n    u8 aBuf[WAL_HDRSIZE];         /* Buffer to load WAL header into */\n    u32 *aPrivate = 0;            /* Heap copy of *-shm hash being populated */\n    u8 *aFrame = 0;               /* Malloc'd buffer to load entire frame */\n    int szFrame;                  /* Number of bytes in buffer aFrame[] */\n    u8 *aData;                    /* Pointer to data part of aFrame buffer */\n    int szPage;                   /* Page size according to the log */\n    u32 magic;                    /* Magic value read from WAL header */\n    u32 version;                  /* Magic value read from WAL header */\n    int isValid;                  /* True if this frame is valid */\n    u32 iPg;                      /* Current 32KB wal-index page */\n    u32 iLastFrame;               /* Last frame in wal, based on nSize alone */\n\n    /* Read in the WAL header. */\n    rc = sqlite3OsRead(pWal->pWalFd, aBuf, WAL_HDRSIZE, 0);\n    if( rc!=SQLITE_OK ){\n      goto recovery_error;\n    }\n\n    /* If the database page size is not a power of two, or is greater than\n    ** SQLITE_MAX_PAGE_SIZE, conclude that the WAL file contains no valid\n    ** data. Similarly, if the 'magic' value is invalid, ignore the whole\n    ** WAL file.\n    */\n    magic = sqlite3Get4byte(&aBuf[0]);\n    szPage = sqlite3Get4byte(&aBuf[8]);\n    if( (magic&0xFFFFFFFE)!=WAL_MAGIC\n     || szPage&(szPage-1)\n     || szPage>SQLITE_MAX_PAGE_SIZE\n     || szPage<512\n    ){\n      goto finished;\n    }\n    pWal->hdr.bigEndCksum = (u8)(magic&0x00000001);\n    pWal->szPage = szPage;\n    pWal->nCkpt = sqlite3Get4byte(&aBuf[12]);\n    memcpy(&pWal->hdr.aSalt, &aBuf[16], 8);\n\n    /* Verify that the WAL header checksum is correct */\n    walChecksumBytes(pWal->hdr.bigEndCksum==SQLITE_BIGENDIAN,\n        aBuf, WAL_HDRSIZE-2*4, 0, pWal->hdr.aFrameCksum\n    );\n    if( pWal->hdr.aFrameCksum[0]!=sqlite3Get4byte(&aBuf[24])\n     || pWal->hdr.aFrameCksum[1]!=sqlite3Get4byte(&aBuf[28])\n    ){\n      goto finished;\n    }\n\n    /* Verify that the version number on the WAL format is one that\n    ** are able to understand */\n    version = sqlite3Get4byte(&aBuf[4]);\n    if( version!=WAL_MAX_VERSION ){\n      rc = SQLITE_CANTOPEN_BKPT;\n      goto finished;\n    }\n\n    /* Malloc a buffer to read frames into. */\n    szFrame = szPage + WAL_FRAME_HDRSIZE;\n    aFrame = (u8 *)sqlite3_malloc64(szFrame + WALINDEX_PGSZ);\n    SEH_FREE_ON_ERROR(0, aFrame);\n    if( !aFrame ){\n      rc = SQLITE_NOMEM_BKPT;\n      goto recovery_error;\n    }\n    aData = &aFrame[WAL_FRAME_HDRSIZE];\n    aPrivate = (u32*)&aData[szPage];\n\n    /* Read all frames from the log file. */\n    iLastFrame = (nSize - WAL_HDRSIZE) / szFrame;\n    for(iPg=0; iPg<=(u32)walFramePage(iLastFrame); iPg++){\n      u32 *aShare;\n      u32 iFrame;                 /* Index of last frame read */\n      u32 iLast = MIN(iLastFrame, HASHTABLE_NPAGE_ONE+iPg*HASHTABLE_NPAGE);\n      u32 iFirst = 1 + (iPg==0?0:HASHTABLE_NPAGE_ONE+(iPg-1)*HASHTABLE_NPAGE);\n      u32 nHdr, nHdr32;\n      rc = walIndexPage(pWal, iPg, (volatile u32**)&aShare);\n      assert( aShare!=0 || rc!=SQLITE_OK );\n      if( aShare==0 ) break;\n      SEH_SET_ON_ERROR(iPg, aShare);\n      pWal->apWiData[iPg] = aPrivate;\n\n      for(iFrame=iFirst; iFrame<=iLast; iFrame++){\n        i64 iOffset = walFrameOffset(iFrame, szPage);\n        u32 pgno;                 /* Database page number for frame */\n        u32 nTruncate;            /* dbsize field from frame header */\n\n        /* Read and decode the next log frame. */\n        rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);\n        if( rc!=SQLITE_OK ) break;\n        isValid = walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame);\n        if( !isValid ) break;\n        rc = walIndexAppend(pWal, iFrame, pgno);\n        if( NEVER(rc!=SQLITE_OK) ) break;\n\n        /* If nTruncate is non-zero, this is a commit record. */\n        if( nTruncate ){\n          pWal->hdr.mxFrame = iFrame;\n          pWal->hdr.nPage = nTruncate;\n          pWal->hdr.szPage = (u16)((szPage&0xff00) | (szPage>>16));\n          testcase( szPage<=32768 );\n          testcase( szPage>=65536 );\n          aFrameCksum[0] = pWal->hdr.aFrameCksum[0];\n          aFrameCksum[1] = pWal->hdr.aFrameCksum[1];\n        }\n      }\n      pWal->apWiData[iPg] = aShare;\n      SEH_SET_ON_ERROR(0,0);\n      nHdr = (iPg==0 ? WALINDEX_HDR_SIZE : 0);\n      nHdr32 = nHdr / sizeof(u32);\n#ifndef SQLITE_SAFER_WALINDEX_RECOVERY\n      /* Memcpy() should work fine here, on all reasonable implementations.\n      ** Technically, memcpy() might change the destination to some\n      ** intermediate value before setting to the final value, and that might\n      ** cause a concurrent reader to malfunction.  Memcpy() is allowed to\n      ** do that, according to the spec, but no memcpy() implementation that\n      ** we know of actually does that, which is why we say that memcpy()\n      ** is safe for this.  Memcpy() is certainly a lot faster.\n      */\n      memcpy(&aShare[nHdr32], &aPrivate[nHdr32], WALINDEX_PGSZ-nHdr);\n#else\n      /* In the event that some platform is found for which memcpy()\n      ** changes the destination to some intermediate value before\n      ** setting the final value, this alternative copy routine is\n      ** provided.\n      */\n      {\n        int i;\n        for(i=nHdr32; i<WALINDEX_PGSZ/sizeof(u32); i++){\n          if( aShare[i]!=aPrivate[i] ){\n            /* Atomic memory operations are not required here because if\n            ** the value needs to be changed, that means it is not being\n            ** accessed concurrently. */\n            aShare[i] = aPrivate[i];\n          }\n        }\n      }\n#endif\n      SEH_INJECT_FAULT;\n      if( iFrame<=iLast ) break;\n    }\n\n    SEH_FREE_ON_ERROR(aFrame, 0);\n    sqlite3_free(aFrame);\n  }\n\nfinished:\n  if( rc==SQLITE_OK ){\n    volatile WalCkptInfo *pInfo;\n    int i;\n    pWal->hdr.aFrameCksum[0] = aFrameCksum[0];\n    pWal->hdr.aFrameCksum[1] = aFrameCksum[1];\n    walIndexWriteHdr(pWal);\n\n    /* Reset the checkpoint-header. This is safe because this thread is\n    ** currently holding locks that exclude all other writers and\n    ** checkpointers. Then set the values of read-mark slots 1 through N.\n    */\n    pInfo = walCkptInfo(pWal);\n    pInfo->nBackfill = 0;\n    pInfo->nBackfillAttempted = pWal->hdr.mxFrame;\n    pInfo->aReadMark[0] = 0;\n    for(i=1; i<WAL_NREADER; i++){\n      rc = walLockExclusive(pWal, WAL_READ_LOCK(i), 1);\n      if( rc==SQLITE_OK ){\n        if( i==1 && pWal->hdr.mxFrame ){\n          pInfo->aReadMark[i] = pWal->hdr.mxFrame;\n        }else{\n          pInfo->aReadMark[i] = READMARK_NOT_USED;\n        }\n        SEH_INJECT_FAULT;\n        walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);\n      }else if( rc!=SQLITE_BUSY ){\n        goto recovery_error;\n      }\n    }\n\n    /* If more than one frame was recovered from the log file, report an\n    ** event via sqlite3_log(). This is to help with identifying performance\n    ** problems caused by applications routinely shutting down without\n    ** checkpointing the log file.\n    */\n    if( pWal->hdr.nPage ){\n      sqlite3_log(SQLITE_NOTICE_RECOVER_WAL,\n          \"recovered %d frames from WAL file %s\",\n          pWal->hdr.mxFrame, pWal->zWalName\n      );\n    }\n  }\n\nrecovery_error:\n  WALTRACE((\"WAL%p: recovery %s\\n\", pWal, rc ? \"failed\" : \"ok\"));\n  walUnlockExclusive(pWal, iLock, WAL_READ_LOCK(0)-iLock);\n  return rc;\n}\n\n/*\n** Close an open wal-index.\n*/\nstatic void walIndexClose(Wal *pWal, int isDelete){\n  if( pWal->exclusiveMode==WAL_HEAPMEMORY_MODE || pWal->bShmUnreliable ){\n    int i;\n    for(i=0; i<pWal->nWiData; i++){\n      sqlite3_free((void *)pWal->apWiData[i]);\n      pWal->apWiData[i] = 0;\n    }\n  }\n  if( pWal->exclusiveMode!=WAL_HEAPMEMORY_MODE ){\n    sqlite3OsShmUnmap(pWal->pDbFd, isDelete);\n  }\n}\n\n/*\n** Open a connection to the WAL file zWalName. The database file must\n** already be opened on connection pDbFd. The buffer that zWalName points\n** to must remain valid for the lifetime of the returned Wal* handle.\n**\n** A SHARED lock should be held on the database file when this function\n** is called. The purpose of this SHARED lock is to prevent any other\n** client from unlinking the WAL or wal-index file. If another process\n** were to do this just after this client opened one of these files, the\n** system would be badly broken.\n**\n** If the log file is successfully opened, SQLITE_OK is returned and\n** *ppWal is set to point to a new WAL handle. If an error occurs,\n** an SQLite error code is returned and *ppWal is left unmodified.\n*/\nint sqlite3WalOpen(\n  sqlite3_vfs *pVfs,              /* vfs module to open wal and wal-index */\n  sqlite3_file *pDbFd,            /* The open database file */\n  const char *zWalName,           /* Name of the WAL file */\n  int bNoShm,                     /* True to run in heap-memory mode */\n  i64 mxWalSize,                  /* Truncate WAL to this size on reset */\n  Wal **ppWal                     /* OUT: Allocated Wal handle */\n){\n  int rc;                         /* Return Code */\n  Wal *pRet;                      /* Object to allocate and return */\n  int flags;                      /* Flags passed to OsOpen() */\n\n  assert( zWalName && zWalName[0] );\n  assert( pDbFd );\n\n  /* Verify the values of various constants.  Any changes to the values\n  ** of these constants would result in an incompatible on-disk format\n  ** for the -shm file.  Any change that causes one of these asserts to\n  ** fail is a backward compatibility problem, even if the change otherwise\n  ** works.\n  **\n  ** This table also serves as a helpful cross-reference when trying to\n  ** interpret hex dumps of the -shm file.\n  */\n  assert(    48 ==  sizeof(WalIndexHdr)  );\n  assert(    40 ==  sizeof(WalCkptInfo)  );\n  assert(   120 ==  WALINDEX_LOCK_OFFSET );\n  assert(   136 ==  WALINDEX_HDR_SIZE    );\n  assert(  4096 ==  HASHTABLE_NPAGE      );\n  assert(  4062 ==  HASHTABLE_NPAGE_ONE  );\n  assert(  8192 ==  HASHTABLE_NSLOT      );\n  assert(   383 ==  HASHTABLE_HASH_1     );\n  assert( 32768 ==  WALINDEX_PGSZ        );\n  assert(     8 ==  SQLITE_SHM_NLOCK     );\n  assert(     5 ==  WAL_NREADER          );\n  assert(    24 ==  WAL_FRAME_HDRSIZE    );\n  assert(    32 ==  WAL_HDRSIZE          );\n  assert(   120 ==  WALINDEX_LOCK_OFFSET + WAL_WRITE_LOCK   );\n  assert(   121 ==  WALINDEX_LOCK_OFFSET + WAL_CKPT_LOCK    );\n  assert(   122 ==  WALINDEX_LOCK_OFFSET + WAL_RECOVER_LOCK );\n  assert(   123 ==  WALINDEX_LOCK_OFFSET + WAL_READ_LOCK(0) );\n  assert(   124 ==  WALINDEX_LOCK_OFFSET + WAL_READ_LOCK(1) );\n  assert(   125 ==  WALINDEX_LOCK_OFFSET + WAL_READ_LOCK(2) );\n  assert(   126 ==  WALINDEX_LOCK_OFFSET + WAL_READ_LOCK(3) );\n  assert(   127 ==  WALINDEX_LOCK_OFFSET + WAL_READ_LOCK(4) );\n\n  /* In the amalgamation, the os_unix.c and os_win.c source files come before\n  ** this source file.  Verify that the #defines of the locking byte offsets\n  ** in os_unix.c and os_win.c agree with the WALINDEX_LOCK_OFFSET value.\n  ** For that matter, if the lock offset ever changes from its initial design\n  ** value of 120, we need to know that so there is an assert() to check it.\n  */\n#ifdef WIN_SHM_BASE\n  assert( WIN_SHM_BASE==WALINDEX_LOCK_OFFSET );\n#endif\n#ifdef UNIX_SHM_BASE\n  assert( UNIX_SHM_BASE==WALINDEX_LOCK_OFFSET );\n#endif\n\n\n  /* Allocate an instance of struct Wal to return. */\n  *ppWal = 0;\n  pRet = (Wal*)sqlite3MallocZero(sizeof(Wal) + pVfs->szOsFile);\n  if( !pRet ){\n    return SQLITE_NOMEM_BKPT;\n  }\n\n  pRet->pVfs = pVfs;\n  pRet->pWalFd = (sqlite3_file *)&pRet[1];\n  pRet->pDbFd = pDbFd;\n  pRet->readLock = -1;\n  pRet->mxWalSize = mxWalSize;\n  pRet->zWalName = zWalName;\n  pRet->syncHeader = 1;\n  pRet->padToSectorBoundary = 1;\n  pRet->exclusiveMode = (bNoShm ? WAL_HEAPMEMORY_MODE: WAL_NORMAL_MODE);\n\n  /* Open file handle on the write-ahead log file. */\n  flags = (SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|SQLITE_OPEN_WAL);\n  rc = sqlite3OsOpen(pVfs, zWalName, pRet->pWalFd, flags, &flags);\n  if( rc==SQLITE_OK && flags&SQLITE_OPEN_READONLY ){\n    pRet->readOnly = WAL_RDONLY;\n  }\n\n  if( rc!=SQLITE_OK ){\n    walIndexClose(pRet, 0);\n    sqlite3OsClose(pRet->pWalFd);\n    sqlite3_free(pRet);\n  }else{\n    int iDC = sqlite3OsDeviceCharacteristics(pDbFd);\n    if( iDC & SQLITE_IOCAP_SEQUENTIAL ){ pRet->syncHeader = 0; }\n    if( iDC & SQLITE_IOCAP_POWERSAFE_OVERWRITE ){\n      pRet->padToSectorBoundary = 0;\n    }\n    *ppWal = pRet;\n    WALTRACE((\"WAL%d: opened\\n\", pRet));\n  }\n  return rc;\n}\n\n/*\n** Change the size to which the WAL file is truncated on each reset.\n*/\nvoid sqlite3WalLimit(Wal *pWal, i64 iLimit){\n  if( pWal ) pWal->mxWalSize = iLimit;\n}\n\n/*\n** Find the smallest page number out of all pages held in the WAL that\n** has not been returned by any prior invocation of this method on the\n** same WalIterator object.   Write into *piFrame the frame index where\n** that page was last written into the WAL.  Write into *piPage the page\n** number.\n**\n** Return 0 on success.  If there are no pages in the WAL with a page\n** number larger than *piPage, then return 1.\n*/\nstatic int walIteratorNext(\n  WalIterator *p,               /* Iterator */\n  u32 *piPage,                  /* OUT: The page number of the next page */\n  u32 *piFrame                  /* OUT: Wal frame index of next page */\n){\n  u32 iMin;                     /* Result pgno must be greater than iMin */\n  u32 iRet = 0xFFFFFFFF;        /* 0xffffffff is never a valid page number */\n  int i;                        /* For looping through segments */\n\n  iMin = p->iPrior;\n  assert( iMin<0xffffffff );\n  for(i=p->nSegment-1; i>=0; i--){\n    struct WalSegment *pSegment = &p->aSegment[i];\n    while( pSegment->iNext<pSegment->nEntry ){\n      u32 iPg = pSegment->aPgno[pSegment->aIndex[pSegment->iNext]];\n      if( iPg>iMin ){\n        if( iPg<iRet ){\n          iRet = iPg;\n          *piFrame = pSegment->iZero + pSegment->aIndex[pSegment->iNext];\n        }\n        break;\n      }\n      pSegment->iNext++;\n    }\n  }\n\n  *piPage = p->iPrior = iRet;\n  return (iRet==0xFFFFFFFF);\n}\n\n/*\n** This function merges two sorted lists into a single sorted list.\n**\n** aLeft[] and aRight[] are arrays of indices.  The sort key is\n** aContent[aLeft[]] and aContent[aRight[]].  Upon entry, the following\n** is guaranteed for all J<K:\n**\n**        aContent[aLeft[J]] < aContent[aLeft[K]]\n**        aContent[aRight[J]] < aContent[aRight[K]]\n**\n** This routine overwrites aRight[] with a new (probably longer) sequence\n** of indices such that the aRight[] contains every index that appears in\n** either aLeft[] or the old aRight[] and such that the second condition\n** above is still met.\n**\n** The aContent[aLeft[X]] values will be unique for all X.  And the\n** aContent[aRight[X]] values will be unique too.  But there might be\n** one or more combinations of X and Y such that\n**\n**      aLeft[X]!=aRight[Y]  &&  aContent[aLeft[X]] == aContent[aRight[Y]]\n**\n** When that happens, omit the aLeft[X] and use the aRight[Y] index.\n*/\nstatic void walMerge(\n  const u32 *aContent,            /* Pages in wal - keys for the sort */\n  ht_slot *aLeft,                 /* IN: Left hand input list */\n  int nLeft,                      /* IN: Elements in array *paLeft */\n  ht_slot **paRight,              /* IN/OUT: Right hand input list */\n  int *pnRight,                   /* IN/OUT: Elements in *paRight */\n  ht_slot *aTmp                   /* Temporary buffer */\n){\n  int iLeft = 0;                  /* Current index in aLeft */\n  int iRight = 0;                 /* Current index in aRight */\n  int iOut = 0;                   /* Current index in output buffer */\n  int nRight = *pnRight;\n  ht_slot *aRight = *paRight;\n\n  assert( nLeft>0 && nRight>0 );\n  while( iRight<nRight || iLeft<nLeft ){\n    ht_slot logpage;\n    Pgno dbpage;\n\n    if( (iLeft<nLeft)\n     && (iRight>=nRight || aContent[aLeft[iLeft]]<aContent[aRight[iRight]])\n    ){\n      logpage = aLeft[iLeft++];\n    }else{\n      logpage = aRight[iRight++];\n    }\n    dbpage = aContent[logpage];\n\n    aTmp[iOut++] = logpage;\n    if( iLeft<nLeft && aContent[aLeft[iLeft]]==dbpage ) iLeft++;\n\n    assert( iLeft>=nLeft || aContent[aLeft[iLeft]]>dbpage );\n    assert( iRight>=nRight || aContent[aRight[iRight]]>dbpage );\n  }\n\n  *paRight = aLeft;\n  *pnRight = iOut;\n  memcpy(aLeft, aTmp, sizeof(aTmp[0])*iOut);\n}\n\n/*\n** Sort the elements in list aList using aContent[] as the sort key.\n** Remove elements with duplicate keys, preferring to keep the\n** larger aList[] values.\n**\n** The aList[] entries are indices into aContent[].  The values in\n** aList[] are to be sorted so that for all J<K:\n**\n**      aContent[aList[J]] < aContent[aList[K]]\n**\n** For any X and Y such that\n**\n**      aContent[aList[X]] == aContent[aList[Y]]\n**\n** Keep the larger of the two values aList[X] and aList[Y] and discard\n** the smaller.\n*/\nstatic void walMergesort(\n  const u32 *aContent,            /* Pages in wal */\n  ht_slot *aBuffer,               /* Buffer of at least *pnList items to use */\n  ht_slot *aList,                 /* IN/OUT: List to sort */\n  int *pnList                     /* IN/OUT: Number of elements in aList[] */\n){\n  struct Sublist {\n    int nList;                    /* Number of elements in aList */\n    ht_slot *aList;               /* Pointer to sub-list content */\n  };\n\n  const int nList = *pnList;      /* Size of input list */\n  int nMerge = 0;                 /* Number of elements in list aMerge */\n  ht_slot *aMerge = 0;            /* List to be merged */\n  int iList;                      /* Index into input list */\n  u32 iSub = 0;                   /* Index into aSub array */\n  struct Sublist aSub[13];        /* Array of sub-lists */\n\n  memset(aSub, 0, sizeof(aSub));\n  assert( nList<=HASHTABLE_NPAGE && nList>0 );\n  assert( HASHTABLE_NPAGE==(1<<(ArraySize(aSub)-1)) );\n\n  for(iList=0; iList<nList; iList++){\n    nMerge = 1;\n    aMerge = &aList[iList];\n    for(iSub=0; iList & (1<<iSub); iSub++){\n      struct Sublist *p;\n      assert( iSub<ArraySize(aSub) );\n      p = &aSub[iSub];\n      assert( p->aList && p->nList<=(1<<iSub) );\n      assert( p->aList==&aList[iList&~((2<<iSub)-1)] );\n      walMerge(aContent, p->aList, p->nList, &aMerge, &nMerge, aBuffer);\n    }\n    aSub[iSub].aList = aMerge;\n    aSub[iSub].nList = nMerge;\n  }\n\n  for(iSub++; iSub<ArraySize(aSub); iSub++){\n    if( nList & (1<<iSub) ){\n      struct Sublist *p;\n      assert( iSub<ArraySize(aSub) );\n      p = &aSub[iSub];\n      assert( p->nList<=(1<<iSub) );\n      assert( p->aList==&aList[nList&~((2<<iSub)-1)] );\n      walMerge(aContent, p->aList, p->nList, &aMerge, &nMerge, aBuffer);\n    }\n  }\n  assert( aMerge==aList );\n  *pnList = nMerge;\n\n#ifdef SQLITE_DEBUG\n  {\n    int i;\n    for(i=1; i<*pnList; i++){\n      assert( aContent[aList[i]] > aContent[aList[i-1]] );\n    }\n  }\n#endif\n}\n\n/*\n** Free an iterator allocated by walIteratorInit().\n*/\nstatic void walIteratorFree(WalIterator *p){\n  sqlite3_free(p);\n}\n\n/*\n** Construct a WalInterator object that can be used to loop over all\n** pages in the WAL following frame nBackfill in ascending order. Frames\n** nBackfill or earlier may be included - excluding them is an optimization\n** only. The caller must hold the checkpoint lock.\n**\n** On success, make *pp point to the newly allocated WalInterator object\n** return SQLITE_OK. Otherwise, return an error code. If this routine\n** returns an error, the value of *pp is undefined.\n**\n** The calling routine should invoke walIteratorFree() to destroy the\n** WalIterator object when it has finished with it.\n*/\nstatic int walIteratorInit(Wal *pWal, u32 nBackfill, WalIterator **pp){\n  WalIterator *p;                 /* Return value */\n  int nSegment;                   /* Number of segments to merge */\n  u32 iLast;                      /* Last frame in log */\n  sqlite3_int64 nByte;            /* Number of bytes to allocate */\n  int i;                          /* Iterator variable */\n  ht_slot *aTmp;                  /* Temp space used by merge-sort */\n  int rc = SQLITE_OK;             /* Return Code */\n\n  /* This routine only runs while holding the checkpoint lock. And\n  ** it only runs if there is actually content in the log (mxFrame>0).\n  */\n  assert( pWal->ckptLock && pWal->hdr.mxFrame>0 );\n  iLast = pWal->hdr.mxFrame;\n\n  /* Allocate space for the WalIterator object. */\n  nSegment = walFramePage(iLast) + 1;\n  nByte = SZ_WALITERATOR(nSegment)\n        + iLast*sizeof(ht_slot);\n  p = (WalIterator *)sqlite3_malloc64(nByte\n      + sizeof(ht_slot) * (iLast>HASHTABLE_NPAGE?HASHTABLE_NPAGE:iLast)\n  );\n  if( !p ){\n    return SQLITE_NOMEM_BKPT;\n  }\n  memset(p, 0, nByte);\n  p->nSegment = nSegment;\n  aTmp = (ht_slot*)&(((u8*)p)[nByte]);\n  SEH_FREE_ON_ERROR(0, p);\n  for(i=walFramePage(nBackfill+1); rc==SQLITE_OK && i<nSegment; i++){\n    WalHashLoc sLoc;\n\n    rc = walHashGet(pWal, i, &sLoc);\n    if( rc==SQLITE_OK ){\n      int j;                      /* Counter variable */\n      int nEntry;                 /* Number of entries in this segment */\n      ht_slot *aIndex;            /* Sorted index for this segment */\n\n      if( (i+1)==nSegment ){\n        nEntry = (int)(iLast - sLoc.iZero);\n      }else{\n        nEntry = (int)((u32*)sLoc.aHash - (u32*)sLoc.aPgno);\n      }\n      aIndex = &((ht_slot *)&p->aSegment[p->nSegment])[sLoc.iZero];\n      sLoc.iZero++;\n\n      for(j=0; j<nEntry; j++){\n        aIndex[j] = (ht_slot)j;\n      }\n      walMergesort((u32 *)sLoc.aPgno, aTmp, aIndex, &nEntry);\n      p->aSegment[i].iZero = sLoc.iZero;\n      p->aSegment[i].nEntry = nEntry;\n      p->aSegment[i].aIndex = aIndex;\n      p->aSegment[i].aPgno = (u32 *)sLoc.aPgno;\n    }\n  }\n  if( rc!=SQLITE_OK ){\n    SEH_FREE_ON_ERROR(p, 0);\n    walIteratorFree(p);\n    p = 0;\n  }\n  *pp = p;\n  return rc;\n}\n\n#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n\n\n/*\n** Attempt to enable blocking locks that block for nMs ms. Return 1 if \n** blocking locks are successfully enabled, or 0 otherwise.\n*/\nstatic int walEnableBlockingMs(Wal *pWal, int nMs){\n  int rc = sqlite3OsFileControl(\n      pWal->pDbFd, SQLITE_FCNTL_LOCK_TIMEOUT, (void*)&nMs\n  );\n  return (rc==SQLITE_OK);\n}\n\n/*\n** Attempt to enable blocking locks. Blocking locks are enabled only if (a)\n** they are supported by the VFS, and (b) the database handle is configured\n** with a busy-timeout. Return 1 if blocking locks are successfully enabled,\n** or 0 otherwise.\n*/\nstatic int walEnableBlocking(Wal *pWal){\n  int res = 0;\n  if( pWal->db ){\n    int tmout = pWal->db->setlkTimeout;\n    if( tmout ){\n      res = walEnableBlockingMs(pWal, tmout);\n    }\n  }\n  return res;\n}\n\n/*\n** Disable blocking locks.\n*/\nstatic void walDisableBlocking(Wal *pWal){\n  int tmout = 0;\n  sqlite3OsFileControl(pWal->pDbFd, SQLITE_FCNTL_LOCK_TIMEOUT, (void*)&tmout);\n}\n\n/*\n** If parameter bLock is true, attempt to enable blocking locks, take\n** the WRITER lock, and then disable blocking locks. If blocking locks\n** cannot be enabled, no attempt to obtain the WRITER lock is made. Return\n** an SQLite error code if an error occurs, or SQLITE_OK otherwise. It is not\n** an error if blocking locks can not be enabled.\n**\n** If the bLock parameter is false and the WRITER lock is held, release it.\n*/\nint sqlite3WalWriteLock(Wal *pWal, int bLock){\n  int rc = SQLITE_OK;\n  assert( pWal->readLock<0 || bLock==0 );\n  if( bLock ){\n    assert( pWal->db );\n    if( walEnableBlocking(pWal) ){\n      rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1);\n      if( rc==SQLITE_OK ){\n        pWal->writeLock = 1;\n      }\n      walDisableBlocking(pWal);\n    }\n  }else if( pWal->writeLock ){\n    walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);\n    pWal->writeLock = 0;\n  }\n  return rc;\n}\n\n/*\n** Set the database handle used to determine if blocking locks are required.\n*/\nvoid sqlite3WalDb(Wal *pWal, sqlite3 *db){\n  pWal->db = db;\n}\n\n#else\n# define walEnableBlocking(x) 0\n# define walDisableBlocking(x)\n# define walEnableBlockingMs(pWal, ms) 0\n# define sqlite3WalDb(pWal, db)\n#endif   /* ifdef SQLITE_ENABLE_SETLK_TIMEOUT */\n\n\n/*\n** Attempt to obtain the exclusive WAL lock defined by parameters lockIdx and\n** n. If the attempt fails and parameter xBusy is not NULL, then it is a\n** busy-handler function. Invoke it and retry the lock until either the\n** lock is successfully obtained or the busy-handler returns 0.\n*/\nstatic int walBusyLock(\n  Wal *pWal,                      /* WAL connection */\n  int (*xBusy)(void*),            /* Function to call when busy */\n  void *pBusyArg,                 /* Context argument for xBusyHandler */\n  int lockIdx,                    /* Offset of first byte to lock */\n  int n                           /* Number of bytes to lock */\n){\n  int rc;\n  do {\n    rc = walLockExclusive(pWal, lockIdx, n);\n  }while( xBusy && rc==SQLITE_BUSY && xBusy(pBusyArg) );\n#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n  if( rc==SQLITE_BUSY_TIMEOUT ){\n    walDisableBlocking(pWal);\n    rc = SQLITE_BUSY;\n  }\n#endif\n  return rc;\n}\n\n/*\n** The cache of the wal-index header must be valid to call this function.\n** Return the page-size in bytes used by the database.\n*/\nstatic int walPagesize(Wal *pWal){\n  return (pWal->hdr.szPage&0xfe00) + ((pWal->hdr.szPage&0x0001)<<16);\n}\n\n/*\n** The following is guaranteed when this function is called:\n**\n**   a) the WRITER lock is held,\n**   b) the entire log file has been checkpointed, and\n**   c) any existing readers are reading exclusively from the database\n**      file - there are no readers that may attempt to read a frame from\n**      the log file.\n**\n** This function updates the shared-memory structures so that the next\n** client to write to the database (which may be this one) does so by\n** writing frames into the start of the log file.\n**\n** The value of parameter salt1 is used as the aSalt[1] value in the\n** new wal-index header. It should be passed a pseudo-random value (i.e.\n** one obtained from sqlite3_randomness()).\n*/\nstatic void walRestartHdr(Wal *pWal, u32 salt1){\n  volatile WalCkptInfo *pInfo = walCkptInfo(pWal);\n  int i;                          /* Loop counter */\n  u32 *aSalt = pWal->hdr.aSalt;   /* Big-endian salt values */\n  pWal->nCkpt++;\n  pWal->hdr.mxFrame = 0;\n  sqlite3Put4byte((u8*)&aSalt[0], 1 + sqlite3Get4byte((u8*)&aSalt[0]));\n  memcpy(&pWal->hdr.aSalt[1], &salt1, 4);\n  walIndexWriteHdr(pWal);\n  AtomicStore(&pInfo->nBackfill, 0);\n  pInfo->nBackfillAttempted = 0;\n  pInfo->aReadMark[1] = 0;\n  for(i=2; i<WAL_NREADER; i++) pInfo->aReadMark[i] = READMARK_NOT_USED;\n  assert( pInfo->aReadMark[0]==0 );\n}\n\n/*\n** Copy as much content as we can from the WAL back into the database file\n** in response to an sqlite3_wal_checkpoint() request or the equivalent.\n**\n** The amount of information copies from WAL to database might be limited\n** by active readers.  This routine will never overwrite a database page\n** that a concurrent reader might be using.\n**\n** All I/O barrier operations (a.k.a fsyncs) occur in this routine when\n** SQLite is in WAL-mode in synchronous=NORMAL.  That means that if\n** checkpoints are always run by a background thread or background\n** process, foreground threads will never block on a lengthy fsync call.\n**\n** Fsync is called on the WAL before writing content out of the WAL and\n** into the database.  This ensures that if the new content is persistent\n** in the WAL and can be recovered following a power-loss or hard reset.\n**\n** Fsync is also called on the database file if (and only if) the entire\n** WAL content is copied into the database file.  This second fsync makes\n** it safe to delete the WAL since the new content will persist in the\n** database file.\n**\n** This routine uses and updates the nBackfill field of the wal-index header.\n** This is the only routine that will increase the value of nBackfill.\n** (A WAL reset or recovery will revert nBackfill to zero, but not increase\n** its value.)\n**\n** The caller must be holding sufficient locks to ensure that no other\n** checkpoint is running (in any other thread or process) at the same\n** time.\n*/\nstatic int walCheckpoint(\n  Wal *pWal,                      /* Wal connection */\n  sqlite3 *db,                    /* Check for interrupts on this handle */\n  int eMode,                      /* One of PASSIVE, FULL or RESTART */\n  int (*xBusy)(void*),            /* Function to call when busy */\n  void *pBusyArg,                 /* Context argument for xBusyHandler */\n  int sync_flags,                 /* Flags for OsSync() (or 0) */\n  u8 *zBuf                        /* Temporary buffer to use */\n){\n  int rc = SQLITE_OK;             /* Return code */\n  int szPage;                     /* Database page-size */\n  WalIterator *pIter = 0;         /* Wal iterator context */\n  u32 iDbpage = 0;                /* Next database page to write */\n  u32 iFrame = 0;                 /* Wal frame containing data for iDbpage */\n  u32 mxSafeFrame;                /* Max frame that can be backfilled */\n  u32 mxPage;                     /* Max database page to write */\n  int i;                          /* Loop counter */\n  volatile WalCkptInfo *pInfo;    /* The checkpoint status information */\n\n  szPage = walPagesize(pWal);\n  testcase( szPage<=32768 );\n  testcase( szPage>=65536 );\n  pInfo = walCkptInfo(pWal);\n  if( pInfo->nBackfill<pWal->hdr.mxFrame ){\n\n    /* EVIDENCE-OF: R-62920-47450 The busy-handler callback is never invoked\n    ** in the SQLITE_CHECKPOINT_PASSIVE mode. */\n    assert( eMode!=SQLITE_CHECKPOINT_PASSIVE || xBusy==0 );\n\n    /* Compute in mxSafeFrame the index of the last frame of the WAL that is\n    ** safe to write into the database.  Frames beyond mxSafeFrame might\n    ** overwrite database pages that are in use by active readers and thus\n    ** cannot be backfilled from the WAL.\n    */\n    mxSafeFrame = pWal->hdr.mxFrame;\n    mxPage = pWal->hdr.nPage;\n    for(i=1; i<WAL_NREADER; i++){\n      u32 y = AtomicLoad(pInfo->aReadMark+i); SEH_INJECT_FAULT;\n      if( mxSafeFrame>y ){\n        assert( y<=pWal->hdr.mxFrame );\n        rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(i), 1);\n        if( rc==SQLITE_OK ){\n          u32 iMark = (i==1 ? mxSafeFrame : READMARK_NOT_USED);\n          AtomicStore(pInfo->aReadMark+i, iMark); SEH_INJECT_FAULT;\n          walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);\n        }else if( rc==SQLITE_BUSY ){\n          mxSafeFrame = y;\n          xBusy = 0;\n        }else{\n          goto walcheckpoint_out;\n        }\n      }\n    }\n\n    /* Allocate the iterator */\n    if( pInfo->nBackfill<mxSafeFrame ){\n      rc = walIteratorInit(pWal, pInfo->nBackfill, &pIter);\n      assert( rc==SQLITE_OK || pIter==0 );\n    }\n\n    if( pIter\n     && (rc = walBusyLock(pWal,xBusy,pBusyArg,WAL_READ_LOCK(0),1))==SQLITE_OK\n    ){\n      u32 nBackfill = pInfo->nBackfill;\n      pInfo->nBackfillAttempted = mxSafeFrame; SEH_INJECT_FAULT;\n\n      /* Sync the WAL to disk */\n      rc = sqlite3OsSync(pWal->pWalFd, CKPT_SYNC_FLAGS(sync_flags));\n\n      /* If the database may grow as a result of this checkpoint, hint\n      ** about the eventual size of the db file to the VFS layer.\n      */\n      if( rc==SQLITE_OK ){\n        i64 nReq = ((i64)mxPage * szPage);\n        i64 nSize;                    /* Current size of database file */\n        sqlite3OsFileControl(pWal->pDbFd, SQLITE_FCNTL_CKPT_START, 0);\n        rc = sqlite3OsFileSize(pWal->pDbFd, &nSize);\n        if( rc==SQLITE_OK && nSize<nReq ){\n          if( (nSize+65536+(i64)pWal->hdr.mxFrame*szPage)<nReq ){\n            /* If the size of the final database is larger than the current\n            ** database plus the amount of data in the wal file, plus the\n            ** maximum size of the pending-byte page (65536 bytes), then\n            ** must be corruption somewhere.  */\n            rc = SQLITE_CORRUPT_BKPT;\n          }else{\n            sqlite3OsFileControlHint(pWal->pDbFd, SQLITE_FCNTL_SIZE_HINT,&nReq);\n          }\n        }\n\n      }\n\n      /* Iterate through the contents of the WAL, copying data to the db file */\n      while( rc==SQLITE_OK && 0==walIteratorNext(pIter, &iDbpage, &iFrame) ){\n        i64 iOffset;\n        assert( walFramePgno(pWal, iFrame)==iDbpage );\n        SEH_INJECT_FAULT;\n        if( AtomicLoad(&db->u1.isInterrupted) ){\n          rc = db->mallocFailed ? SQLITE_NOMEM_BKPT : SQLITE_INTERRUPT;\n          break;\n        }\n        if( iFrame<=nBackfill || iFrame>mxSafeFrame || iDbpage>mxPage ){\n          continue;\n        }\n        iOffset = walFrameOffset(iFrame, szPage) + WAL_FRAME_HDRSIZE;\n        /* testcase( IS_BIG_INT(iOffset) ); // requires a 4GiB WAL file */\n        rc = sqlite3OsRead(pWal->pWalFd, zBuf, szPage, iOffset);\n        if( rc!=SQLITE_OK ) break;\n        iOffset = (iDbpage-1)*(i64)szPage;\n        testcase( IS_BIG_INT(iOffset) );\n        rc = sqlite3OsWrite(pWal->pDbFd, zBuf, szPage, iOffset);\n        if( rc!=SQLITE_OK ) break;\n      }\n      sqlite3OsFileControl(pWal->pDbFd, SQLITE_FCNTL_CKPT_DONE, 0);\n\n      /* If work was actually accomplished... */\n      if( rc==SQLITE_OK ){\n        if( mxSafeFrame==walIndexHdr(pWal)->mxFrame ){\n          i64 szDb = pWal->hdr.nPage*(i64)szPage;\n          testcase( IS_BIG_INT(szDb) );\n          rc = sqlite3OsTruncate(pWal->pDbFd, szDb);\n          if( rc==SQLITE_OK ){\n            rc = sqlite3OsSync(pWal->pDbFd, CKPT_SYNC_FLAGS(sync_flags));\n          }\n        }\n        if( rc==SQLITE_OK ){\n          AtomicStore(&pInfo->nBackfill, mxSafeFrame); SEH_INJECT_FAULT;\n        }\n      }\n\n      /* Release the reader lock held while backfilling */\n      walUnlockExclusive(pWal, WAL_READ_LOCK(0), 1);\n    }\n\n    if( rc==SQLITE_BUSY ){\n      /* Reset the return code so as not to report a checkpoint failure\n      ** just because there are active readers.  */\n      rc = SQLITE_OK;\n    }\n  }\n\n  /* If this is an SQLITE_CHECKPOINT_RESTART or TRUNCATE operation, and the\n  ** entire wal file has been copied into the database file, then block\n  ** until all readers have finished using the wal file. This ensures that\n  ** the next process to write to the database restarts the wal file.\n  */\n  if( rc==SQLITE_OK && eMode!=SQLITE_CHECKPOINT_PASSIVE ){\n    assert( pWal->writeLock );\n    SEH_INJECT_FAULT;\n    if( pInfo->nBackfill<pWal->hdr.mxFrame ){\n      rc = SQLITE_BUSY;\n    }else if( eMode>=SQLITE_CHECKPOINT_RESTART ){\n      u32 salt1;\n      sqlite3_randomness(4, &salt1);\n      assert( pInfo->nBackfill==pWal->hdr.mxFrame );\n      rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(1), WAL_NREADER-1);\n      if( rc==SQLITE_OK ){\n        if( eMode==SQLITE_CHECKPOINT_TRUNCATE ){\n          /* IMPLEMENTATION-OF: R-44699-57140 This mode works the same way as\n          ** SQLITE_CHECKPOINT_RESTART with the addition that it also\n          ** truncates the log file to zero bytes just prior to a\n          ** successful return.\n          **\n          ** In theory, it might be safe to do this without updating the\n          ** wal-index header in shared memory, as all subsequent reader or\n          ** writer clients should see that the entire log file has been\n          ** checkpointed and behave accordingly. This seems unsafe though,\n          ** as it would leave the system in a state where the contents of\n          ** the wal-index header do not match the contents of the\n          ** file-system. To avoid this, update the wal-index header to\n          ** indicate that the log file contains zero valid frames.  */\n          walRestartHdr(pWal, salt1);\n          rc = sqlite3OsTruncate(pWal->pWalFd, 0);\n        }\n        walUnlockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);\n      }\n    }\n  }\n\n walcheckpoint_out:\n  SEH_FREE_ON_ERROR(pIter, 0);\n  walIteratorFree(pIter);\n  return rc;\n}\n\n/*\n** If the WAL file is currently larger than nMax bytes in size, truncate\n** it to exactly nMax bytes. If an error occurs while doing so, ignore it.\n*/\nstatic void walLimitSize(Wal *pWal, i64 nMax){\n  i64 sz;\n  int rx;\n  sqlite3BeginBenignMalloc();\n  rx = sqlite3OsFileSize(pWal->pWalFd, &sz);\n  if( rx==SQLITE_OK && (sz > nMax ) ){\n    rx = sqlite3OsTruncate(pWal->pWalFd, nMax);\n  }\n  sqlite3EndBenignMalloc();\n  if( rx ){\n    sqlite3_log(rx, \"cannot limit WAL size: %s\", pWal->zWalName);\n  }\n}\n\n#ifdef SQLITE_USE_SEH\n/*\n** This is the \"standard\" exception handler used in a few places to handle \n** an exception thrown by reading from the *-shm mapping after it has become\n** invalid in SQLITE_USE_SEH builds. It is used as follows:\n**\n**   SEH_TRY { ... }\n**   SEH_EXCEPT( rc = walHandleException(pWal); )\n**\n** This function does three things:\n**\n**   1) Determines the locks that should be held, based on the contents of\n**      the Wal.readLock, Wal.writeLock and Wal.ckptLock variables. All other\n**      held locks are assumed to be transient locks that would have been\n**      released had the exception not been thrown and are dropped.\n**\n**   2) Frees the pointer at Wal.pFree, if any, using sqlite3_free().\n**\n**   3) Set pWal->apWiData[pWal->iWiPg] to pWal->pWiValue if not NULL\n**\n**   4) Returns SQLITE_IOERR.\n*/\nstatic int walHandleException(Wal *pWal){\n  if( pWal->exclusiveMode==0 ){\n    static const int S = 1;\n    static const int E = (1<<SQLITE_SHM_NLOCK);\n    int ii;\n    u32 mUnlock;\n    if( pWal->writeLock==2 ) pWal->writeLock = 0;\n    mUnlock = pWal->lockMask & ~(\n        (pWal->readLock<0 ? 0 : (S << WAL_READ_LOCK(pWal->readLock)))\n        | (pWal->writeLock ? (E << WAL_WRITE_LOCK) : 0)\n        | (pWal->ckptLock ? (E << WAL_CKPT_LOCK) : 0)\n        );\n    for(ii=0; ii<SQLITE_SHM_NLOCK; ii++){\n      if( (S<<ii) & mUnlock ) walUnlockShared(pWal, ii);\n      if( (E<<ii) & mUnlock ) walUnlockExclusive(pWal, ii, 1);\n    }\n  }\n  sqlite3_free(pWal->pFree);\n  pWal->pFree = 0;\n  if( pWal->pWiValue ){\n    pWal->apWiData[pWal->iWiPg] = pWal->pWiValue;\n    pWal->pWiValue = 0;\n  }\n  return SQLITE_IOERR_IN_PAGE;\n}\n\n/*\n** Assert that the Wal.lockMask mask, which indicates the locks held\n** by the connection, is consistent with the Wal.readLock, Wal.writeLock\n** and Wal.ckptLock variables. To be used as:\n**\n**   assert( walAssertLockmask(pWal) );\n*/\nstatic int walAssertLockmask(Wal *pWal){\n  if( pWal->exclusiveMode==0 ){\n    static const int S = 1;\n    static const int E = (1<<SQLITE_SHM_NLOCK);\n    u32 mExpect = (\n        (pWal->readLock<0 ? 0 : (S << WAL_READ_LOCK(pWal->readLock)))\n      | (pWal->writeLock ? (E << WAL_WRITE_LOCK) : 0)\n      | (pWal->ckptLock ? (E << WAL_CKPT_LOCK) : 0)\n#ifdef SQLITE_ENABLE_SNAPSHOT\n      | (pWal->pSnapshot ? (pWal->lockMask & (1 << WAL_CKPT_LOCK)) : 0)\n#endif\n    );\n    assert( mExpect==pWal->lockMask );\n  }\n  return 1;\n}\n\n/*\n** Return and zero the \"system error\" field set when an \n** EXCEPTION_IN_PAGE_ERROR exception is caught.\n*/\nint sqlite3WalSystemErrno(Wal *pWal){\n  int iRet = 0;\n  if( pWal ){\n    iRet = pWal->iSysErrno;\n    pWal->iSysErrno = 0;\n  }\n  return iRet;\n}\n\n#else\n# define walAssertLockmask(x) 1\n#endif /* ifdef SQLITE_USE_SEH */\n\n/*\n** Close a connection to a log file.\n*/\nint sqlite3WalClose(\n  Wal *pWal,                      /* Wal to close */\n  sqlite3 *db,                    /* For interrupt flag */\n  int sync_flags,                 /* Flags to pass to OsSync() (or 0) */\n  int nBuf,\n  u8 *zBuf                        /* Buffer of at least nBuf bytes */\n){\n  int rc = SQLITE_OK;\n  if( pWal ){\n    int isDelete = 0;             /* True to unlink wal and wal-index files */\n\n    assert( walAssertLockmask(pWal) );\n\n    /* If an EXCLUSIVE lock can be obtained on the database file (using the\n    ** ordinary, rollback-mode locking methods, this guarantees that the\n    ** connection associated with this log file is the only connection to\n    ** the database. In this case checkpoint the database and unlink both\n    ** the wal and wal-index files.\n    **\n    ** The EXCLUSIVE lock is not released before returning.\n    */\n    if( zBuf!=0\n     && SQLITE_OK==(rc = sqlite3OsLock(pWal->pDbFd, SQLITE_LOCK_EXCLUSIVE))\n    ){\n      if( pWal->exclusiveMode==WAL_NORMAL_MODE ){\n        pWal->exclusiveMode = WAL_EXCLUSIVE_MODE;\n      }\n      rc = sqlite3WalCheckpoint(pWal, db,\n          SQLITE_CHECKPOINT_PASSIVE, 0, 0, sync_flags, nBuf, zBuf, 0, 0\n      );\n      if( rc==SQLITE_OK ){\n        int bPersist = -1;\n        sqlite3OsFileControlHint(\n            pWal->pDbFd, SQLITE_FCNTL_PERSIST_WAL, &bPersist\n        );\n        if( bPersist!=1 ){\n          /* Try to delete the WAL file if the checkpoint completed and\n          ** fsynced (rc==SQLITE_OK) and if we are not in persistent-wal\n          ** mode (!bPersist) */\n          isDelete = 1;\n        }else if( pWal->mxWalSize>=0 ){\n          /* Try to truncate the WAL file to zero bytes if the checkpoint\n          ** completed and fsynced (rc==SQLITE_OK) and we are in persistent\n          ** WAL mode (bPersist) and if the PRAGMA journal_size_limit is a\n          ** non-negative value (pWal->mxWalSize>=0).  Note that we truncate\n          ** to zero bytes as truncating to the journal_size_limit might\n          ** leave a corrupt WAL file on disk. */\n          walLimitSize(pWal, 0);\n        }\n      }\n    }\n\n    walIndexClose(pWal, isDelete);\n    sqlite3OsClose(pWal->pWalFd);\n    if( isDelete ){\n      sqlite3BeginBenignMalloc();\n      sqlite3OsDelete(pWal->pVfs, pWal->zWalName, 0);\n      sqlite3EndBenignMalloc();\n    }\n    WALTRACE((\"WAL%p: closed\\n\", pWal));\n    sqlite3_free((void *)pWal->apWiData);\n    sqlite3_free(pWal);\n  }\n  return rc;\n}\n\n/*\n** Try to read the wal-index header.  Return 0 on success and 1 if\n** there is a problem.\n**\n** The wal-index is in shared memory.  Another thread or process might\n** be writing the header at the same time this procedure is trying to\n** read it, which might result in inconsistency.  A dirty read is detected\n** by verifying that both copies of the header are the same and also by\n** a checksum on the header.\n**\n** If and only if the read is consistent and the header is different from\n** pWal->hdr, then pWal->hdr is updated to the content of the new header\n** and *pChanged is set to 1.\n**\n** If the checksum cannot be verified return non-zero. If the header\n** is read successfully and the checksum verified, return zero.\n*/\nstatic SQLITE_NO_TSAN int walIndexTryHdr(Wal *pWal, int *pChanged){\n  u32 aCksum[2];                  /* Checksum on the header content */\n  WalIndexHdr h1, h2;             /* Two copies of the header content */\n  WalIndexHdr volatile *aHdr;     /* Header in shared memory */\n\n  /* The first page of the wal-index must be mapped at this point. */\n  assert( pWal->nWiData>0 && pWal->apWiData[0] );\n\n  /* Read the header. This might happen concurrently with a write to the\n  ** same area of shared memory on a different CPU in a SMP,\n  ** meaning it is possible that an inconsistent snapshot is read\n  ** from the file. If this happens, return non-zero.\n  **\n  ** tag-20200519-1:\n  ** There are two copies of the header at the beginning of the wal-index.\n  ** When reading, read [0] first then [1].  Writes are in the reverse order.\n  ** Memory barriers are used to prevent the compiler or the hardware from\n  ** reordering the reads and writes.  TSAN and similar tools can sometimes\n  ** give false-positive warnings about these accesses because the tools do not\n  ** account for the double-read and the memory barrier. The use of mutexes\n  ** here would be problematic as the memory being accessed is potentially\n  ** shared among multiple processes and not all mutex implementations work\n  ** reliably in that environment.\n  */\n  aHdr = walIndexHdr(pWal);\n  memcpy(&h1, (void *)&aHdr[0], sizeof(h1)); /* Possible TSAN false-positive */\n  walShmBarrier(pWal);\n  memcpy(&h2, (void *)&aHdr[1], sizeof(h2));\n\n  if( memcmp(&h1, &h2, sizeof(h1))!=0 ){\n    return 1;   /* Dirty read */\n  }\n  if( h1.isInit==0 ){\n    return 1;   /* Malformed header - probably all zeros */\n  }\n  walChecksumBytes(1, (u8*)&h1, sizeof(h1)-sizeof(h1.aCksum), 0, aCksum);\n  if( aCksum[0]!=h1.aCksum[0] || aCksum[1]!=h1.aCksum[1] ){\n    return 1;   /* Checksum does not match */\n  }\n\n  if( memcmp(&pWal->hdr, &h1, sizeof(WalIndexHdr)) ){\n    *pChanged = 1;\n    memcpy(&pWal->hdr, &h1, sizeof(WalIndexHdr));\n    pWal->szPage = (pWal->hdr.szPage&0xfe00) + ((pWal->hdr.szPage&0x0001)<<16);\n    testcase( pWal->szPage<=32768 );\n    testcase( pWal->szPage>=65536 );\n  }\n\n  /* The header was successfully read. Return zero. */\n  return 0;\n}\n\n/*\n** This is the value that walTryBeginRead returns when it needs to\n** be retried.\n*/\n#define WAL_RETRY  (-1)\n\n/*\n** Read the wal-index header from the wal-index and into pWal->hdr.\n** If the wal-header appears to be corrupt, try to reconstruct the\n** wal-index from the WAL before returning.\n**\n** Set *pChanged to 1 if the wal-index header value in pWal->hdr is\n** changed by this operation.  If pWal->hdr is unchanged, set *pChanged\n** to 0.\n**\n** If the wal-index header is successfully read, return SQLITE_OK.\n** Otherwise an SQLite error code.\n*/\nstatic int walIndexReadHdr(Wal *pWal, int *pChanged){\n  int rc;                         /* Return code */\n  int badHdr;                     /* True if a header read failed */\n  volatile u32 *page0;            /* Chunk of wal-index containing header */\n\n  /* Ensure that page 0 of the wal-index (the page that contains the\n  ** wal-index header) is mapped. Return early if an error occurs here.\n  */\n  assert( pChanged );\n  rc = walIndexPage(pWal, 0, &page0);\n  if( rc!=SQLITE_OK ){\n    assert( rc!=SQLITE_READONLY ); /* READONLY changed to OK in walIndexPage */\n    if( rc==SQLITE_READONLY_CANTINIT ){\n      /* The SQLITE_READONLY_CANTINIT return means that the shared-memory\n      ** was openable but is not writable, and this thread is unable to\n      ** confirm that another write-capable connection has the shared-memory\n      ** open, and hence the content of the shared-memory is unreliable,\n      ** since the shared-memory might be inconsistent with the WAL file\n      ** and there is no writer on hand to fix it. */\n      assert( page0==0 );\n      assert( pWal->writeLock==0 );\n      assert( pWal->readOnly & WAL_SHM_RDONLY );\n      pWal->bShmUnreliable = 1;\n      pWal->exclusiveMode = WAL_HEAPMEMORY_MODE;\n      *pChanged = 1;\n    }else{\n      return rc; /* Any other non-OK return is just an error */\n    }\n  }else{\n    /* page0 can be NULL if the SHM is zero bytes in size and pWal->writeLock\n    ** is zero, which prevents the SHM from growing */\n    testcase( page0!=0 );\n  }\n  assert( page0!=0 || pWal->writeLock==0 );\n\n  /* If the first page of the wal-index has been mapped, try to read the\n  ** wal-index header immediately, without holding any lock. This usually\n  ** works, but may fail if the wal-index header is corrupt or currently\n  ** being modified by another thread or process.\n  */\n  badHdr = (page0 ? walIndexTryHdr(pWal, pChanged) : 1);\n\n  /* If the first attempt failed, it might have been due to a race\n  ** with a writer.  So get a WRITE lock and try again.\n  */\n  if( badHdr ){\n    if( pWal->bShmUnreliable==0 && (pWal->readOnly & WAL_SHM_RDONLY) ){\n      if( SQLITE_OK==(rc = walLockShared(pWal, WAL_WRITE_LOCK)) ){\n        walUnlockShared(pWal, WAL_WRITE_LOCK);\n        rc = SQLITE_READONLY_RECOVERY;\n      }\n    }else{\n      int bWriteLock = pWal->writeLock;\n      if( bWriteLock \n       || SQLITE_OK==(rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1)) \n      ){\n        /* If the write-lock was just obtained, set writeLock to 2 instead of\n        ** the usual 1. This causes walIndexPage() to behave as if the \n        ** write-lock were held (so that it allocates new pages as required),\n        ** and walHandleException() to unlock the write-lock if a SEH exception\n        ** is thrown.  */\n        if( !bWriteLock ) pWal->writeLock = 2;\n        if( SQLITE_OK==(rc = walIndexPage(pWal, 0, &page0)) ){\n          badHdr = walIndexTryHdr(pWal, pChanged);\n          if( badHdr ){\n            /* If the wal-index header is still malformed even while holding\n            ** a WRITE lock, it can only mean that the header is corrupted and\n            ** needs to be reconstructed.  So run recovery to do exactly that.\n            ** Disable blocking locks first.  */\n            walDisableBlocking(pWal);\n            rc = walIndexRecover(pWal);\n            *pChanged = 1;\n          }\n        }\n        if( bWriteLock==0 ){\n          pWal->writeLock = 0;\n          walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);\n        }\n      }\n    }\n  }\n\n  /* If the header is read successfully, check the version number to make\n  ** sure the wal-index was not constructed with some future format that\n  ** this version of SQLite cannot understand.\n  */\n  if( badHdr==0 && pWal->hdr.iVersion!=WALINDEX_MAX_VERSION ){\n    rc = SQLITE_CANTOPEN_BKPT;\n  }\n  if( pWal->bShmUnreliable ){\n    if( rc!=SQLITE_OK ){\n      walIndexClose(pWal, 0);\n      pWal->bShmUnreliable = 0;\n      assert( pWal->nWiData>0 && pWal->apWiData[0]==0 );\n      /* walIndexRecover() might have returned SHORT_READ if a concurrent\n      ** writer truncated the WAL out from under it.  If that happens, it\n      ** indicates that a writer has fixed the SHM file for us, so retry */\n      if( rc==SQLITE_IOERR_SHORT_READ ) rc = WAL_RETRY;\n    }\n    pWal->exclusiveMode = WAL_NORMAL_MODE;\n  }\n\n  return rc;\n}\n\n/*\n** Open a transaction in a connection where the shared-memory is read-only\n** and where we cannot verify that there is a separate write-capable connection\n** on hand to keep the shared-memory up-to-date with the WAL file.\n**\n** This can happen, for example, when the shared-memory is implemented by\n** memory-mapping a *-shm file, where a prior writer has shut down and\n** left the *-shm file on disk, and now the present connection is trying\n** to use that database but lacks write permission on the *-shm file.\n** Other scenarios are also possible, depending on the VFS implementation.\n**\n** Precondition:\n**\n**    The *-wal file has been read and an appropriate wal-index has been\n**    constructed in pWal->apWiData[] using heap memory instead of shared\n**    memory.\n**\n** If this function returns SQLITE_OK, then the read transaction has\n** been successfully opened. In this case output variable (*pChanged)\n** is set to true before returning if the caller should discard the\n** contents of the page cache before proceeding. Or, if it returns\n** WAL_RETRY, then the heap memory wal-index has been discarded and\n** the caller should retry opening the read transaction from the\n** beginning (including attempting to map the *-shm file).\n**\n** If an error occurs, an SQLite error code is returned.\n*/\nstatic int walBeginShmUnreliable(Wal *pWal, int *pChanged){\n  i64 szWal;                      /* Size of wal file on disk in bytes */\n  i64 iOffset;                    /* Current offset when reading wal file */\n  u8 aBuf[WAL_HDRSIZE];           /* Buffer to load WAL header into */\n  u8 *aFrame = 0;                 /* Malloc'd buffer to load entire frame */\n  int szFrame;                    /* Number of bytes in buffer aFrame[] */\n  u8 *aData;                      /* Pointer to data part of aFrame buffer */\n  volatile void *pDummy;          /* Dummy argument for xShmMap */\n  int rc;                         /* Return code */\n  u32 aSaveCksum[2];              /* Saved copy of pWal->hdr.aFrameCksum */\n\n  assert( pWal->bShmUnreliable );\n  assert( pWal->readOnly & WAL_SHM_RDONLY );\n  assert( pWal->nWiData>0 && pWal->apWiData[0] );\n\n  /* Take WAL_READ_LOCK(0). This has the effect of preventing any\n  ** writers from running a checkpoint, but does not stop them\n  ** from running recovery.  */\n  rc = walLockShared(pWal, WAL_READ_LOCK(0));\n  if( rc!=SQLITE_OK ){\n    if( rc==SQLITE_BUSY ) rc = WAL_RETRY;\n    goto begin_unreliable_shm_out;\n  }\n  pWal->readLock = 0;\n\n  /* Check to see if a separate writer has attached to the shared-memory area,\n  ** thus making the shared-memory \"reliable\" again.  Do this by invoking\n  ** the xShmMap() routine of the VFS and looking to see if the return\n  ** is SQLITE_READONLY instead of SQLITE_READONLY_CANTINIT.\n  **\n  ** If the shared-memory is now \"reliable\" return WAL_RETRY, which will\n  ** cause the heap-memory WAL-index to be discarded and the actual\n  ** shared memory to be used in its place.\n  **\n  ** This step is important because, even though this connection is holding\n  ** the WAL_READ_LOCK(0) which prevents a checkpoint, a writer might\n  ** have already checkpointed the WAL file and, while the current\n  ** is active, wrap the WAL and start overwriting frames that this\n  ** process wants to use.\n  **\n  ** Once sqlite3OsShmMap() has been called for an sqlite3_file and has\n  ** returned any SQLITE_READONLY value, it must return only SQLITE_READONLY\n  ** or SQLITE_READONLY_CANTINIT or some error for all subsequent invocations,\n  ** even if some external agent does a \"chmod\" to make the shared-memory\n  ** writable by us, until sqlite3OsShmUnmap() has been called.\n  ** This is a requirement on the VFS implementation.\n   */\n  rc = sqlite3OsShmMap(pWal->pDbFd, 0, WALINDEX_PGSZ, 0, &pDummy);\n  assert( rc!=SQLITE_OK ); /* SQLITE_OK not possible for read-only connection */\n  if( rc!=SQLITE_READONLY_CANTINIT ){\n    rc = (rc==SQLITE_READONLY ? WAL_RETRY : rc);\n    goto begin_unreliable_shm_out;\n  }\n\n  /* We reach this point only if the real shared-memory is still unreliable.\n  ** Assume the in-memory WAL-index substitute is correct and load it\n  ** into pWal->hdr.\n  */\n  memcpy(&pWal->hdr, (void*)walIndexHdr(pWal), sizeof(WalIndexHdr));\n\n  /* Make sure some writer hasn't come in and changed the WAL file out\n  ** from under us, then disconnected, while we were not looking.\n  */\n  rc = sqlite3OsFileSize(pWal->pWalFd, &szWal);\n  if( rc!=SQLITE_OK ){\n    goto begin_unreliable_shm_out;\n  }\n  if( szWal<WAL_HDRSIZE ){\n    /* If the wal file is too small to contain a wal-header and the\n    ** wal-index header has mxFrame==0, then it must be safe to proceed\n    ** reading the database file only. However, the page cache cannot\n    ** be trusted, as a read/write connection may have connected, written\n    ** the db, run a checkpoint, truncated the wal file and disconnected\n    ** since this client's last read transaction.  */\n    *pChanged = 1;\n    rc = (pWal->hdr.mxFrame==0 ? SQLITE_OK : WAL_RETRY);\n    goto begin_unreliable_shm_out;\n  }\n\n  /* Check the salt keys at the start of the wal file still match. */\n  rc = sqlite3OsRead(pWal->pWalFd, aBuf, WAL_HDRSIZE, 0);\n  if( rc!=SQLITE_OK ){\n    goto begin_unreliable_shm_out;\n  }\n  if( memcmp(&pWal->hdr.aSalt, &aBuf[16], 8) ){\n    /* Some writer has wrapped the WAL file while we were not looking.\n    ** Return WAL_RETRY which will cause the in-memory WAL-index to be\n    ** rebuilt. */\n    rc = WAL_RETRY;\n    goto begin_unreliable_shm_out;\n  }\n\n  /* Allocate a buffer to read frames into */\n  assert( (pWal->szPage & (pWal->szPage-1))==0 );\n  assert( pWal->szPage>=512 && pWal->szPage<=65536 );\n  szFrame = pWal->szPage + WAL_FRAME_HDRSIZE;\n  aFrame = (u8 *)sqlite3_malloc64(szFrame);\n  if( aFrame==0 ){\n    rc = SQLITE_NOMEM_BKPT;\n    goto begin_unreliable_shm_out;\n  }\n  aData = &aFrame[WAL_FRAME_HDRSIZE];\n\n  /* Check to see if a complete transaction has been appended to the\n  ** wal file since the heap-memory wal-index was created. If so, the\n  ** heap-memory wal-index is discarded and WAL_RETRY returned to\n  ** the caller.  */\n  aSaveCksum[0] = pWal->hdr.aFrameCksum[0];\n  aSaveCksum[1] = pWal->hdr.aFrameCksum[1];\n  for(iOffset=walFrameOffset(pWal->hdr.mxFrame+1, pWal->szPage);\n      iOffset+szFrame<=szWal;\n      iOffset+=szFrame\n  ){\n    u32 pgno;                   /* Database page number for frame */\n    u32 nTruncate;              /* dbsize field from frame header */\n\n    /* Read and decode the next log frame. */\n    rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);\n    if( rc!=SQLITE_OK ) break;\n    if( !walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame) ) break;\n\n    /* If nTruncate is non-zero, then a complete transaction has been\n    ** appended to this wal file. Set rc to WAL_RETRY and break out of\n    ** the loop.  */\n    if( nTruncate ){\n      rc = WAL_RETRY;\n      break;\n    }\n  }\n  pWal->hdr.aFrameCksum[0] = aSaveCksum[0];\n  pWal->hdr.aFrameCksum[1] = aSaveCksum[1];\n\n begin_unreliable_shm_out:\n  sqlite3_free(aFrame);\n  if( rc!=SQLITE_OK ){\n    int i;\n    for(i=0; i<pWal->nWiData; i++){\n      sqlite3_free((void*)pWal->apWiData[i]);\n      pWal->apWiData[i] = 0;\n    }\n    pWal->bShmUnreliable = 0;\n    sqlite3WalEndReadTransaction(pWal);\n    *pChanged = 1;\n  }\n  return rc;\n}\n\n/*\n** The final argument passed to walTryBeginRead() is of type (int*). The\n** caller should invoke walTryBeginRead as follows:\n**\n**   int cnt = 0;\n**   do {\n**     rc = walTryBeginRead(..., &cnt);\n**   }while( rc==WAL_RETRY );\n**\n** The final value of \"cnt\" is of no use to the caller. It is used by\n** the implementation of walTryBeginRead() as follows:\n**\n**   + Each time walTryBeginRead() is called, it is incremented. Once\n**     it reaches WAL_RETRY_PROTOCOL_LIMIT - indicating that walTryBeginRead()\n**     has many times been invoked and failed with WAL_RETRY - walTryBeginRead()\n**     returns SQLITE_PROTOCOL.\n**\n**   + If SQLITE_ENABLE_SETLK_TIMEOUT is defined and walTryBeginRead() failed\n**     because a blocking lock timed out (SQLITE_BUSY_TIMEOUT from the OS\n**     layer), the WAL_RETRY_BLOCKED_MASK bit is set in \"cnt\". In this case\n**     the next invocation of walTryBeginRead() may omit an expected call to \n**     sqlite3OsSleep(). There has already been a delay when the previous call\n**     waited on a lock.\n*/\n#define WAL_RETRY_PROTOCOL_LIMIT 100\n#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n# define WAL_RETRY_BLOCKED_MASK    0x10000000\n#else\n# define WAL_RETRY_BLOCKED_MASK    0\n#endif\n\n/*\n** Attempt to start a read transaction.  This might fail due to a race or\n** other transient condition.  When that happens, it returns WAL_RETRY to\n** indicate to the caller that it is safe to retry immediately.\n**\n** On success return SQLITE_OK.  On a permanent failure (such an\n** I/O error or an SQLITE_BUSY because another process is running\n** recovery) return a positive error code.\n**\n** The useWal parameter is true to force the use of the WAL and disable\n** the case where the WAL is bypassed because it has been completely\n** checkpointed.  If useWal==0 then this routine calls walIndexReadHdr()\n** to make a copy of the wal-index header into pWal->hdr.  If the\n** wal-index header has changed, *pChanged is set to 1 (as an indication\n** to the caller that the local page cache is obsolete and needs to be\n** flushed.)  When useWal==1, the wal-index header is assumed to already\n** be loaded and the pChanged parameter is unused.\n**\n** The caller must set the cnt parameter to the number of prior calls to\n** this routine during the current read attempt that returned WAL_RETRY.\n** This routine will start taking more aggressive measures to clear the\n** race conditions after multiple WAL_RETRY returns, and after an excessive\n** number of errors will ultimately return SQLITE_PROTOCOL.  The\n** SQLITE_PROTOCOL return indicates that some other process has gone rogue\n** and is not honoring the locking protocol.  There is a vanishingly small\n** chance that SQLITE_PROTOCOL could be returned because of a run of really\n** bad luck when there is lots of contention for the wal-index, but that\n** possibility is so small that it can be safely neglected, we believe.\n**\n** On success, this routine obtains a read lock on\n** WAL_READ_LOCK(pWal->readLock).  The pWal->readLock integer is\n** in the range 0 <= pWal->readLock < WAL_NREADER.  If pWal->readLock==(-1)\n** that means the Wal does not hold any read lock.  The reader must not\n** access any database page that is modified by a WAL frame up to and\n** including frame number aReadMark[pWal->readLock].  The reader will\n** use WAL frames up to and including pWal->hdr.mxFrame if pWal->readLock>0\n** Or if pWal->readLock==0, then the reader will ignore the WAL\n** completely and get all content directly from the database file.\n** If the useWal parameter is 1 then the WAL will never be ignored and\n** this routine will always set pWal->readLock>0 on success.\n** When the read transaction is completed, the caller must release the\n** lock on WAL_READ_LOCK(pWal->readLock) and set pWal->readLock to -1.\n**\n** This routine uses the nBackfill and aReadMark[] fields of the header\n** to select a particular WAL_READ_LOCK() that strives to let the\n** checkpoint process do as much work as possible.  This routine might\n** update values of the aReadMark[] array in the header, but if it does\n** so it takes care to hold an exclusive lock on the corresponding\n** WAL_READ_LOCK() while changing values.\n*/\nstatic int walTryBeginRead(Wal *pWal, int *pChanged, int useWal, int *pCnt){\n  volatile WalCkptInfo *pInfo;    /* Checkpoint information in wal-index */\n  int rc = SQLITE_OK;             /* Return code  */\n#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n  int nBlockTmout = 0;\n#endif\n\n  assert( pWal->readLock<0 );     /* Not currently locked */\n\n  /* useWal may only be set for read/write connections */\n  assert( (pWal->readOnly & WAL_SHM_RDONLY)==0 || useWal==0 );\n\n  /* Take steps to avoid spinning forever if there is a protocol error.\n  **\n  ** Circumstances that cause a RETRY should only last for the briefest\n  ** instances of time.  No I/O or other system calls are done while the\n  ** locks are held, so the locks should not be held for very long. But\n  ** if we are unlucky, another process that is holding a lock might get\n  ** paged out or take a page-fault that is time-consuming to resolve,\n  ** during the few nanoseconds that it is holding the lock.  In that case,\n  ** it might take longer than normal for the lock to free.\n  **\n  ** After 5 RETRYs, we begin calling sqlite3OsSleep().  The first few\n  ** calls to sqlite3OsSleep() have a delay of 1 microsecond.  Really this\n  ** is more of a scheduler yield than an actual delay.  But on the 10th\n  ** an subsequent retries, the delays start becoming longer and longer,\n  ** so that on the 100th (and last) RETRY we delay for 323 milliseconds.\n  ** The total delay time before giving up is less than 10 seconds.\n  */\n  (*pCnt)++;\n  if( *pCnt>5 ){\n    int nDelay = 1;                      /* Pause time in microseconds */\n    int cnt = (*pCnt & ~WAL_RETRY_BLOCKED_MASK);\n    if( cnt>WAL_RETRY_PROTOCOL_LIMIT ){\n      VVA_ONLY( pWal->lockError = 1; )\n      return SQLITE_PROTOCOL;\n    }\n    if( *pCnt>=10 ) nDelay = (cnt-9)*(cnt-9)*39;\n#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n    /* In SQLITE_ENABLE_SETLK_TIMEOUT builds, configure the file-descriptor\n    ** to block for locks for approximately nDelay us. This affects three\n    ** locks: (a) the shared lock taken on the DMS slot in os_unix.c (if\n    ** using os_unix.c), (b) the WRITER lock taken in walIndexReadHdr() if the\n    ** first attempted read fails, and (c) the shared lock taken on the \n    ** read-mark.  \n    **\n    ** If the previous call failed due to an SQLITE_BUSY_TIMEOUT error,\n    ** then sleep for the minimum of 1us. The previous call already provided \n    ** an extra delay while it was blocking on the lock.\n    */\n    nBlockTmout = (nDelay+998) / 1000;\n    if( !useWal && walEnableBlockingMs(pWal, nBlockTmout) ){\n      if( *pCnt & WAL_RETRY_BLOCKED_MASK ) nDelay = 1;\n    }\n#endif\n    sqlite3OsSleep(pWal->pVfs, nDelay);\n    *pCnt &= ~WAL_RETRY_BLOCKED_MASK;\n  }\n\n  if( !useWal ){\n    assert( rc==SQLITE_OK );\n    if( pWal->bShmUnreliable==0 ){\n      rc = walIndexReadHdr(pWal, pChanged);\n    }\n#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n    if( rc==SQLITE_BUSY_TIMEOUT ){\n      rc = SQLITE_BUSY;\n      *pCnt |= WAL_RETRY_BLOCKED_MASK;\n    }\n#endif\n    if( rc==SQLITE_BUSY ){\n      /* If there is not a recovery running in another thread or process\n      ** then convert BUSY errors to WAL_RETRY.  If recovery is known to\n      ** be running, convert BUSY to BUSY_RECOVERY.  There is a race here\n      ** which might cause WAL_RETRY to be returned even if BUSY_RECOVERY\n      ** would be technically correct.  But the race is benign since with\n      ** WAL_RETRY this routine will be called again and will probably be\n      ** right on the second iteration.\n      */\n      (void)walEnableBlocking(pWal);\n      if( pWal->apWiData[0]==0 ){\n        /* This branch is taken when the xShmMap() method returns SQLITE_BUSY.\n        ** We assume this is a transient condition, so return WAL_RETRY. The\n        ** xShmMap() implementation used by the default unix and win32 VFS\n        ** modules may return SQLITE_BUSY due to a race condition in the\n        ** code that determines whether or not the shared-memory region\n        ** must be zeroed before the requested page is returned.\n        */\n        rc = WAL_RETRY;\n      }else if( SQLITE_OK==(rc = walLockShared(pWal, WAL_RECOVER_LOCK)) ){\n        walUnlockShared(pWal, WAL_RECOVER_LOCK);\n        rc = WAL_RETRY;\n      }else if( rc==SQLITE_BUSY ){\n        rc = SQLITE_BUSY_RECOVERY;\n      }\n    }\n    walDisableBlocking(pWal);\n    if( rc!=SQLITE_OK ){\n      return rc;\n    }\n    else if( pWal->bShmUnreliable ){\n      return walBeginShmUnreliable(pWal, pChanged);\n    }\n  }\n\n  assert( pWal->nWiData>0 );\n  assert( pWal->apWiData[0]!=0 );\n  pInfo = walCkptInfo(pWal);\n  SEH_INJECT_FAULT;\n  {\n    u32 mxReadMark;               /* Largest aReadMark[] value */\n    int mxI;                      /* Index of largest aReadMark[] value */\n    int i;                        /* Loop counter */\n    u32 mxFrame;                  /* Wal frame to lock to */\n    if( !useWal && AtomicLoad(&pInfo->nBackfill)==pWal->hdr.mxFrame\n#ifdef SQLITE_ENABLE_SNAPSHOT\n     && ((pWal->bGetSnapshot==0 && pWal->pSnapshot==0) || pWal->hdr.mxFrame==0)\n#endif\n    ){\n      /* The WAL has been completely backfilled (or it is empty).\n      ** and can be safely ignored.\n      */\n      rc = walLockShared(pWal, WAL_READ_LOCK(0));\n      walShmBarrier(pWal);\n      if( rc==SQLITE_OK ){\n        if( memcmp((void *)walIndexHdr(pWal), &pWal->hdr,sizeof(WalIndexHdr)) ){\n          /* It is not safe to allow the reader to continue here if frames\n          ** may have been appended to the log before READ_LOCK(0) was obtained.\n          ** When holding READ_LOCK(0), the reader ignores the entire log file,\n          ** which implies that the database file contains a trustworthy\n          ** snapshot. Since holding READ_LOCK(0) prevents a checkpoint from\n          ** happening, this is usually correct.\n          **\n          ** However, if frames have been appended to the log (or if the log\n          ** is wrapped and written for that matter) before the READ_LOCK(0)\n          ** is obtained, that is not necessarily true. A checkpointer may\n          ** have started to backfill the appended frames but crashed before\n          ** it finished. Leaving a corrupt image in the database file.\n          */\n          walUnlockShared(pWal, WAL_READ_LOCK(0));\n          return WAL_RETRY;\n        }\n        pWal->readLock = 0;\n        return SQLITE_OK;\n      }else if( rc!=SQLITE_BUSY ){\n        return rc;\n      }\n    }\n  \n    /* If we get this far, it means that the reader will want to use\n    ** the WAL to get at content from recent commits.  The job now is\n    ** to select one of the aReadMark[] entries that is closest to\n    ** but not exceeding pWal->hdr.mxFrame and lock that entry.\n    */\n    mxReadMark = 0;\n    mxI = 0;\n    mxFrame = pWal->hdr.mxFrame;\n#ifdef SQLITE_ENABLE_SNAPSHOT\n    if( pWal->pSnapshot && pWal->pSnapshot->mxFrame<mxFrame ){\n      mxFrame = pWal->pSnapshot->mxFrame;\n    }\n#endif\n    for(i=1; i<WAL_NREADER; i++){\n      u32 thisMark = AtomicLoad(pInfo->aReadMark+i); SEH_INJECT_FAULT;\n      if( mxReadMark<=thisMark && thisMark<=mxFrame ){\n        assert( thisMark!=READMARK_NOT_USED );\n        mxReadMark = thisMark;\n        mxI = i;\n      }\n    }\n    if( (pWal->readOnly & WAL_SHM_RDONLY)==0\n     && (mxReadMark<mxFrame || mxI==0)\n    ){\n      for(i=1; i<WAL_NREADER; i++){\n        rc = walLockExclusive(pWal, WAL_READ_LOCK(i), 1);\n        if( rc==SQLITE_OK ){\n          AtomicStore(pInfo->aReadMark+i,mxFrame);\n          mxReadMark = mxFrame;\n          mxI = i;\n          walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);\n          break;\n        }else if( rc!=SQLITE_BUSY ){\n          return rc;\n        }\n      }\n    }\n    if( mxI==0 ){\n      assert( rc==SQLITE_BUSY || (pWal->readOnly & WAL_SHM_RDONLY)!=0 );\n      return rc==SQLITE_BUSY ? WAL_RETRY : SQLITE_READONLY_CANTINIT;\n    }\n  \n    (void)walEnableBlockingMs(pWal, nBlockTmout);\n    rc = walLockShared(pWal, WAL_READ_LOCK(mxI));\n    walDisableBlocking(pWal);\n    if( rc ){\n#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n      if( rc==SQLITE_BUSY_TIMEOUT ){\n        *pCnt |= WAL_RETRY_BLOCKED_MASK;\n      }\n#else\n      assert( rc!=SQLITE_BUSY_TIMEOUT );\n#endif\n      assert((rc&0xFF)!=SQLITE_BUSY||rc==SQLITE_BUSY||rc==SQLITE_BUSY_TIMEOUT);\n      return (rc&0xFF)==SQLITE_BUSY ? WAL_RETRY : rc;\n    }\n    /* Now that the read-lock has been obtained, check that neither the\n    ** value in the aReadMark[] array or the contents of the wal-index\n    ** header have changed.\n    **\n    ** It is necessary to check that the wal-index header did not change\n    ** between the time it was read and when the shared-lock was obtained\n    ** on WAL_READ_LOCK(mxI) was obtained to account for the possibility\n    ** that the log file may have been wrapped by a writer, or that frames\n    ** that occur later in the log than pWal->hdr.mxFrame may have been\n    ** copied into the database by a checkpointer. If either of these things\n    ** happened, then reading the database with the current value of\n    ** pWal->hdr.mxFrame risks reading a corrupted snapshot. So, retry\n    ** instead.\n    **\n    ** Before checking that the live wal-index header has not changed\n    ** since it was read, set Wal.minFrame to the first frame in the wal\n    ** file that has not yet been checkpointed. This client will not need\n    ** to read any frames earlier than minFrame from the wal file - they\n    ** can be safely read directly from the database file.\n    **\n    ** Because a ShmBarrier() call is made between taking the copy of\n    ** nBackfill and checking that the wal-header in shared-memory still\n    ** matches the one cached in pWal->hdr, it is guaranteed that the\n    ** checkpointer that set nBackfill was not working with a wal-index\n    ** header newer than that cached in pWal->hdr. If it were, that could\n    ** cause a problem. The checkpointer could omit to checkpoint\n    ** a version of page X that lies before pWal->minFrame (call that version\n    ** A) on the basis that there is a newer version (version B) of the same\n    ** page later in the wal file. But if version B happens to like past\n    ** frame pWal->hdr.mxFrame - then the client would incorrectly assume\n    ** that it can read version A from the database file. However, since\n    ** we can guarantee that the checkpointer that set nBackfill could not\n    ** see any pages past pWal->hdr.mxFrame, this problem does not come up.\n    */\n    pWal->minFrame = AtomicLoad(&pInfo->nBackfill)+1; SEH_INJECT_FAULT;\n    walShmBarrier(pWal);\n    if( AtomicLoad(pInfo->aReadMark+mxI)!=mxReadMark\n     || memcmp((void *)walIndexHdr(pWal), &pWal->hdr, sizeof(WalIndexHdr))\n    ){\n      walUnlockShared(pWal, WAL_READ_LOCK(mxI));\n      return WAL_RETRY;\n    }else{\n      assert( mxReadMark<=pWal->hdr.mxFrame );\n      pWal->readLock = (i16)mxI;\n    }\n  }\n  return rc;\n}\n\n#ifdef SQLITE_ENABLE_SNAPSHOT\n/*\n** This function does the work of sqlite3WalSnapshotRecover().\n*/\nstatic int walSnapshotRecover(\n  Wal *pWal,                      /* WAL handle */\n  void *pBuf1,                    /* Temp buffer pWal->szPage bytes in size */\n  void *pBuf2                     /* Temp buffer pWal->szPage bytes in size */\n){\n  int szPage = (int)pWal->szPage;\n  int rc;\n  i64 szDb;                       /* Size of db file in bytes */\n\n  rc = sqlite3OsFileSize(pWal->pDbFd, &szDb);\n  if( rc==SQLITE_OK ){\n    volatile WalCkptInfo *pInfo = walCkptInfo(pWal);\n    u32 i = pInfo->nBackfillAttempted;\n    for(i=pInfo->nBackfillAttempted; i>AtomicLoad(&pInfo->nBackfill); i--){\n      WalHashLoc sLoc;          /* Hash table location */\n      u32 pgno;                 /* Page number in db file */\n      i64 iDbOff;               /* Offset of db file entry */\n      i64 iWalOff;              /* Offset of wal file entry */\n\n      rc = walHashGet(pWal, walFramePage(i), &sLoc);\n      if( rc!=SQLITE_OK ) break;\n      assert( i - sLoc.iZero - 1 >=0 );\n      pgno = sLoc.aPgno[i-sLoc.iZero-1];\n      iDbOff = (i64)(pgno-1) * szPage;\n\n      if( iDbOff+szPage<=szDb ){\n        iWalOff = walFrameOffset(i, szPage) + WAL_FRAME_HDRSIZE;\n        rc = sqlite3OsRead(pWal->pWalFd, pBuf1, szPage, iWalOff);\n\n        if( rc==SQLITE_OK ){\n          rc = sqlite3OsRead(pWal->pDbFd, pBuf2, szPage, iDbOff);\n        }\n\n        if( rc!=SQLITE_OK || 0==memcmp(pBuf1, pBuf2, szPage) ){\n          break;\n        }\n      }\n\n      pInfo->nBackfillAttempted = i-1;\n    }\n  }\n\n  return rc;\n}\n\n/*\n** Attempt to reduce the value of the WalCkptInfo.nBackfillAttempted\n** variable so that older snapshots can be accessed. To do this, loop\n** through all wal frames from nBackfillAttempted to (nBackfill+1),\n** comparing their content to the corresponding page with the database\n** file, if any. Set nBackfillAttempted to the frame number of the\n** first frame for which the wal file content matches the db file.\n**\n** This is only really safe if the file-system is such that any page\n** writes made by earlier checkpointers were atomic operations, which\n** is not always true. It is also possible that nBackfillAttempted\n** may be left set to a value larger than expected, if a wal frame\n** contains content that duplicate of an earlier version of the same\n** page.\n**\n** SQLITE_OK is returned if successful, or an SQLite error code if an\n** error occurs. It is not an error if nBackfillAttempted cannot be\n** decreased at all.\n*/\nint sqlite3WalSnapshotRecover(Wal *pWal){\n  int rc;\n\n  assert( pWal->readLock>=0 );\n  rc = walLockExclusive(pWal, WAL_CKPT_LOCK, 1);\n  if( rc==SQLITE_OK ){\n    void *pBuf1 = sqlite3_malloc(pWal->szPage);\n    void *pBuf2 = sqlite3_malloc(pWal->szPage);\n    if( pBuf1==0 || pBuf2==0 ){\n      rc = SQLITE_NOMEM;\n    }else{\n      pWal->ckptLock = 1;\n      SEH_TRY {\n        rc = walSnapshotRecover(pWal, pBuf1, pBuf2);\n      }\n      SEH_EXCEPT( rc = SQLITE_IOERR_IN_PAGE; )\n      pWal->ckptLock = 0;\n    }\n\n    sqlite3_free(pBuf1);\n    sqlite3_free(pBuf2);\n    walUnlockExclusive(pWal, WAL_CKPT_LOCK, 1);\n  }\n\n  return rc;\n}\n#endif /* SQLITE_ENABLE_SNAPSHOT */\n\n/*\n** This function does the work of sqlite3WalBeginReadTransaction() (see \n** below). That function simply calls this one inside an SEH_TRY{...} block.\n*/\nstatic int walBeginReadTransaction(Wal *pWal, int *pChanged){\n  int rc;                         /* Return code */\n  int cnt = 0;                    /* Number of TryBeginRead attempts */\n#ifdef SQLITE_ENABLE_SNAPSHOT\n  int ckptLock = 0;\n  int bChanged = 0;\n  WalIndexHdr *pSnapshot = pWal->pSnapshot;\n#endif\n\n  assert( pWal->ckptLock==0 );\n  assert( pWal->nSehTry>0 );\n\n#ifdef SQLITE_ENABLE_SNAPSHOT\n  if( pSnapshot ){\n    if( memcmp(pSnapshot, &pWal->hdr, sizeof(WalIndexHdr))!=0 ){\n      bChanged = 1;\n    }\n\n    /* It is possible that there is a checkpointer thread running\n    ** concurrent with this code. If this is the case, it may be that the\n    ** checkpointer has already determined that it will checkpoint\n    ** snapshot X, where X is later in the wal file than pSnapshot, but\n    ** has not yet set the pInfo->nBackfillAttempted variable to indicate\n    ** its intent. To avoid the race condition this leads to, ensure that\n    ** there is no checkpointer process by taking a shared CKPT lock\n    ** before checking pInfo->nBackfillAttempted.  */\n    (void)walEnableBlocking(pWal);\n    rc = walLockShared(pWal, WAL_CKPT_LOCK);\n    walDisableBlocking(pWal);\n\n    if( rc!=SQLITE_OK ){\n      return rc;\n    }\n    ckptLock = 1;\n  }\n#endif\n\n  do{\n    rc = walTryBeginRead(pWal, pChanged, 0, &cnt);\n  }while( rc==WAL_RETRY );\n  testcase( (rc&0xff)==SQLITE_BUSY );\n  testcase( (rc&0xff)==SQLITE_IOERR );\n  testcase( rc==SQLITE_PROTOCOL );\n  testcase( rc==SQLITE_OK );\n\n#ifdef SQLITE_ENABLE_SNAPSHOT\n  if( rc==SQLITE_OK ){\n    if( pSnapshot && memcmp(pSnapshot, &pWal->hdr, sizeof(WalIndexHdr))!=0 ){\n      /* At this point the client has a lock on an aReadMark[] slot holding\n      ** a value equal to or smaller than pSnapshot->mxFrame, but pWal->hdr\n      ** is populated with the wal-index header corresponding to the head\n      ** of the wal file. Verify that pSnapshot is still valid before\n      ** continuing.  Reasons why pSnapshot might no longer be valid:\n      **\n      **    (1)  The WAL file has been reset since the snapshot was taken.\n      **         In this case, the salt will have changed.\n      **\n      **    (2)  A checkpoint as been attempted that wrote frames past\n      **         pSnapshot->mxFrame into the database file.  Note that the\n      **         checkpoint need not have completed for this to cause problems.\n      */\n      volatile WalCkptInfo *pInfo = walCkptInfo(pWal);\n\n      assert( pWal->readLock>0 || pWal->hdr.mxFrame==0 );\n      assert( pInfo->aReadMark[pWal->readLock]<=pSnapshot->mxFrame );\n\n      /* Check that the wal file has not been wrapped. Assuming that it has\n      ** not, also check that no checkpointer has attempted to checkpoint any\n      ** frames beyond pSnapshot->mxFrame. If either of these conditions are\n      ** true, return SQLITE_ERROR_SNAPSHOT. Otherwise, overwrite pWal->hdr\n      ** with *pSnapshot and set *pChanged as appropriate for opening the\n      ** snapshot.  */\n      if( !memcmp(pSnapshot->aSalt, pWal->hdr.aSalt, sizeof(pWal->hdr.aSalt))\n       && pSnapshot->mxFrame>=pInfo->nBackfillAttempted\n      ){\n        assert( pWal->readLock>0 );\n        memcpy(&pWal->hdr, pSnapshot, sizeof(WalIndexHdr));\n        *pChanged = bChanged;\n      }else{\n        rc = SQLITE_ERROR_SNAPSHOT;\n      }\n\n      /* A client using a non-current snapshot may not ignore any frames\n      ** from the start of the wal file. This is because, for a system\n      ** where (minFrame < iSnapshot < maxFrame), a checkpointer may\n      ** have omitted to checkpoint a frame earlier than minFrame in\n      ** the file because there exists a frame after iSnapshot that\n      ** is the same database page.  */\n      pWal->minFrame = 1;\n\n      if( rc!=SQLITE_OK ){\n        sqlite3WalEndReadTransaction(pWal);\n      }\n    }\n  }\n\n  /* Release the shared CKPT lock obtained above. */\n  if( ckptLock ){\n    assert( pSnapshot );\n    walUnlockShared(pWal, WAL_CKPT_LOCK);\n  }\n#endif\n  return rc;\n}\n\n/*\n** Begin a read transaction on the database.\n**\n** This routine used to be called sqlite3OpenSnapshot() and with good reason:\n** it takes a snapshot of the state of the WAL and wal-index for the current\n** instant in time.  The current thread will continue to use this snapshot.\n** Other threads might append new content to the WAL and wal-index but\n** that extra content is ignored by the current thread.\n**\n** If the database contents have changes since the previous read\n** transaction, then *pChanged is set to 1 before returning.  The\n** Pager layer will use this to know that its cache is stale and\n** needs to be flushed.\n*/\nint sqlite3WalBeginReadTransaction(Wal *pWal, int *pChanged){\n  int rc;\n  SEH_TRY {\n    rc = walBeginReadTransaction(pWal, pChanged);\n  }\n  SEH_EXCEPT( rc = walHandleException(pWal); )\n  return rc;\n}\n\n/*\n** Finish with a read transaction.  All this does is release the\n** read-lock.\n*/\nvoid sqlite3WalEndReadTransaction(Wal *pWal){\n#ifndef SQLITE_ENABLE_SETLK_TIMEOUT\n  assert( pWal->writeLock==0 || pWal->readLock<0 );\n#endif\n  if( pWal->readLock>=0 ){\n    (void)sqlite3WalEndWriteTransaction(pWal);\n    walUnlockShared(pWal, WAL_READ_LOCK(pWal->readLock));\n    pWal->readLock = -1;\n  }\n}\n\n/*\n** Search the wal file for page pgno. If found, set *piRead to the frame that\n** contains the page. Otherwise, if pgno is not in the wal file, set *piRead\n** to zero.\n**\n** Return SQLITE_OK if successful, or an error code if an error occurs. If an\n** error does occur, the final value of *piRead is undefined.\n*/\nstatic int walFindFrame(\n  Wal *pWal,                      /* WAL handle */\n  Pgno pgno,                      /* Database page number to read data for */\n  u32 *piRead                     /* OUT: Frame number (or zero) */\n){\n  u32 iRead = 0;                  /* If !=0, WAL frame to return data from */\n  u32 iLast = pWal->hdr.mxFrame;  /* Last page in WAL for this reader */\n  int iHash;                      /* Used to loop through N hash tables */\n  int iMinHash;\n\n  /* This routine is only be called from within a read transaction. */\n  assert( pWal->readLock>=0 || pWal->lockError );\n\n  /* If the \"last page\" field of the wal-index header snapshot is 0, then\n  ** no data will be read from the wal under any circumstances. Return early\n  ** in this case as an optimization.  Likewise, if pWal->readLock==0,\n  ** then the WAL is ignored by the reader so return early, as if the\n  ** WAL were empty.\n  */\n  if( iLast==0 || (pWal->readLock==0 && pWal->bShmUnreliable==0) ){\n    *piRead = 0;\n    return SQLITE_OK;\n  }\n\n  /* Search the hash table or tables for an entry matching page number\n  ** pgno. Each iteration of the following for() loop searches one\n  ** hash table (each hash table indexes up to HASHTABLE_NPAGE frames).\n  **\n  ** This code might run concurrently to the code in walIndexAppend()\n  ** that adds entries to the wal-index (and possibly to this hash\n  ** table). This means the value just read from the hash\n  ** slot (aHash[iKey]) may have been added before or after the\n  ** current read transaction was opened. Values added after the\n  ** read transaction was opened may have been written incorrectly -\n  ** i.e. these slots may contain garbage data. However, we assume\n  ** that any slots written before the current read transaction was\n  ** opened remain unmodified.\n  **\n  ** For the reasons above, the if(...) condition featured in the inner\n  ** loop of the following block is more stringent that would be required\n  ** if we had exclusive access to the hash-table:\n  **\n  **   (aPgno[iFrame]==pgno):\n  **     This condition filters out normal hash-table collisions.\n  **\n  **   (iFrame<=iLast):\n  **     This condition filters out entries that were added to the hash\n  **     table after the current read-transaction had started.\n  */\n  iMinHash = walFramePage(pWal->minFrame);\n  for(iHash=walFramePage(iLast); iHash>=iMinHash; iHash--){\n    WalHashLoc sLoc;              /* Hash table location */\n    int iKey;                     /* Hash slot index */\n    int nCollide;                 /* Number of hash collisions remaining */\n    int rc;                       /* Error code */\n    u32 iH;\n\n    rc = walHashGet(pWal, iHash, &sLoc);\n    if( rc!=SQLITE_OK ){\n      return rc;\n    }\n    nCollide = HASHTABLE_NSLOT;\n    iKey = walHash(pgno);\n    SEH_INJECT_FAULT;\n    while( (iH = AtomicLoad(&sLoc.aHash[iKey]))!=0 ){\n      u32 iFrame = iH + sLoc.iZero;\n      if( iFrame<=iLast && iFrame>=pWal->minFrame && sLoc.aPgno[iH-1]==pgno ){\n        assert( iFrame>iRead || CORRUPT_DB );\n        iRead = iFrame;\n      }\n      if( (nCollide--)==0 ){\n        *piRead = 0;\n        return SQLITE_CORRUPT_BKPT;\n      }\n      iKey = walNextHash(iKey);\n    }\n    if( iRead ) break;\n  }\n\n#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT\n  /* If expensive assert() statements are available, do a linear search\n  ** of the wal-index file content. Make sure the results agree with the\n  ** result obtained using the hash indexes above.  */\n  {\n    u32 iRead2 = 0;\n    u32 iTest;\n    assert( pWal->bShmUnreliable || pWal->minFrame>0 );\n    for(iTest=iLast; iTest>=pWal->minFrame && iTest>0; iTest--){\n      if( walFramePgno(pWal, iTest)==pgno ){\n        iRead2 = iTest;\n        break;\n      }\n    }\n    assert( iRead==iRead2 );\n  }\n#endif\n\n  *piRead = iRead;\n  return SQLITE_OK;\n}\n\n/*\n** Search the wal file for page pgno. If found, set *piRead to the frame that\n** contains the page. Otherwise, if pgno is not in the wal file, set *piRead\n** to zero.\n**\n** Return SQLITE_OK if successful, or an error code if an error occurs. If an\n** error does occur, the final value of *piRead is undefined.\n**\n** The difference between this function and walFindFrame() is that this\n** function wraps walFindFrame() in an SEH_TRY{...} block.\n*/\nint sqlite3WalFindFrame(\n  Wal *pWal,                      /* WAL handle */\n  Pgno pgno,                      /* Database page number to read data for */\n  u32 *piRead                     /* OUT: Frame number (or zero) */\n){\n  int rc;\n  SEH_TRY {\n    rc = walFindFrame(pWal, pgno, piRead);\n  }\n  SEH_EXCEPT( rc = SQLITE_IOERR_IN_PAGE; )\n  return rc;\n}\n\n/*\n** Read the contents of frame iRead from the wal file into buffer pOut\n** (which is nOut bytes in size). Return SQLITE_OK if successful, or an\n** error code otherwise.\n*/\nint sqlite3WalReadFrame(\n  Wal *pWal,                      /* WAL handle */\n  u32 iRead,                      /* Frame to read */\n  int nOut,                       /* Size of buffer pOut in bytes */\n  u8 *pOut                        /* Buffer to write page data to */\n){\n  int sz;\n  i64 iOffset;\n  sz = pWal->hdr.szPage;\n  sz = (sz&0xfe00) + ((sz&0x0001)<<16);\n  testcase( sz<=32768 );\n  testcase( sz>=65536 );\n  iOffset = walFrameOffset(iRead, sz) + WAL_FRAME_HDRSIZE;\n  /* testcase( IS_BIG_INT(iOffset) ); // requires a 4GiB WAL */\n  return sqlite3OsRead(pWal->pWalFd, pOut, (nOut>sz ? sz : nOut), iOffset);\n}\n\n/*\n** Return the size of the database in pages (or zero, if unknown).\n*/\nPgno sqlite3WalDbsize(Wal *pWal){\n  if( pWal && ALWAYS(pWal->readLock>=0) ){\n    return pWal->hdr.nPage;\n  }\n  return 0;\n}\n\n\n/*\n** This function starts a write transaction on the WAL.\n**\n** A read transaction must have already been started by a prior call\n** to sqlite3WalBeginReadTransaction().\n**\n** If another thread or process has written into the database since\n** the read transaction was started, then it is not possible for this\n** thread to write as doing so would cause a fork.  So this routine\n** returns SQLITE_BUSY in that case and no write transaction is started.\n**\n** There can only be a single writer active at a time.\n*/\nint sqlite3WalBeginWriteTransaction(Wal *pWal){\n  int rc;\n\n#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n  /* If the write-lock is already held, then it was obtained before the\n  ** read-transaction was even opened, making this call a no-op.\n  ** Return early. */\n  if( pWal->writeLock ){\n    assert( !memcmp(&pWal->hdr,(void*)pWal->apWiData[0],sizeof(WalIndexHdr)) );\n    return SQLITE_OK;\n  }\n#endif\n\n  /* Cannot start a write transaction without first holding a read\n  ** transaction. */\n  assert( pWal->readLock>=0 );\n  assert( pWal->writeLock==0 && pWal->iReCksum==0 );\n\n  if( pWal->readOnly ){\n    return SQLITE_READONLY;\n  }\n\n  /* Only one writer allowed at a time.  Get the write lock.  Return\n  ** SQLITE_BUSY if unable.\n  */\n  rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1);\n  if( rc ){\n    return rc;\n  }\n  pWal->writeLock = 1;\n\n  /* If another connection has written to the database file since the\n  ** time the read transaction on this connection was started, then\n  ** the write is disallowed.\n  */\n  SEH_TRY {\n    if( memcmp(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr))!=0 ){\n      rc = SQLITE_BUSY_SNAPSHOT;\n    }\n  }\n  SEH_EXCEPT( rc = SQLITE_IOERR_IN_PAGE; )\n\n  if( rc!=SQLITE_OK ){\n    walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);\n    pWal->writeLock = 0;\n  }\n  return rc;\n}\n\n/*\n** End a write transaction.  The commit has already been done.  This\n** routine merely releases the lock.\n*/\nint sqlite3WalEndWriteTransaction(Wal *pWal){\n  if( pWal->writeLock ){\n    walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);\n    pWal->writeLock = 0;\n    pWal->iReCksum = 0;\n    pWal->truncateOnCommit = 0;\n  }\n  return SQLITE_OK;\n}\n\n/*\n** If any data has been written (but not committed) to the log file, this\n** function moves the write-pointer back to the start of the transaction.\n**\n** Additionally, the callback function is invoked for each frame written\n** to the WAL since the start of the transaction. If the callback returns\n** other than SQLITE_OK, it is not invoked again and the error code is\n** returned to the caller.\n**\n** Otherwise, if the callback function does not return an error, this\n** function returns SQLITE_OK.\n*/\nint sqlite3WalUndo(Wal *pWal, int (*xUndo)(void *, Pgno), void *pUndoCtx){\n  int rc = SQLITE_OK;\n  if( ALWAYS(pWal->writeLock) ){\n    Pgno iMax = pWal->hdr.mxFrame;\n    Pgno iFrame;\n\n    SEH_TRY {\n      /* Restore the clients cache of the wal-index header to the state it\n      ** was in before the client began writing to the database.\n      */\n      memcpy(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr));\n\n      for(iFrame=pWal->hdr.mxFrame+1;\n          ALWAYS(rc==SQLITE_OK) && iFrame<=iMax;\n          iFrame++\n      ){\n        /* This call cannot fail. Unless the page for which the page number\n        ** is passed as the second argument is (a) in the cache and\n        ** (b) has an outstanding reference, then xUndo is either a no-op\n        ** (if (a) is false) or simply expels the page from the cache (if (b)\n        ** is false).\n        **\n        ** If the upper layer is doing a rollback, it is guaranteed that there\n        ** are no outstanding references to any page other than page 1. And\n        ** page 1 is never written to the log until the transaction is\n        ** committed. As a result, the call to xUndo may not fail.\n        */\n        assert( walFramePgno(pWal, iFrame)!=1 );\n        rc = xUndo(pUndoCtx, walFramePgno(pWal, iFrame));\n      }\n      if( iMax!=pWal->hdr.mxFrame ) walCleanupHash(pWal);\n    }\n    SEH_EXCEPT( rc = SQLITE_IOERR_IN_PAGE; )\n    pWal->iReCksum = 0;\n  }\n  return rc;\n}\n\n/*\n** Argument aWalData must point to an array of WAL_SAVEPOINT_NDATA u32\n** values. This function populates the array with values required to\n** \"rollback\" the write position of the WAL handle back to the current\n** point in the event of a savepoint rollback (via WalSavepointUndo()).\n*/\nvoid sqlite3WalSavepoint(Wal *pWal, u32 *aWalData){\n  assert( pWal->writeLock );\n  aWalData[0] = pWal->hdr.mxFrame;\n  aWalData[1] = pWal->hdr.aFrameCksum[0];\n  aWalData[2] = pWal->hdr.aFrameCksum[1];\n  aWalData[3] = pWal->nCkpt;\n}\n\n/*\n** Move the write position of the WAL back to the point identified by\n** the values in the aWalData[] array. aWalData must point to an array\n** of WAL_SAVEPOINT_NDATA u32 values that has been previously populated\n** by a call to WalSavepoint().\n*/\nint sqlite3WalSavepointUndo(Wal *pWal, u32 *aWalData){\n  int rc = SQLITE_OK;\n\n  assert( pWal->writeLock );\n  assert( aWalData[3]!=pWal->nCkpt || aWalData[0]<=pWal->hdr.mxFrame );\n\n  if( aWalData[3]!=pWal->nCkpt ){\n    /* This savepoint was opened immediately after the write-transaction\n    ** was started. Right after that, the writer decided to wrap around\n    ** to the start of the log. Update the savepoint values to match.\n    */\n    aWalData[0] = 0;\n    aWalData[3] = pWal->nCkpt;\n  }\n\n  if( aWalData[0]<pWal->hdr.mxFrame ){\n    pWal->hdr.mxFrame = aWalData[0];\n    pWal->hdr.aFrameCksum[0] = aWalData[1];\n    pWal->hdr.aFrameCksum[1] = aWalData[2];\n    SEH_TRY {\n      walCleanupHash(pWal);\n    }\n    SEH_EXCEPT( rc = SQLITE_IOERR_IN_PAGE; )\n    if( pWal->iReCksum>pWal->hdr.mxFrame ){\n      pWal->iReCksum = 0;\n    }\n  }\n\n  return rc;\n}\n\n/*\n** This function is called just before writing a set of frames to the log\n** file (see sqlite3WalFrames()). It checks to see if, instead of appending\n** to the current log file, it is possible to overwrite the start of the\n** existing log file with the new frames (i.e. \"reset\" the log). If so,\n** it sets pWal->hdr.mxFrame to 0. Otherwise, pWal->hdr.mxFrame is left\n** unchanged.\n**\n** SQLITE_OK is returned if no error is encountered (regardless of whether\n** or not pWal->hdr.mxFrame is modified). An SQLite error code is returned\n** if an error occurs.\n*/\nstatic int walRestartLog(Wal *pWal){\n  int rc = SQLITE_OK;\n  int cnt;\n\n  if( pWal->readLock==0 ){\n    volatile WalCkptInfo *pInfo = walCkptInfo(pWal);\n    assert( pInfo->nBackfill==pWal->hdr.mxFrame );\n    if( pInfo->nBackfill>0 ){\n      u32 salt1;\n      sqlite3_randomness(4, &salt1);\n      rc = walLockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);\n      if( rc==SQLITE_OK ){\n        /* If all readers are using WAL_READ_LOCK(0) (in other words if no\n        ** readers are currently using the WAL), then the transactions\n        ** frames will overwrite the start of the existing log. Update the\n        ** wal-index header to reflect this.\n        **\n        ** In theory it would be Ok to update the cache of the header only\n        ** at this point. But updating the actual wal-index header is also\n        ** safe and means there is no special case for sqlite3WalUndo()\n        ** to handle if this transaction is rolled back.  */\n        walRestartHdr(pWal, salt1);\n        walUnlockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);\n      }else if( rc!=SQLITE_BUSY ){\n        return rc;\n      }\n    }\n    walUnlockShared(pWal, WAL_READ_LOCK(0));\n    pWal->readLock = -1;\n    cnt = 0;\n    do{\n      int notUsed;\n      rc = walTryBeginRead(pWal, &notUsed, 1, &cnt);\n    }while( rc==WAL_RETRY );\n    assert( (rc&0xff)!=SQLITE_BUSY ); /* BUSY not possible when useWal==1 */\n    testcase( (rc&0xff)==SQLITE_IOERR );\n    testcase( rc==SQLITE_PROTOCOL );\n    testcase( rc==SQLITE_OK );\n  }\n  return rc;\n}\n\n/*\n** Information about the current state of the WAL file and where\n** the next fsync should occur - passed from sqlite3WalFrames() into\n** walWriteToLog().\n*/\ntypedef struct WalWriter {\n  Wal *pWal;                   /* The complete WAL information */\n  sqlite3_file *pFd;           /* The WAL file to which we write */\n  sqlite3_int64 iSyncPoint;    /* Fsync at this offset */\n  int syncFlags;               /* Flags for the fsync */\n  int szPage;                  /* Size of one page */\n} WalWriter;\n\n/*\n** Write iAmt bytes of content into the WAL file beginning at iOffset.\n** Do a sync when crossing the p->iSyncPoint boundary.\n**\n** In other words, if iSyncPoint is in between iOffset and iOffset+iAmt,\n** first write the part before iSyncPoint, then sync, then write the\n** rest.\n*/\nstatic int walWriteToLog(\n  WalWriter *p,              /* WAL to write to */\n  void *pContent,            /* Content to be written */\n  int iAmt,                  /* Number of bytes to write */\n  sqlite3_int64 iOffset      /* Start writing at this offset */\n){\n  int rc;\n  if( iOffset<p->iSyncPoint && iOffset+iAmt>=p->iSyncPoint ){\n    int iFirstAmt = (int)(p->iSyncPoint - iOffset);\n    rc = sqlite3OsWrite(p->pFd, pContent, iFirstAmt, iOffset);\n    if( rc ) return rc;\n    iOffset += iFirstAmt;\n    iAmt -= iFirstAmt;\n    pContent = (void*)(iFirstAmt + (char*)pContent);\n    assert( WAL_SYNC_FLAGS(p->syncFlags)!=0 );\n    rc = sqlite3OsSync(p->pFd, WAL_SYNC_FLAGS(p->syncFlags));\n    if( iAmt==0 || rc ) return rc;\n  }\n  rc = sqlite3OsWrite(p->pFd, pContent, iAmt, iOffset);\n  return rc;\n}\n\n/*\n** Write out a single frame of the WAL\n*/\nstatic int walWriteOneFrame(\n  WalWriter *p,               /* Where to write the frame */\n  PgHdr *pPage,               /* The page of the frame to be written */\n  int nTruncate,              /* The commit flag.  Usually 0.  >0 for commit */\n  sqlite3_int64 iOffset       /* Byte offset at which to write */\n){\n  int rc;                         /* Result code from subfunctions */\n  void *pData;                    /* Data actually written */\n  u8 aFrame[WAL_FRAME_HDRSIZE];   /* Buffer to assemble frame-header in */\n  pData = pPage->pData;\n  walEncodeFrame(p->pWal, pPage->pgno, nTruncate, pData, aFrame);\n  rc = walWriteToLog(p, aFrame, sizeof(aFrame), iOffset);\n  if( rc ) return rc;\n  /* Write the page data */\n  rc = walWriteToLog(p, pData, p->szPage, iOffset+sizeof(aFrame));\n  return rc;\n}\n\n/*\n** This function is called as part of committing a transaction within which\n** one or more frames have been overwritten. It updates the checksums for\n** all frames written to the wal file by the current transaction starting\n** with the earliest to have been overwritten.\n**\n** SQLITE_OK is returned if successful, or an SQLite error code otherwise.\n*/\nstatic int walRewriteChecksums(Wal *pWal, u32 iLast){\n  const int szPage = pWal->szPage;/* Database page size */\n  int rc = SQLITE_OK;             /* Return code */\n  u8 *aBuf;                       /* Buffer to load data from wal file into */\n  u8 aFrame[WAL_FRAME_HDRSIZE];   /* Buffer to assemble frame-headers in */\n  u32 iRead;                      /* Next frame to read from wal file */\n  i64 iCksumOff;\n\n  aBuf = sqlite3_malloc(szPage + WAL_FRAME_HDRSIZE);\n  if( aBuf==0 ) return SQLITE_NOMEM_BKPT;\n\n  /* Find the checksum values to use as input for the recalculating the\n  ** first checksum. If the first frame is frame 1 (implying that the current\n  ** transaction restarted the wal file), these values must be read from the\n  ** wal-file header. Otherwise, read them from the frame header of the\n  ** previous frame.  */\n  assert( pWal->iReCksum>0 );\n  if( pWal->iReCksum==1 ){\n    iCksumOff = 24;\n  }else{\n    iCksumOff = walFrameOffset(pWal->iReCksum-1, szPage) + 16;\n  }\n  rc = sqlite3OsRead(pWal->pWalFd, aBuf, sizeof(u32)*2, iCksumOff);\n  pWal->hdr.aFrameCksum[0] = sqlite3Get4byte(aBuf);\n  pWal->hdr.aFrameCksum[1] = sqlite3Get4byte(&aBuf[sizeof(u32)]);\n\n  iRead = pWal->iReCksum;\n  pWal->iReCksum = 0;\n  for(; rc==SQLITE_OK && iRead<=iLast; iRead++){\n    i64 iOff = walFrameOffset(iRead, szPage);\n    rc = sqlite3OsRead(pWal->pWalFd, aBuf, szPage+WAL_FRAME_HDRSIZE, iOff);\n    if( rc==SQLITE_OK ){\n      u32 iPgno, nDbSize;\n      iPgno = sqlite3Get4byte(aBuf);\n      nDbSize = sqlite3Get4byte(&aBuf[4]);\n\n      walEncodeFrame(pWal, iPgno, nDbSize, &aBuf[WAL_FRAME_HDRSIZE], aFrame);\n      rc = sqlite3OsWrite(pWal->pWalFd, aFrame, sizeof(aFrame), iOff);\n    }\n  }\n\n  sqlite3_free(aBuf);\n  return rc;\n}\n\n/*\n** Write a set of frames to the log. The caller must hold the write-lock\n** on the log file (obtained using sqlite3WalBeginWriteTransaction()).\n*/\nstatic int walFrames(\n  Wal *pWal,                      /* Wal handle to write to */\n  int szPage,                     /* Database page-size in bytes */\n  PgHdr *pList,                   /* List of dirty pages to write */\n  Pgno nTruncate,                 /* Database size after this commit */\n  int isCommit,                   /* True if this is a commit */\n  int sync_flags                  /* Flags to pass to OsSync() (or 0) */\n){\n  int rc;                         /* Used to catch return codes */\n  u32 iFrame;                     /* Next frame address */\n  PgHdr *p;                       /* Iterator to run through pList with. */\n  PgHdr *pLast = 0;               /* Last frame in list */\n  int nExtra = 0;                 /* Number of extra copies of last page */\n  int szFrame;                    /* The size of a single frame */\n  i64 iOffset;                    /* Next byte to write in WAL file */\n  WalWriter w;                    /* The writer */\n  u32 iFirst = 0;                 /* First frame that may be overwritten */\n  WalIndexHdr *pLive;             /* Pointer to shared header */\n\n  assert( pList );\n  assert( pWal->writeLock );\n\n  /* If this frame set completes a transaction, then nTruncate>0.  If\n  ** nTruncate==0 then this frame set does not complete the transaction. */\n  assert( (isCommit!=0)==(nTruncate!=0) );\n\n#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)\n  { int cnt; for(cnt=0, p=pList; p; p=p->pDirty, cnt++){}\n    WALTRACE((\"WAL%p: frame write begin. %d frames. mxFrame=%d. %s\\n\",\n              pWal, cnt, pWal->hdr.mxFrame, isCommit ? \"Commit\" : \"Spill\"));\n  }\n#endif\n\n  pLive = (WalIndexHdr*)walIndexHdr(pWal);\n  if( memcmp(&pWal->hdr, (void *)pLive, sizeof(WalIndexHdr))!=0 ){\n    iFirst = pLive->mxFrame+1;\n  }\n\n  /* See if it is possible to write these frames into the start of the\n  ** log file, instead of appending to it at pWal->hdr.mxFrame.\n  */\n  if( SQLITE_OK!=(rc = walRestartLog(pWal)) ){\n    return rc;\n  }\n\n  /* If this is the first frame written into the log, write the WAL\n  ** header to the start of the WAL file. See comments at the top of\n  ** this source file for a description of the WAL header format.\n  */\n  iFrame = pWal->hdr.mxFrame;\n  if( iFrame==0 ){\n    u8 aWalHdr[WAL_HDRSIZE];      /* Buffer to assemble wal-header in */\n    u32 aCksum[2];                /* Checksum for wal-header */\n\n    sqlite3Put4byte(&aWalHdr[0], (WAL_MAGIC | SQLITE_BIGENDIAN));\n    sqlite3Put4byte(&aWalHdr[4], WAL_MAX_VERSION);\n    sqlite3Put4byte(&aWalHdr[8], szPage);\n    sqlite3Put4byte(&aWalHdr[12], pWal->nCkpt);\n    if( pWal->nCkpt==0 ) sqlite3_randomness(8, pWal->hdr.aSalt);\n    memcpy(&aWalHdr[16], pWal->hdr.aSalt, 8);\n    walChecksumBytes(1, aWalHdr, WAL_HDRSIZE-2*4, 0, aCksum);\n    sqlite3Put4byte(&aWalHdr[24], aCksum[0]);\n    sqlite3Put4byte(&aWalHdr[28], aCksum[1]);\n\n    pWal->szPage = szPage;\n    pWal->hdr.bigEndCksum = SQLITE_BIGENDIAN;\n    pWal->hdr.aFrameCksum[0] = aCksum[0];\n    pWal->hdr.aFrameCksum[1] = aCksum[1];\n    pWal->truncateOnCommit = 1;\n\n    rc = sqlite3OsWrite(pWal->pWalFd, aWalHdr, sizeof(aWalHdr), 0);\n    WALTRACE((\"WAL%p: wal-header write %s\\n\", pWal, rc ? \"failed\" : \"ok\"));\n    if( rc!=SQLITE_OK ){\n      return rc;\n    }\n\n    /* Sync the header (unless SQLITE_IOCAP_SEQUENTIAL is true or unless\n    ** all syncing is turned off by PRAGMA synchronous=OFF).  Otherwise\n    ** an out-of-order write following a WAL restart could result in\n    ** database corruption.  See the ticket:\n    **\n    **     https://sqlite.org/src/info/ff5be73dee\n    */\n    if( pWal->syncHeader ){\n      rc = sqlite3OsSync(pWal->pWalFd, CKPT_SYNC_FLAGS(sync_flags));\n      if( rc ) return rc;\n    }\n  }\n  if( (int)pWal->szPage!=szPage ){\n    return SQLITE_CORRUPT_BKPT;  /* TH3 test case: cov1/corrupt155.test */\n  }\n\n  /* Setup information needed to write frames into the WAL */\n  w.pWal = pWal;\n  w.pFd = pWal->pWalFd;\n  w.iSyncPoint = 0;\n  w.syncFlags = sync_flags;\n  w.szPage = szPage;\n  iOffset = walFrameOffset(iFrame+1, szPage);\n  szFrame = szPage + WAL_FRAME_HDRSIZE;\n\n  /* Write all frames into the log file exactly once */\n  for(p=pList; p; p=p->pDirty){\n    int nDbSize;   /* 0 normally.  Positive == commit flag */\n\n    /* Check if this page has already been written into the wal file by\n    ** the current transaction. If so, overwrite the existing frame and\n    ** set Wal.writeLock to WAL_WRITELOCK_RECKSUM - indicating that\n    ** checksums must be recomputed when the transaction is committed.  */\n    if( iFirst && (p->pDirty || isCommit==0) ){\n      u32 iWrite = 0;\n      VVA_ONLY(rc =) walFindFrame(pWal, p->pgno, &iWrite);\n      assert( rc==SQLITE_OK || iWrite==0 );\n      if( iWrite>=iFirst ){\n        i64 iOff = walFrameOffset(iWrite, szPage) + WAL_FRAME_HDRSIZE;\n        void *pData;\n        if( pWal->iReCksum==0 || iWrite<pWal->iReCksum ){\n          pWal->iReCksum = iWrite;\n        }\n        pData = p->pData;\n        rc = sqlite3OsWrite(pWal->pWalFd, pData, szPage, iOff);\n        if( rc ) return rc;\n        p->flags &= ~PGHDR_WAL_APPEND;\n        continue;\n      }\n    }\n\n    iFrame++;\n    assert( iOffset==walFrameOffset(iFrame, szPage) );\n    nDbSize = (isCommit && p->pDirty==0) ? nTruncate : 0;\n    rc = walWriteOneFrame(&w, p, nDbSize, iOffset);\n    if( rc ) return rc;\n    pLast = p;\n    iOffset += szFrame;\n    p->flags |= PGHDR_WAL_APPEND;\n  }\n\n  /* Recalculate checksums within the wal file if required. */\n  if( isCommit && pWal->iReCksum ){\n    rc = walRewriteChecksums(pWal, iFrame);\n    if( rc ) return rc;\n  }\n\n  /* If this is the end of a transaction, then we might need to pad\n  ** the transaction and/or sync the WAL file.\n  **\n  ** Padding and syncing only occur if this set of frames complete a\n  ** transaction and if PRAGMA synchronous=FULL.  If synchronous==NORMAL\n  ** or synchronous==OFF, then no padding or syncing are needed.\n  **\n  ** If SQLITE_IOCAP_POWERSAFE_OVERWRITE is defined, then padding is not\n  ** needed and only the sync is done.  If padding is needed, then the\n  ** final frame is repeated (with its commit mark) until the next sector\n  ** boundary is crossed.  Only the part of the WAL prior to the last\n  ** sector boundary is synced; the part of the last frame that extends\n  ** past the sector boundary is written after the sync.\n  */\n  if( isCommit && WAL_SYNC_FLAGS(sync_flags)!=0 ){\n    int bSync = 1;\n    if( pWal->padToSectorBoundary ){\n      int sectorSize = sqlite3SectorSize(pWal->pWalFd);\n      w.iSyncPoint = ((iOffset+sectorSize-1)/sectorSize)*sectorSize;\n      bSync = (w.iSyncPoint==iOffset);\n      testcase( bSync );\n      while( iOffset<w.iSyncPoint ){\n        rc = walWriteOneFrame(&w, pLast, nTruncate, iOffset);\n        if( rc ) return rc;\n        iOffset += szFrame;\n        nExtra++;\n        assert( pLast!=0 );\n      }\n    }\n    if( bSync ){\n      assert( rc==SQLITE_OK );\n      rc = sqlite3OsSync(w.pFd, WAL_SYNC_FLAGS(sync_flags));\n    }\n  }\n\n  /* If this frame set completes the first transaction in the WAL and\n  ** if PRAGMA journal_size_limit is set, then truncate the WAL to the\n  ** journal size limit, if possible.\n  */\n  if( isCommit && pWal->truncateOnCommit && pWal->mxWalSize>=0 ){\n    i64 sz = pWal->mxWalSize;\n    if( walFrameOffset(iFrame+nExtra+1, szPage)>pWal->mxWalSize ){\n      sz = walFrameOffset(iFrame+nExtra+1, szPage);\n    }\n    walLimitSize(pWal, sz);\n    pWal->truncateOnCommit = 0;\n  }\n\n  /* Append data to the wal-index. It is not necessary to lock the\n  ** wal-index to do this as the SQLITE_SHM_WRITE lock held on the wal-index\n  ** guarantees that there are no other writers, and no data that may\n  ** be in use by existing readers is being overwritten.\n  */\n  iFrame = pWal->hdr.mxFrame;\n  for(p=pList; p && rc==SQLITE_OK; p=p->pDirty){\n    if( (p->flags & PGHDR_WAL_APPEND)==0 ) continue;\n    iFrame++;\n    rc = walIndexAppend(pWal, iFrame, p->pgno);\n  }\n  assert( pLast!=0 || nExtra==0 );\n  while( rc==SQLITE_OK && nExtra>0 ){\n    iFrame++;\n    nExtra--;\n    rc = walIndexAppend(pWal, iFrame, pLast->pgno);\n  }\n\n  if( rc==SQLITE_OK ){\n    /* Update the private copy of the header. */\n    pWal->hdr.szPage = (u16)((szPage&0xff00) | (szPage>>16));\n    testcase( szPage<=32768 );\n    testcase( szPage>=65536 );\n    pWal->hdr.mxFrame = iFrame;\n    if( isCommit ){\n      pWal->hdr.iChange++;\n      pWal->hdr.nPage = nTruncate;\n    }\n    /* If this is a commit, update the wal-index header too. */\n    if( isCommit ){\n      walIndexWriteHdr(pWal);\n      pWal->iCallback = iFrame;\n    }\n  }\n\n  WALTRACE((\"WAL%p: frame write %s\\n\", pWal, rc ? \"failed\" : \"ok\"));\n  return rc;\n}\n\n/* \n** Write a set of frames to the log. The caller must hold the write-lock\n** on the log file (obtained using sqlite3WalBeginWriteTransaction()).\n**\n** The difference between this function and walFrames() is that this\n** function wraps walFrames() in an SEH_TRY{...} block.\n*/\nint sqlite3WalFrames(\n  Wal *pWal,                      /* Wal handle to write to */\n  int szPage,                     /* Database page-size in bytes */\n  PgHdr *pList,                   /* List of dirty pages to write */\n  Pgno nTruncate,                 /* Database size after this commit */\n  int isCommit,                   /* True if this is a commit */\n  int sync_flags                  /* Flags to pass to OsSync() (or 0) */\n){\n  int rc;\n  SEH_TRY {\n    rc = walFrames(pWal, szPage, pList, nTruncate, isCommit, sync_flags);\n  }\n  SEH_EXCEPT( rc = walHandleException(pWal); )\n  return rc;\n}\n\n/*\n** This routine is called to implement sqlite3_wal_checkpoint() and\n** related interfaces.\n**\n** Obtain a CHECKPOINT lock and then backfill as much information as\n** we can from WAL into the database.\n**\n** If parameter xBusy is not NULL, it is a pointer to a busy-handler\n** callback. In this case this function runs a blocking checkpoint.\n*/\nint sqlite3WalCheckpoint(\n  Wal *pWal,                      /* Wal connection */\n  sqlite3 *db,                    /* Check this handle's interrupt flag */\n  int eMode,                      /* PASSIVE, FULL, RESTART, or TRUNCATE */\n  int (*xBusy)(void*),            /* Function to call when busy */\n  void *pBusyArg,                 /* Context argument for xBusyHandler */\n  int sync_flags,                 /* Flags to sync db file with (or 0) */\n  int nBuf,                       /* Size of temporary buffer */\n  u8 *zBuf,                       /* Temporary buffer to use */\n  int *pnLog,                     /* OUT: Number of frames in WAL */\n  int *pnCkpt                     /* OUT: Number of backfilled frames in WAL */\n){\n  int rc;                         /* Return code */\n  int isChanged = 0;              /* True if a new wal-index header is loaded */\n  int eMode2 = eMode;             /* Mode to pass to walCheckpoint() */\n  int (*xBusy2)(void*) = xBusy;   /* Busy handler for eMode2 */\n\n  assert( pWal->ckptLock==0 );\n  assert( pWal->writeLock==0 );\n\n  /* EVIDENCE-OF: R-62920-47450 The busy-handler callback is never invoked\n  ** in the SQLITE_CHECKPOINT_PASSIVE mode. */\n  assert( SQLITE_CHECKPOINT_NOOP<SQLITE_CHECKPOINT_PASSIVE );\n  assert( eMode>SQLITE_CHECKPOINT_PASSIVE || xBusy==0 );\n\n  if( pWal->readOnly ) return SQLITE_READONLY;\n  WALTRACE((\"WAL%p: checkpoint begins\\n\", pWal));\n\n  /* Enable blocking locks, if possible. */\n  sqlite3WalDb(pWal, db);\n  if( xBusy2 ) (void)walEnableBlocking(pWal);\n\n  /* IMPLEMENTATION-OF: R-62028-47212 All calls obtain an exclusive\n  ** \"checkpoint\" lock on the database file.\n  ** EVIDENCE-OF: R-10421-19736 If any other process is running a\n  ** checkpoint operation at the same time, the lock cannot be obtained and\n  ** SQLITE_BUSY is returned.\n  ** EVIDENCE-OF: R-53820-33897 Even if there is a busy-handler configured,\n  ** it will not be invoked in this case.\n  */\n  if( eMode!=SQLITE_CHECKPOINT_NOOP ){\n    rc = walLockExclusive(pWal, WAL_CKPT_LOCK, 1);\n    testcase( rc==SQLITE_BUSY );\n    testcase( rc!=SQLITE_OK && xBusy2!=0 );\n    if( rc==SQLITE_OK ){\n      pWal->ckptLock = 1;\n\n      /* IMPLEMENTATION-OF: R-59782-36818 The SQLITE_CHECKPOINT_FULL, RESTART \n      ** and TRUNCATE modes also obtain the exclusive \"writer\" lock on the \n      ** database file.\n      **\n      ** EVIDENCE-OF: R-60642-04082 If the writer lock cannot be obtained\n      ** immediately, and a busy-handler is configured, it is invoked and the\n      ** writer lock retried until either the busy-handler returns 0 or the\n      ** lock is successfully obtained.\n      */\n      if( eMode!=SQLITE_CHECKPOINT_PASSIVE ){\n        rc = walBusyLock(pWal, xBusy2, pBusyArg, WAL_WRITE_LOCK, 1);\n        if( rc==SQLITE_OK ){\n          pWal->writeLock = 1;\n        }else if( rc==SQLITE_BUSY ){\n          eMode2 = SQLITE_CHECKPOINT_PASSIVE;\n          xBusy2 = 0;\n          rc = SQLITE_OK;\n        }\n      }\n    }\n  }else{\n    rc = SQLITE_OK;\n  }\n\n\n  /* Read the wal-index header. */\n  SEH_TRY {\n    if( rc==SQLITE_OK ){\n      /* For a passive checkpoint, do not re-enable blocking locks after\n      ** reading the wal-index header. A passive checkpoint should not block \n      ** or invoke the busy handler. The only lock such a checkpoint may \n      ** attempt to obtain is a lock on a read-slot, and it should give up\n      ** immediately and do a partial checkpoint if it cannot obtain it. */\n      walDisableBlocking(pWal);\n      rc = walIndexReadHdr(pWal, &isChanged);\n      if( eMode2>SQLITE_CHECKPOINT_PASSIVE ) (void)walEnableBlocking(pWal);\n      if( isChanged && pWal->pDbFd->pMethods->iVersion>=3 ){\n        sqlite3OsUnfetch(pWal->pDbFd, 0, 0);\n      }\n    }\n  \n    /* Copy data from the log to the database file. */\n    if( rc==SQLITE_OK ){\n      if( pWal->hdr.mxFrame && walPagesize(pWal)!=nBuf ){\n        rc = SQLITE_CORRUPT_BKPT;\n      }else if( eMode2!=SQLITE_CHECKPOINT_NOOP ){\n        rc = walCheckpoint(pWal, db, eMode2, xBusy2, pBusyArg, sync_flags,zBuf);\n      }\n\n      /* If no error occurred, set the output variables. */\n      if( rc==SQLITE_OK || rc==SQLITE_BUSY ){\n        if( pnLog ) *pnLog = (int)pWal->hdr.mxFrame;\n        SEH_INJECT_FAULT;\n        if( pnCkpt ) *pnCkpt = (int)(walCkptInfo(pWal)->nBackfill);\n      }\n    }\n  }\n  SEH_EXCEPT( rc = walHandleException(pWal); )\n\n  if( isChanged ){\n    /* If a new wal-index header was loaded before the checkpoint was\n    ** performed, then the pager-cache associated with pWal is now\n    ** out of date. So zero the cached wal-index header to ensure that\n    ** next time the pager opens a snapshot on this database it knows that\n    ** the cache needs to be reset.\n    */\n    memset(&pWal->hdr, 0, sizeof(WalIndexHdr));\n  }\n\n  walDisableBlocking(pWal);\n  sqlite3WalDb(pWal, 0);\n\n  /* Release the locks. */\n  (void)sqlite3WalEndWriteTransaction(pWal);\n  if( pWal->ckptLock ){\n    walUnlockExclusive(pWal, WAL_CKPT_LOCK, 1);\n    pWal->ckptLock = 0;\n  }\n  WALTRACE((\"WAL%p: checkpoint %s\\n\", pWal, rc ? \"failed\" : \"ok\"));\n#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n  if( rc==SQLITE_BUSY_TIMEOUT ) rc = SQLITE_BUSY;\n#endif\n  return (rc==SQLITE_OK && eMode!=eMode2 ? SQLITE_BUSY : rc);\n}\n\n/* Return the value to pass to a sqlite3_wal_hook callback, the\n** number of frames in the WAL at the point of the last commit since\n** sqlite3WalCallback() was called.  If no commits have occurred since\n** the last call, then return 0.\n*/\nint sqlite3WalCallback(Wal *pWal){\n  u32 ret = 0;\n  if( pWal ){\n    ret = pWal->iCallback;\n    pWal->iCallback = 0;\n  }\n  return (int)ret;\n}\n\n/*\n** This function is called to change the WAL subsystem into or out\n** of locking_mode=EXCLUSIVE.\n**\n** If op is zero, then attempt to change from locking_mode=EXCLUSIVE\n** into locking_mode=NORMAL.  This means that we must acquire a lock\n** on the pWal->readLock byte.  If the WAL is already in locking_mode=NORMAL\n** or if the acquisition of the lock fails, then return 0.  If the\n** transition out of exclusive-mode is successful, return 1.  This\n** operation must occur while the pager is still holding the exclusive\n** lock on the main database file.\n**\n** If op is one, then change from locking_mode=NORMAL into\n** locking_mode=EXCLUSIVE.  This means that the pWal->readLock must\n** be released.  Return 1 if the transition is made and 0 if the\n** WAL is already in exclusive-locking mode - meaning that this\n** routine is a no-op.  The pager must already hold the exclusive lock\n** on the main database file before invoking this operation.\n**\n** If op is negative, then do a dry-run of the op==1 case but do\n** not actually change anything. The pager uses this to see if it\n** should acquire the database exclusive lock prior to invoking\n** the op==1 case.\n*/\nint sqlite3WalExclusiveMode(Wal *pWal, int op){\n  int rc;\n  assert( pWal->writeLock==0 );\n  assert( pWal->exclusiveMode!=WAL_HEAPMEMORY_MODE || op==-1 );\n\n  /* pWal->readLock is usually set, but might be -1 if there was a\n  ** prior error while attempting to acquire are read-lock. This cannot\n  ** happen if the connection is actually in exclusive mode (as no xShmLock\n  ** locks are taken in this case). Nor should the pager attempt to\n  ** upgrade to exclusive-mode following such an error.\n  */\n#ifndef SQLITE_USE_SEH\n  assert( pWal->readLock>=0 || pWal->lockError );\n#endif\n  assert( pWal->readLock>=0 || (op<=0 && pWal->exclusiveMode==0) );\n\n  if( op==0 ){\n    if( pWal->exclusiveMode!=WAL_NORMAL_MODE ){\n      pWal->exclusiveMode = WAL_NORMAL_MODE;\n      if( walLockShared(pWal, WAL_READ_LOCK(pWal->readLock))!=SQLITE_OK ){\n        pWal->exclusiveMode = WAL_EXCLUSIVE_MODE;\n      }\n      rc = pWal->exclusiveMode==WAL_NORMAL_MODE;\n    }else{\n      /* Already in locking_mode=NORMAL */\n      rc = 0;\n    }\n  }else if( op>0 ){\n    assert( pWal->exclusiveMode==WAL_NORMAL_MODE );\n    assert( pWal->readLock>=0 );\n    walUnlockShared(pWal, WAL_READ_LOCK(pWal->readLock));\n    pWal->exclusiveMode = WAL_EXCLUSIVE_MODE;\n    rc = 1;\n  }else{\n    rc = pWal->exclusiveMode==WAL_NORMAL_MODE;\n  }\n  return rc;\n}\n\n/*\n** Return true if the argument is non-NULL and the WAL module is using\n** heap-memory for the wal-index. Otherwise, if the argument is NULL or the\n** WAL module is using shared-memory, return false.\n*/\nint sqlite3WalHeapMemory(Wal *pWal){\n  return (pWal && pWal->exclusiveMode==WAL_HEAPMEMORY_MODE );\n}\n\n#ifdef SQLITE_ENABLE_SNAPSHOT\n/* Create a snapshot object.  The content of a snapshot is opaque to\n** every other subsystem, so the WAL module can put whatever it needs\n** in the object.\n*/\nint sqlite3WalSnapshotGet(Wal *pWal, sqlite3_snapshot **ppSnapshot){\n  int rc = SQLITE_OK;\n  WalIndexHdr *pRet;\n  static const u32 aZero[4] = { 0, 0, 0, 0 };\n\n  assert( pWal->readLock>=0 && pWal->writeLock==0 );\n\n  if( memcmp(&pWal->hdr.aFrameCksum[0],aZero,16)==0 ){\n    *ppSnapshot = 0;\n    return SQLITE_ERROR;\n  }\n  pRet = (WalIndexHdr*)sqlite3_malloc(sizeof(WalIndexHdr));\n  if( pRet==0 ){\n    rc = SQLITE_NOMEM_BKPT;\n  }else{\n    memcpy(pRet, &pWal->hdr, sizeof(WalIndexHdr));\n    *ppSnapshot = (sqlite3_snapshot*)pRet;\n  }\n\n  return rc;\n}\n\n/* Try to open on pSnapshot when the next read-transaction starts\n*/\nvoid sqlite3WalSnapshotOpen(\n  Wal *pWal,\n  sqlite3_snapshot *pSnapshot\n){\n  if( pSnapshot && ((WalIndexHdr*)pSnapshot)->iVersion==0 ){\n    /* iVersion==0 means that this is a call to sqlite3_snapshot_get().  In\n    ** this case set the bGetSnapshot flag so that if the call to\n    ** sqlite3_snapshot_get() is about to read transaction on this wal \n    ** file, it does not take read-lock 0 if the wal file has been completely\n    ** checkpointed. Taking read-lock 0 would work, but then it would be\n    ** possible for a subsequent writer to destroy the snapshot even while \n    ** this connection is holding its read-transaction open. This is contrary\n    ** to user expectations, so we avoid it by not taking read-lock 0. */\n    pWal->bGetSnapshot = 1;\n  }else{\n    pWal->pSnapshot = (WalIndexHdr*)pSnapshot;\n    pWal->bGetSnapshot = 0;\n  }\n}\n\n/*\n** Return a +ve value if snapshot p1 is newer than p2. A -ve value if\n** p1 is older than p2 and zero if p1 and p2 are the same snapshot.\n*/\nint sqlite3_snapshot_cmp(sqlite3_snapshot *p1, sqlite3_snapshot *p2){\n  WalIndexHdr *pHdr1 = (WalIndexHdr*)p1;\n  WalIndexHdr *pHdr2 = (WalIndexHdr*)p2;\n\n  /* aSalt[0] is a copy of the value stored in the wal file header. It\n  ** is incremented each time the wal file is restarted.  */\n  if( pHdr1->aSalt[0]<pHdr2->aSalt[0] ) return -1;\n  if( pHdr1->aSalt[0]>pHdr2->aSalt[0] ) return +1;\n  if( pHdr1->mxFrame<pHdr2->mxFrame ) return -1;\n  if( pHdr1->mxFrame>pHdr2->mxFrame ) return +1;\n  return 0;\n}\n\n/*\n** The caller currently has a read transaction open on the database.\n** This function takes a SHARED lock on the CHECKPOINTER slot and then\n** checks if the snapshot passed as the second argument is still\n** available. If so, SQLITE_OK is returned.\n**\n** If the snapshot is not available, SQLITE_ERROR is returned. Or, if\n** the CHECKPOINTER lock cannot be obtained, SQLITE_BUSY. If any error\n** occurs (any value other than SQLITE_OK is returned), the CHECKPOINTER\n** lock is released before returning.\n*/\nint sqlite3WalSnapshotCheck(Wal *pWal, sqlite3_snapshot *pSnapshot){\n  int rc;\n  SEH_TRY {\n    rc = walLockShared(pWal, WAL_CKPT_LOCK);\n    if( rc==SQLITE_OK ){\n      WalIndexHdr *pNew = (WalIndexHdr*)pSnapshot;\n      if( memcmp(pNew->aSalt, pWal->hdr.aSalt, sizeof(pWal->hdr.aSalt))\n       || pNew->mxFrame<walCkptInfo(pWal)->nBackfillAttempted\n      ){\n        rc = SQLITE_ERROR_SNAPSHOT;\n        walUnlockShared(pWal, WAL_CKPT_LOCK);\n      }\n    }\n  }\n  SEH_EXCEPT( rc = walHandleException(pWal); )\n  return rc;\n}\n\n/*\n** Release a lock obtained by an earlier successful call to\n** sqlite3WalSnapshotCheck().\n*/\nvoid sqlite3WalSnapshotUnlock(Wal *pWal){\n  assert( pWal );\n  walUnlockShared(pWal, WAL_CKPT_LOCK);\n}\n\n\n#endif /* SQLITE_ENABLE_SNAPSHOT */\n\n#ifdef SQLITE_ENABLE_ZIPVFS\n/*\n** If the argument is not NULL, it points to a Wal object that holds a\n** read-lock. This function returns the database page-size if it is known,\n** or zero if it is not (or if pWal is NULL).\n*/\nint sqlite3WalFramesize(Wal *pWal){\n  assert( pWal==0 || pWal->readLock>=0 );\n  return (pWal ? pWal->szPage : 0);\n}\n#endif\n\n/* Return the sqlite3_file object for the WAL file\n*/\nsqlite3_file *sqlite3WalFile(Wal *pWal){\n  return pWal->pWalFd;\n}\n\n#endif /* #ifndef SQLITE_OMIT_WAL */\n"}
{"repo": "sqlite", "file": "delete.c", "lang": "C++", "code": "/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains C code routines that are called by the parser\n** in order to generate code for DELETE FROM statements.\n*/\n#include \"sqliteInt.h\"\n\n/*\n** While a SrcList can in general represent multiple tables and subqueries\n** (as in the FROM clause of a SELECT statement) in this case it contains\n** the name of a single table, as one might find in an INSERT, DELETE,\n** or UPDATE statement.  Look up that table in the symbol table and\n** return a pointer.  Set an error message and return NULL if the table\n** name is not found or if any other error occurs.\n**\n** The following fields are initialized appropriate in pSrc:\n**\n**    pSrc->a[0].spTab        Pointer to the Table object\n**    pSrc->a[0].u2.pIBIndex  Pointer to the INDEXED BY index, if there is one\n**\n*/\nTable *sqlite3SrcListLookup(Parse *pParse, SrcList *pSrc){\n  SrcItem *pItem = pSrc->a;\n  Table *pTab;\n  assert( pItem && pSrc->nSrc>=1 );\n  pTab = sqlite3LocateTableItem(pParse, 0, pItem);\n  if( pItem->pSTab ) sqlite3DeleteTable(pParse->db, pItem->pSTab);\n  pItem->pSTab = pTab;\n  pItem->fg.notCte = 1;\n  if( pTab ){\n    pTab->nTabRef++;\n    if( pItem->fg.isIndexedBy && sqlite3IndexedByLookup(pParse, pItem) ){\n      pTab = 0;\n    }\n  }\n  return pTab;\n}\n\n/* Generate byte-code that will report the number of rows modified\n** by a DELETE, INSERT, or UPDATE statement.\n*/\nvoid sqlite3CodeChangeCount(Vdbe *v, int regCounter, const char *zColName){\n  sqlite3VdbeAddOp0(v, OP_FkCheck);\n  sqlite3VdbeAddOp2(v, OP_ResultRow, regCounter, 1);\n  sqlite3VdbeSetNumCols(v, 1);\n  sqlite3VdbeSetColName(v, 0, COLNAME_NAME, zColName, SQLITE_STATIC);\n}\n\n/* Return true if table pTab is read-only.\n**\n** A table is read-only if any of the following are true:\n**\n**   1) It is a virtual table and no implementation of the xUpdate method\n**      has been provided\n**\n**   2) A trigger is currently being coded and the table is a virtual table\n**      that is SQLITE_VTAB_DIRECTONLY or if PRAGMA trusted_schema=OFF and\n**      the table is not SQLITE_VTAB_INNOCUOUS.\n**\n**   3) It is a system table (i.e. sqlite_schema), this call is not\n**      part of a nested parse and writable_schema pragma has not\n**      been specified\n**\n**   4) The table is a shadow table, the database connection is in\n**      defensive mode, and the current sqlite3_prepare()\n**      is for a top-level SQL statement.\n*/\nstatic int vtabIsReadOnly(Parse *pParse, Table *pTab){\n  assert( IsVirtual(pTab) );\n  if( sqlite3GetVTable(pParse->db, pTab)->pMod->pModule->xUpdate==0 ){\n    return 1;\n  }\n\n  /* Within triggers:\n  **   *  Do not allow DELETE, INSERT, or UPDATE of SQLITE_VTAB_DIRECTONLY\n  **      virtual tables\n  **   *  Only allow DELETE, INSERT, or UPDATE of non-SQLITE_VTAB_INNOCUOUS\n  **      virtual tables if PRAGMA trusted_schema=ON.\n  */\n  if( (pParse->pToplevel!=0 || (pParse->prepFlags & SQLITE_PREPARE_FROM_DDL))\n   && pTab->u.vtab.p->eVtabRisk >\n           ((pParse->db->flags & SQLITE_TrustedSchema)!=0)\n  ){\n    sqlite3ErrorMsg(pParse, \"unsafe use of virtual table \\\"%s\\\"\",\n      pTab->zName);\n  }\n  return 0;\n}\nstatic int tabIsReadOnly(Parse *pParse, Table *pTab){\n  sqlite3 *db;\n  if( IsVirtual(pTab) ){\n    return vtabIsReadOnly(pParse, pTab);\n  }\n  if( (pTab->tabFlags & (TF_Readonly|TF_Shadow))==0 ) return 0;\n  db = pParse->db;\n  if( (pTab->tabFlags & TF_Readonly)!=0 ){\n    return sqlite3WritableSchema(db)==0 && pParse->nested==0;\n  }\n  assert( pTab->tabFlags & TF_Shadow );\n  return sqlite3ReadOnlyShadowTables(db);\n}\n\n/*\n** Check to make sure the given table is writable.\n**\n** If pTab is not writable  ->  generate an error message and return 1.\n** If pTab is writable but other errors have occurred -> return 1.\n** If pTab is writable and no prior errors -> return 0;\n*/\nint sqlite3IsReadOnly(Parse *pParse, Table *pTab, Trigger *pTrigger){\n  if( tabIsReadOnly(pParse, pTab) ){\n    sqlite3ErrorMsg(pParse, \"table %s may not be modified\", pTab->zName);\n    return 1;\n  }\n#ifndef SQLITE_OMIT_VIEW\n  if( IsView(pTab)\n   && (pTrigger==0 || (pTrigger->bReturning && pTrigger->pNext==0))\n  ){\n    sqlite3ErrorMsg(pParse,\"cannot modify %s because it is a view\",pTab->zName);\n    return 1;\n  }\n#endif\n  return 0;\n}\n\n\n#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)\n/*\n** Evaluate a view and store its result in an ephemeral table.  The\n** pWhere argument is an optional WHERE clause that restricts the\n** set of rows in the view that are to be added to the ephemeral table.\n*/\nvoid sqlite3MaterializeView(\n  Parse *pParse,       /* Parsing context */\n  Table *pView,        /* View definition */\n  Expr *pWhere,        /* Optional WHERE clause to be added */\n  ExprList *pOrderBy,  /* Optional ORDER BY clause */\n  Expr *pLimit,        /* Optional LIMIT clause */\n  int iCur             /* Cursor number for ephemeral table */\n){\n  SelectDest dest;\n  Select *pSel;\n  SrcList *pFrom;\n  sqlite3 *db = pParse->db;\n  int iDb = sqlite3SchemaToIndex(db, pView->pSchema);\n  pWhere = sqlite3ExprDup(db, pWhere, 0);\n  pFrom = sqlite3SrcListAppend(pParse, 0, 0, 0);\n  if( pFrom ){\n    assert( pFrom->nSrc==1 );\n    pFrom->a[0].zName = sqlite3DbStrDup(db, pView->zName);\n    assert( pFrom->a[0].fg.fixedSchema==0 && pFrom->a[0].fg.isSubquery==0 );\n    pFrom->a[0].u4.zDatabase = sqlite3DbStrDup(db, db->aDb[iDb].zDbSName);\n    assert( pFrom->a[0].fg.isUsing==0 );\n    assert( pFrom->a[0].u3.pOn==0 );\n  }\n  pSel = sqlite3SelectNew(pParse, 0, pFrom, pWhere, 0, 0, pOrderBy,\n                          SF_IncludeHidden, pLimit);\n  sqlite3SelectDestInit(&dest, SRT_EphemTab, iCur);\n  sqlite3Select(pParse, pSel, &dest);\n  sqlite3SelectDelete(db, pSel);\n}\n#endif /* !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER) */\n\n#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY)\n/*\n** Generate an expression tree to implement the WHERE, ORDER BY,\n** and LIMIT/OFFSET portion of DELETE and UPDATE statements.\n**\n**     DELETE FROM table_wxyz WHERE a<5 ORDER BY a LIMIT 1;\n**                            \\__________________________/\n**                               pLimitWhere (pInClause)\n*/\nExpr *sqlite3LimitWhere(\n  Parse *pParse,               /* The parser context */\n  SrcList *pSrc,               /* the FROM clause -- which tables to scan */\n  Expr *pWhere,                /* The WHERE clause.  May be null */\n  ExprList *pOrderBy,          /* The ORDER BY clause.  May be null */\n  Expr *pLimit,                /* The LIMIT clause.  May be null */\n  char *zStmtType              /* Either DELETE or UPDATE.  For err msgs. */\n){\n  sqlite3 *db = pParse->db;\n  Expr *pLhs = NULL;           /* LHS of IN(SELECT...) operator */\n  Expr *pInClause = NULL;      /* WHERE rowid IN ( select ) */\n  ExprList *pEList = NULL;     /* Expression list containing only pSelectRowid*/\n  SrcList *pSelectSrc = NULL;  /* SELECT rowid FROM x ... (dup of pSrc) */\n  Select *pSelect = NULL;      /* Complete SELECT tree */\n  Table *pTab;\n\n  /* Check that there isn't an ORDER BY without a LIMIT clause.\n  */\n  if( pOrderBy && pLimit==0 ) {\n    sqlite3ErrorMsg(pParse, \"ORDER BY without LIMIT on %s\", zStmtType);\n    sqlite3ExprDelete(pParse->db, pWhere);\n    sqlite3ExprListDelete(pParse->db, pOrderBy);\n    return 0;\n  }\n\n  /* We only need to generate a select expression if there\n  ** is a limit/offset term to enforce.\n  */\n  if( pLimit == 0 ) {\n    return pWhere;\n  }\n\n  /* Generate a select expression tree to enforce the limit/offset\n  ** term for the DELETE or UPDATE statement.  For example:\n  **   DELETE FROM table_a WHERE col1=1 ORDER BY col2 LIMIT 1 OFFSET 1\n  ** becomes:\n  **   DELETE FROM table_a WHERE rowid IN (\n  **     SELECT rowid FROM table_a WHERE col1=1 ORDER BY col2 LIMIT 1 OFFSET 1\n  **   );\n  */\n\n  pTab = pSrc->a[0].pSTab;\n  if( HasRowid(pTab) ){\n    pLhs = sqlite3PExpr(pParse, TK_ROW, 0, 0);\n    pEList = sqlite3ExprListAppend(\n        pParse, 0, sqlite3PExpr(pParse, TK_ROW, 0, 0)\n    );\n  }else{\n    Index *pPk = sqlite3PrimaryKeyIndex(pTab);\n    assert( pPk!=0 );\n    assert( pPk->nKeyCol>=1 );\n    if( pPk->nKeyCol==1 ){\n      const char *zName;\n      assert( pPk->aiColumn[0]>=0 && pPk->aiColumn[0]<pTab->nCol );\n      zName = pTab->aCol[pPk->aiColumn[0]].zCnName;\n      pLhs = sqlite3Expr(db, TK_ID, zName);\n      pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db, TK_ID, zName));\n    }else{\n      int i;\n      for(i=0; i<pPk->nKeyCol; i++){\n        Expr *p;\n        assert( pPk->aiColumn[i]>=0 && pPk->aiColumn[i]<pTab->nCol );\n        p = sqlite3Expr(db, TK_ID, pTab->aCol[pPk->aiColumn[i]].zCnName);\n        pEList = sqlite3ExprListAppend(pParse, pEList, p);\n      }\n      pLhs = sqlite3PExpr(pParse, TK_VECTOR, 0, 0);\n      if( pLhs ){\n        pLhs->x.pList = sqlite3ExprListDup(db, pEList, 0);\n      }\n    }\n  }\n\n  /* duplicate the FROM clause as it is needed by both the DELETE/UPDATE tree\n  ** and the SELECT subtree. */\n  pSrc->a[0].pSTab = 0;\n  pSelectSrc = sqlite3SrcListDup(db, pSrc, 0);\n  pSrc->a[0].pSTab = pTab;\n  if( pSrc->a[0].fg.isIndexedBy ){\n    assert( pSrc->a[0].fg.isCte==0 );\n    pSrc->a[0].u2.pIBIndex = 0;\n    pSrc->a[0].fg.isIndexedBy = 0;\n    sqlite3DbFree(db, pSrc->a[0].u1.zIndexedBy);\n  }else if( pSrc->a[0].fg.isCte ){\n    pSrc->a[0].u2.pCteUse->nUse++;\n  }\n\n  /* generate the SELECT expression tree. */\n  pSelect = sqlite3SelectNew(pParse, pEList, pSelectSrc, pWhere, 0 ,0,\n      pOrderBy,0,pLimit\n  );\n\n  /* now generate the new WHERE rowid IN clause for the DELETE/UPDATE */\n  pInClause = sqlite3PExpr(pParse, TK_IN, pLhs, 0);\n  sqlite3PExprAddSelect(pParse, pInClause, pSelect);\n  return pInClause;\n}\n#endif /* defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) */\n       /*      && !defined(SQLITE_OMIT_SUBQUERY) */\n\n/*\n** Generate code for a DELETE FROM statement.\n**\n**     DELETE FROM table_wxyz WHERE a<5 AND b NOT NULL;\n**                 \\________/       \\________________/\n**                  pTabList              pWhere\n*/\nvoid sqlite3DeleteFrom(\n  Parse *pParse,         /* The parser context */\n  SrcList *pTabList,     /* The table from which we should delete things */\n  Expr *pWhere,          /* The WHERE clause.  May be null */\n  ExprList *pOrderBy,    /* ORDER BY clause. May be null */\n  Expr *pLimit           /* LIMIT clause. May be null */\n){\n  Vdbe *v;               /* The virtual database engine */\n  Table *pTab;           /* The table from which records will be deleted */\n  int i;                 /* Loop counter */\n  WhereInfo *pWInfo;     /* Information about the WHERE clause */\n  Index *pIdx;           /* For looping over indices of the table */\n  int iTabCur;           /* Cursor number for the table */\n  int iDataCur = 0;      /* VDBE cursor for the canonical data source */\n  int iIdxCur = 0;       /* Cursor number of the first index */\n  int nIdx;              /* Number of indices */\n  sqlite3 *db;           /* Main database structure */\n  AuthContext sContext;  /* Authorization context */\n  NameContext sNC;       /* Name context to resolve expressions in */\n  int iDb;               /* Database number */\n  int memCnt = 0;        /* Memory cell used for change counting */\n  int rcauth;            /* Value returned by authorization callback */\n  int eOnePass;          /* ONEPASS_OFF or _SINGLE or _MULTI */\n  int aiCurOnePass[2];   /* The write cursors opened by WHERE_ONEPASS */\n  u8 *aToOpen = 0;       /* Open cursor iTabCur+j if aToOpen[j] is true */\n  Index *pPk;            /* The PRIMARY KEY index on the table */\n  int iPk = 0;           /* First of nPk registers holding PRIMARY KEY value */\n  i16 nPk = 1;           /* Number of columns in the PRIMARY KEY */\n  int iKey;              /* Memory cell holding key of row to be deleted */\n  i16 nKey;              /* Number of memory cells in the row key */\n  int iEphCur = 0;       /* Ephemeral table holding all primary key values */\n  int iRowSet = 0;       /* Register for rowset of rows to delete */\n  int addrBypass = 0;    /* Address of jump over the delete logic */\n  int addrLoop = 0;      /* Top of the delete loop */\n  int addrEphOpen = 0;   /* Instruction to open the Ephemeral table */\n  int bComplex;          /* True if there are triggers or FKs or\n                         ** subqueries in the WHERE clause */\n\n#ifndef SQLITE_OMIT_TRIGGER\n  int isView;                  /* True if attempting to delete from a view */\n  Trigger *pTrigger;           /* List of table triggers, if required */\n#endif\n\n  memset(&sContext, 0, sizeof(sContext));\n  db = pParse->db;\n  assert( db->pParse==pParse );\n  if( pParse->nErr ){\n    goto delete_from_cleanup;\n  }\n  assert( db->mallocFailed==0 );\n  assert( pTabList->nSrc==1 );\n\n  /* Locate the table which we want to delete.  This table has to be\n  ** put in an SrcList structure because some of the subroutines we\n  ** will be calling are designed to work with multiple tables and expect\n  ** an SrcList* parameter instead of just a Table* parameter.\n  */\n  pTab = sqlite3SrcListLookup(pParse, pTabList);\n  if( pTab==0 )  goto delete_from_cleanup;\n\n  /* Figure out if we have any triggers and if the table being\n  ** deleted from is a view\n  */\n#ifndef SQLITE_OMIT_TRIGGER\n  pTrigger = sqlite3TriggersExist(pParse, pTab, TK_DELETE, 0, 0);\n  isView = IsView(pTab);\n#else\n# define pTrigger 0\n# define isView 0\n#endif\n  bComplex = pTrigger || sqlite3FkRequired(pParse, pTab, 0, 0);\n#ifdef SQLITE_OMIT_VIEW\n# undef isView\n# define isView 0\n#endif\n\n#if TREETRACE_ENABLED\n  if( sqlite3TreeTrace & 0x10000 ){\n    sqlite3TreeViewLine(0, \"In sqlite3Delete() at %s:%d\", __FILE__, __LINE__);\n    sqlite3TreeViewDelete(pParse->pWith, pTabList, pWhere,\n                          pOrderBy, pLimit, pTrigger);\n  }\n#endif\n\n#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT\n  if( !isView ){\n    pWhere = sqlite3LimitWhere(\n        pParse, pTabList, pWhere, pOrderBy, pLimit, \"DELETE\"\n    );\n    pOrderBy = 0;\n    pLimit = 0;\n  }\n#endif\n\n  /* If pTab is really a view, make sure it has been initialized.\n  */\n  if( sqlite3ViewGetColumnNames(pParse, pTab) ){\n    goto delete_from_cleanup;\n  }\n\n  if( sqlite3IsReadOnly(pParse, pTab, pTrigger) ){\n    goto delete_from_cleanup;\n  }\n  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n  assert( iDb<db->nDb );\n  rcauth = sqlite3AuthCheck(pParse, SQLITE_DELETE, pTab->zName, 0,\n                            db->aDb[iDb].zDbSName);\n  assert( rcauth==SQLITE_OK || rcauth==SQLITE_DENY || rcauth==SQLITE_IGNORE );\n  if( rcauth==SQLITE_DENY ){\n    goto delete_from_cleanup;\n  }\n  assert(!isView || pTrigger);\n\n  /* Assign cursor numbers to the table and all its indices.\n  */\n  assert( pTabList->nSrc==1 );\n  iTabCur = pTabList->a[0].iCursor = pParse->nTab++;\n  for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){\n    pParse->nTab++;\n  }\n\n  /* Start the view context\n  */\n  if( isView ){\n    sqlite3AuthContextPush(pParse, &sContext, pTab->zName);\n  }\n\n  /* Begin generating code.\n  */\n  v = sqlite3GetVdbe(pParse);\n  if( v==0 ){\n    goto delete_from_cleanup;\n  }\n  if( pParse->nested==0 ) sqlite3VdbeCountChanges(v);\n  sqlite3BeginWriteOperation(pParse, bComplex, iDb);\n\n  /* If we are trying to delete from a view, realize that view into\n  ** an ephemeral table.\n  */\n#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)\n  if( isView ){\n    sqlite3MaterializeView(pParse, pTab,\n        pWhere, pOrderBy, pLimit, iTabCur\n    );\n    iDataCur = iIdxCur = iTabCur;\n    pOrderBy = 0;\n    pLimit = 0;\n  }\n#endif\n\n  /* Resolve the column names in the WHERE clause.\n  */\n  memset(&sNC, 0, sizeof(sNC));\n  sNC.pParse = pParse;\n  sNC.pSrcList = pTabList;\n  if( sqlite3ResolveExprNames(&sNC, pWhere) ){\n    goto delete_from_cleanup;\n  }\n\n  /* Initialize the counter of the number of rows deleted, if\n  ** we are counting rows.\n  */\n  if( (db->flags & SQLITE_CountRows)!=0\n   && !pParse->nested\n   && !pParse->pTriggerTab\n   && !pParse->bReturning\n  ){\n    memCnt = ++pParse->nMem;\n    sqlite3VdbeAddOp2(v, OP_Integer, 0, memCnt);\n  }\n\n#ifndef SQLITE_OMIT_TRUNCATE_OPTIMIZATION\n  /* Special case: A DELETE without a WHERE clause deletes everything.\n  ** It is easier just to erase the whole table. Prior to version 3.6.5,\n  ** this optimization caused the row change count (the value returned by\n  ** API function sqlite3_count_changes) to be set incorrectly.\n  **\n  ** The \"rcauth==SQLITE_OK\" terms is the\n  ** IMPLEMENTATION-OF: R-17228-37124 If the action code is SQLITE_DELETE and\n  ** the callback returns SQLITE_IGNORE then the DELETE operation proceeds but\n  ** the truncate optimization is disabled and all rows are deleted\n  ** individually.\n  */\n  if( rcauth==SQLITE_OK\n   && pWhere==0\n   && !bComplex\n   && !IsVirtual(pTab)\n#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n   && db->xPreUpdateCallback==0\n#endif\n  ){\n    assert( !isView );\n    sqlite3TableLock(pParse, iDb, pTab->tnum, 1, pTab->zName);\n    if( HasRowid(pTab) ){\n      sqlite3VdbeAddOp4(v, OP_Clear, pTab->tnum, iDb, memCnt ? memCnt : -1,\n                        pTab->zName, P4_STATIC);\n    }\n    for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n      assert( pIdx->pSchema==pTab->pSchema );\n      if( IsPrimaryKeyIndex(pIdx) && !HasRowid(pTab) ){\n        sqlite3VdbeAddOp3(v, OP_Clear, pIdx->tnum, iDb, memCnt ? memCnt : -1);\n      }else{\n        sqlite3VdbeAddOp2(v, OP_Clear, pIdx->tnum, iDb);\n      }\n    }\n  }else\n#endif /* SQLITE_OMIT_TRUNCATE_OPTIMIZATION */\n  {\n    u16 wcf = WHERE_ONEPASS_DESIRED|WHERE_DUPLICATES_OK;\n    if( sNC.ncFlags & NC_Subquery ) bComplex = 1;\n    wcf |= (bComplex ? 0 : WHERE_ONEPASS_MULTIROW);\n    if( HasRowid(pTab) ){\n      /* For a rowid table, initialize the RowSet to an empty set */\n      pPk = 0;\n      assert( nPk==1 );\n      iRowSet = ++pParse->nMem;\n      sqlite3VdbeAddOp2(v, OP_Null, 0, iRowSet);\n    }else{\n      /* For a WITHOUT ROWID table, create an ephemeral table used to\n      ** hold all primary keys for rows to be deleted. */\n      pPk = sqlite3PrimaryKeyIndex(pTab);\n      assert( pPk!=0 );\n      nPk = pPk->nKeyCol;\n      iPk = pParse->nMem+1;\n      pParse->nMem += nPk;\n      iEphCur = pParse->nTab++;\n      addrEphOpen = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iEphCur, nPk);\n      sqlite3VdbeSetP4KeyInfo(pParse, pPk);\n    }\n \n    /* Construct a query to find the rowid or primary key for every row\n    ** to be deleted, based on the WHERE clause. Set variable eOnePass\n    ** to indicate the strategy used to implement this delete:\n    **\n    **  ONEPASS_OFF:    Two-pass approach - use a FIFO for rowids/PK values.\n    **  ONEPASS_SINGLE: One-pass approach - at most one row deleted.\n    **  ONEPASS_MULTI:  One-pass approach - any number of rows may be deleted.\n    */\n    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0,0,wcf,iTabCur+1);\n    if( pWInfo==0 ) goto delete_from_cleanup;\n    eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);\n    assert( IsVirtual(pTab)==0 || eOnePass!=ONEPASS_MULTI );\n    assert( IsVirtual(pTab) || bComplex || eOnePass!=ONEPASS_OFF\n            || OptimizationDisabled(db, SQLITE_OnePass) );\n    if( eOnePass!=ONEPASS_SINGLE ) sqlite3MultiWrite(pParse);\n    if( sqlite3WhereUsesDeferredSeek(pWInfo) ){\n      sqlite3VdbeAddOp1(v, OP_FinishSeek, iTabCur);\n    }\n \n    /* Keep track of the number of rows to be deleted */\n    if( memCnt ){\n      sqlite3VdbeAddOp2(v, OP_AddImm, memCnt, 1);\n    }\n \n    /* Extract the rowid or primary key for the current row */\n    if( pPk ){\n      for(i=0; i<nPk; i++){\n        assert( pPk->aiColumn[i]>=0 );\n        sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur,\n                                        pPk->aiColumn[i], iPk+i);\n      }\n      iKey = iPk;\n    }else{\n      iKey = ++pParse->nMem;\n      sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur, -1, iKey);\n    }\n \n    if( eOnePass!=ONEPASS_OFF ){\n      /* For ONEPASS, no need to store the rowid/primary-key. There is only\n      ** one, so just keep it in its register(s) and fall through to the\n      ** delete code.  */\n      nKey = nPk; /* OP_Found will use an unpacked key */\n      aToOpen = sqlite3DbMallocRawNN(db, nIdx+2);\n      if( aToOpen==0 ){\n        sqlite3WhereEnd(pWInfo);\n        goto delete_from_cleanup;\n      }\n      memset(aToOpen, 1, nIdx+1);\n      aToOpen[nIdx+1] = 0;\n      if( aiCurOnePass[0]>=0 ) aToOpen[aiCurOnePass[0]-iTabCur] = 0;\n      if( aiCurOnePass[1]>=0 ) aToOpen[aiCurOnePass[1]-iTabCur] = 0;\n      if( addrEphOpen ) sqlite3VdbeChangeToNoop(v, addrEphOpen);\n      addrBypass = sqlite3VdbeMakeLabel(pParse);\n    }else{\n      if( pPk ){\n        /* Add the PK key for this row to the temporary table */\n        iKey = ++pParse->nMem;\n        nKey = 0;   /* Zero tells OP_Found to use a composite key */\n        sqlite3VdbeAddOp4(v, OP_MakeRecord, iPk, nPk, iKey,\n            sqlite3IndexAffinityStr(pParse->db, pPk), nPk);\n        sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iEphCur, iKey, iPk, nPk);\n      }else{\n        /* Add the rowid of the row to be deleted to the RowSet */\n        nKey = 1;  /* OP_DeferredSeek always uses a single rowid */\n        sqlite3VdbeAddOp2(v, OP_RowSetAdd, iRowSet, iKey);\n      }\n      sqlite3WhereEnd(pWInfo);\n    }\n \n    /* Unless this is a view, open cursors for the table we are\n    ** deleting from and all its indices. If this is a view, then the\n    ** only effect this statement has is to fire the INSTEAD OF\n    ** triggers.\n    */\n    if( !isView ){\n      int iAddrOnce = 0;\n      if( eOnePass==ONEPASS_MULTI ){\n        iAddrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);\n      }\n      testcase( IsVirtual(pTab) );\n      sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenWrite, OPFLAG_FORDELETE,\n                                 iTabCur, aToOpen, &iDataCur, &iIdxCur);\n      assert( pPk || IsVirtual(pTab) || iDataCur==iTabCur );\n      assert( pPk || IsVirtual(pTab) || iIdxCur==iDataCur+1 );\n      if( eOnePass==ONEPASS_MULTI ){\n        sqlite3VdbeJumpHereOrPopInst(v, iAddrOnce);\n      }\n    }\n \n    /* Set up a loop over the rowids/primary-keys that were found in the\n    ** where-clause loop above.\n    */\n    if( eOnePass!=ONEPASS_OFF ){\n      assert( nKey==nPk );  /* OP_Found will use an unpacked key */\n      if( !IsVirtual(pTab) && aToOpen[iDataCur-iTabCur] ){\n        assert( pPk!=0 || IsView(pTab) );\n        sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, addrBypass, iKey, nKey);\n        VdbeCoverage(v);\n      }\n    }else if( pPk ){\n      addrLoop = sqlite3VdbeAddOp1(v, OP_Rewind, iEphCur); VdbeCoverage(v);\n      if( IsVirtual(pTab) ){\n        sqlite3VdbeAddOp3(v, OP_Column, iEphCur, 0, iKey);\n      }else{\n        sqlite3VdbeAddOp2(v, OP_RowData, iEphCur, iKey);\n      }\n      assert( nKey==0 );  /* OP_Found will use a composite key */\n    }else{\n      addrLoop = sqlite3VdbeAddOp3(v, OP_RowSetRead, iRowSet, 0, iKey);\n      VdbeCoverage(v);\n      assert( nKey==1 );\n    } \n \n    /* Delete the row */\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n    if( IsVirtual(pTab) ){\n      const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);\n      sqlite3VtabMakeWritable(pParse, pTab);\n      assert( eOnePass==ONEPASS_OFF || eOnePass==ONEPASS_SINGLE );\n      sqlite3MayAbort(pParse);\n      if( eOnePass==ONEPASS_SINGLE ){\n        sqlite3VdbeAddOp1(v, OP_Close, iTabCur);\n        if( sqlite3IsToplevel(pParse) ){\n          pParse->isMultiWrite = 0;\n        }\n      }\n      sqlite3VdbeAddOp4(v, OP_VUpdate, 0, 1, iKey, pVTab, P4_VTAB);\n      sqlite3VdbeChangeP5(v, OE_Abort);\n    }else\n#endif\n    {\n      int count = (pParse->nested==0);    /* True to count changes */\n      sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur,\n          iKey, nKey, count, OE_Default, eOnePass, aiCurOnePass[1]);\n    }\n \n    /* End of the loop over all rowids/primary-keys. */\n    if( eOnePass!=ONEPASS_OFF ){\n      sqlite3VdbeResolveLabel(v, addrBypass);\n      sqlite3WhereEnd(pWInfo);\n    }else if( pPk ){\n      sqlite3VdbeAddOp2(v, OP_Next, iEphCur, addrLoop+1); VdbeCoverage(v);\n      sqlite3VdbeJumpHere(v, addrLoop);\n    }else{\n      sqlite3VdbeGoto(v, addrLoop);\n      sqlite3VdbeJumpHere(v, addrLoop);\n    }    \n  } /* End non-truncate path */\n\n  /* Update the sqlite_sequence table by storing the content of the\n  ** maximum rowid counter values recorded while inserting into\n  ** autoincrement tables.\n  */\n  if( pParse->nested==0 && pParse->pTriggerTab==0 ){\n    sqlite3AutoincrementEnd(pParse);\n  }\n\n  /* Return the number of rows that were deleted. If this routine is\n  ** generating code because of a call to sqlite3NestedParse(), do not\n  ** invoke the callback function.\n  */\n  if( memCnt ){\n    sqlite3CodeChangeCount(v, memCnt, \"rows deleted\");\n  }\n\ndelete_from_cleanup:\n  sqlite3AuthContextPop(&sContext);\n  sqlite3SrcListDelete(db, pTabList);\n  sqlite3ExprDelete(db, pWhere);\n#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT)\n  sqlite3ExprListDelete(db, pOrderBy);\n  sqlite3ExprDelete(db, pLimit);\n#endif\n  if( aToOpen ) sqlite3DbNNFreeNN(db, aToOpen);\n  return;\n}\n/* Make sure \"isView\" and other macros defined above are undefined. Otherwise\n** they may interfere with compilation of other functions in this file\n** (or in another file, if this file becomes part of the amalgamation).  */\n#ifdef isView\n #undef isView\n#endif\n#ifdef pTrigger\n #undef pTrigger\n#endif\n\n/*\n** This routine generates VDBE code that causes a single row of a\n** single table to be deleted.  Both the original table entry and\n** all indices are removed.\n**\n** Preconditions:\n**\n**   1.  iDataCur is an open cursor on the btree that is the canonical data\n**       store for the table.  (This will be either the table itself,\n**       in the case of a rowid table, or the PRIMARY KEY index in the case\n**       of a WITHOUT ROWID table.)\n**\n**   2.  Read/write cursors for all indices of pTab must be open as\n**       cursor number iIdxCur+i for the i-th index.\n**\n**   3.  The primary key for the row to be deleted must be stored in a\n**       sequence of nPk memory cells starting at iPk.  If nPk==0 that means\n**       that a search record formed from OP_MakeRecord is contained in the\n**       single memory location iPk.\n**\n** eMode:\n**   Parameter eMode may be passed either ONEPASS_OFF (0), ONEPASS_SINGLE, or\n**   ONEPASS_MULTI.  If eMode is not ONEPASS_OFF, then the cursor\n**   iDataCur already points to the row to delete. If eMode is ONEPASS_OFF\n**   then this function must seek iDataCur to the entry identified by iPk\n**   and nPk before reading from it.\n**\n**   If eMode is ONEPASS_MULTI, then this call is being made as part\n**   of a ONEPASS delete that affects multiple rows. In this case, if\n**   iIdxNoSeek is a valid cursor number (>=0) and is not the same as\n**   iDataCur, then its position should be preserved following the delete\n**   operation. Or, if iIdxNoSeek is not a valid cursor number, the\n**   position of iDataCur should be preserved instead.\n**\n** iIdxNoSeek:\n**   If iIdxNoSeek is a valid cursor number (>=0) not equal to iDataCur,\n**   then it identifies an index cursor (from within array of cursors\n**   starting at iIdxCur) that already points to the index entry to be deleted.\n**   Except, this optimization is disabled if there are BEFORE triggers since\n**   the trigger body might have moved the cursor.\n*/\nvoid sqlite3GenerateRowDelete(\n  Parse *pParse,     /* Parsing context */\n  Table *pTab,       /* Table containing the row to be deleted */\n  Trigger *pTrigger, /* List of triggers to (potentially) fire */\n  int iDataCur,      /* Cursor from which column data is extracted */\n  int iIdxCur,       /* First index cursor */\n  int iPk,           /* First memory cell containing the PRIMARY KEY */\n  i16 nPk,           /* Number of PRIMARY KEY memory cells */\n  u8 count,          /* If non-zero, increment the row change counter */\n  u8 onconf,         /* Default ON CONFLICT policy for triggers */\n  u8 eMode,          /* ONEPASS_OFF, _SINGLE, or _MULTI.  See above */\n  int iIdxNoSeek     /* Cursor number of cursor that does not need seeking */\n){\n  Vdbe *v = pParse->pVdbe;        /* Vdbe */\n  int iOld = 0;                   /* First register in OLD.* array */\n  int iLabel;                     /* Label resolved to end of generated code */\n  u8 opSeek;                      /* Seek opcode */\n\n  /* Vdbe is guaranteed to have been allocated by this stage. */\n  assert( v );\n  VdbeModuleComment((v, \"BEGIN: GenRowDel(%d,%d,%d,%d)\",\n                         iDataCur, iIdxCur, iPk, (int)nPk));\n\n  /* Seek cursor iCur to the row to delete. If this row no longer exists\n  ** (this can happen if a trigger program has already deleted it), do\n  ** not attempt to delete it or fire any DELETE triggers.  */\n  iLabel = sqlite3VdbeMakeLabel(pParse);\n  opSeek = HasRowid(pTab) ? OP_NotExists : OP_NotFound;\n  if( eMode==ONEPASS_OFF ){\n    sqlite3VdbeAddOp4Int(v, opSeek, iDataCur, iLabel, iPk, nPk);\n    VdbeCoverageIf(v, opSeek==OP_NotExists);\n    VdbeCoverageIf(v, opSeek==OP_NotFound);\n  }\n\n  /* If there are any triggers to fire, allocate a range of registers to\n  ** use for the old.* references in the triggers.  */\n  if( sqlite3FkRequired(pParse, pTab, 0, 0) || pTrigger ){\n    u32 mask;                     /* Mask of OLD.* columns in use */\n    int iCol;                     /* Iterator used while populating OLD.* */\n    int addrStart;                /* Start of BEFORE trigger programs */\n\n    /* TODO: Could use temporary registers here. Also could attempt to\n    ** avoid copying the contents of the rowid register.  */\n    mask = sqlite3TriggerColmask(\n        pParse, pTrigger, 0, 0, TRIGGER_BEFORE|TRIGGER_AFTER, pTab, onconf\n    );\n    mask |= sqlite3FkOldmask(pParse, pTab);\n    iOld = pParse->nMem+1;\n    pParse->nMem += (1 + pTab->nCol);\n\n    /* Populate the OLD.* pseudo-table register array. These values will be\n    ** used by any BEFORE and AFTER triggers that exist.  */\n    sqlite3VdbeAddOp2(v, OP_Copy, iPk, iOld);\n    for(iCol=0; iCol<pTab->nCol; iCol++){\n      testcase( mask!=0xffffffff && iCol==31 );\n      testcase( mask!=0xffffffff && iCol==32 );\n      if( mask==0xffffffff || (iCol<=31 && (mask & MASKBIT32(iCol))!=0) ){\n        int kk = sqlite3TableColumnToStorage(pTab, iCol);\n        sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, iCol, iOld+kk+1);\n      }\n    }\n\n    /* Invoke BEFORE DELETE trigger programs. */\n    addrStart = sqlite3VdbeCurrentAddr(v);\n    sqlite3CodeRowTrigger(pParse, pTrigger,\n        TK_DELETE, 0, TRIGGER_BEFORE, pTab, iOld, onconf, iLabel\n    );\n\n    /* If any BEFORE triggers were coded, then seek the cursor to the\n    ** row to be deleted again. It may be that the BEFORE triggers moved\n    ** the cursor or already deleted the row that the cursor was\n    ** pointing to.\n    **\n    ** Also disable the iIdxNoSeek optimization since the BEFORE trigger\n    ** may have moved that cursor.\n    */\n    if( addrStart<sqlite3VdbeCurrentAddr(v) ){\n      sqlite3VdbeAddOp4Int(v, opSeek, iDataCur, iLabel, iPk, nPk);\n      VdbeCoverageIf(v, opSeek==OP_NotExists);\n      VdbeCoverageIf(v, opSeek==OP_NotFound);\n      testcase( iIdxNoSeek>=0 );\n      iIdxNoSeek = -1;\n    }\n\n    /* Do FK processing. This call checks that any FK constraints that\n    ** refer to this table (i.e. constraints attached to other tables)\n    ** are not violated by deleting this row.  */\n    sqlite3FkCheck(pParse, pTab, iOld, 0, 0, 0);\n  }\n\n  /* Delete the index and table entries. Skip this step if pTab is really\n  ** a view (in which case the only effect of the DELETE statement is to\n  ** fire the INSTEAD OF triggers). \n  **\n  ** If variable 'count' is non-zero, then this OP_Delete instruction should\n  ** invoke the update-hook. The pre-update-hook, on the other hand should\n  ** be invoked unless table pTab is a system table. The difference is that\n  ** the update-hook is not invoked for rows removed by REPLACE, but the\n  ** pre-update-hook is.\n  */\n  if( !IsView(pTab) ){\n    u8 p5 = 0;\n    sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur,0,iIdxNoSeek);\n    sqlite3VdbeAddOp2(v, OP_Delete, iDataCur, (count?OPFLAG_NCHANGE:0));\n    if( pParse->nested==0 || 0==sqlite3_stricmp(pTab->zName, \"sqlite_stat1\") ){\n      sqlite3VdbeAppendP4(v, (char*)pTab, P4_TABLE);\n    }\n    if( eMode!=ONEPASS_OFF ){\n      sqlite3VdbeChangeP5(v, OPFLAG_AUXDELETE);\n    }\n    if( iIdxNoSeek>=0 && iIdxNoSeek!=iDataCur ){\n      sqlite3VdbeAddOp1(v, OP_Delete, iIdxNoSeek);\n    }\n    if( eMode==ONEPASS_MULTI ) p5 |= OPFLAG_SAVEPOSITION;\n    sqlite3VdbeChangeP5(v, p5);\n  }\n\n  /* Do any ON CASCADE, SET NULL or SET DEFAULT operations required to\n  ** handle rows (possibly in other tables) that refer via a foreign key\n  ** to the row just deleted. */\n  sqlite3FkActions(pParse, pTab, 0, iOld, 0, 0);\n\n  /* Invoke AFTER DELETE trigger programs. */\n  if( pTrigger ){\n    sqlite3CodeRowTrigger(pParse, pTrigger,\n        TK_DELETE, 0, TRIGGER_AFTER, pTab, iOld, onconf, iLabel\n    );\n  }\n\n  /* Jump here if the row had already been deleted before any BEFORE\n  ** trigger programs were invoked. Or if a trigger program throws a\n  ** RAISE(IGNORE) exception.  */\n  sqlite3VdbeResolveLabel(v, iLabel);\n  VdbeModuleComment((v, \"END: GenRowDel()\"));\n}\n\n/*\n** This routine generates VDBE code that causes the deletion of all\n** index entries associated with a single row of a single table, pTab\n**\n** Preconditions:\n**\n**   1.  A read/write cursor \"iDataCur\" must be open on the canonical storage\n**       btree for the table pTab.  (This will be either the table itself\n**       for rowid tables or to the primary key index for WITHOUT ROWID\n**       tables.)\n**\n**   2.  Read/write cursors for all indices of pTab must be open as\n**       cursor number iIdxCur+i for the i-th index.  (The pTab->pIndex\n**       index is the 0-th index.)\n**\n**   3.  The \"iDataCur\" cursor must be already be positioned on the row\n**       that is to be deleted.\n*/\nvoid sqlite3GenerateRowIndexDelete(\n  Parse *pParse,     /* Parsing and code generating context */\n  Table *pTab,       /* Table containing the row to be deleted */\n  int iDataCur,      /* Cursor of table holding data. */\n  int iIdxCur,       /* First index cursor */\n  int *aRegIdx,      /* Only delete if aRegIdx!=0 && aRegIdx[i]>0 */\n  int iIdxNoSeek     /* Do not delete from this cursor */\n){\n  int i;             /* Index loop counter */\n  int r1 = -1;       /* Register holding an index key */\n  int iPartIdxLabel; /* Jump destination for skipping partial index entries */\n  Index *pIdx;       /* Current index */\n  Index *pPrior = 0; /* Prior index */\n  Vdbe *v;           /* The prepared statement under construction */\n  Index *pPk;        /* PRIMARY KEY index, or NULL for rowid tables */\n\n  v = pParse->pVdbe;\n  pPk = HasRowid(pTab) ? 0 : sqlite3PrimaryKeyIndex(pTab);\n  for(i=0, pIdx=pTab->pIndex; pIdx; i++, pIdx=pIdx->pNext){\n    assert( iIdxCur+i!=iDataCur || pPk==pIdx );\n    if( aRegIdx!=0 && aRegIdx[i]==0 ) continue;\n    if( pIdx==pPk ) continue;\n    if( iIdxCur+i==iIdxNoSeek ) continue;\n    VdbeModuleComment((v, \"GenRowIdxDel for %s\", pIdx->zName));\n    r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 1,\n        &iPartIdxLabel, pPrior, r1);\n    sqlite3VdbeAddOp3(v, OP_IdxDelete, iIdxCur+i, r1,\n        pIdx->uniqNotNull ? pIdx->nKeyCol : pIdx->nColumn);\n    sqlite3ResolvePartIdxLabel(pParse, iPartIdxLabel);\n    pPrior = pIdx;\n  }\n}\n\n/*\n** Generate code that will assemble an index key and stores it in register\n** regOut.  The key with be for index pIdx which is an index on pTab.\n** iCur is the index of a cursor open on the pTab table and pointing to\n** the entry that needs indexing.  If pTab is a WITHOUT ROWID table, then\n** iCur must be the cursor of the PRIMARY KEY index.\n**\n** Return a register number which is the first in a block of\n** registers that holds the elements of the index key.  The\n** block of registers has already been deallocated by the time\n** this routine returns.\n**\n** If *piPartIdxLabel is not NULL, fill it in with a label and jump\n** to that label if pIdx is a partial index that should be skipped.\n** The label should be resolved using sqlite3ResolvePartIdxLabel().\n** A partial index should be skipped if its WHERE clause evaluates\n** to false or null.  If pIdx is not a partial index, *piPartIdxLabel\n** will be set to zero which is an empty label that is ignored by\n** sqlite3ResolvePartIdxLabel().\n**\n** The pPrior and regPrior parameters are used to implement a cache to\n** avoid unnecessary register loads.  If pPrior is not NULL, then it is\n** a pointer to a different index for which an index key has just been\n** computed into register regPrior.  If the current pIdx index is generating\n** its key into the same sequence of registers and if pPrior and pIdx share\n** a column in common, then the register corresponding to that column already\n** holds the correct value and the loading of that register is skipped.\n** This optimization is helpful when doing a DELETE or an INTEGRITY_CHECK\n** on a table with multiple indices, and especially with the ROWID or\n** PRIMARY KEY columns of the index.\n*/\nint sqlite3GenerateIndexKey(\n  Parse *pParse,       /* Parsing context */\n  Index *pIdx,         /* The index for which to generate a key */\n  int iDataCur,        /* Cursor number from which to take column data */\n  int regOut,          /* Put the new key into this register if not 0 */\n  int prefixOnly,      /* Compute only a unique prefix of the key */\n  int *piPartIdxLabel, /* OUT: Jump to this label to skip partial index */\n  Index *pPrior,       /* Previously generated index key */\n  int regPrior         /* Register holding previous generated key */\n){\n  Vdbe *v = pParse->pVdbe;\n  int j;\n  int regBase;\n  int nCol;\n\n  if( piPartIdxLabel ){\n    if( pIdx->pPartIdxWhere ){\n      *piPartIdxLabel = sqlite3VdbeMakeLabel(pParse);\n      pParse->iSelfTab = iDataCur + 1;\n      sqlite3ExprIfFalseDup(pParse, pIdx->pPartIdxWhere, *piPartIdxLabel,\n                            SQLITE_JUMPIFNULL);\n      pParse->iSelfTab = 0;\n      pPrior = 0; /* Ticket a9efb42811fa41ee 2019-11-02;\n                  ** pPartIdxWhere may have corrupted regPrior registers */\n    }else{\n      *piPartIdxLabel = 0;\n    }\n  }\n  nCol = (prefixOnly && pIdx->uniqNotNull) ? pIdx->nKeyCol : pIdx->nColumn;\n  regBase = sqlite3GetTempRange(pParse, nCol);\n  if( pPrior && (regBase!=regPrior || pPrior->pPartIdxWhere) ) pPrior = 0;\n  for(j=0; j<nCol; j++){\n    if( pPrior\n     && pPrior->aiColumn[j]==pIdx->aiColumn[j]\n     && pPrior->aiColumn[j]!=XN_EXPR\n    ){\n      /* This column was already computed by the previous index */\n      continue;\n    }\n    sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, iDataCur, j, regBase+j);\n    if( pIdx->aiColumn[j]>=0 ){\n      /* If the column affinity is REAL but the number is an integer, then it\n      ** might be stored in the table as an integer (using a compact\n      ** representation) then converted to REAL by an OP_RealAffinity opcode.\n      ** But we are getting ready to store this value back into an index, where\n      ** it should be converted by to INTEGER again.  So omit the\n      ** OP_RealAffinity opcode if it is present */\n      sqlite3VdbeDeletePriorOpcode(v, OP_RealAffinity);\n    }\n  }\n  if( regOut ){\n    sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase, nCol, regOut);\n  }\n  sqlite3ReleaseTempRange(pParse, regBase, nCol);\n  return regBase;\n}\n\n/*\n** If a prior call to sqlite3GenerateIndexKey() generated a jump-over label\n** because it was a partial index, then this routine should be called to\n** resolve that label.\n*/\nvoid sqlite3ResolvePartIdxLabel(Parse *pParse, int iLabel){\n  if( iLabel ){\n    sqlite3VdbeResolveLabel(pParse->pVdbe, iLabel);\n  }\n}\n"}
{"repo": "sqlite", "file": "test_loadext.c", "lang": "C++", "code": "/*\n** 2006 June 14\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** Test extension for testing the sqlite3_load_extension() function.\n*/\n#include <string.h>\n#include \"sqlite3ext.h\"\nSQLITE_EXTENSION_INIT1\n\n/*\n** The half() SQL function returns half of its input value.\n*/\nstatic void halfFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  sqlite3_result_double(context, 0.5*sqlite3_value_double(argv[0]));\n}\n\n/*\n** SQL functions to call the sqlite3_status function and return results.\n*/\nstatic void statusFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  int op = 0, mx, cur, resetFlag, rc;\n  if( sqlite3_value_type(argv[0])==SQLITE_INTEGER ){\n    op = sqlite3_value_int(argv[0]);\n  }else if( sqlite3_value_type(argv[0])==SQLITE_TEXT ){\n    int i;\n    const char *zName;\n    static const struct {\n      const char *zName;\n      int op;\n    } aOp[] = {\n      { \"MEMORY_USED\",         SQLITE_STATUS_MEMORY_USED         },\n      { \"PAGECACHE_USED\",      SQLITE_STATUS_PAGECACHE_USED      },\n      { \"PAGECACHE_OVERFLOW\",  SQLITE_STATUS_PAGECACHE_OVERFLOW  },\n      { \"SCRATCH_USED\",        SQLITE_STATUS_SCRATCH_USED        },\n      { \"SCRATCH_OVERFLOW\",    SQLITE_STATUS_SCRATCH_OVERFLOW    },\n      { \"MALLOC_SIZE\",         SQLITE_STATUS_MALLOC_SIZE         },\n    };\n    int nOp = sizeof(aOp)/sizeof(aOp[0]);\n    zName = (const char*)sqlite3_value_text(argv[0]);\n    for(i=0; i<nOp; i++){\n      if( strcmp(aOp[i].zName, zName)==0 ){\n        op = aOp[i].op;\n        break;\n      }\n    }\n    if( i>=nOp ){\n      char *zMsg = sqlite3_mprintf(\"unknown status property: %s\", zName);\n      sqlite3_result_error(context, zMsg, -1);\n      sqlite3_free(zMsg);\n      return;\n    }\n  }else{\n    sqlite3_result_error(context, \"unknown status type\", -1);\n    return;\n  }\n  if( argc==2 ){\n    resetFlag = sqlite3_value_int(argv[1]);\n  }else{\n    resetFlag = 0;\n  }\n  rc = sqlite3_status(op, &cur, &mx, resetFlag);\n  if( rc!=SQLITE_OK ){\n    char *zMsg = sqlite3_mprintf(\"sqlite3_status(%d,...) returns %d\", op, rc);\n    sqlite3_result_error(context, zMsg, -1);\n    sqlite3_free(zMsg);\n    return;\n  } \n  if( argc==2 ){\n    sqlite3_result_int(context, mx);\n  }else{\n    sqlite3_result_int(context, cur);\n  }\n}\n\n/*\n** Extension load function.\n*/\n#ifdef _WIN32\n__declspec(dllexport)\n#endif\nint testloadext_init(\n  sqlite3 *db, \n  char **pzErrMsg, \n  const sqlite3_api_routines *pApi\n){\n  int nErr = 0;\n  SQLITE_EXTENSION_INIT2(pApi);\n  nErr |= sqlite3_create_function(db, \"half\", 1, SQLITE_ANY, 0, halfFunc, 0, 0);\n  nErr |= sqlite3_create_function(db, \"sqlite3_status\", 1, SQLITE_ANY, 0,\n                          statusFunc, 0, 0);\n  nErr |= sqlite3_create_function(db, \"sqlite3_status\", 2, SQLITE_ANY, 0,\n                          statusFunc, 0, 0);\n  return nErr ? SQLITE_ERROR : SQLITE_OK;\n}\n\n/*\n** Another extension entry point. This one always fails.\n*/\n#ifdef _WIN32\n__declspec(dllexport)\n#endif\nint testbrokenext_init(\n  sqlite3 *db, \n  char **pzErrMsg, \n  const sqlite3_api_routines *pApi\n){\n  char *zErr;\n  SQLITE_EXTENSION_INIT2(pApi);\n  zErr = sqlite3_mprintf(\"broken!\");\n  *pzErrMsg = zErr;\n  return 1;\n}\n"}
{"repo": "sqlite", "file": "test_btree.c", "lang": "C++", "code": "/*\n** 2007 May 05\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** Code for testing the btree.c module in SQLite.  This code\n** is not included in the SQLite library.  It is used for automated\n** testing of the SQLite library.\n*/\n#include \"btreeInt.h\"\n#include \"tclsqlite.h\"\n\n/*\n** Usage: sqlite3_shared_cache_report\n**\n** Return a list of file that are shared and the number of\n** references to each file.\n*/\nint SQLITE_TCLAPI sqlite3BtreeSharedCacheReport(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n#ifndef SQLITE_OMIT_SHARED_CACHE\n  extern BtShared *sqlite3SharedCacheList;\n  BtShared *pBt;\n  Tcl_Obj *pRet = Tcl_NewObj();\n  for(pBt=GLOBAL(BtShared*,sqlite3SharedCacheList); pBt; pBt=pBt->pNext){\n    const char *zFile = sqlite3PagerFilename(pBt->pPager, 1);\n    Tcl_ListObjAppendElement(interp, pRet, Tcl_NewStringObj(zFile, -1));\n    Tcl_ListObjAppendElement(interp, pRet, Tcl_NewIntObj(pBt->nRef));\n  }\n  Tcl_SetObjResult(interp, pRet);\n#endif\n  return TCL_OK;\n}\n\n/*\n** Print debugging information about all cursors to standard output.\n*/\nvoid sqlite3BtreeCursorList(Btree *p){\n#ifdef SQLITE_DEBUG\n  BtCursor *pCur;\n  BtShared *pBt = p->pBt;\n  for(pCur=pBt->pCursor; pCur; pCur=pCur->pNext){\n    MemPage *pPage = pCur->apPage[pCur->iPage];\n    char *zMode = (pCur->curFlags & BTCF_WriteFlag) ? \"rw\" : \"ro\";\n    sqlite3DebugPrintf(\"CURSOR %p rooted at %4d(%s) currently at %d.%d%s\\n\",\n       pCur, pCur->pgnoRoot, zMode,\n       pPage ? pPage->pgno : 0, pCur->aiIdx[pCur->iPage],\n       (pCur->eState==CURSOR_VALID) ? \"\" : \" eof\"\n    );\n  }\n#endif\n}\n"}
{"repo": "sqlite", "file": "attach.c", "lang": "C++", "code": "/*\n** 2003 April 6\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains code used to implement the ATTACH and DETACH commands.\n*/\n#include \"sqliteInt.h\"\n\n#ifndef SQLITE_OMIT_ATTACH\n/*\n** Resolve an expression that was part of an ATTACH or DETACH statement. This\n** is slightly different from resolving a normal SQL expression, because simple\n** identifiers are treated as strings, not possible column names or aliases.\n**\n** i.e. if the parser sees:\n**\n**     ATTACH DATABASE abc AS def\n**\n** it treats the two expressions as literal strings 'abc' and 'def' instead of\n** looking for columns of the same name.\n**\n** This only applies to the root node of pExpr, so the statement:\n**\n**     ATTACH DATABASE abc||def AS 'db2'\n**\n** will fail because neither abc or def can be resolved.\n*/\nstatic int resolveAttachExpr(NameContext *pName, Expr *pExpr)\n{\n  int rc = SQLITE_OK;\n  if( pExpr ){\n    if( pExpr->op!=TK_ID ){\n      rc = sqlite3ResolveExprNames(pName, pExpr);\n    }else{\n      pExpr->op = TK_STRING;\n    }\n  }\n  return rc;\n}\n\n/*\n** Return true if zName points to a name that may be used to refer to\n** database iDb attached to handle db.\n*/\nint sqlite3DbIsNamed(sqlite3 *db, int iDb, const char *zName){\n  return (\n      sqlite3StrICmp(db->aDb[iDb].zDbSName, zName)==0\n   || (iDb==0 && sqlite3StrICmp(\"main\", zName)==0)\n  );\n}\n\n/*\n** An SQL user-function registered to do the work of an ATTACH statement. The\n** three arguments to the function come directly from an attach statement:\n**\n**     ATTACH DATABASE x AS y KEY z\n**\n**     SELECT sqlite_attach(x, y, z)\n**\n** If the optional \"KEY z\" syntax is omitted, an SQL NULL is passed as the\n** third argument.\n**\n** If the db->init.reopenMemdb flags is set, then instead of attaching a\n** new database, close the database on db->init.iDb and reopen it as an\n** empty MemDB.\n*/\nstatic void attachFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **argv\n){\n  int i;\n  int rc = 0;\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  const char *zName;\n  const char *zFile;\n  char *zPath = 0;\n  char *zErr = 0;\n  unsigned int flags;\n  Db *aNew;                 /* New array of Db pointers */\n  Db *pNew = 0;             /* Db object for the newly attached database */\n  char *zErrDyn = 0;\n  sqlite3_vfs *pVfs;\n\n  UNUSED_PARAMETER(NotUsed);\n  zFile = (const char *)sqlite3_value_text(argv[0]);\n  zName = (const char *)sqlite3_value_text(argv[1]);\n  if( zFile==0 ) zFile = \"\";\n  if( zName==0 ) zName = \"\";\n\n#ifndef SQLITE_OMIT_DESERIALIZE\n# define REOPEN_AS_MEMDB(db)  (db->init.reopenMemdb)\n#else\n# define REOPEN_AS_MEMDB(db)  (0)\n#endif\n\n  if( REOPEN_AS_MEMDB(db) ){\n    /* This is not a real ATTACH.  Instead, this routine is being called\n    ** from sqlite3_deserialize() to close database db->init.iDb and\n    ** reopen it as a MemDB */\n    Btree *pNewBt = 0;\n    pVfs = sqlite3_vfs_find(\"memdb\");\n    if( pVfs==0 ) return;\n    rc = sqlite3BtreeOpen(pVfs, \"x\\0\", db, &pNewBt, 0, SQLITE_OPEN_MAIN_DB);\n    if( rc==SQLITE_OK ){\n      Schema *pNewSchema = sqlite3SchemaGet(db, pNewBt);\n      if( pNewSchema ){\n        /* Both the Btree and the new Schema were allocated successfully.\n        ** Close the old db and update the aDb[] slot with the new memdb\n        ** values.  */\n        pNew = &db->aDb[db->init.iDb];\n        if( ALWAYS(pNew->pBt) ) sqlite3BtreeClose(pNew->pBt);\n        pNew->pBt = pNewBt;\n        pNew->pSchema = pNewSchema;\n      }else{\n        sqlite3BtreeClose(pNewBt);\n        rc = SQLITE_NOMEM;\n      }\n    }\n    if( rc ) goto attach_error;\n  }else{\n    /* This is a real ATTACH\n    **\n    ** Check for the following errors:\n    **\n    **     * Too many attached databases,\n    **     * Transaction currently open\n    **     * Specified database name already being used.\n    */\n    if( db->nDb>=db->aLimit[SQLITE_LIMIT_ATTACHED]+2 ){\n      zErrDyn = sqlite3MPrintf(db, \"too many attached databases - max %d\", \n        db->aLimit[SQLITE_LIMIT_ATTACHED]\n      );\n      goto attach_error;\n    }\n    for(i=0; i<db->nDb; i++){\n      assert( zName );\n      if( sqlite3DbIsNamed(db, i, zName) ){\n        zErrDyn = sqlite3MPrintf(db, \"database %s is already in use\", zName);\n        goto attach_error;\n      }\n    }\n  \n    /* Allocate the new entry in the db->aDb[] array and initialize the schema\n    ** hash tables.\n    */\n    if( db->aDb==db->aDbStatic ){\n      aNew = sqlite3DbMallocRawNN(db, sizeof(db->aDb[0])*3 );\n      if( aNew==0 ) return;\n      memcpy(aNew, db->aDb, sizeof(db->aDb[0])*2);\n    }else{\n      aNew = sqlite3DbRealloc(db, db->aDb, sizeof(db->aDb[0])*(1+(i64)db->nDb));\n      if( aNew==0 ) return;\n    }\n    db->aDb = aNew;\n    pNew = &db->aDb[db->nDb];\n    memset(pNew, 0, sizeof(*pNew));\n  \n    /* Open the database file. If the btree is successfully opened, use\n    ** it to obtain the database schema. At this point the schema may\n    ** or may not be initialized.\n    */\n    flags = db->openFlags;\n    rc = sqlite3ParseUri(db->pVfs->zName, zFile, &flags, &pVfs, &zPath, &zErr);\n    if( rc!=SQLITE_OK ){\n      if( rc==SQLITE_NOMEM ) sqlite3OomFault(db);\n      sqlite3_result_error(context, zErr, -1);\n      sqlite3_free(zErr);\n      return;\n    }\n    if( (db->flags & SQLITE_AttachWrite)==0 ){\n      flags &= ~(SQLITE_OPEN_CREATE|SQLITE_OPEN_READWRITE);\n      flags |= SQLITE_OPEN_READONLY;\n    }else if( (db->flags & SQLITE_AttachCreate)==0 ){\n      flags &= ~SQLITE_OPEN_CREATE;\n    }\n    assert( pVfs );\n    flags |= SQLITE_OPEN_MAIN_DB;\n    rc = sqlite3BtreeOpen(pVfs, zPath, db, &pNew->pBt, 0, flags);\n    db->nDb++;\n    pNew->zDbSName = sqlite3DbStrDup(db, zName);\n  }\n  db->noSharedCache = 0;\n  if( rc==SQLITE_CONSTRAINT ){\n    rc = SQLITE_ERROR;\n    zErrDyn = sqlite3MPrintf(db, \"database is already attached\");\n  }else if( rc==SQLITE_OK ){\n    Pager *pPager;\n    pNew->pSchema = sqlite3SchemaGet(db, pNew->pBt);\n    if( !pNew->pSchema ){\n      rc = SQLITE_NOMEM_BKPT;\n    }else if( pNew->pSchema->file_format && pNew->pSchema->enc!=ENC(db) ){\n      zErrDyn = sqlite3MPrintf(db, \n        \"attached databases must use the same text encoding as main database\");\n      rc = SQLITE_ERROR;\n    }\n    sqlite3BtreeEnter(pNew->pBt);\n    pPager = sqlite3BtreePager(pNew->pBt);\n    sqlite3PagerLockingMode(pPager, db->dfltLockMode);\n    sqlite3BtreeSecureDelete(pNew->pBt,\n                             sqlite3BtreeSecureDelete(db->aDb[0].pBt,-1) );\n#ifndef SQLITE_OMIT_PAGER_PRAGMAS\n    sqlite3BtreeSetPagerFlags(pNew->pBt,\n                      PAGER_SYNCHRONOUS_FULL | (db->flags & PAGER_FLAGS_MASK));\n#endif\n    sqlite3BtreeLeave(pNew->pBt);\n  }\n  pNew->safety_level = SQLITE_DEFAULT_SYNCHRONOUS+1;\n  if( rc==SQLITE_OK && pNew->zDbSName==0 ){\n    rc = SQLITE_NOMEM_BKPT;\n  }\n  sqlite3_free_filename( zPath );\n\n  /* If the file was opened successfully, read the schema for the new database.\n  ** If this fails, or if opening the file failed, then close the file and \n  ** remove the entry from the db->aDb[] array. i.e. put everything back the\n  ** way we found it.\n  */\n  if( rc==SQLITE_OK ){\n    sqlite3BtreeEnterAll(db);\n    db->init.iDb = 0;\n    db->mDbFlags &= ~(DBFLAG_SchemaKnownOk);\n#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n    if( db->setlkFlags & SQLITE_SETLK_BLOCK_ON_CONNECT ){\n      int val = 1;\n      sqlite3_file *fd = sqlite3PagerFile(sqlite3BtreePager(pNew->pBt));\n      sqlite3OsFileControlHint(fd, SQLITE_FCNTL_BLOCK_ON_CONNECT, &val);\n    }\n#endif\n    if( !REOPEN_AS_MEMDB(db) ){\n      rc = sqlite3Init(db, &zErrDyn);\n    }\n    sqlite3BtreeLeaveAll(db);\n    assert( zErrDyn==0 || rc!=SQLITE_OK );\n  }\n  if( rc ){\n    if( ALWAYS(!REOPEN_AS_MEMDB(db)) ){\n      int iDb = db->nDb - 1;\n      assert( iDb>=2 );\n      if( db->aDb[iDb].pBt ){\n        sqlite3BtreeClose(db->aDb[iDb].pBt);\n        db->aDb[iDb].pBt = 0;\n        db->aDb[iDb].pSchema = 0;\n      }\n      sqlite3ResetAllSchemasOfConnection(db);\n      db->nDb = iDb;\n      if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ){\n        sqlite3OomFault(db);\n        sqlite3DbFree(db, zErrDyn);\n        zErrDyn = sqlite3MPrintf(db, \"out of memory\");\n      }else if( zErrDyn==0 ){\n        zErrDyn = sqlite3MPrintf(db, \"unable to open database: %s\", zFile);\n      }\n    }\n    goto attach_error;\n  }\n  \n  return;\n\nattach_error:\n  /* Return an error if we get here */\n  if( zErrDyn ){\n    sqlite3_result_error(context, zErrDyn, -1);\n    sqlite3DbFree(db, zErrDyn);\n  }\n  if( rc ) sqlite3_result_error_code(context, rc);\n}\n\n/*\n** An SQL user-function registered to do the work of an DETACH statement. The\n** three arguments to the function come directly from a detach statement:\n**\n**     DETACH DATABASE x\n**\n**     SELECT sqlite_detach(x)\n*/\nstatic void detachFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **argv\n){\n  const char *zName = (const char *)sqlite3_value_text(argv[0]);\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  int i;\n  Db *pDb = 0;\n  HashElem *pEntry;\n  char zErr[128];\n\n  UNUSED_PARAMETER(NotUsed);\n\n  if( zName==0 ) zName = \"\";\n  for(i=0; i<db->nDb; i++){\n    pDb = &db->aDb[i];\n    if( pDb->pBt==0 ) continue;\n    if( sqlite3DbIsNamed(db, i, zName) ) break;\n  }\n\n  if( i>=db->nDb ){\n    sqlite3_snprintf(sizeof(zErr),zErr, \"no such database: %s\", zName);\n    goto detach_error;\n  }\n  if( i<2 ){\n    sqlite3_snprintf(sizeof(zErr),zErr, \"cannot detach database %s\", zName);\n    goto detach_error;\n  }\n  if( sqlite3BtreeTxnState(pDb->pBt)!=SQLITE_TXN_NONE\n   || sqlite3BtreeIsInBackup(pDb->pBt)\n  ){\n    sqlite3_snprintf(sizeof(zErr),zErr, \"database %s is locked\", zName);\n    goto detach_error;\n  }\n\n  /* If any TEMP triggers reference the schema being detached, move those\n  ** triggers to reference the TEMP schema itself. */\n  assert( db->aDb[1].pSchema );\n  pEntry = sqliteHashFirst(&db->aDb[1].pSchema->trigHash);\n  while( pEntry ){\n    Trigger *pTrig = (Trigger*)sqliteHashData(pEntry);\n    if( pTrig->pTabSchema==pDb->pSchema ){\n      pTrig->pTabSchema = pTrig->pSchema;\n    }\n    pEntry = sqliteHashNext(pEntry);\n  }\n\n  sqlite3BtreeClose(pDb->pBt);\n  pDb->pBt = 0;\n  pDb->pSchema = 0;\n  sqlite3CollapseDatabaseArray(db);\n  return;\n\ndetach_error:\n  sqlite3_result_error(context, zErr, -1);\n}\n\n/*\n** This procedure generates VDBE code for a single invocation of either the\n** sqlite_detach() or sqlite_attach() SQL user functions.\n*/\nstatic void codeAttach(\n  Parse *pParse,       /* The parser context */\n  int type,            /* Either SQLITE_ATTACH or SQLITE_DETACH */\n  FuncDef const *pFunc,/* FuncDef wrapper for detachFunc() or attachFunc() */\n  Expr *pAuthArg,      /* Expression to pass to authorization callback */\n  Expr *pFilename,     /* Name of database file */\n  Expr *pDbname,       /* Name of the database to use internally */\n  Expr *pKey           /* Database key for encryption extension */\n){\n  int rc;\n  NameContext sName;\n  Vdbe *v;\n  sqlite3* db = pParse->db;\n  int regArgs;\n\n  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ) goto attach_end;\n\n  if( pParse->nErr ) goto attach_end;\n  memset(&sName, 0, sizeof(NameContext));\n  sName.pParse = pParse;\n\n  if( \n      SQLITE_OK!=resolveAttachExpr(&sName, pFilename) ||\n      SQLITE_OK!=resolveAttachExpr(&sName, pDbname) ||\n      SQLITE_OK!=resolveAttachExpr(&sName, pKey)\n  ){\n    goto attach_end;\n  }\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  if( ALWAYS(pAuthArg) ){\n    char *zAuthArg;\n    if( pAuthArg->op==TK_STRING ){\n      assert( !ExprHasProperty(pAuthArg, EP_IntValue) );\n      zAuthArg = pAuthArg->u.zToken;\n    }else{\n      zAuthArg = 0;\n    }\n    rc = sqlite3AuthCheck(pParse, type, zAuthArg, 0, 0);\n    if(rc!=SQLITE_OK ){\n      goto attach_end;\n    }\n  }\n#endif /* SQLITE_OMIT_AUTHORIZATION */\n\n\n  v = sqlite3GetVdbe(pParse);\n  regArgs = sqlite3GetTempRange(pParse, 4);\n  sqlite3ExprCode(pParse, pFilename, regArgs);\n  sqlite3ExprCode(pParse, pDbname, regArgs+1);\n  sqlite3ExprCode(pParse, pKey, regArgs+2);\n\n  assert( v || db->mallocFailed );\n  if( v ){\n    sqlite3VdbeAddFunctionCall(pParse, 0, regArgs+3-pFunc->nArg, regArgs+3,\n                               pFunc->nArg, pFunc, 0);\n    /* Code an OP_Expire. For an ATTACH statement, set P1 to true (expire this\n    ** statement only). For DETACH, set it to false (expire all existing\n    ** statements).\n    */\n    sqlite3VdbeAddOp1(v, OP_Expire, (type==SQLITE_ATTACH));\n  }\n  \nattach_end:\n  sqlite3ExprDelete(db, pFilename);\n  sqlite3ExprDelete(db, pDbname);\n  sqlite3ExprDelete(db, pKey);\n}\n\n/*\n** Called by the parser to compile a DETACH statement.\n**\n**     DETACH pDbname\n*/\nvoid sqlite3Detach(Parse *pParse, Expr *pDbname){\n  static const FuncDef detach_func = {\n    1,                /* nArg */\n    SQLITE_UTF8,      /* funcFlags */\n    0,                /* pUserData */\n    0,                /* pNext */\n    detachFunc,       /* xSFunc */\n    0,                /* xFinalize */\n    0, 0,             /* xValue, xInverse */\n    \"sqlite_detach\",  /* zName */\n    {0}\n  };\n  codeAttach(pParse, SQLITE_DETACH, &detach_func, pDbname, 0, 0, pDbname);\n}\n\n/*\n** Called by the parser to compile an ATTACH statement.\n**\n**     ATTACH p AS pDbname KEY pKey\n*/\nvoid sqlite3Attach(Parse *pParse, Expr *p, Expr *pDbname, Expr *pKey){\n  static const FuncDef attach_func = {\n    3,                /* nArg */\n    SQLITE_UTF8,      /* funcFlags */\n    0,                /* pUserData */\n    0,                /* pNext */\n    attachFunc,       /* xSFunc */\n    0,                /* xFinalize */\n    0, 0,             /* xValue, xInverse */\n    \"sqlite_attach\",  /* zName */\n    {0}\n  };\n  codeAttach(pParse, SQLITE_ATTACH, &attach_func, p, p, pDbname, pKey);\n}\n#endif /* SQLITE_OMIT_ATTACH */\n\n/*\n** Expression callback used by sqlite3FixAAAA() routines.\n*/\nstatic int fixExprCb(Walker *p, Expr *pExpr){\n  DbFixer *pFix = p->u.pFix;\n  if( !pFix->bTemp ) ExprSetProperty(pExpr, EP_FromDDL);\n  if( pExpr->op==TK_VARIABLE ){\n    if( pFix->pParse->db->init.busy ){\n      pExpr->op = TK_NULL;\n    }else{\n      sqlite3ErrorMsg(pFix->pParse, \"%s cannot use variables\", pFix->zType);\n      return WRC_Abort;\n    }\n  }\n  return WRC_Continue;\n}\n\n/*\n** Select callback used by sqlite3FixAAAA() routines.\n*/\nstatic int fixSelectCb(Walker *p, Select *pSelect){\n  DbFixer *pFix = p->u.pFix;\n  int i;\n  SrcItem *pItem;\n  sqlite3 *db = pFix->pParse->db;\n  int iDb = sqlite3FindDbName(db, pFix->zDb);\n  SrcList *pList = pSelect->pSrc;\n\n  if( NEVER(pList==0) ) return WRC_Continue;\n  for(i=0, pItem=pList->a; i<pList->nSrc; i++, pItem++){\n    if( pFix->bTemp==0 && pItem->fg.isSubquery==0 ){\n      if( pItem->fg.fixedSchema==0 && pItem->u4.zDatabase!=0 ){\n        if( iDb!=sqlite3FindDbName(db, pItem->u4.zDatabase) ){\n          sqlite3ErrorMsg(pFix->pParse,\n              \"%s %T cannot reference objects in database %s\",\n              pFix->zType, pFix->pName, pItem->u4.zDatabase);\n          return WRC_Abort;\n        }\n        sqlite3DbFree(db, pItem->u4.zDatabase);\n        pItem->fg.notCte = 1;\n        pItem->fg.hadSchema = 1;\n      }\n      pItem->u4.pSchema = pFix->pSchema;\n      pItem->fg.fromDDL = 1;\n      pItem->fg.fixedSchema = 1;\n    }\n#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER)\n    if( pList->a[i].fg.isUsing==0\n     && sqlite3WalkExpr(&pFix->w, pList->a[i].u3.pOn)\n    ){\n      return WRC_Abort;\n    }\n#endif\n  }\n  if( pSelect->pWith ){\n    for(i=0; i<pSelect->pWith->nCte; i++){\n      if( sqlite3WalkSelect(p, pSelect->pWith->a[i].pSelect) ){\n        return WRC_Abort;\n      }\n    }\n  }\n  return WRC_Continue;\n}\n\n/*\n** Initialize a DbFixer structure.  This routine must be called prior\n** to passing the structure to one of the sqliteFixAAAA() routines below.\n*/\nvoid sqlite3FixInit(\n  DbFixer *pFix,      /* The fixer to be initialized */\n  Parse *pParse,      /* Error messages will be written here */\n  int iDb,            /* This is the database that must be used */\n  const char *zType,  /* \"view\", \"trigger\", or \"index\" */\n  const Token *pName  /* Name of the view, trigger, or index */\n){\n  sqlite3 *db = pParse->db;\n  assert( db->nDb>iDb );\n  pFix->pParse = pParse;\n  pFix->zDb = db->aDb[iDb].zDbSName;\n  pFix->pSchema = db->aDb[iDb].pSchema;\n  pFix->zType = zType;\n  pFix->pName = pName;\n  pFix->bTemp = (iDb==1);\n  pFix->w.pParse = pParse;\n  pFix->w.xExprCallback = fixExprCb;\n  pFix->w.xSelectCallback = fixSelectCb;\n  pFix->w.xSelectCallback2 = sqlite3WalkWinDefnDummyCallback;\n  pFix->w.walkerDepth = 0;\n  pFix->w.eCode = 0;\n  pFix->w.u.pFix = pFix;\n}\n\n/*\n** The following set of routines walk through the parse tree and assign\n** a specific database to all table references where the database name\n** was left unspecified in the original SQL statement.  The pFix structure\n** must have been initialized by a prior call to sqlite3FixInit().\n**\n** These routines are used to make sure that an index, trigger, or\n** view in one database does not refer to objects in a different database.\n** (Exception: indices, triggers, and views in the TEMP database are\n** allowed to refer to anything.)  If a reference is explicitly made\n** to an object in a different database, an error message is added to\n** pParse->zErrMsg and these routines return non-zero.  If everything\n** checks out, these routines return 0.\n*/\nint sqlite3FixSrcList(\n  DbFixer *pFix,       /* Context of the fixation */\n  SrcList *pList       /* The Source list to check and modify */\n){\n  int res = 0;\n  if( pList ){\n    Select s; \n    memset(&s, 0, sizeof(s));\n    s.pSrc = pList;\n    res = sqlite3WalkSelect(&pFix->w, &s);\n  }\n  return res;\n}\n#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER)\nint sqlite3FixSelect(\n  DbFixer *pFix,       /* Context of the fixation */\n  Select *pSelect      /* The SELECT statement to be fixed to one database */\n){\n  return sqlite3WalkSelect(&pFix->w, pSelect);\n}\nint sqlite3FixExpr(\n  DbFixer *pFix,     /* Context of the fixation */\n  Expr *pExpr        /* The expression to be fixed to one database */\n){\n  return sqlite3WalkExpr(&pFix->w, pExpr);\n}\n#endif\n\n#ifndef SQLITE_OMIT_TRIGGER\nint sqlite3FixTriggerStep(\n  DbFixer *pFix,     /* Context of the fixation */\n  TriggerStep *pStep /* The trigger step be fixed to one database */\n){\n  while( pStep ){\n    if( sqlite3WalkSelect(&pFix->w, pStep->pSelect)\n     || sqlite3WalkExpr(&pFix->w, pStep->pWhere) \n     || sqlite3WalkExprList(&pFix->w, pStep->pExprList)\n     || sqlite3FixSrcList(pFix, pStep->pSrc)\n    ){\n      return 1;\n    }\n#ifndef SQLITE_OMIT_UPSERT\n    {\n      Upsert *pUp;\n      for(pUp=pStep->pUpsert; pUp; pUp=pUp->pNextUpsert){\n        if( sqlite3WalkExprList(&pFix->w, pUp->pUpsertTarget)\n         || sqlite3WalkExpr(&pFix->w, pUp->pUpsertTargetWhere)\n         || sqlite3WalkExprList(&pFix->w, pUp->pUpsertSet)\n         || sqlite3WalkExpr(&pFix->w, pUp->pUpsertWhere)\n        ){\n          return 1;\n        }\n      }\n    }\n#endif\n    pStep = pStep->pNext;\n  }\n\n  return 0;\n}\n#endif\n"}
{"repo": "sqlite", "file": "threads.c", "lang": "C++", "code": "/*\n** 2012 July 21\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This file presents a simple cross-platform threading interface for\n** use internally by SQLite.\n**\n** A \"thread\" can be created using sqlite3ThreadCreate().  This thread\n** runs independently of its creator until it is joined using\n** sqlite3ThreadJoin(), at which point it terminates.\n**\n** Threads do not have to be real.  It could be that the work of the\n** \"thread\" is done by the main thread at either the sqlite3ThreadCreate()\n** or sqlite3ThreadJoin() call.  This is, in fact, what happens in\n** single threaded systems.  Nothing in SQLite requires multiple threads.\n** This interface exists so that applications that want to take advantage\n** of multiple cores can do so, while also allowing applications to stay\n** single-threaded if desired.\n*/\n#include \"sqliteInt.h\"\n#if SQLITE_OS_WIN\n#  include \"os_win.h\"\n#endif\n\n#if SQLITE_MAX_WORKER_THREADS>0\n\n/********************************* Unix Pthreads ****************************/\n#if SQLITE_OS_UNIX && defined(SQLITE_MUTEX_PTHREADS) && SQLITE_THREADSAFE>0\n\n#define SQLITE_THREADS_IMPLEMENTED 1  /* Prevent the single-thread code below */\n#include <pthread.h>\n\n/* A running thread */\nstruct SQLiteThread {\n  pthread_t tid;                 /* Thread ID */\n  int done;                      /* Set to true when thread finishes */\n  void *pOut;                    /* Result returned by the thread */\n  void *(*xTask)(void*);         /* The thread routine */\n  void *pIn;                     /* Argument to the thread */\n};\n\n/* Create a new thread */\nint sqlite3ThreadCreate(\n  SQLiteThread **ppThread,  /* OUT: Write the thread object here */\n  void *(*xTask)(void*),    /* Routine to run in a separate thread */\n  void *pIn                 /* Argument passed into xTask() */\n){\n  SQLiteThread *p;\n  int rc;\n\n  assert( ppThread!=0 );\n  assert( xTask!=0 );\n  /* This routine is never used in single-threaded mode */\n  assert( sqlite3GlobalConfig.bCoreMutex!=0 );\n\n  *ppThread = 0;\n  p = sqlite3Malloc(sizeof(*p));\n  if( p==0 ) return SQLITE_NOMEM_BKPT;\n  memset(p, 0, sizeof(*p));\n  p->xTask = xTask;\n  p->pIn = pIn;\n  /* If the SQLITE_TESTCTRL_FAULT_INSTALL callback is registered to a \n  ** function that returns SQLITE_ERROR when passed the argument 200, that\n  ** forces worker threads to run sequentially and deterministically \n  ** for testing purposes. */\n  if( sqlite3FaultSim(200) ){\n    rc = 1;\n  }else{    \n    rc = pthread_create(&p->tid, 0, xTask, pIn);\n  }\n  if( rc ){\n    p->done = 1;\n    p->pOut = xTask(pIn);\n  }\n  *ppThread = p;\n  return SQLITE_OK;\n}\n\n/* Get the results of the thread */\nint sqlite3ThreadJoin(SQLiteThread *p, void **ppOut){\n  int rc;\n\n  assert( ppOut!=0 );\n  if( NEVER(p==0) ) return SQLITE_NOMEM_BKPT;\n  if( p->done ){\n    *ppOut = p->pOut;\n    rc = SQLITE_OK;\n  }else{\n    rc = pthread_join(p->tid, ppOut) ? SQLITE_ERROR : SQLITE_OK;\n  }\n  sqlite3_free(p);\n  return rc;\n}\n\n#endif /* SQLITE_OS_UNIX && defined(SQLITE_MUTEX_PTHREADS) */\n/******************************** End Unix Pthreads *************************/\n\n\n/********************************* Win32 Threads ****************************/\n#if SQLITE_OS_WIN_THREADS\n\n#define SQLITE_THREADS_IMPLEMENTED 1  /* Prevent the single-thread code below */\n#include <process.h>\n\n/* A running thread */\nstruct SQLiteThread {\n  void *tid;               /* The thread handle */\n  unsigned id;             /* The thread identifier */\n  void *(*xTask)(void*);   /* The routine to run as a thread */\n  void *pIn;               /* Argument to xTask */\n  void *pResult;           /* Result of xTask */\n};\n\n/* Thread procedure Win32 compatibility shim */\nstatic unsigned __stdcall sqlite3ThreadProc(\n  void *pArg  /* IN: Pointer to the SQLiteThread structure */\n){\n  SQLiteThread *p = (SQLiteThread *)pArg;\n\n  assert( p!=0 );\n#if 0\n  /*\n  ** This assert appears to trigger spuriously on certain\n  ** versions of Windows, possibly due to _beginthreadex()\n  ** and/or CreateThread() not fully setting their thread\n  ** ID parameter before starting the thread.\n  */\n  assert( p->id==GetCurrentThreadId() );\n#endif\n  assert( p->xTask!=0 );\n  p->pResult = p->xTask(p->pIn);\n\n  _endthreadex(0);\n  return 0; /* NOT REACHED */\n}\n\n/* Create a new thread */\nint sqlite3ThreadCreate(\n  SQLiteThread **ppThread,  /* OUT: Write the thread object here */\n  void *(*xTask)(void*),    /* Routine to run in a separate thread */\n  void *pIn                 /* Argument passed into xTask() */\n){\n  SQLiteThread *p;\n\n  assert( ppThread!=0 );\n  assert( xTask!=0 );\n  *ppThread = 0;\n  p = sqlite3Malloc(sizeof(*p));\n  if( p==0 ) return SQLITE_NOMEM_BKPT;\n  /* If the SQLITE_TESTCTRL_FAULT_INSTALL callback is registered to a \n  ** function that returns SQLITE_ERROR when passed the argument 200, that\n  ** forces worker threads to run sequentially and deterministically \n  ** (via the sqlite3FaultSim() term of the conditional) for testing\n  ** purposes. */\n  if( sqlite3GlobalConfig.bCoreMutex==0 || sqlite3FaultSim(200) ){\n    memset(p, 0, sizeof(*p));\n  }else{\n    p->xTask = xTask;\n    p->pIn = pIn;\n    p->tid = (void*)_beginthreadex(0, 0, sqlite3ThreadProc, p, 0, &p->id);\n    if( p->tid==0 ){\n      memset(p, 0, sizeof(*p));\n    }\n  }\n  if( p->xTask==0 ){\n    p->id = GetCurrentThreadId();\n    p->pResult = xTask(pIn);\n  }\n  *ppThread = p;\n  return SQLITE_OK;\n}\n\nDWORD sqlite3Win32Wait(HANDLE hObject); /* os_win.c */\n\n/* Get the results of the thread */\nint sqlite3ThreadJoin(SQLiteThread *p, void **ppOut){\n  DWORD rc;\n  BOOL bRc;\n\n  assert( ppOut!=0 );\n  if( NEVER(p==0) ) return SQLITE_NOMEM_BKPT;\n  if( p->xTask==0 ){\n    /* assert( p->id==GetCurrentThreadId() ); */\n    rc = WAIT_OBJECT_0;\n    assert( p->tid==0 );\n  }else{\n    assert( p->id!=0 && p->id!=GetCurrentThreadId() );\n    rc = sqlite3Win32Wait((HANDLE)p->tid);\n    assert( rc!=WAIT_IO_COMPLETION );\n    bRc = CloseHandle((HANDLE)p->tid);\n    assert( bRc );\n  }\n  if( rc==WAIT_OBJECT_0 ) *ppOut = p->pResult;\n  sqlite3_free(p);\n  return (rc==WAIT_OBJECT_0) ? SQLITE_OK : SQLITE_ERROR;\n}\n\n#endif /* SQLITE_OS_WIN_THREADS */\n/******************************** End Win32 Threads *************************/\n\n\n/********************************* Single-Threaded **************************/\n#ifndef SQLITE_THREADS_IMPLEMENTED\n/*\n** This implementation does not actually create a new thread.  It does the\n** work of the thread in the main thread, when either the thread is created\n** or when it is joined\n*/\n\n/* A running thread */\nstruct SQLiteThread {\n  void *(*xTask)(void*);   /* The routine to run as a thread */\n  void *pIn;               /* Argument to xTask */\n  void *pResult;           /* Result of xTask */\n};\n\n/* Create a new thread */\nint sqlite3ThreadCreate(\n  SQLiteThread **ppThread,  /* OUT: Write the thread object here */\n  void *(*xTask)(void*),    /* Routine to run in a separate thread */\n  void *pIn                 /* Argument passed into xTask() */\n){\n  SQLiteThread *p;\n\n  assert( ppThread!=0 );\n  assert( xTask!=0 );\n  *ppThread = 0;\n  p = sqlite3Malloc(sizeof(*p));\n  if( p==0 ) return SQLITE_NOMEM_BKPT;\n  if( (SQLITE_PTR_TO_INT(p)/17)&1 ){\n    p->xTask = xTask;\n    p->pIn = pIn;\n  }else{\n    p->xTask = 0;\n    p->pResult = xTask(pIn);\n  }\n  *ppThread = p;\n  return SQLITE_OK;\n}\n\n/* Get the results of the thread */\nint sqlite3ThreadJoin(SQLiteThread *p, void **ppOut){\n\n  assert( ppOut!=0 );\n  if( NEVER(p==0) ) return SQLITE_NOMEM_BKPT;\n  if( p->xTask ){\n    *ppOut = p->xTask(p->pIn);\n  }else{\n    *ppOut = p->pResult;\n  }\n  sqlite3_free(p);\n\n#if defined(SQLITE_TEST)\n  {\n    void *pTstAlloc = sqlite3Malloc(10);\n    if (!pTstAlloc) return SQLITE_NOMEM_BKPT;\n    sqlite3_free(pTstAlloc);\n  }\n#endif\n\n  return SQLITE_OK;\n}\n\n#endif /* !defined(SQLITE_THREADS_IMPLEMENTED) */\n/****************************** End Single-Threaded *************************/\n#endif /* SQLITE_MAX_WORKER_THREADS>0 */\n"}
{"repo": "sqlite", "file": "table.c", "lang": "C++", "code": "/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains the sqlite3_get_table() and sqlite3_free_table()\n** interface routines.  These are just wrappers around the main\n** interface routine of sqlite3_exec().\n**\n** These routines are in a separate files so that they will not be linked\n** if they are not used.\n*/\n#include \"sqliteInt.h\"\n\n#ifndef SQLITE_OMIT_GET_TABLE\n\n/*\n** This structure is used to pass data from sqlite3_get_table() through\n** to the callback function is uses to build the result.\n*/\ntypedef struct TabResult {\n  char **azResult;   /* Accumulated output */\n  char *zErrMsg;     /* Error message text, if an error occurs */\n  u32 nAlloc;        /* Slots allocated for azResult[] */\n  u32 nRow;          /* Number of rows in the result */\n  u32 nColumn;       /* Number of columns in the result */\n  u32 nData;         /* Slots used in azResult[].  (nRow+1)*nColumn */\n  int rc;            /* Return code from sqlite3_exec() */\n} TabResult;\n\n/*\n** This routine is called once for each row in the result table.  Its job\n** is to fill in the TabResult structure appropriately, allocating new\n** memory as necessary.\n*/\nstatic int sqlite3_get_table_cb(void *pArg, int nCol, char **argv, char **colv){\n  TabResult *p = (TabResult*)pArg;  /* Result accumulator */\n  int need;                         /* Slots needed in p->azResult[] */\n  int i;                            /* Loop counter */\n  char *z;                          /* A single column of result */\n\n  /* Make sure there is enough space in p->azResult to hold everything\n  ** we need to remember from this invocation of the callback.\n  */\n  if( p->nRow==0 && argv!=0 ){\n    need = nCol*2;\n  }else{\n    need = nCol;\n  }\n  if( p->nData + need > p->nAlloc ){\n    char **azNew;\n    p->nAlloc = p->nAlloc*2 + need;\n    azNew = sqlite3Realloc( p->azResult, sizeof(char*)*p->nAlloc );\n    if( azNew==0 ) goto malloc_failed;\n    p->azResult = azNew;\n  }\n\n  /* If this is the first row, then generate an extra row containing\n  ** the names of all columns.\n  */\n  if( p->nRow==0 ){\n    p->nColumn = nCol;\n    for(i=0; i<nCol; i++){\n      z = sqlite3_mprintf(\"%s\", colv[i]);\n      if( z==0 ) goto malloc_failed;\n      p->azResult[p->nData++] = z;\n    }\n  }else if( (int)p->nColumn!=nCol ){\n    sqlite3_free(p->zErrMsg);\n    p->zErrMsg = sqlite3_mprintf(\n       \"sqlite3_get_table() called with two or more incompatible queries\"\n    );\n    p->rc = SQLITE_ERROR;\n    return 1;\n  }\n\n  /* Copy over the row data\n  */\n  if( argv!=0 ){\n    for(i=0; i<nCol; i++){\n      if( argv[i]==0 ){\n        z = 0;\n      }else{\n        int n = sqlite3Strlen30(argv[i])+1;\n        z = sqlite3_malloc64( n );\n        if( z==0 ) goto malloc_failed;\n        memcpy(z, argv[i], n);\n      }\n      p->azResult[p->nData++] = z;\n    }\n    p->nRow++;\n  }\n  return 0;\n\nmalloc_failed:\n  p->rc = SQLITE_NOMEM_BKPT;\n  return 1;\n}\n\n/*\n** Query the database.  But instead of invoking a callback for each row,\n** malloc() for space to hold the result and return the entire results\n** at the conclusion of the call.\n**\n** The result that is written to ***pazResult is held in memory obtained\n** from malloc().  But the caller cannot free this memory directly.  \n** Instead, the entire table should be passed to sqlite3_free_table() when\n** the calling procedure is finished using it.\n*/\nint sqlite3_get_table(\n  sqlite3 *db,                /* The database on which the SQL executes */\n  const char *zSql,           /* The SQL to be executed */\n  char ***pazResult,          /* Write the result table here */\n  int *pnRow,                 /* Write the number of rows in the result here */\n  int *pnColumn,              /* Write the number of columns of result here */\n  char **pzErrMsg             /* Write error messages here */\n){\n  int rc;\n  TabResult res;\n\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( !sqlite3SafetyCheckOk(db) || pazResult==0 ) return SQLITE_MISUSE_BKPT;\n#endif\n  *pazResult = 0;\n  if( pnColumn ) *pnColumn = 0;\n  if( pnRow ) *pnRow = 0;\n  if( pzErrMsg ) *pzErrMsg = 0;\n  res.zErrMsg = 0;\n  res.nRow = 0;\n  res.nColumn = 0;\n  res.nData = 1;\n  res.nAlloc = 20;\n  res.rc = SQLITE_OK;\n  res.azResult = sqlite3_malloc64(sizeof(char*)*res.nAlloc );\n  if( res.azResult==0 ){\n     db->errCode = SQLITE_NOMEM;\n     return SQLITE_NOMEM_BKPT;\n  }\n  res.azResult[0] = 0;\n  rc = sqlite3_exec(db, zSql, sqlite3_get_table_cb, &res, pzErrMsg);\n  assert( sizeof(res.azResult[0])>= sizeof(res.nData) );\n  res.azResult[0] = SQLITE_INT_TO_PTR(res.nData);\n  if( (rc&0xff)==SQLITE_ABORT ){\n    sqlite3_free_table(&res.azResult[1]);\n    if( res.zErrMsg ){\n      if( pzErrMsg ){\n        sqlite3_free(*pzErrMsg);\n        *pzErrMsg = sqlite3_mprintf(\"%s\",res.zErrMsg);\n      }\n      sqlite3_free(res.zErrMsg);\n    }\n    db->errCode = res.rc;  /* Assume 32-bit assignment is atomic */\n    return res.rc;\n  }\n  sqlite3_free(res.zErrMsg);\n  if( rc!=SQLITE_OK ){\n    sqlite3_free_table(&res.azResult[1]);\n    return rc;\n  }\n  if( res.nAlloc>res.nData ){\n    char **azNew;\n    azNew = sqlite3Realloc( res.azResult, sizeof(char*)*res.nData );\n    if( azNew==0 ){\n      sqlite3_free_table(&res.azResult[1]);\n      db->errCode = SQLITE_NOMEM;\n      return SQLITE_NOMEM_BKPT;\n    }\n    res.azResult = azNew;\n  }\n  *pazResult = &res.azResult[1];\n  if( pnColumn ) *pnColumn = res.nColumn;\n  if( pnRow ) *pnRow = res.nRow;\n  return rc;\n}\n\n/*\n** This routine frees the space the sqlite3_get_table() malloced.\n*/\nvoid sqlite3_free_table(\n  char **azResult            /* Result returned from sqlite3_get_table() */\n){\n  if( azResult ){\n    int i, n;\n    azResult--;\n    assert( azResult!=0 );\n    n = SQLITE_PTR_TO_INT(azResult[0]);\n    for(i=1; i<n; i++){ if( azResult[i] ) sqlite3_free(azResult[i]); }\n    sqlite3_free(azResult);\n  }\n}\n\n#endif /* SQLITE_OMIT_GET_TABLE */\n"}
{"repo": "sqlite", "file": "test_delete.c", "lang": "C++", "code": "/*\n** 2016 September 10\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains test code to delete an SQLite database and all\n** of its associated files. Associated files include:\n**\n**   * The journal file.\n**   * The wal file.\n**   * The SQLITE_ENABLE_8_3_NAMES version of the db, journal or wal files.\n**   * Files created by the test_multiplex.c module to extend any of the \n**     above.\n*/\n\n#ifndef SQLITE_OS_WIN\n#  include <unistd.h>\n#  include <errno.h>\n#endif\n#include <string.h>\n#include <assert.h>\n#include \"sqlite3.h\"\n\n/* The following #defines are copied from test_multiplex.c */\n#ifndef MX_CHUNK_NUMBER \n# define MX_CHUNK_NUMBER 299\n#endif\n#ifndef SQLITE_MULTIPLEX_JOURNAL_8_3_OFFSET\n# define SQLITE_MULTIPLEX_JOURNAL_8_3_OFFSET 400\n#endif\n#ifndef SQLITE_MULTIPLEX_WAL_8_3_OFFSET\n# define SQLITE_MULTIPLEX_WAL_8_3_OFFSET 700\n#endif\n\n/*\n** This routine is a copy of (most of) the code from SQLite function\n** sqlite3FileSuffix3(). It modifies the filename in buffer z in the\n** same way as SQLite does when in 8.3 filenames mode.\n*/\nstatic void sqlite3Delete83Name(char *z){\n  int i, sz;\n  sz = (int)strlen(z);\n  for(i=sz-1; i>0 && z[i]!='/' && z[i]!='.'; i--){}\n  if( z[i]=='.' && (sz>i+4) ) memmove(&z[i+1], &z[sz-3], 4);\n}\n\n/*\n** zFile is a filename. Assuming no error occurs, if this file exists, \n** set *pbExists to true and unlink it. Or, if the file does not exist,\n** set *pbExists to false before returning.\n**\n** If an error occurs, non-zero is returned. Or, if no error occurs, zero.\n*/\nstatic int sqlite3DeleteUnlinkIfExists(\n  sqlite3_vfs *pVfs,\n  const char *zFile, \n  int *pbExists\n){\n  int rc = SQLITE_ERROR;\n#ifdef _WIN32\n  if( pVfs ){\n    if( pbExists ) *pbExists = 1;\n    rc = pVfs->xDelete(pVfs, zFile, 0);\n    if( rc==SQLITE_IOERR_DELETE_NOENT ){\n      if( pbExists ) *pbExists = 0;\n      rc = SQLITE_OK;\n    }\n  }\n#else\n  assert( pVfs==0 );\n  rc = access(zFile, F_OK);\n  if( rc ){\n    if( errno==ENOENT ){ \n      if( pbExists ) *pbExists = 0;\n      rc = SQLITE_OK; \n    }\n  }else{\n    if( pbExists ) *pbExists = 1;\n    rc = unlink(zFile);\n  }\n#endif\n  return rc;\n}\n\n/*\n** Delete the database file identified by the string argument passed to this\n** function. The string must contain a filename, not an SQLite URI.\n*/\nSQLITE_API int sqlite3_delete_database(\n  const char *zFile               /* File to delete */\n){\n  char *zBuf;                     /* Buffer to sprintf() filenames to */\n  int nBuf;                       /* Size of buffer in bytes */\n  int rc = 0;                     /* System error code */\n  int i;                          /* Iterate through azFmt[] and aMFile[] */\n\n  const char *azFmt[] = { \"%s\", \"%s-journal\", \"%s-wal\", \"%s-shm\" };\n\n  struct MFile {\n    const char *zFmt;\n    int iOffset;\n    int b83;\n  } aMFile[] = {\n    { \"%s%03d\",         0,   0 },\n    { \"%s-journal%03d\", 0,   0 },\n    { \"%s-wal%03d\",     0,   0 },\n    { \"%s%03d\",         0,   1 },\n    { \"%s-journal%03d\", SQLITE_MULTIPLEX_JOURNAL_8_3_OFFSET, 1 },\n    { \"%s-wal%03d\",     SQLITE_MULTIPLEX_WAL_8_3_OFFSET, 1 },\n  };\n\n#ifdef _WIN32\n  sqlite3_vfs *pVfs = sqlite3_vfs_find(\"win32\");\n#else\n  sqlite3_vfs *pVfs = 0;\n#endif\n\n  /* Allocate a buffer large enough for any of the files that need to be\n  ** deleted.  */\n  nBuf = (int)strlen(zFile) + 100;\n  zBuf = (char*)sqlite3_malloc(nBuf);\n  if( zBuf==0 ) return SQLITE_NOMEM;\n\n  /* Delete both the regular and 8.3 filenames versions of the database,\n  ** journal, wal and shm files.  */\n  for(i=0; rc==0 && i<sizeof(azFmt)/sizeof(azFmt[0]); i++){\n    sqlite3_snprintf(nBuf, zBuf, azFmt[i], zFile);\n    rc = sqlite3DeleteUnlinkIfExists(pVfs, zBuf, 0);\n    if( rc==0 && i!=0 ){\n      sqlite3Delete83Name(zBuf);\n      rc = sqlite3DeleteUnlinkIfExists(pVfs, zBuf, 0);\n    }\n  }\n\n  /* Delete any multiplexor files */\n  for(i=0; rc==0 && i<sizeof(aMFile)/sizeof(aMFile[0]); i++){\n    struct MFile *p = &aMFile[i];\n    int iChunk;\n    for(iChunk=1; iChunk<=MX_CHUNK_NUMBER; iChunk++){\n      int bExists;\n      sqlite3_snprintf(nBuf, zBuf, p->zFmt, zFile, iChunk+p->iOffset);\n      if( p->b83 ) sqlite3Delete83Name(zBuf);\n      rc = sqlite3DeleteUnlinkIfExists(pVfs, zBuf, &bExists);\n      if( bExists==0 || rc!=0 ) break;\n    }\n  }\n\n  sqlite3_free(zBuf);\n  return (rc ? SQLITE_ERROR : SQLITE_OK);\n}\n"}
{"repo": "sqlite", "file": "msvc.h", "lang": "C++", "code": "/*\n** 2015 January 12\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This file contains code that is specific to MSVC.\n*/\n#ifndef SQLITE_MSVC_H\n#define SQLITE_MSVC_H\n\n#if defined(_MSC_VER)\n#pragma warning(disable : 4054)\n#pragma warning(disable : 4055)\n#pragma warning(disable : 4100)\n#pragma warning(disable : 4127)\n#pragma warning(disable : 4130)\n#pragma warning(disable : 4152)\n#pragma warning(disable : 4189)\n#pragma warning(disable : 4206)\n#pragma warning(disable : 4210)\n#pragma warning(disable : 4232)\n#pragma warning(disable : 4244)\n#pragma warning(disable : 4305)\n#pragma warning(disable : 4306)\n#pragma warning(disable : 4702)\n#pragma warning(disable : 4706)\n#endif /* defined(_MSC_VER) */\n\n#if defined(_MSC_VER) && !defined(_WIN64)\n#undef SQLITE_4_BYTE_ALIGNED_MALLOC\n#define SQLITE_4_BYTE_ALIGNED_MALLOC\n#endif /* defined(_MSC_VER) && !defined(_WIN64) */\n\n#if !defined(HAVE_LOG2) && defined(_MSC_VER) && _MSC_VER<1800\n#define HAVE_LOG2 0\n#endif /* !defined(HAVE_LOG2) && defined(_MSC_VER) && _MSC_VER<1800 */\n\n#endif /* SQLITE_MSVC_H */\n"}
{"repo": "sqlite", "file": "fault.c", "lang": "C++", "code": "/*\n** 2008 Jan 22\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains code to support the concept of \"benign\" \n** malloc failures (when the xMalloc() or xRealloc() method of the\n** sqlite3_mem_methods structure fails to allocate a block of memory\n** and returns 0). \n**\n** Most malloc failures are non-benign. After they occur, SQLite\n** abandons the current operation and returns an error code (usually\n** SQLITE_NOMEM) to the user. However, sometimes a fault is not necessarily\n** fatal. For example, if a malloc fails while resizing a hash table, this \n** is completely recoverable simply by not carrying out the resize. The \n** hash table will continue to function normally.  So a malloc failure \n** during a hash table resize is a benign fault.\n*/\n\n#include \"sqliteInt.h\"\n\n#ifndef SQLITE_UNTESTABLE\n\n/*\n** Global variables.\n*/\ntypedef struct BenignMallocHooks BenignMallocHooks;\nstatic SQLITE_WSD struct BenignMallocHooks {\n  void (*xBenignBegin)(void);\n  void (*xBenignEnd)(void);\n} sqlite3Hooks = { 0, 0 };\n\n/* The \"wsdHooks\" macro will resolve to the appropriate BenignMallocHooks\n** structure.  If writable static data is unsupported on the target,\n** we have to locate the state vector at run-time.  In the more common\n** case where writable static data is supported, wsdHooks can refer directly\n** to the \"sqlite3Hooks\" state vector declared above.\n*/\n#ifdef SQLITE_OMIT_WSD\n# define wsdHooksInit \\\n  BenignMallocHooks *x = &GLOBAL(BenignMallocHooks,sqlite3Hooks)\n# define wsdHooks x[0]\n#else\n# define wsdHooksInit\n# define wsdHooks sqlite3Hooks\n#endif\n\n\n/*\n** Register hooks to call when sqlite3BeginBenignMalloc() and\n** sqlite3EndBenignMalloc() are called, respectively.\n*/\nvoid sqlite3BenignMallocHooks(\n  void (*xBenignBegin)(void),\n  void (*xBenignEnd)(void)\n){\n  wsdHooksInit;\n  wsdHooks.xBenignBegin = xBenignBegin;\n  wsdHooks.xBenignEnd = xBenignEnd;\n}\n\n/*\n** This (sqlite3EndBenignMalloc()) is called by SQLite code to indicate that\n** subsequent malloc failures are benign. A call to sqlite3EndBenignMalloc()\n** indicates that subsequent malloc failures are non-benign.\n*/\nvoid sqlite3BeginBenignMalloc(void){\n  wsdHooksInit;\n  if( wsdHooks.xBenignBegin ){\n    wsdHooks.xBenignBegin();\n  }\n}\nvoid sqlite3EndBenignMalloc(void){\n  wsdHooksInit;\n  if( wsdHooks.xBenignEnd ){\n    wsdHooks.xBenignEnd();\n  }\n}\n\n#endif   /* #ifndef SQLITE_UNTESTABLE */\n"}
{"repo": "sqlite", "file": "test3.c", "lang": "C++", "code": "/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** Code for testing the btree.c module in SQLite.  This code\n** is not included in the SQLite library.  It is used for automated\n** testing of the SQLite library.\n*/\n#include \"sqliteInt.h\"\n#include \"btreeInt.h\"\n#include \"tclsqlite.h\"\n#include <stdlib.h>\n#include <string.h>\n\nextern const char *sqlite3ErrName(int);\n\n/*\n** A bogus sqlite3 connection structure for use in the btree\n** tests.\n*/\nstatic sqlite3 sDb;\nstatic int nRefSqlite3 = 0;\n\n/*\n** Usage:   btree_open FILENAME NCACHE\n**\n** Open a new database\n*/\nstatic int SQLITE_TCLAPI btree_open(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  Btree *pBt;\n  int rc, nCache;\n  char zBuf[100];\n  int n;\n  char *zFilename;\n  if( argc!=3 ){\n    Tcl_AppendResult(interp, \"wrong # args: should be \\\"\", argv[0],\n       \" FILENAME NCACHE FLAGS\\\"\", NULL);\n    return TCL_ERROR;\n  }\n\n  if( Tcl_GetInt(interp, argv[2], &nCache) ) return TCL_ERROR;\n  nRefSqlite3++;\n  if( nRefSqlite3==1 ){\n    sDb.pVfs = sqlite3_vfs_find(0);\n    sDb.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_RECURSIVE);\n    sqlite3_mutex_enter(sDb.mutex);\n  }\n  n = (int)strlen(argv[1]);\n  zFilename = sqlite3_malloc( n+2 );\n  if( zFilename==0 ) return TCL_ERROR;\n  memcpy(zFilename, argv[1], n+1);\n  zFilename[n+1] = 0;\n  rc = sqlite3BtreeOpen(sDb.pVfs, zFilename, &sDb, &pBt, 0, \n     SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_MAIN_DB);\n  sqlite3_free(zFilename);\n  if( rc!=SQLITE_OK ){\n    Tcl_AppendResult(interp, sqlite3ErrName(rc), NULL);\n    return TCL_ERROR;\n  }\n  sqlite3BtreeSetCacheSize(pBt, nCache);\n  sqlite3_snprintf(sizeof(zBuf), zBuf,\"%p\", pBt);\n  Tcl_AppendResult(interp, zBuf, NULL);\n  return TCL_OK;\n}\n\n/*\n** Usage:   btree_close ID\n**\n** Close the given database.\n*/\nstatic int SQLITE_TCLAPI btree_close(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  Btree *pBt;\n  int rc;\n  if( argc!=2 ){\n    Tcl_AppendResult(interp, \"wrong # args: should be \\\"\", argv[0],\n       \" ID\\\"\", NULL);\n    return TCL_ERROR;\n  }\n  pBt = sqlite3TestTextToPtr(argv[1]);\n  rc = sqlite3BtreeClose(pBt);\n  if( rc!=SQLITE_OK ){\n    Tcl_AppendResult(interp, sqlite3ErrName(rc), NULL);\n    return TCL_ERROR;\n  }\n  nRefSqlite3--;\n  if( nRefSqlite3==0 ){\n    sqlite3_mutex_leave(sDb.mutex);\n    sqlite3_mutex_free(sDb.mutex);\n    sDb.mutex = 0;\n    sDb.pVfs = 0;\n  }\n  return TCL_OK;\n}\n\n\n/*\n** Usage:   btree_begin_transaction ID\n**\n** Start a new transaction\n*/\nstatic int SQLITE_TCLAPI btree_begin_transaction(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  Btree *pBt;\n  int rc;\n  if( argc!=2 ){\n    Tcl_AppendResult(interp, \"wrong # args: should be \\\"\", argv[0],\n       \" ID\\\"\", NULL);\n    return TCL_ERROR;\n  }\n  pBt = sqlite3TestTextToPtr(argv[1]);\n  sqlite3BtreeEnter(pBt);\n  rc = sqlite3BtreeBeginTrans(pBt, 1, 0);\n  sqlite3BtreeLeave(pBt);\n  if( rc!=SQLITE_OK ){\n    Tcl_AppendResult(interp, sqlite3ErrName(rc), NULL);\n    return TCL_ERROR;\n  }\n  return TCL_OK;\n}\n\n/*\n** Usage:   btree_pager_stats ID\n**\n** Returns pager statistics\n*/\nstatic int SQLITE_TCLAPI btree_pager_stats(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  Btree *pBt;\n  int i;\n  int *a;\n\n  if( argc!=2 ){\n    Tcl_AppendResult(interp, \"wrong # args: should be \\\"\", argv[0],\n       \" ID\\\"\", NULL);\n    return TCL_ERROR;\n  }\n  pBt = sqlite3TestTextToPtr(argv[1]);\n \n  /* Normally in this file, with a b-tree handle opened using the \n  ** [btree_open] command it is safe to call sqlite3BtreeEnter() directly.\n  ** But this function is sometimes called with a btree handle obtained\n  ** from an open SQLite connection (using [btree_from_db]). In this case\n  ** we need to obtain the mutex for the controlling SQLite handle before\n  ** it is safe to call sqlite3BtreeEnter().\n  */\n  sqlite3_mutex_enter(pBt->db->mutex);\n\n  sqlite3BtreeEnter(pBt);\n  a = sqlite3PagerStats(sqlite3BtreePager(pBt));\n  for(i=0; i<11; i++){\n    static char *zName[] = {\n      \"ref\", \"page\", \"max\", \"size\", \"state\", \"err\",\n      \"hit\", \"miss\", \"ovfl\", \"read\", \"write\"\n    };\n    char zBuf[100];\n    Tcl_AppendElement(interp, zName[i]);\n    sqlite3_snprintf(sizeof(zBuf), zBuf,\"%d\",a[i]);\n    Tcl_AppendElement(interp, zBuf);\n  }\n  sqlite3BtreeLeave(pBt);\n\n  /* Release the mutex on the SQLite handle that controls this b-tree */\n  sqlite3_mutex_leave(pBt->db->mutex);\n  return TCL_OK;\n}\n\n/*\n** Usage:   btree_cursor ID TABLENUM WRITEABLE\n**\n** Create a new cursor.  Return the ID for the cursor.\n*/\nstatic int SQLITE_TCLAPI btree_cursor(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  Btree *pBt;\n  int iTable;\n  BtCursor *pCur;\n  int rc = SQLITE_OK;\n  int wrFlag;\n  char zBuf[30];\n\n  if( argc!=4 ){\n    Tcl_AppendResult(interp, \"wrong # args: should be \\\"\", argv[0],\n       \" ID TABLENUM WRITEABLE\\\"\", NULL);\n    return TCL_ERROR;\n  }\n  pBt = sqlite3TestTextToPtr(argv[1]);\n  if( Tcl_GetInt(interp, argv[2], &iTable) ) return TCL_ERROR;\n  if( Tcl_GetBoolean(interp, argv[3], &wrFlag) ) return TCL_ERROR;\n  if( wrFlag ) wrFlag = BTREE_WRCSR;\n  pCur = (BtCursor *)ckalloc(sqlite3BtreeCursorSize());\n  memset(pCur, 0, sqlite3BtreeCursorSize());\n  sqlite3_mutex_enter(pBt->db->mutex);\n  sqlite3BtreeEnter(pBt);\n#ifndef SQLITE_OMIT_SHARED_CACHE\n  rc = sqlite3BtreeLockTable(pBt, iTable, !!wrFlag);\n#endif\n  if( rc==SQLITE_OK ){\n    rc = sqlite3BtreeCursor(pBt, iTable, wrFlag, 0, pCur);\n  }\n  sqlite3BtreeLeave(pBt);\n  sqlite3_mutex_leave(pBt->db->mutex);\n  if( rc ){\n    ckfree((char *)pCur);\n    Tcl_AppendResult(interp, sqlite3ErrName(rc), NULL);\n    return TCL_ERROR;\n  }\n  sqlite3_snprintf(sizeof(zBuf), zBuf,\"%p\", pCur);\n  Tcl_AppendResult(interp, zBuf, NULL);\n  return SQLITE_OK;\n}\n\n/*\n** Usage:   btree_close_cursor ID\n**\n** Close a cursor opened using btree_cursor.\n*/\nstatic int SQLITE_TCLAPI btree_close_cursor(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  BtCursor *pCur;\n  int rc;\n\n  if( argc!=2 ){\n    Tcl_AppendResult(interp, \"wrong # args: should be \\\"\", argv[0],\n       \" ID\\\"\", NULL);\n    return TCL_ERROR;\n  }\n  pCur = sqlite3TestTextToPtr(argv[1]);\n#if SQLITE_THREADSAFE>0\n  {\n    Btree *pBt = pCur->pBtree;\n    sqlite3_mutex_enter(pBt->db->mutex);\n    sqlite3BtreeEnter(pBt);\n    rc = sqlite3BtreeCloseCursor(pCur);\n    sqlite3BtreeLeave(pBt);\n    sqlite3_mutex_leave(pBt->db->mutex);\n  }\n#else\n  rc = sqlite3BtreeCloseCursor(pCur);\n#endif\n  ckfree((char *)pCur);\n  if( rc ){\n    Tcl_AppendResult(interp, sqlite3ErrName(rc), NULL);\n    return TCL_ERROR;\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Usage:   btree_next ID\n**\n** Move the cursor to the next entry in the table.  Return 0 on success\n** or 1 if the cursor was already on the last entry in the table or if\n** the table is empty.\n*/\nstatic int SQLITE_TCLAPI btree_next(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  BtCursor *pCur;\n  int rc;\n  int res = 0;\n  char zBuf[100];\n\n  if( argc!=2 ){\n    Tcl_AppendResult(interp, \"wrong # args: should be \\\"\", argv[0],\n       \" ID\\\"\", NULL);\n    return TCL_ERROR;\n  }\n  pCur = sqlite3TestTextToPtr(argv[1]);\n  sqlite3BtreeEnter(pCur->pBtree);\n  rc = sqlite3BtreeNext(pCur, 0);\n  if( rc==SQLITE_DONE ){\n    res = 1;\n    rc = SQLITE_OK;\n  }\n  sqlite3BtreeLeave(pCur->pBtree);\n  if( rc ){\n    Tcl_AppendResult(interp, sqlite3ErrName(rc), NULL);\n    return TCL_ERROR;\n  }\n  sqlite3_snprintf(sizeof(zBuf),zBuf,\"%d\",res);\n  Tcl_AppendResult(interp, zBuf, NULL);\n  return SQLITE_OK;\n}\n\n/*\n** Usage:   btree_first ID\n**\n** Move the cursor to the first entry in the table.  Return 0 if the\n** cursor was left point to something and 1 if the table is empty.\n*/\nstatic int SQLITE_TCLAPI btree_first(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  BtCursor *pCur;\n  int rc;\n  int res = 0;\n  char zBuf[100];\n\n  if( argc!=2 ){\n    Tcl_AppendResult(interp, \"wrong # args: should be \\\"\", argv[0],\n       \" ID\\\"\", NULL);\n    return TCL_ERROR;\n  }\n  pCur = sqlite3TestTextToPtr(argv[1]);\n  sqlite3BtreeEnter(pCur->pBtree);\n  rc = sqlite3BtreeFirst(pCur, &res);\n  sqlite3BtreeLeave(pCur->pBtree);\n  if( rc ){\n    Tcl_AppendResult(interp, sqlite3ErrName(rc), NULL);\n    return TCL_ERROR;\n  }\n  sqlite3_snprintf(sizeof(zBuf),zBuf,\"%d\",res);\n  Tcl_AppendResult(interp, zBuf, NULL);\n  return SQLITE_OK;\n}\n\n/*\n** Usage:   btree_eof ID\n**\n** Return TRUE if the given cursor is not pointing at a valid entry.\n** Return FALSE if the cursor does point to a valid entry.\n*/\nstatic int SQLITE_TCLAPI btree_eof(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  BtCursor *pCur;\n  int rc;\n  char zBuf[50];\n\n  if( argc!=2 ){\n    Tcl_AppendResult(interp, \"wrong # args: should be \\\"\", argv[0],\n       \" ID\\\"\", NULL);\n    return TCL_ERROR;\n  }\n  pCur = sqlite3TestTextToPtr(argv[1]);\n  sqlite3BtreeEnter(pCur->pBtree);\n  rc = sqlite3BtreeEof(pCur);\n  sqlite3BtreeLeave(pCur->pBtree);\n  sqlite3_snprintf(sizeof(zBuf),zBuf, \"%d\", rc);\n  Tcl_AppendResult(interp, zBuf, NULL);\n  return SQLITE_OK;\n}\n\n/*\n** Usage:   btree_payload_size ID\n**\n** Return the number of bytes of payload\n*/\nstatic int SQLITE_TCLAPI btree_payload_size(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  BtCursor *pCur;\n  u32 n;\n  char zBuf[50];\n\n  if( argc!=2 ){\n    Tcl_AppendResult(interp, \"wrong # args: should be \\\"\", argv[0],\n       \" ID\\\"\", NULL);\n    return TCL_ERROR;\n  }\n  pCur = sqlite3TestTextToPtr(argv[1]);\n  sqlite3BtreeEnter(pCur->pBtree);\n  n = sqlite3BtreePayloadSize(pCur);\n  sqlite3BtreeLeave(pCur->pBtree);\n  sqlite3_snprintf(sizeof(zBuf),zBuf, \"%u\", n);\n  Tcl_AppendResult(interp, zBuf, NULL);\n  return SQLITE_OK;\n}\n\n/*\n** usage:   varint_test  START  MULTIPLIER  COUNT  INCREMENT\n**\n** This command tests the putVarint() and getVarint()\n** routines, both for accuracy and for speed.\n**\n** An integer is written using putVarint() and read back with\n** getVarint() and verified to be unchanged.  This repeats COUNT\n** times.  The first integer is START*MULTIPLIER.  Each iteration\n** increases the integer by INCREMENT.\n**\n** This command returns nothing if it works.  It returns an error message\n** if something goes wrong.\n*/\nstatic int SQLITE_TCLAPI btree_varint_test(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  u32 start, mult, count, incr;\n  u64 in, out;\n  int n1, n2, i, j;\n  unsigned char zBuf[100];\n  if( argc!=5 ){\n    Tcl_AppendResult(interp, \"wrong # args: should be \\\"\", argv[0],\n       \" START MULTIPLIER COUNT INCREMENT\\\"\", NULL);\n    return TCL_ERROR;\n  }\n  if( Tcl_GetInt(interp, argv[1], (int*)&start) ) return TCL_ERROR;\n  if( Tcl_GetInt(interp, argv[2], (int*)&mult) ) return TCL_ERROR;\n  if( Tcl_GetInt(interp, argv[3], (int*)&count) ) return TCL_ERROR;\n  if( Tcl_GetInt(interp, argv[4], (int*)&incr) ) return TCL_ERROR;\n  in = start;\n  in *= mult;\n  for(i=0; i<(int)count; i++){\n    char zErr[200];\n    n1 = putVarint(zBuf, in);\n    if( n1>9 || n1<1 ){\n      sqlite3_snprintf(sizeof(zErr), zErr,\n         \"putVarint returned %d - should be between 1 and 9\", n1);\n      Tcl_AppendResult(interp, zErr, NULL);\n      return TCL_ERROR;\n    }\n    n2 = getVarint(zBuf, &out);\n    if( n1!=n2 ){\n      sqlite3_snprintf(sizeof(zErr), zErr,\n          \"putVarint returned %d and getVarint returned %d\", n1, n2);\n      Tcl_AppendResult(interp, zErr, NULL);\n      return TCL_ERROR;\n    }\n    if( in!=out ){\n      sqlite3_snprintf(sizeof(zErr), zErr,\n          \"Wrote 0x%016llx and got back 0x%016llx\", in, out);\n      Tcl_AppendResult(interp, zErr, NULL);\n      return TCL_ERROR;\n    }\n    if( (in & 0xffffffff)==in ){\n      u32 out32;\n      n2 = getVarint32(zBuf, out32);\n      out = out32;\n      if( n1!=n2 ){\n        sqlite3_snprintf(sizeof(zErr), zErr,\n          \"putVarint returned %d and GetVarint32 returned %d\", \n                  n1, n2);\n        Tcl_AppendResult(interp, zErr, NULL);\n        return TCL_ERROR;\n      }\n      if( in!=out ){\n        sqlite3_snprintf(sizeof(zErr), zErr,\n          \"Wrote 0x%016llx and got back 0x%016llx from GetVarint32\",\n            in, out);\n        Tcl_AppendResult(interp, zErr, NULL);\n        return TCL_ERROR;\n      }\n    }\n\n    /* In order to get realistic timings, run getVarint 19 more times.\n    ** This is because getVarint is called about 20 times more often\n    ** than putVarint.\n    */\n    for(j=0; j<19; j++){\n      getVarint(zBuf, &out);\n    }\n    in += incr;\n  }\n  return TCL_OK;\n}\n\n/*\n** usage:   btree_from_db  DB-HANDLE\n**\n** This command returns the btree handle for the main database associated\n** with the database-handle passed as the argument. Example usage:\n**\n** sqlite3 db test.db\n** set bt [btree_from_db db]\n*/\nstatic int SQLITE_TCLAPI btree_from_db(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  char zBuf[100];\n  Tcl_CmdInfo info;\n  sqlite3 *db;\n  Btree *pBt;\n  int iDb = 0;\n\n  if( argc!=2 && argc!=3 ){\n    Tcl_AppendResult(interp, \"wrong # args: should be \\\"\", argv[0],\n       \" DB-HANDLE ?N?\\\"\", NULL);\n    return TCL_ERROR;\n  }\n\n  if( 1!=Tcl_GetCommandInfo(interp, argv[1], &info) ){\n    Tcl_AppendResult(interp, \"No such db-handle: \\\"\", argv[1], \"\\\"\", NULL);\n    return TCL_ERROR;\n  }\n  if( argc==3 ){\n    iDb = atoi(argv[2]);\n  }\n\n  db = *((sqlite3 **)info.objClientData);\n  assert( db );\n\n  pBt = db->aDb[iDb].pBt;\n  sqlite3_snprintf(sizeof(zBuf), zBuf, \"%p\", pBt);\n  Tcl_SetResult(interp, zBuf, TCL_VOLATILE);\n  return TCL_OK;\n}\n\n/*\n** Usage:   btree_ismemdb ID\n**\n** Return true if the B-Tree is currently stored entirely in memory.\n*/\nstatic int SQLITE_TCLAPI btree_ismemdb(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  Btree *pBt;\n  int res;\n  sqlite3_file *pFile;\n\n  if( argc!=2 ){\n    Tcl_AppendResult(interp, \"wrong # args: should be \\\"\", argv[0],\n       \" ID\\\"\", NULL);\n    return TCL_ERROR;\n  }\n  pBt = sqlite3TestTextToPtr(argv[1]);\n  sqlite3_mutex_enter(pBt->db->mutex);\n  sqlite3BtreeEnter(pBt);\n  pFile = sqlite3PagerFile(sqlite3BtreePager(pBt));\n  res = (pFile->pMethods==0);\n  sqlite3BtreeLeave(pBt);\n  sqlite3_mutex_leave(pBt->db->mutex);\n  Tcl_SetObjResult(interp, Tcl_NewBooleanObj(res));\n  return SQLITE_OK;\n}\n\n/*\n** usage:   btree_set_cache_size ID NCACHE\n**\n** Set the size of the cache used by btree $ID.\n*/\nstatic int SQLITE_TCLAPI btree_set_cache_size(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  int nCache;\n  Btree *pBt;\n  \n  if( argc!=3 ){\n    Tcl_AppendResult(\n        interp, \"wrong # args: should be \\\"\", argv[0], \" BT NCACHE\\\"\", NULL);\n    return TCL_ERROR;\n  }\n  pBt = sqlite3TestTextToPtr(argv[1]);\n  if( Tcl_GetInt(interp, argv[2], &nCache) ) return TCL_ERROR;\n\n  sqlite3_mutex_enter(pBt->db->mutex);\n  sqlite3BtreeEnter(pBt);\n  sqlite3BtreeSetCacheSize(pBt, nCache);\n  sqlite3BtreeLeave(pBt);\n  sqlite3_mutex_leave(pBt->db->mutex);\n  return TCL_OK;\n}      \n\n/*\n** usage:   btree_insert CSR ?KEY? VALUE\n**\n** Set the size of the cache used by btree $ID.\n*/\nstatic int SQLITE_TCLAPI btree_insert(\n  ClientData clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *const objv[]\n){\n  BtCursor *pCur;\n  int rc;\n  BtreePayload x;\n  Tcl_Size n;\n\n  if( objc!=4 && objc!=3 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"?-intkey? CSR KEY VALUE\");\n    return TCL_ERROR;\n  }\n\n  memset(&x, 0, sizeof(x));\n  if( objc==4 ){\n    if( Tcl_GetIntFromObj(interp, objv[2], &rc) ) return TCL_ERROR;\n    x.nKey = rc;\n    x.pData = (void*)Tcl_GetByteArrayFromObj(objv[3], &n);\n    x.nData = (int)n;\n  }else{\n    x.pKey = (void*)Tcl_GetByteArrayFromObj(objv[2], &n);\n    x.nKey = (int)n;\n  }\n  pCur = (BtCursor*)sqlite3TestTextToPtr(Tcl_GetString(objv[1]));\n\n  sqlite3_mutex_enter(pCur->pBtree->db->mutex);\n  sqlite3BtreeEnter(pCur->pBtree);\n  rc = sqlite3BtreeInsert(pCur, &x, 0, 0);\n  sqlite3BtreeLeave(pCur->pBtree);\n  sqlite3_mutex_leave(pCur->pBtree->db->mutex);\n\n  Tcl_ResetResult(interp);\n  if( rc ){\n    Tcl_AppendResult(interp, sqlite3ErrName(rc), NULL);\n    return TCL_ERROR;\n  }\n  return TCL_OK;\n}\n\n\n/*\n** Register commands with the TCL interpreter.\n*/\nint Sqlitetest3_Init(Tcl_Interp *interp){\n  static struct {\n     char *zName;\n     Tcl_CmdProc *xProc;\n  } aCmd[] = {\n     { \"btree_open\",               (Tcl_CmdProc*)btree_open               },\n     { \"btree_close\",              (Tcl_CmdProc*)btree_close              },\n     { \"btree_begin_transaction\",  (Tcl_CmdProc*)btree_begin_transaction  },\n     { \"btree_pager_stats\",        (Tcl_CmdProc*)btree_pager_stats        },\n     { \"btree_cursor\",             (Tcl_CmdProc*)btree_cursor             },\n     { \"btree_close_cursor\",       (Tcl_CmdProc*)btree_close_cursor       },\n     { \"btree_next\",               (Tcl_CmdProc*)btree_next               },\n     { \"btree_eof\",                (Tcl_CmdProc*)btree_eof                },\n     { \"btree_payload_size\",       (Tcl_CmdProc*)btree_payload_size       },\n     { \"btree_first\",              (Tcl_CmdProc*)btree_first              },\n     { \"btree_varint_test\",        (Tcl_CmdProc*)btree_varint_test        },\n     { \"btree_from_db\",            (Tcl_CmdProc*)btree_from_db            },\n     { \"btree_ismemdb\",            (Tcl_CmdProc*)btree_ismemdb            },\n     { \"btree_set_cache_size\",     (Tcl_CmdProc*)btree_set_cache_size     }\n  };\n  int i;\n\n  for(i=0; i<sizeof(aCmd)/sizeof(aCmd[0]); i++){\n    Tcl_CreateCommand(interp, aCmd[i].zName, aCmd[i].xProc, 0, 0);\n  }\n\n  Tcl_CreateObjCommand(interp, \"btree_insert\", btree_insert, 0, 0);\n\n  return TCL_OK;\n}\n"}
{"repo": "sqlite", "file": "whereexpr.c", "lang": "C++", "code": "/*\n** 2015-06-08\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This module contains C code that generates VDBE code used to process\n** the WHERE clause of SQL statements.\n**\n** This file was originally part of where.c but was split out to improve\n** readability and editability.  This file contains utility routines for\n** analyzing Expr objects in the WHERE clause.\n*/\n#include \"sqliteInt.h\"\n#include \"whereInt.h\"\n\n/* Forward declarations */\nstatic void exprAnalyze(SrcList*, WhereClause*, int);\n\n/*\n** Deallocate all memory associated with a WhereOrInfo object.\n*/\nstatic void whereOrInfoDelete(sqlite3 *db, WhereOrInfo *p){\n  sqlite3WhereClauseClear(&p->wc);\n  sqlite3DbFree(db, p);\n}\n\n/*\n** Deallocate all memory associated with a WhereAndInfo object.\n*/\nstatic void whereAndInfoDelete(sqlite3 *db, WhereAndInfo *p){\n  sqlite3WhereClauseClear(&p->wc);\n  sqlite3DbFree(db, p);\n}\n\n/*\n** Add a single new WhereTerm entry to the WhereClause object pWC.\n** The new WhereTerm object is constructed from Expr p and with wtFlags.\n** The index in pWC->a[] of the new WhereTerm is returned on success.\n** 0 is returned if the new WhereTerm could not be added due to a memory\n** allocation error.  The memory allocation failure will be recorded in\n** the db->mallocFailed flag so that higher-level functions can detect it.\n**\n** This routine will increase the size of the pWC->a[] array as necessary.\n**\n** If the wtFlags argument includes TERM_DYNAMIC, then responsibility\n** for freeing the expression p is assumed by the WhereClause object pWC.\n** This is true even if this routine fails to allocate a new WhereTerm.\n**\n** WARNING:  This routine might reallocate the space used to store\n** WhereTerms.  All pointers to WhereTerms should be invalidated after\n** calling this routine.  Such pointers may be reinitialized by referencing\n** the pWC->a[] array.\n*/\nstatic int whereClauseInsert(WhereClause *pWC, Expr *p, u16 wtFlags){\n  WhereTerm *pTerm;\n  int idx;\n  testcase( wtFlags & TERM_VIRTUAL );\n  if( pWC->nTerm>=pWC->nSlot ){\n    WhereTerm *pOld = pWC->a;\n    sqlite3 *db = pWC->pWInfo->pParse->db;\n    pWC->a = sqlite3WhereMalloc(pWC->pWInfo, sizeof(pWC->a[0])*pWC->nSlot*2 );\n    if( pWC->a==0 ){\n      if( wtFlags & TERM_DYNAMIC ){\n        sqlite3ExprDelete(db, p);\n      }\n      pWC->a = pOld;\n      return 0;\n    }\n    memcpy(pWC->a, pOld, sizeof(pWC->a[0])*pWC->nTerm);\n    pWC->nSlot = pWC->nSlot*2;\n  }\n  pTerm = &pWC->a[idx = pWC->nTerm++];\n  if( (wtFlags & TERM_VIRTUAL)==0 ) pWC->nBase = pWC->nTerm;\n  if( p && ExprHasProperty(p, EP_Unlikely) ){\n    pTerm->truthProb = sqlite3LogEst(p->iTable) - 270;\n  }else{\n    pTerm->truthProb = 1;\n  }\n  pTerm->pExpr = sqlite3ExprSkipCollateAndLikely(p);\n  pTerm->wtFlags = wtFlags;\n  pTerm->pWC = pWC;\n  pTerm->iParent = -1;\n  memset(&pTerm->eOperator, 0,\n         sizeof(WhereTerm) - offsetof(WhereTerm,eOperator));\n  return idx;\n}\n\n/*\n** Return TRUE if the given operator is one of the operators that is\n** allowed for an indexable WHERE clause term.  The allowed operators are\n** \"=\", \"<\", \">\", \"<=\", \">=\", \"IN\", \"IS\", and \"IS NULL\"\n*/\nstatic int allowedOp(int op){\n  assert( TK_GT>TK_EQ && TK_GT<TK_GE );\n  assert( TK_LT>TK_EQ && TK_LT<TK_GE );\n  assert( TK_LE>TK_EQ && TK_LE<TK_GE );\n  assert( TK_GE==TK_EQ+4 );\n  assert( TK_IN<TK_EQ );\n  assert( TK_IS<TK_EQ );\n  assert( TK_ISNULL<TK_EQ );\n  if( op>TK_GE ) return 0;\n  if( op>=TK_EQ ) return 1;\n  return op==TK_IN || op==TK_ISNULL || op==TK_IS;\n}\n\n/*\n** Commute a comparison operator.  Expressions of the form \"X op Y\"\n** are converted into \"Y op X\".\n*/\nstatic u16 exprCommute(Parse *pParse, Expr *pExpr){\n  if( pExpr->pLeft->op==TK_VECTOR\n   || pExpr->pRight->op==TK_VECTOR\n   || sqlite3BinaryCompareCollSeq(pParse, pExpr->pLeft, pExpr->pRight) !=\n      sqlite3BinaryCompareCollSeq(pParse, pExpr->pRight, pExpr->pLeft)\n  ){\n    pExpr->flags ^= EP_Commuted;\n  }\n  SWAP(Expr*,pExpr->pRight,pExpr->pLeft);\n  if( pExpr->op>=TK_GT ){\n    assert( TK_LT==TK_GT+2 );\n    assert( TK_GE==TK_LE+2 );\n    assert( TK_GT>TK_EQ );\n    assert( TK_GT<TK_LE );\n    assert( pExpr->op>=TK_GT && pExpr->op<=TK_GE );\n    pExpr->op = ((pExpr->op-TK_GT)^2)+TK_GT;\n  }\n  return 0;\n}\n\n/*\n** Translate from TK_xx operator to WO_xx bitmask.\n*/\nstatic u16 operatorMask(int op){\n  u16 c;\n  assert( allowedOp(op) );\n  if( op>=TK_EQ ){\n    assert( (WO_EQ<<(op-TK_EQ)) < 0x7fff );\n    c = (u16)(WO_EQ<<(op-TK_EQ));\n  }else if( op==TK_IN ){\n    c = WO_IN;\n  }else if( op==TK_ISNULL ){\n    c = WO_ISNULL;\n  }else{\n    assert( op==TK_IS );\n    c = WO_IS;\n  }\n  assert( op!=TK_ISNULL || c==WO_ISNULL );\n  assert( op!=TK_IN || c==WO_IN );\n  assert( op!=TK_EQ || c==WO_EQ );\n  assert( op!=TK_LT || c==WO_LT );\n  assert( op!=TK_LE || c==WO_LE );\n  assert( op!=TK_GT || c==WO_GT );\n  assert( op!=TK_GE || c==WO_GE );\n  assert( op!=TK_IS || c==WO_IS );\n  return c;\n}\n\n\n#ifndef SQLITE_OMIT_LIKE_OPTIMIZATION\n/*\n** Check to see if the given expression is a LIKE or GLOB operator that\n** can be optimized using inequality constraints.  Return TRUE if it is\n** so and false if not.\n**\n** In order for the operator to be optimizible, the RHS must be a string\n** literal that does not begin with a wildcard.  The LHS must be a column\n** that may only be NULL, a string, or a BLOB, never a number. (This means\n** that virtual tables cannot participate in the LIKE optimization.)  The\n** collating sequence for the column on the LHS must be appropriate for\n** the operator.\n*/\nstatic int isLikeOrGlob(\n  Parse *pParse,    /* Parsing and code generating context */\n  Expr *pExpr,      /* Test this expression */\n  Expr **ppPrefix,  /* Pointer to TK_STRING expression with pattern prefix */\n  int *pisComplete, /* True if the only wildcard is % in the last character */\n  int *pnoCase      /* True if uppercase is equivalent to lowercase */\n){\n  const u8 *z = 0;           /* String on RHS of LIKE operator */\n  Expr *pRight, *pLeft;      /* Right and left size of LIKE operator */\n  ExprList *pList;           /* List of operands to the LIKE operator */\n  u8 c;                      /* One character in z[] */\n  int cnt;                   /* Number of non-wildcard prefix characters */\n  u8 wc[4];                  /* Wildcard characters */\n  sqlite3 *db = pParse->db;  /* Database connection */\n  sqlite3_value *pVal = 0;\n  int op;                    /* Opcode of pRight */\n  int rc;                    /* Result code to return */\n\n  if( !sqlite3IsLikeFunction(db, pExpr, pnoCase, (char*)wc) ){\n    return 0;\n  }\n#ifdef SQLITE_EBCDIC\n  if( *pnoCase ) return 0;\n#endif\n  assert( ExprUseXList(pExpr) );\n  pList = pExpr->x.pList;\n  pLeft = pList->a[1].pExpr;\n\n  pRight = sqlite3ExprSkipCollate(pList->a[0].pExpr);\n  op = pRight->op;\n  if( op==TK_VARIABLE && (db->flags & SQLITE_EnableQPSG)==0 ){\n    Vdbe *pReprepare = pParse->pReprepare;\n    int iCol = pRight->iColumn;\n    pVal = sqlite3VdbeGetBoundValue(pReprepare, iCol, SQLITE_AFF_BLOB);\n    if( pVal && sqlite3_value_type(pVal)==SQLITE_TEXT ){\n      z = sqlite3_value_text(pVal);\n    }\n    sqlite3VdbeSetVarmask(pParse->pVdbe, iCol);\n    assert( pRight->op==TK_VARIABLE || pRight->op==TK_REGISTER );\n  }else if( op==TK_STRING ){\n    assert( !ExprHasProperty(pRight, EP_IntValue) );\n     z = (u8*)pRight->u.zToken;\n  }\n  if( z ){\n    /* Count the number of prefix bytes prior to the first wildcard,\n    ** U+fffd character, or malformed utf-8. If the underlying database\n    ** has a UTF16LE encoding, then only consider ASCII characters.  Note that\n    ** the encoding of z[] is UTF8 - we are dealing with only UTF8 here in this\n    ** code, but the database engine itself might be processing content using a\n    ** different encoding. */\n    cnt = 0;\n    while( (c=z[cnt])!=0 && c!=wc[0] && c!=wc[1] && c!=wc[2] ){\n      cnt++;\n      if( c==wc[3] && z[cnt]>0 && z[cnt]<0x80 ){\n        cnt++;\n      }else if( c>=0x80 ){\n        const u8 *z2 = z+cnt-1;\n        if( c==0xff || sqlite3Utf8Read(&z2)==0xfffd  /* bad utf-8 */\n         || ENC(db)==SQLITE_UTF16LE \n        ){\n          cnt--;\n          break;\n        }else{\n          cnt = (int)(z2-z);\n        }\n      }\n    }\n\n    /* The optimization is possible only if (1) the pattern does not begin\n    ** with a wildcard and if (2) the non-wildcard prefix does not end with\n    ** an (illegal 0xff) character, or (3) the pattern does not consist of\n    ** a single escape character. The second condition is necessary so\n    ** that we can increment the prefix key to find an upper bound for the\n    ** range search. The third is because the caller assumes that the pattern\n    ** consists of at least one character after all escapes have been\n    ** removed.  */\n    if( (cnt>1 || (cnt>0 && z[0]!=wc[3])) && ALWAYS(255!=(u8)z[cnt-1]) ){\n      Expr *pPrefix;\n\n      /* A \"complete\" match if the pattern ends with \"*\" or \"%\" */\n      *pisComplete = c==wc[0] && z[cnt+1]==0 && ENC(db)!=SQLITE_UTF16LE;\n\n      /* Get the pattern prefix.  Remove all escapes from the prefix. */\n      pPrefix = sqlite3Expr(db, TK_STRING, (char*)z);\n      if( pPrefix ){\n        int iFrom, iTo;\n        char *zNew;\n        assert( !ExprHasProperty(pPrefix, EP_IntValue) );\n        zNew = pPrefix->u.zToken;\n        zNew[cnt] = 0;\n        for(iFrom=iTo=0; iFrom<cnt; iFrom++){\n          if( zNew[iFrom]==wc[3] ) iFrom++;\n          zNew[iTo++] = zNew[iFrom];\n        }\n        zNew[iTo] = 0;\n        assert( iTo>0 );\n\n        /* If the LHS is not an ordinary column with TEXT affinity, then the\n        ** pattern prefix boundaries (both the start and end boundaries) must\n        ** not look like a number.  Otherwise the pattern might be treated as\n        ** a number, which will invalidate the LIKE optimization.\n        **\n        ** Getting this right has been a persistent source of bugs in the\n        ** LIKE optimization.  See, for example:\n        **    2018-09-10 https://sqlite.org/src/info/c94369cae9b561b1\n        **    2019-05-02 https://sqlite.org/src/info/b043a54c3de54b28\n        **    2019-06-10 https://sqlite.org/src/info/fd76310a5e843e07\n        **    2019-06-14 https://sqlite.org/src/info/ce8717f0885af975\n        **    2019-09-03 https://sqlite.org/src/info/0f0428096f17252a\n        */\n        if( pLeft->op!=TK_COLUMN\n         || sqlite3ExprAffinity(pLeft)!=SQLITE_AFF_TEXT\n         || (ALWAYS( ExprUseYTab(pLeft) )\n             && ALWAYS(pLeft->y.pTab)\n             && IsVirtual(pLeft->y.pTab))  /* Might be numeric */\n        ){\n          int isNum;\n          double rDummy;\n          isNum = sqlite3AtoF(zNew, &rDummy, iTo, SQLITE_UTF8);\n          if( isNum<=0 ){\n            if( iTo==1 && zNew[0]=='-' ){\n              isNum = +1;\n            }else{\n              zNew[iTo-1]++;\n              isNum = sqlite3AtoF(zNew, &rDummy, iTo, SQLITE_UTF8);\n              zNew[iTo-1]--;\n            }\n          }\n          if( isNum>0 ){\n            sqlite3ExprDelete(db, pPrefix);\n            sqlite3ValueFree(pVal);\n            return 0;\n          }\n        }\n      }\n      *ppPrefix = pPrefix;\n\n      /* If the RHS pattern is a bound parameter, make arrangements to\n      ** reprepare the statement when that parameter is rebound */\n      if( op==TK_VARIABLE ){\n        Vdbe *v = pParse->pVdbe;\n        sqlite3VdbeSetVarmask(v, pRight->iColumn);\n        assert( !ExprHasProperty(pRight, EP_IntValue) );\n        if( *pisComplete && pRight->u.zToken[1] ){\n          /* If the rhs of the LIKE expression is a variable, and the current\n          ** value of the variable means there is no need to invoke the LIKE\n          ** function, then no OP_Variable will be added to the program.\n          ** This causes problems for the sqlite3_bind_parameter_name()\n          ** API. To work around them, add a dummy OP_Variable here.\n          */\n          int r1 = sqlite3GetTempReg(pParse);\n          sqlite3ExprCodeTarget(pParse, pRight, r1);\n          sqlite3VdbeChangeP3(v, sqlite3VdbeCurrentAddr(v)-1, 0);\n          sqlite3ReleaseTempReg(pParse, r1);\n        }\n      }\n    }else{\n      z = 0;\n    }\n  }\n\n  rc = (z!=0);\n  sqlite3ValueFree(pVal);\n  return rc;\n}\n#endif /* SQLITE_OMIT_LIKE_OPTIMIZATION */\n\n/*\n** If pExpr is one of \"like\", \"glob\", \"match\", or \"regexp\", then\n** return the corresponding SQLITE_INDEX_CONSTRAINT_xxxx value.\n** If not, return 0.\n**\n** pExpr is guaranteed to be a TK_FUNCTION.\n*/\nint sqlite3ExprIsLikeOperator(const Expr *pExpr){\n  static const struct {\n    const char *zOp;\n    unsigned char eOp;\n  } aOp[] = {\n    { \"match\",  SQLITE_INDEX_CONSTRAINT_MATCH },\n    { \"glob\",   SQLITE_INDEX_CONSTRAINT_GLOB },\n    { \"like\",   SQLITE_INDEX_CONSTRAINT_LIKE },\n    { \"regexp\", SQLITE_INDEX_CONSTRAINT_REGEXP }\n  };\n  int i;\n  assert( pExpr->op==TK_FUNCTION );\n  assert( !ExprHasProperty(pExpr, EP_IntValue) );\n  for(i=0; i<ArraySize(aOp); i++){\n    if( sqlite3StrICmp(pExpr->u.zToken, aOp[i].zOp)==0 ){\n      return aOp[i].eOp;\n    }\n  }\n  return 0;\n}\n\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n/*\n** Check to see if the pExpr expression is a form that needs to be passed\n** to the xBestIndex method of virtual tables.  Forms of interest include:\n**\n**          Expression                   Virtual Table Operator\n**          -----------------------      ---------------------------------\n**      1.  column MATCH expr            SQLITE_INDEX_CONSTRAINT_MATCH\n**      2.  column GLOB expr             SQLITE_INDEX_CONSTRAINT_GLOB\n**      3.  column LIKE expr             SQLITE_INDEX_CONSTRAINT_LIKE\n**      4.  column REGEXP expr           SQLITE_INDEX_CONSTRAINT_REGEXP\n**      5.  column != expr               SQLITE_INDEX_CONSTRAINT_NE\n**      6.  expr != column               SQLITE_INDEX_CONSTRAINT_NE\n**      7.  column IS NOT expr           SQLITE_INDEX_CONSTRAINT_ISNOT\n**      8.  expr IS NOT column           SQLITE_INDEX_CONSTRAINT_ISNOT\n**      9.  column IS NOT NULL           SQLITE_INDEX_CONSTRAINT_ISNOTNULL\n**\n** In every case, \"column\" must be a column of a virtual table.  If there\n** is a match, set *ppLeft to the \"column\" expression, set *ppRight to the\n** \"expr\" expression (even though in forms (6) and (8) the column is on the\n** right and the expression is on the left).  Also set *peOp2 to the\n** appropriate virtual table operator.  The return value is 1 or 2 if there\n** is a match.  The usual return is 1, but if the RHS is also a column\n** of virtual table in forms (5) or (7) then return 2.\n**\n** If the expression matches none of the patterns above, return 0.\n*/\nstatic int isAuxiliaryVtabOperator(\n  sqlite3 *db,                    /* Parsing context */\n  Expr *pExpr,                    /* Test this expression */\n  unsigned char *peOp2,           /* OUT: 0 for MATCH, or else an op2 value */\n  Expr **ppLeft,                  /* Column expression to left of MATCH/op2 */\n  Expr **ppRight                  /* Expression to left of MATCH/op2 */\n){\n  if( pExpr->op==TK_FUNCTION ){\n    ExprList *pList;\n    Expr *pCol;                     /* Column reference */\n    int i;\n\n    assert( ExprUseXList(pExpr) );\n    pList = pExpr->x.pList;\n    if( pList==0 || pList->nExpr!=2 ){\n      return 0;\n    }\n\n    /* Built-in operators MATCH, GLOB, LIKE, and REGEXP attach to a\n    ** virtual table on their second argument, which is the same as\n    ** the left-hand side operand in their in-fix form.\n    **\n    **       vtab_column MATCH expression\n    **       MATCH(expression,vtab_column)\n    */\n    pCol = pList->a[1].pExpr;\n    assert( pCol->op!=TK_COLUMN || (ExprUseYTab(pCol) && pCol->y.pTab!=0) );\n    if( ExprIsVtab(pCol) && (i = sqlite3ExprIsLikeOperator(pExpr))!=0 ){\n      *peOp2 = i;\n      *ppRight = pList->a[0].pExpr;\n      *ppLeft = pCol;\n      return 1;\n    }\n\n    /* We can also match against the first column of overloaded\n    ** functions where xFindFunction returns a value of at least\n    ** SQLITE_INDEX_CONSTRAINT_FUNCTION.\n    **\n    **      OVERLOADED(vtab_column,expression)\n    **\n    ** Historically, xFindFunction expected to see lower-case function\n    ** names.  But for this use case, xFindFunction is expected to deal\n    ** with function names in an arbitrary case.\n    */\n    pCol = pList->a[0].pExpr;\n    assert( pCol->op!=TK_COLUMN || ExprUseYTab(pCol) );\n    assert( pCol->op!=TK_COLUMN || (ExprUseYTab(pCol) && pCol->y.pTab!=0) );\n    if( ExprIsVtab(pCol) ){\n      sqlite3_vtab *pVtab;\n      sqlite3_module *pMod;\n      void (*xNotUsed)(sqlite3_context*,int,sqlite3_value**);\n      void *pNotUsed;\n      pVtab = sqlite3GetVTable(db, pCol->y.pTab)->pVtab;\n      assert( pVtab!=0 );\n      assert( pVtab->pModule!=0 );\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      pMod = (sqlite3_module *)pVtab->pModule;\n      if( pMod->xFindFunction!=0 ){\n        i = pMod->xFindFunction(pVtab,2, pExpr->u.zToken, &xNotUsed, &pNotUsed);\n        if( i>=SQLITE_INDEX_CONSTRAINT_FUNCTION ){\n          *peOp2 = i;\n          *ppRight = pList->a[1].pExpr;\n          *ppLeft = pCol;\n          return 1;\n        }\n      }\n    }\n  }else if( pExpr->op>=TK_EQ ){\n    /* Comparison operators are a common case.  Save a few comparisons for\n    ** that common case by terminating early. */\n    assert( TK_NE < TK_EQ );\n    assert( TK_ISNOT < TK_EQ );\n    assert( TK_NOTNULL < TK_EQ );\n    return 0;\n  }else if( pExpr->op==TK_NE || pExpr->op==TK_ISNOT || pExpr->op==TK_NOTNULL ){\n    int res = 0;\n    Expr *pLeft = pExpr->pLeft;\n    Expr *pRight = pExpr->pRight;\n    assert( pLeft->op!=TK_COLUMN || (ExprUseYTab(pLeft) && pLeft->y.pTab!=0) );\n    if( ExprIsVtab(pLeft) ){\n      res++;\n    }\n    assert( pRight==0 || pRight->op!=TK_COLUMN\n            || (ExprUseYTab(pRight) && pRight->y.pTab!=0) );\n    if( pRight && ExprIsVtab(pRight) ){\n      res++;\n      SWAP(Expr*, pLeft, pRight);\n    }\n    *ppLeft = pLeft;\n    *ppRight = pRight;\n    if( pExpr->op==TK_NE ) *peOp2 = SQLITE_INDEX_CONSTRAINT_NE;\n    if( pExpr->op==TK_ISNOT ) *peOp2 = SQLITE_INDEX_CONSTRAINT_ISNOT;\n    if( pExpr->op==TK_NOTNULL ) *peOp2 = SQLITE_INDEX_CONSTRAINT_ISNOTNULL;\n    return res;\n  }\n  return 0;\n}\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n\n/*\n** If the pBase expression originated in the ON or USING clause of\n** a join, then transfer the appropriate markings over to derived.\n*/\nstatic void transferJoinMarkings(Expr *pDerived, Expr *pBase){\n  if( pDerived && ExprHasProperty(pBase, EP_OuterON|EP_InnerON) ){\n    pDerived->flags |= pBase->flags & (EP_OuterON|EP_InnerON);\n    pDerived->w.iJoin = pBase->w.iJoin;\n  }\n}\n\n/*\n** Mark term iChild as being a child of term iParent\n*/\nstatic void markTermAsChild(WhereClause *pWC, int iChild, int iParent){\n  pWC->a[iChild].iParent = iParent;\n  pWC->a[iChild].truthProb = pWC->a[iParent].truthProb;\n  pWC->a[iParent].nChild++;\n}\n\n/*\n** Return the N-th AND-connected subterm of pTerm.  Or if pTerm is not\n** a conjunction, then return just pTerm when N==0.  If N is exceeds\n** the number of available subterms, return NULL.\n*/\nstatic WhereTerm *whereNthSubterm(WhereTerm *pTerm, int N){\n  if( pTerm->eOperator!=WO_AND ){\n    return N==0 ? pTerm : 0;\n  }\n  if( N<pTerm->u.pAndInfo->wc.nTerm ){\n    return &pTerm->u.pAndInfo->wc.a[N];\n  }\n  return 0;\n}\n\n/*\n** Subterms pOne and pTwo are contained within WHERE clause pWC.  The\n** two subterms are in disjunction - they are OR-ed together.\n**\n** If these two terms are both of the form:  \"A op B\" with the same\n** A and B values but different operators and if the operators are\n** compatible (if one is = and the other is <, for example) then\n** add a new virtual AND term to pWC that is the combination of the\n** two.\n**\n** Some examples:\n**\n**    x<y OR x=y    -->     x<=y\n**    x=y OR x=y    -->     x=y\n**    x<=y OR x<y   -->     x<=y\n**\n** The following is NOT generated:\n**\n**    x<y OR x>y    -->     x!=y    \n*/\nstatic void whereCombineDisjuncts(\n  SrcList *pSrc,         /* the FROM clause */\n  WhereClause *pWC,      /* The complete WHERE clause */\n  WhereTerm *pOne,       /* First disjunct */\n  WhereTerm *pTwo        /* Second disjunct */\n){\n  u16 eOp = pOne->eOperator | pTwo->eOperator;\n  sqlite3 *db;           /* Database connection (for malloc) */\n  Expr *pNew;            /* New virtual expression */\n  int op;                /* Operator for the combined expression */\n  int idxNew;            /* Index in pWC of the next virtual term */\n  Expr *pA, *pB;         /* Expressions associated with pOne and pTwo */\n\n  if( (pOne->wtFlags | pTwo->wtFlags) & TERM_VNULL ) return;\n  if( (pOne->eOperator & (WO_EQ|WO_LT|WO_LE|WO_GT|WO_GE))==0 ) return;\n  if( (pTwo->eOperator & (WO_EQ|WO_LT|WO_LE|WO_GT|WO_GE))==0 ) return;\n  if( (eOp & (WO_EQ|WO_LT|WO_LE))!=eOp\n   && (eOp & (WO_EQ|WO_GT|WO_GE))!=eOp ) return;\n  pA = pOne->pExpr;\n  pB = pTwo->pExpr;\n  assert( pA->pLeft!=0 && pA->pRight!=0 );\n  assert( pB->pLeft!=0 && pB->pRight!=0 );\n  if( sqlite3ExprCompare(0,pA->pLeft, pB->pLeft, -1) )  return;\n  if( sqlite3ExprCompare(0,pA->pRight, pB->pRight,-1) ) return;\n  if( ExprHasProperty(pA,EP_Commuted)!=ExprHasProperty(pB,EP_Commuted) ){\n    return;\n  }\n  /* If we reach this point, it means the two subterms can be combined */\n  if( (eOp & (eOp-1))!=0 ){\n    if( eOp & (WO_LT|WO_LE) ){\n      eOp = WO_LE;\n    }else{\n      assert( eOp & (WO_GT|WO_GE) );\n      eOp = WO_GE;\n    }\n  }\n  db = pWC->pWInfo->pParse->db;\n  pNew = sqlite3ExprDup(db, pA, 0);\n  if( pNew==0 ) return;\n  for(op=TK_EQ; eOp!=(WO_EQ<<(op-TK_EQ)); op++){ assert( op<TK_GE ); }\n  pNew->op = op;\n  idxNew = whereClauseInsert(pWC, pNew, TERM_VIRTUAL|TERM_DYNAMIC);\n  exprAnalyze(pSrc, pWC, idxNew);\n}\n\n#if !defined(SQLITE_OMIT_OR_OPTIMIZATION) && !defined(SQLITE_OMIT_SUBQUERY)\n/*\n** Analyze a term that consists of two or more OR-connected\n** subterms.  So in:\n**\n**     ... WHERE  (a=5) AND (b=7 OR c=9 OR d=13) AND (d=13)\n**                          ^^^^^^^^^^^^^^^^^^^^\n**\n** This routine analyzes terms such as the middle term in the above example.\n** A WhereOrTerm object is computed and attached to the term under\n** analysis, regardless of the outcome of the analysis.  Hence:\n**\n**     WhereTerm.wtFlags   |=  TERM_ORINFO\n**     WhereTerm.u.pOrInfo  =  a dynamically allocated WhereOrTerm object\n**\n** The term being analyzed must have two or more of OR-connected subterms.\n** A single subterm might be a set of AND-connected sub-subterms.\n** Examples of terms under analysis:\n**\n**     (A)     t1.x=t2.y OR t1.x=t2.z OR t1.y=15 OR t1.z=t3.a+5\n**     (B)     x=expr1 OR expr2=x OR x=expr3\n**     (C)     t1.x=t2.y OR (t1.x=t2.z AND t1.y=15)\n**     (D)     x=expr1 OR (y>11 AND y<22 AND z LIKE '*hello*')\n**     (E)     (p.a=1 AND q.b=2 AND r.c=3) OR (p.x=4 AND q.y=5 AND r.z=6)\n**     (F)     x>A OR (x=A AND y>=B)\n**\n** CASE 1:\n**\n** If all subterms are of the form T.C=expr for some single column of C and\n** a single table T (as shown in example B above) then create a new virtual\n** term that is an equivalent IN expression.  In other words, if the term\n** being analyzed is:\n**\n**      x = expr1  OR  expr2 = x  OR  x = expr3\n**\n** then create a new virtual term like this:\n**\n**      x IN (expr1,expr2,expr3)\n**\n** CASE 2:\n**\n** If there are exactly two disjuncts and one side has x>A and the other side\n** has x=A (for the same x and A) then add a new virtual conjunct term to the\n** WHERE clause of the form \"x>=A\".  Example:\n**\n**      x>A OR (x=A AND y>B)    adds:    x>=A\n**\n** The added conjunct can sometimes be helpful in query planning.\n**\n** CASE 3:\n**\n** If all subterms are indexable by a single table T, then set\n**\n**     WhereTerm.eOperator              =  WO_OR\n**     WhereTerm.u.pOrInfo->indexable  |=  the cursor number for table T\n**\n** A subterm is \"indexable\" if it is of the form\n** \"T.C <op> <expr>\" where C is any column of table T and\n** <op> is one of \"=\", \"<\", \"<=\", \">\", \">=\", \"IS NULL\", or \"IN\".\n** A subterm is also indexable if it is an AND of two or more\n** subsubterms at least one of which is indexable.  Indexable AND\n** subterms have their eOperator set to WO_AND and they have\n** u.pAndInfo set to a dynamically allocated WhereAndTerm object.\n**\n** From another point of view, \"indexable\" means that the subterm could\n** potentially be used with an index if an appropriate index exists.\n** This analysis does not consider whether or not the index exists; that\n** is decided elsewhere.  This analysis only looks at whether subterms\n** appropriate for indexing exist.\n**\n** All examples A through E above satisfy case 3.  But if a term\n** also satisfies case 1 (such as B) we know that the optimizer will\n** always prefer case 1, so in that case we pretend that case 3 is not\n** satisfied.\n**\n** It might be the case that multiple tables are indexable.  For example,\n** (E) above is indexable on tables P, Q, and R.\n**\n** Terms that satisfy case 3 are candidates for lookup by using\n** separate indices to find rowids for each subterm and composing\n** the union of all rowids using a RowSet object.  This is similar\n** to \"bitmap indices\" in other database engines.\n**\n** OTHERWISE:\n**\n** If none of cases 1, 2, or 3 apply, then leave the eOperator set to\n** zero.  This term is not useful for search.\n*/\nstatic void exprAnalyzeOrTerm(\n  SrcList *pSrc,            /* the FROM clause */\n  WhereClause *pWC,         /* the complete WHERE clause */\n  int idxTerm               /* Index of the OR-term to be analyzed */\n){\n  WhereInfo *pWInfo = pWC->pWInfo;        /* WHERE clause processing context */\n  Parse *pParse = pWInfo->pParse;         /* Parser context */\n  sqlite3 *db = pParse->db;               /* Database connection */\n  WhereTerm *pTerm = &pWC->a[idxTerm];    /* The term to be analyzed */\n  Expr *pExpr = pTerm->pExpr;             /* The expression of the term */\n  int i;                                  /* Loop counters */\n  WhereClause *pOrWc;       /* Breakup of pTerm into subterms */\n  WhereTerm *pOrTerm;       /* A Sub-term within the pOrWc */\n  WhereOrInfo *pOrInfo;     /* Additional information associated with pTerm */\n  Bitmask chngToIN;         /* Tables that might satisfy case 1 */\n  Bitmask indexable;        /* Tables that are indexable, satisfying case 2 */\n\n  /*\n  ** Break the OR clause into its separate subterms.  The subterms are\n  ** stored in a WhereClause structure containing within the WhereOrInfo\n  ** object that is attached to the original OR clause term.\n  */\n  assert( (pTerm->wtFlags & (TERM_DYNAMIC|TERM_ORINFO|TERM_ANDINFO))==0 );\n  assert( pExpr->op==TK_OR );\n  pTerm->u.pOrInfo = pOrInfo = sqlite3DbMallocZero(db, sizeof(*pOrInfo));\n  if( pOrInfo==0 ) return;\n  pTerm->wtFlags |= TERM_ORINFO;\n  pOrWc = &pOrInfo->wc;\n  memset(pOrWc->aStatic, 0, sizeof(pOrWc->aStatic));\n  sqlite3WhereClauseInit(pOrWc, pWInfo);\n  sqlite3WhereSplit(pOrWc, pExpr, TK_OR);\n  sqlite3WhereExprAnalyze(pSrc, pOrWc);\n  if( db->mallocFailed ) return;\n  assert( pOrWc->nTerm>=2 );\n\n  /*\n  ** Compute the set of tables that might satisfy cases 1 or 3.\n  */\n  indexable = ~(Bitmask)0;\n  chngToIN = ~(Bitmask)0;\n  for(i=pOrWc->nTerm-1, pOrTerm=pOrWc->a; i>=0 && indexable; i--, pOrTerm++){\n    if( (pOrTerm->eOperator & WO_SINGLE)==0 ){\n      WhereAndInfo *pAndInfo;\n      assert( (pOrTerm->wtFlags & (TERM_ANDINFO|TERM_ORINFO))==0 );\n      chngToIN = 0;\n      pAndInfo = sqlite3DbMallocRawNN(db, sizeof(*pAndInfo));\n      if( pAndInfo ){\n        WhereClause *pAndWC;\n        WhereTerm *pAndTerm;\n        int j;\n        Bitmask b = 0;\n        pOrTerm->u.pAndInfo = pAndInfo;\n        pOrTerm->wtFlags |= TERM_ANDINFO;\n        pOrTerm->eOperator = WO_AND;\n        pOrTerm->leftCursor = -1;\n        pAndWC = &pAndInfo->wc;\n        memset(pAndWC->aStatic, 0, sizeof(pAndWC->aStatic));\n        sqlite3WhereClauseInit(pAndWC, pWC->pWInfo);\n        sqlite3WhereSplit(pAndWC, pOrTerm->pExpr, TK_AND);\n        sqlite3WhereExprAnalyze(pSrc, pAndWC);\n        pAndWC->pOuter = pWC;\n        if( !db->mallocFailed ){\n          for(j=0, pAndTerm=pAndWC->a; j<pAndWC->nTerm; j++, pAndTerm++){\n            assert( pAndTerm->pExpr );\n            if( allowedOp(pAndTerm->pExpr->op)\n             || pAndTerm->eOperator==WO_AUX\n            ){\n              b |= sqlite3WhereGetMask(&pWInfo->sMaskSet, pAndTerm->leftCursor);\n            }\n          }\n        }\n        indexable &= b;\n      }\n    }else if( pOrTerm->wtFlags & TERM_COPIED ){\n      /* Skip this term for now.  We revisit it when we process the\n      ** corresponding TERM_VIRTUAL term */\n    }else{\n      Bitmask b;\n      b = sqlite3WhereGetMask(&pWInfo->sMaskSet, pOrTerm->leftCursor);\n      if( pOrTerm->wtFlags & TERM_VIRTUAL ){\n        WhereTerm *pOther = &pOrWc->a[pOrTerm->iParent];\n        b |= sqlite3WhereGetMask(&pWInfo->sMaskSet, pOther->leftCursor);\n      }\n      indexable &= b;\n      if( (pOrTerm->eOperator & WO_EQ)==0 ){\n        chngToIN = 0;\n      }else{\n        chngToIN &= b;\n      }\n    }\n  }\n\n  /*\n  ** Record the set of tables that satisfy case 3.  The set might be\n  ** empty.\n  */\n  pOrInfo->indexable = indexable;\n  pTerm->eOperator = WO_OR;\n  pTerm->leftCursor = -1;\n  if( indexable ){\n    pWC->hasOr = 1;\n  }\n\n  /* For a two-way OR, attempt to implementation case 2.\n  */\n  if( indexable && pOrWc->nTerm==2 ){\n    int iOne = 0;\n    WhereTerm *pOne;\n    while( (pOne = whereNthSubterm(&pOrWc->a[0],iOne++))!=0 ){\n      int iTwo = 0;\n      WhereTerm *pTwo;\n      while( (pTwo = whereNthSubterm(&pOrWc->a[1],iTwo++))!=0 ){\n        whereCombineDisjuncts(pSrc, pWC, pOne, pTwo);\n      }\n    }\n  }\n\n  /*\n  ** chngToIN holds a set of tables that *might* satisfy case 1.  But\n  ** we have to do some additional checking to see if case 1 really\n  ** is satisfied.\n  **\n  ** chngToIN will hold either 0, 1, or 2 bits.  The 0-bit case means\n  ** that there is no possibility of transforming the OR clause into an\n  ** IN operator because one or more terms in the OR clause contain\n  ** something other than == on a column in the single table.  The 1-bit\n  ** case means that every term of the OR clause is of the form\n  ** \"table.column=expr\" for some single table.  The one bit that is set\n  ** will correspond to the common table.  We still need to check to make\n  ** sure the same column is used on all terms.  The 2-bit case is when\n  ** the all terms are of the form \"table1.column=table2.column\".  It\n  ** might be possible to form an IN operator with either table1.column\n  ** or table2.column as the LHS if either is common to every term of\n  ** the OR clause.\n  **\n  ** Note that terms of the form \"table.column1=table.column2\" (the\n  ** same table on both sizes of the ==) cannot be optimized.\n  */\n  if( chngToIN ){\n    int okToChngToIN = 0;     /* True if the conversion to IN is valid */\n    int iColumn = -1;         /* Column index on lhs of IN operator */\n    int iCursor = -1;         /* Table cursor common to all terms */\n    int j = 0;                /* Loop counter */\n\n    /* Search for a table and column that appears on one side or the\n    ** other of the == operator in every subterm.  That table and column\n    ** will be recorded in iCursor and iColumn.  There might not be any\n    ** such table and column.  Set okToChngToIN if an appropriate table\n    ** and column is found but leave okToChngToIN false if not found.\n    */\n    for(j=0; j<2 && !okToChngToIN; j++){\n      Expr *pLeft = 0;\n      pOrTerm = pOrWc->a;\n      for(i=pOrWc->nTerm-1; i>=0; i--, pOrTerm++){\n        assert( pOrTerm->eOperator & WO_EQ );\n        pOrTerm->wtFlags &= ~TERM_OK;\n        if( pOrTerm->leftCursor==iCursor ){\n          /* This is the 2-bit case and we are on the second iteration and\n          ** current term is from the first iteration.  So skip this term. */\n          assert( j==1 );\n          continue;\n        }\n        if( (chngToIN & sqlite3WhereGetMask(&pWInfo->sMaskSet,\n                                            pOrTerm->leftCursor))==0 ){\n          /* This term must be of the form t1.a==t2.b where t2 is in the\n          ** chngToIN set but t1 is not.  This term will be either preceded\n          ** or followed by an inverted copy (t2.b==t1.a).  Skip this term\n          ** and use its inversion. */\n          testcase( pOrTerm->wtFlags & TERM_COPIED );\n          testcase( pOrTerm->wtFlags & TERM_VIRTUAL );\n          assert( pOrTerm->wtFlags & (TERM_COPIED|TERM_VIRTUAL) );\n          continue;\n        }\n        assert( (pOrTerm->eOperator & (WO_OR|WO_AND))==0 );\n        iColumn = pOrTerm->u.x.leftColumn;\n        iCursor = pOrTerm->leftCursor;\n        pLeft = pOrTerm->pExpr->pLeft;\n        break;\n      }\n      if( i<0 ){\n        /* No candidate table+column was found.  This can only occur\n        ** on the second iteration */\n        assert( j==1 );\n        assert( IsPowerOfTwo(chngToIN) );\n        assert( chngToIN==sqlite3WhereGetMask(&pWInfo->sMaskSet, iCursor) );\n        break;\n      }\n      testcase( j==1 );\n\n      /* We have found a candidate table and column.  Check to see if that\n      ** table and column is common to every term in the OR clause */\n      okToChngToIN = 1;\n      for(; i>=0 && okToChngToIN; i--, pOrTerm++){\n        assert( pOrTerm->eOperator & WO_EQ );\n        assert( (pOrTerm->eOperator & (WO_OR|WO_AND))==0 );\n        if( pOrTerm->leftCursor!=iCursor ){\n          pOrTerm->wtFlags &= ~TERM_OK;\n        }else if( pOrTerm->u.x.leftColumn!=iColumn || (iColumn==XN_EXPR\n               && sqlite3ExprCompare(pParse, pOrTerm->pExpr->pLeft, pLeft, -1)\n        )){\n          okToChngToIN = 0;\n        }else{\n          int affLeft, affRight;\n          /* If the right-hand side is also a column, then the affinities\n          ** of both right and left sides must be such that no type\n          ** conversions are required on the right.  (Ticket #2249)\n          */\n          affRight = sqlite3ExprAffinity(pOrTerm->pExpr->pRight);\n          affLeft = sqlite3ExprAffinity(pOrTerm->pExpr->pLeft);\n          if( affRight!=0 && affRight!=affLeft ){\n            okToChngToIN = 0;\n          }else{\n            pOrTerm->wtFlags |= TERM_OK;\n          }\n        }\n      }\n    }\n\n    /* At this point, okToChngToIN is true if original pTerm satisfies\n    ** case 1.  In that case, construct a new virtual term that is\n    ** pTerm converted into an IN operator.\n    */\n    if( okToChngToIN ){\n      Expr *pDup;            /* A transient duplicate expression */\n      ExprList *pList = 0;   /* The RHS of the IN operator */\n      Expr *pLeft = 0;       /* The LHS of the IN operator */\n      Expr *pNew;            /* The complete IN operator */\n\n      for(i=pOrWc->nTerm-1, pOrTerm=pOrWc->a; i>=0; i--, pOrTerm++){\n        if( (pOrTerm->wtFlags & TERM_OK)==0 ) continue;\n        assert( pOrTerm->eOperator & WO_EQ );\n        assert( (pOrTerm->eOperator & (WO_OR|WO_AND))==0 );\n        assert( pOrTerm->leftCursor==iCursor );\n        assert( pOrTerm->u.x.leftColumn==iColumn );\n        pDup = sqlite3ExprDup(db, pOrTerm->pExpr->pRight, 0);\n        pList = sqlite3ExprListAppend(pWInfo->pParse, pList, pDup);\n        pLeft = pOrTerm->pExpr->pLeft;\n      }\n      assert( pLeft!=0 );\n      pDup = sqlite3ExprDup(db, pLeft, 0);\n      pNew = sqlite3PExpr(pParse, TK_IN, pDup, 0);\n      if( pNew ){\n        int idxNew;\n        transferJoinMarkings(pNew, pExpr);\n        assert( ExprUseXList(pNew) );\n        pNew->x.pList = pList;\n        idxNew = whereClauseInsert(pWC, pNew, TERM_VIRTUAL|TERM_DYNAMIC);\n        testcase( idxNew==0 );\n        exprAnalyze(pSrc, pWC, idxNew);\n        /* pTerm = &pWC->a[idxTerm]; // would be needed if pTerm where reused */\n        markTermAsChild(pWC, idxNew, idxTerm);\n      }else{\n        sqlite3ExprListDelete(db, pList);\n      }\n    }\n  }\n}\n#endif /* !SQLITE_OMIT_OR_OPTIMIZATION && !SQLITE_OMIT_SUBQUERY */\n\n/*\n** We already know that pExpr is a binary operator where both operands are\n** column references.  This routine checks to see if pExpr is an equivalence\n** relation:\n**   1.  The SQLITE_Transitive optimization must be enabled\n**   2.  Must be either an == or an IS operator\n**   3.  Not originating in the ON clause of an OUTER JOIN\n**   4.  The operator is not IS or else the query does not contain RIGHT JOIN\n**   5.  The affinities of A and B must be compatible\n**   6a. Both operands use the same collating sequence OR\n**   6b. The overall collating sequence is BINARY\n** If this routine returns TRUE, that means that the RHS can be substituted\n** for the LHS anyplace else in the WHERE clause where the LHS column occurs.\n** This is an optimization.  No harm comes from returning 0.  But if 1 is\n** returned when it should not be, then incorrect answers might result.\n*/\nstatic int termIsEquivalence(Parse *pParse, Expr *pExpr, SrcList *pSrc){\n  char aff1, aff2;\n  CollSeq *pColl;\n  if( !OptimizationEnabled(pParse->db, SQLITE_Transitive) ) return 0;  /* (1) */\n  if( pExpr->op!=TK_EQ && pExpr->op!=TK_IS ) return 0;                 /* (2) */\n  if( ExprHasProperty(pExpr, EP_OuterON) ) return 0;                   /* (3) */\n  assert( pSrc!=0 );\n  if( pExpr->op==TK_IS\n   && pSrc->nSrc>=2\n   && (pSrc->a[0].fg.jointype & JT_LTORJ)!=0\n  ){\n    return 0;                                                          /* (4) */\n  }\n  aff1 = sqlite3ExprAffinity(pExpr->pLeft);\n  aff2 = sqlite3ExprAffinity(pExpr->pRight);\n  if( aff1!=aff2\n   && (!sqlite3IsNumericAffinity(aff1) || !sqlite3IsNumericAffinity(aff2))\n  ){\n    return 0;                                                          /* (5) */\n  }\n  pColl = sqlite3ExprCompareCollSeq(pParse, pExpr);\n  if( !sqlite3IsBinary(pColl)\n   && !sqlite3ExprCollSeqMatch(pParse, pExpr->pLeft, pExpr->pRight)\n  ){\n    return 0;                                                          /* (6) */\n  }\n  return 1;\n}\n\n/*\n** Recursively walk the expressions of a SELECT statement and generate\n** a bitmask indicating which tables are used in that expression\n** tree.\n*/\nstatic Bitmask exprSelectUsage(WhereMaskSet *pMaskSet, Select *pS){\n  Bitmask mask = 0;\n  while( pS ){\n    SrcList *pSrc = pS->pSrc;\n    mask |= sqlite3WhereExprListUsage(pMaskSet, pS->pEList);\n    mask |= sqlite3WhereExprListUsage(pMaskSet, pS->pGroupBy);\n    mask |= sqlite3WhereExprListUsage(pMaskSet, pS->pOrderBy);\n    mask |= sqlite3WhereExprUsage(pMaskSet, pS->pWhere);\n    mask |= sqlite3WhereExprUsage(pMaskSet, pS->pHaving);\n    if( ALWAYS(pSrc!=0) ){\n      int i;\n      for(i=0; i<pSrc->nSrc; i++){\n        if( pSrc->a[i].fg.isSubquery ){\n          mask |= exprSelectUsage(pMaskSet, pSrc->a[i].u4.pSubq->pSelect);\n        }\n        if( pSrc->a[i].fg.isUsing==0 ){\n          mask |= sqlite3WhereExprUsage(pMaskSet, pSrc->a[i].u3.pOn);\n        }\n        if( pSrc->a[i].fg.isTabFunc ){\n          mask |= sqlite3WhereExprListUsage(pMaskSet, pSrc->a[i].u1.pFuncArg);\n        }\n      }\n    }\n    pS = pS->pPrior;\n  }\n  return mask;\n}\n\n/*\n** Expression pExpr is one operand of a comparison operator that might\n** be useful for indexing.  This routine checks to see if pExpr appears\n** in any index.  Return TRUE (1) if pExpr is an indexed term and return\n** FALSE (0) if not.  If TRUE is returned, also set aiCurCol[0] to the cursor\n** number of the table that is indexed and aiCurCol[1] to the column number\n** of the column that is indexed, or XN_EXPR (-2) if an expression is being\n** indexed.\n**\n** If pExpr is a TK_COLUMN column reference, then this routine always returns\n** true even if that particular column is not indexed, because the column\n** might be added to an automatic index later.\n*/\nstatic SQLITE_NOINLINE int exprMightBeIndexed2(\n  SrcList *pFrom,        /* The FROM clause */\n  int *aiCurCol,         /* Write the referenced table cursor and column here */\n  Expr *pExpr,           /* An operand of a comparison operator */\n  int j                  /* Start looking with the j-th pFrom entry */\n){\n  Index *pIdx;\n  int i;\n  int iCur;\n  do{\n    iCur = pFrom->a[j].iCursor;\n    for(pIdx=pFrom->a[j].pSTab->pIndex; pIdx; pIdx=pIdx->pNext){\n      if( pIdx->aColExpr==0 ) continue;\n      for(i=0; i<pIdx->nKeyCol; i++){\n        if( pIdx->aiColumn[i]!=XN_EXPR ) continue;\n        assert( pIdx->bHasExpr );\n        if( sqlite3ExprCompareSkip(pExpr,pIdx->aColExpr->a[i].pExpr,iCur)==0\n         && !sqlite3ExprIsConstant(0,pIdx->aColExpr->a[i].pExpr)\n        ){\n          aiCurCol[0] = iCur;\n          aiCurCol[1] = XN_EXPR;\n          return 1;\n        }\n      }\n    }\n  }while( ++j < pFrom->nSrc );\n  return 0;\n}\nstatic int exprMightBeIndexed(\n  SrcList *pFrom,        /* The FROM clause */\n  int *aiCurCol,         /* Write the referenced table cursor & column here */\n  Expr *pExpr,           /* An operand of a comparison operator */\n  int op                 /* The specific comparison operator */\n){\n  int i;\n\n  /* If this expression is a vector to the left or right of a\n  ** inequality constraint (>, <, >= or <=), perform the processing\n  ** on the first element of the vector.  */\n  assert( TK_GT+1==TK_LE && TK_GT+2==TK_LT && TK_GT+3==TK_GE );\n  assert( TK_IS<TK_GE && TK_ISNULL<TK_GE && TK_IN<TK_GE );\n  assert( op<=TK_GE );\n  if( pExpr->op==TK_VECTOR && (op>=TK_GT && ALWAYS(op<=TK_GE)) ){\n    assert( ExprUseXList(pExpr) );\n    pExpr = pExpr->x.pList->a[0].pExpr;\n  }\n\n  if( pExpr->op==TK_COLUMN ){\n    aiCurCol[0] = pExpr->iTable;\n    aiCurCol[1] = pExpr->iColumn;\n    return 1;\n  }\n\n  for(i=0; i<pFrom->nSrc; i++){\n    Index *pIdx;\n    for(pIdx=pFrom->a[i].pSTab->pIndex; pIdx; pIdx=pIdx->pNext){\n      if( pIdx->aColExpr ){\n        return exprMightBeIndexed2(pFrom,aiCurCol,pExpr,i);\n      }\n    }\n  }\n  return 0;\n}\n\n\n/*\n** The input to this routine is an WhereTerm structure with only the\n** \"pExpr\" field filled in.  The job of this routine is to analyze the\n** subexpression and populate all the other fields of the WhereTerm\n** structure.\n**\n** If the expression is of the form \"<expr> <op> X\" it gets commuted\n** to the standard form of \"X <op> <expr>\".\n**\n** If the expression is of the form \"X <op> Y\" where both X and Y are\n** columns, then the original expression is unchanged and a new virtual\n** term of the form \"Y <op> X\" is added to the WHERE clause and\n** analyzed separately.  The original term is marked with TERM_COPIED\n** and the new term is marked with TERM_DYNAMIC (because it's pExpr\n** needs to be freed with the WhereClause) and TERM_VIRTUAL (because it\n** is a commuted copy of a prior term.)  The original term has nChild=1\n** and the copy has idxParent set to the index of the original term.\n*/\nstatic void exprAnalyze(\n  SrcList *pSrc,            /* the FROM clause */\n  WhereClause *pWC,         /* the WHERE clause */\n  int idxTerm               /* Index of the term to be analyzed */\n){\n  WhereInfo *pWInfo = pWC->pWInfo; /* WHERE clause processing context */\n  WhereTerm *pTerm;                /* The term to be analyzed */\n  WhereMaskSet *pMaskSet;          /* Set of table index masks */\n  Expr *pExpr;                     /* The expression to be analyzed */\n  Bitmask prereqLeft;              /* Prerequisites of the pExpr->pLeft */\n  Bitmask prereqAll;               /* Prerequisites of pExpr */\n  Bitmask extraRight = 0;          /* Extra dependencies on LEFT JOIN */\n  Expr *pStr1 = 0;                 /* RHS of LIKE/GLOB operator */\n  int isComplete = 0;              /* RHS of LIKE/GLOB ends with wildcard */\n  int noCase = 0;                  /* uppercase equivalent to lowercase */\n  int op;                          /* Top-level operator.  pExpr->op */\n  Parse *pParse = pWInfo->pParse;  /* Parsing context */\n  sqlite3 *db = pParse->db;        /* Database connection */\n  unsigned char eOp2 = 0;          /* op2 value for LIKE/REGEXP/GLOB */\n  int nLeft;                       /* Number of elements on left side vector */\n\n  if( db->mallocFailed ){\n    return;\n  }\n  assert( pWC->nTerm > idxTerm );\n  pTerm = &pWC->a[idxTerm];\n#ifdef SQLITE_DEBUG\n  pTerm->iTerm = idxTerm;\n#endif\n  pMaskSet = &pWInfo->sMaskSet;\n  pExpr = pTerm->pExpr;\n  assert( pExpr!=0 ); /* Because malloc() has not failed */\n  assert( pExpr->op!=TK_AS && pExpr->op!=TK_COLLATE );\n  pMaskSet->bVarSelect = 0;\n  prereqLeft = sqlite3WhereExprUsage(pMaskSet, pExpr->pLeft);\n  op = pExpr->op;\n  if( op==TK_IN ){\n    assert( pExpr->pRight==0 );\n    if( sqlite3ExprCheckIN(pParse, pExpr) ) return;\n    if( ExprUseXSelect(pExpr) ){\n      pTerm->prereqRight = exprSelectUsage(pMaskSet, pExpr->x.pSelect);\n    }else{\n      pTerm->prereqRight = sqlite3WhereExprListUsage(pMaskSet, pExpr->x.pList);\n    }\n    prereqAll = prereqLeft | pTerm->prereqRight;\n  }else{\n    pTerm->prereqRight = sqlite3WhereExprUsage(pMaskSet, pExpr->pRight);\n    if( pExpr->pLeft==0\n     || ExprHasProperty(pExpr, EP_xIsSelect|EP_IfNullRow)\n     || pExpr->x.pList!=0\n    ){\n      prereqAll = sqlite3WhereExprUsageNN(pMaskSet, pExpr);\n    }else{\n      prereqAll = prereqLeft | pTerm->prereqRight;\n    }\n  }\n  if( pMaskSet->bVarSelect ) pTerm->wtFlags |= TERM_VARSELECT;\n\n#ifdef SQLITE_DEBUG\n  if( prereqAll!=sqlite3WhereExprUsageNN(pMaskSet, pExpr) ){\n    printf(\"\\n*** Incorrect prereqAll computed for:\\n\");\n    sqlite3TreeViewExpr(0,pExpr,0);\n    assert( 0 );\n  }\n#endif\n\n  if( ExprHasProperty(pExpr, EP_OuterON|EP_InnerON) ){\n    Bitmask x = sqlite3WhereGetMask(pMaskSet, pExpr->w.iJoin);\n    if( ExprHasProperty(pExpr, EP_OuterON) ){\n      prereqAll |= x;\n      extraRight = x-1;  /* ON clause terms may not be used with an index\n                         ** on left table of a LEFT JOIN.  Ticket #3015 */\n    }else if( (prereqAll>>1)>=x ){\n      ExprClearProperty(pExpr, EP_InnerON);\n    }\n  }\n  pTerm->prereqAll = prereqAll;\n  pTerm->leftCursor = -1;\n  pTerm->iParent = -1;\n  pTerm->eOperator = 0;\n  if( allowedOp(op) ){\n    int aiCurCol[2];\n    Expr *pLeft = sqlite3ExprSkipCollate(pExpr->pLeft);\n    Expr *pRight = sqlite3ExprSkipCollate(pExpr->pRight);\n    u16 opMask = (pTerm->prereqRight & prereqLeft)==0 ? WO_ALL : WO_EQUIV;\n\n    if( pTerm->u.x.iField>0 ){\n      assert( op==TK_IN );\n      assert( pLeft->op==TK_VECTOR );\n      assert( ExprUseXList(pLeft) );\n      pLeft = pLeft->x.pList->a[pTerm->u.x.iField-1].pExpr;\n    }\n\n    if( exprMightBeIndexed(pSrc, aiCurCol, pLeft, op) ){\n      pTerm->leftCursor = aiCurCol[0];\n      assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );\n      pTerm->u.x.leftColumn = aiCurCol[1];\n      pTerm->eOperator = operatorMask(op) & opMask;\n    }\n    if( op==TK_IS ) pTerm->wtFlags |= TERM_IS;\n    if( pRight\n     && exprMightBeIndexed(pSrc, aiCurCol, pRight, op)\n     && !ExprHasProperty(pRight, EP_FixedCol)\n    ){\n      WhereTerm *pNew;\n      Expr *pDup;\n      u16 eExtraOp = 0;        /* Extra bits for pNew->eOperator */\n      assert( pTerm->u.x.iField==0 );\n      if( pTerm->leftCursor>=0 ){\n        int idxNew;\n        pDup = sqlite3ExprDup(db, pExpr, 0);\n        if( db->mallocFailed ){\n          sqlite3ExprDelete(db, pDup);\n          return;\n        }\n        idxNew = whereClauseInsert(pWC, pDup, TERM_VIRTUAL|TERM_DYNAMIC);\n        if( idxNew==0 ) return;\n        pNew = &pWC->a[idxNew];\n        markTermAsChild(pWC, idxNew, idxTerm);\n        if( op==TK_IS ) pNew->wtFlags |= TERM_IS;\n        pTerm = &pWC->a[idxTerm];\n        pTerm->wtFlags |= TERM_COPIED;\n        assert( pWInfo->pTabList!=0 );\n        if( termIsEquivalence(pParse, pDup, pWInfo->pTabList) ){\n          pTerm->eOperator |= WO_EQUIV;\n          eExtraOp = WO_EQUIV;\n        }\n      }else{\n        pDup = pExpr;\n        pNew = pTerm;\n      }\n      pNew->wtFlags |= exprCommute(pParse, pDup);\n      pNew->leftCursor = aiCurCol[0];\n      assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );\n      pNew->u.x.leftColumn = aiCurCol[1];\n      testcase( (prereqLeft | extraRight) != prereqLeft );\n      pNew->prereqRight = prereqLeft | extraRight;\n      pNew->prereqAll = prereqAll;\n      pNew->eOperator = (operatorMask(pDup->op) + eExtraOp) & opMask;\n    }else\n    if( op==TK_ISNULL\n     && !ExprHasProperty(pExpr,EP_OuterON)\n     && 0==sqlite3ExprCanBeNull(pLeft)\n    ){\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      pExpr->op = TK_TRUEFALSE;  /* See tag-20230504-1 */\n      pExpr->u.zToken = \"false\";\n      ExprSetProperty(pExpr, EP_IsFalse);\n      pTerm->prereqAll = 0;\n      pTerm->eOperator = 0;\n    }\n  }\n\n#ifndef SQLITE_OMIT_BETWEEN_OPTIMIZATION\n  /* If a term is the BETWEEN operator, create two new virtual terms\n  ** that define the range that the BETWEEN implements.  For example:\n  **\n  **      a BETWEEN b AND c\n  **\n  ** is converted into:\n  **\n  **      (a BETWEEN b AND c) AND (a>=b) AND (a<=c)\n  **\n  ** The two new terms are added onto the end of the WhereClause object.\n  ** The new terms are \"dynamic\" and are children of the original BETWEEN\n  ** term.  That means that if the BETWEEN term is coded, the children are\n  ** skipped.  Or, if the children are satisfied by an index, the original\n  ** BETWEEN term is skipped.\n  */\n  else if( pExpr->op==TK_BETWEEN && pWC->op==TK_AND ){\n    ExprList *pList;\n    int i;\n    static const u8 ops[] = {TK_GE, TK_LE};\n    assert( ExprUseXList(pExpr) );\n    pList = pExpr->x.pList;\n    assert( pList!=0 );\n    assert( pList->nExpr==2 );\n    for(i=0; i<2; i++){\n      Expr *pNewExpr;\n      int idxNew;\n      pNewExpr = sqlite3PExpr(pParse, ops[i],\n                             sqlite3ExprDup(db, pExpr->pLeft, 0),\n                             sqlite3ExprDup(db, pList->a[i].pExpr, 0));\n      transferJoinMarkings(pNewExpr, pExpr);\n      idxNew = whereClauseInsert(pWC, pNewExpr, TERM_VIRTUAL|TERM_DYNAMIC);\n      testcase( idxNew==0 );\n      exprAnalyze(pSrc, pWC, idxNew);\n      pTerm = &pWC->a[idxTerm];\n      markTermAsChild(pWC, idxNew, idxTerm);\n    }\n  }\n#endif /* SQLITE_OMIT_BETWEEN_OPTIMIZATION */\n\n#if !defined(SQLITE_OMIT_OR_OPTIMIZATION) && !defined(SQLITE_OMIT_SUBQUERY)\n  /* Analyze a term that is composed of two or more subterms connected by\n  ** an OR operator.\n  */\n  else if( pExpr->op==TK_OR ){\n    assert( pWC->op==TK_AND );\n    exprAnalyzeOrTerm(pSrc, pWC, idxTerm);\n    pTerm = &pWC->a[idxTerm];\n  }\n#endif /* SQLITE_OMIT_OR_OPTIMIZATION */\n  /* The form \"x IS NOT NULL\" can sometimes be evaluated more efficiently\n  ** as \"x>NULL\" if x is not an INTEGER PRIMARY KEY.  So construct a\n  ** virtual term of that form.\n  **\n  ** The virtual term must be tagged with TERM_VNULL.\n  */\n  else if( pExpr->op==TK_NOTNULL ){\n    if( pExpr->pLeft->op==TK_COLUMN\n     && pExpr->pLeft->iColumn>=0\n     && !ExprHasProperty(pExpr, EP_OuterON)\n    ){\n      Expr *pNewExpr;\n      Expr *pLeft = pExpr->pLeft;\n      int idxNew;\n      WhereTerm *pNewTerm;\n \n      pNewExpr = sqlite3PExpr(pParse, TK_GT,\n                              sqlite3ExprDup(db, pLeft, 0),\n                              sqlite3ExprAlloc(db, TK_NULL, 0, 0));\n \n      idxNew = whereClauseInsert(pWC, pNewExpr,\n                                TERM_VIRTUAL|TERM_DYNAMIC|TERM_VNULL);\n      if( idxNew ){\n        pNewTerm = &pWC->a[idxNew];\n        pNewTerm->prereqRight = 0;\n        pNewTerm->leftCursor = pLeft->iTable;\n        pNewTerm->u.x.leftColumn = pLeft->iColumn;\n        pNewTerm->eOperator = WO_GT;\n        markTermAsChild(pWC, idxNew, idxTerm);\n        pTerm = &pWC->a[idxTerm];\n        pTerm->wtFlags |= TERM_COPIED;\n        pNewTerm->prereqAll = pTerm->prereqAll;\n      }\n    }\n  }\n\n\n#ifndef SQLITE_OMIT_LIKE_OPTIMIZATION\n  /* Add constraints to reduce the search space on a LIKE or GLOB\n  ** operator.\n  **\n  ** A like pattern of the form \"x LIKE 'aBc%'\" is changed into constraints\n  **\n  **          x>='ABC' AND x<'abd' AND x LIKE 'aBc%'\n  **\n  ** The last character of the prefix \"abc\" is incremented to form the\n  ** termination condition \"abd\".  If case is not significant (the default\n  ** for LIKE) then the lower-bound is made all uppercase and the upper-\n  ** bound is made all lowercase so that the bounds also work when comparing\n  ** BLOBs.\n  */\n  else if( pExpr->op==TK_FUNCTION\n   && pWC->op==TK_AND\n   && isLikeOrGlob(pParse, pExpr, &pStr1, &isComplete, &noCase)\n  ){\n    Expr *pLeft;       /* LHS of LIKE/GLOB operator */\n    Expr *pStr2;       /* Copy of pStr1 - RHS of LIKE/GLOB operator */\n    Expr *pNewExpr1;\n    Expr *pNewExpr2;\n    int idxNew1;\n    int idxNew2;\n    const char *zCollSeqName;     /* Name of collating sequence */\n    const u16 wtFlags = TERM_LIKEOPT | TERM_VIRTUAL | TERM_DYNAMIC;\n\n    assert( ExprUseXList(pExpr) );\n    pLeft = pExpr->x.pList->a[1].pExpr;\n    pStr2 = sqlite3ExprDup(db, pStr1, 0);\n    assert( pStr1==0 || !ExprHasProperty(pStr1, EP_IntValue) );\n    assert( pStr2==0 || !ExprHasProperty(pStr2, EP_IntValue) );\n\n\n    /* Convert the lower bound to upper-case and the upper bound to\n    ** lower-case (upper-case is less than lower-case in ASCII) so that\n    ** the range constraints also work for BLOBs\n    */\n    if( noCase && !pParse->db->mallocFailed ){\n      int i;\n      char c;\n      pTerm->wtFlags |= TERM_LIKE;\n      for(i=0; (c = pStr1->u.zToken[i])!=0; i++){\n        pStr1->u.zToken[i] = sqlite3Toupper(c);\n        pStr2->u.zToken[i] = sqlite3Tolower(c);\n      }\n    }\n\n    if( !db->mallocFailed ){\n      u8 *pC;       /* Last character before the first wildcard */\n      pC = (u8*)&pStr2->u.zToken[sqlite3Strlen30(pStr2->u.zToken)-1];\n      if( noCase ){\n        /* The point is to increment the last character before the first\n        ** wildcard.  But if we increment '@', that will push it into the\n        ** alphabetic range where case conversions will mess up the\n        ** inequality.  To avoid this, make sure to also run the full\n        ** LIKE on all candidate expressions by clearing the isComplete flag\n        */\n        if( *pC=='A'-1 ) isComplete = 0;\n        *pC = sqlite3UpperToLower[*pC];\n      }\n\n      /* Increment the value of the last utf8 character in the prefix. */\n      while( *pC==0xBF && pC>(u8*)pStr2->u.zToken ){\n        *pC = 0x80;\n        pC--;\n      }\n      assert( *pC!=0xFF );        /* isLikeOrGlob() guarantees this */\n      (*pC)++;\n    }\n    zCollSeqName = noCase ? \"NOCASE\" : sqlite3StrBINARY;\n    pNewExpr1 = sqlite3ExprDup(db, pLeft, 0);\n    pNewExpr1 = sqlite3PExpr(pParse, TK_GE,\n           sqlite3ExprAddCollateString(pParse,pNewExpr1,zCollSeqName),\n           pStr1);\n    transferJoinMarkings(pNewExpr1, pExpr);\n    idxNew1 = whereClauseInsert(pWC, pNewExpr1, wtFlags);\n    testcase( idxNew1==0 );\n    pNewExpr2 = sqlite3ExprDup(db, pLeft, 0);\n    pNewExpr2 = sqlite3PExpr(pParse, TK_LT,\n           sqlite3ExprAddCollateString(pParse,pNewExpr2,zCollSeqName),\n           pStr2);\n    transferJoinMarkings(pNewExpr2, pExpr);\n    idxNew2 = whereClauseInsert(pWC, pNewExpr2, wtFlags);\n    testcase( idxNew2==0 );\n    exprAnalyze(pSrc, pWC, idxNew1);\n    exprAnalyze(pSrc, pWC, idxNew2);\n    pTerm = &pWC->a[idxTerm];\n    if( isComplete ){\n      markTermAsChild(pWC, idxNew1, idxTerm);\n      markTermAsChild(pWC, idxNew2, idxTerm);\n    }\n  }\n#endif /* SQLITE_OMIT_LIKE_OPTIMIZATION */\n\n  /* If there is a vector == or IS term - e.g. \"(a, b) == (?, ?)\" - create\n  ** new terms for each component comparison - \"a = ?\" and \"b = ?\".  The\n  ** new terms completely replace the original vector comparison, which is\n  ** no longer used.\n  **\n  ** This is only required if at least one side of the comparison operation\n  ** is not a sub-select.\n  **\n  ** tag-20220128a\n  */\n  if( (pExpr->op==TK_EQ || pExpr->op==TK_IS)\n   && (nLeft = sqlite3ExprVectorSize(pExpr->pLeft))>1\n   && sqlite3ExprVectorSize(pExpr->pRight)==nLeft\n   && ( (pExpr->pLeft->flags & EP_xIsSelect)==0\n     || (pExpr->pRight->flags & EP_xIsSelect)==0)\n   && pWC->op==TK_AND\n  ){\n    int i;\n    for(i=0; i<nLeft; i++){\n      int idxNew;\n      Expr *pNew;\n      Expr *pLeft = sqlite3ExprForVectorField(pParse, pExpr->pLeft, i, nLeft);\n      Expr *pRight = sqlite3ExprForVectorField(pParse, pExpr->pRight, i, nLeft);\n\n      pNew = sqlite3PExpr(pParse, pExpr->op, pLeft, pRight);\n      transferJoinMarkings(pNew, pExpr);\n      idxNew = whereClauseInsert(pWC, pNew, TERM_DYNAMIC|TERM_SLICE);\n      exprAnalyze(pSrc, pWC, idxNew);\n    }\n    pTerm = &pWC->a[idxTerm];\n    pTerm->wtFlags |= TERM_CODED|TERM_VIRTUAL;  /* Disable the original */\n    pTerm->eOperator = WO_ROWVAL;\n  }\n\n  /* If there is a vector IN term - e.g. \"(a, b) IN (SELECT ...)\" - create\n  ** a virtual term for each vector component. The expression object\n  ** used by each such virtual term is pExpr (the full vector IN(...)\n  ** expression). The WhereTerm.u.x.iField variable identifies the index within\n  ** the vector on the LHS that the virtual term represents.\n  **\n  ** This only works if the RHS is a simple SELECT (not a compound) that does\n  ** not use window functions.\n  */\n  else if( pExpr->op==TK_IN\n   && pTerm->u.x.iField==0\n   && pExpr->pLeft->op==TK_VECTOR\n   && ALWAYS( ExprUseXSelect(pExpr) )\n   && (pExpr->x.pSelect->pPrior==0 || (pExpr->x.pSelect->selFlags & SF_Values))\n#ifndef SQLITE_OMIT_WINDOWFUNC\n   && pExpr->x.pSelect->pWin==0\n#endif\n   && pWC->op==TK_AND\n  ){\n    int i;\n    for(i=0; i<sqlite3ExprVectorSize(pExpr->pLeft); i++){\n      int idxNew;\n      idxNew = whereClauseInsert(pWC, pExpr, TERM_VIRTUAL|TERM_SLICE);\n      pWC->a[idxNew].u.x.iField = i+1;\n      exprAnalyze(pSrc, pWC, idxNew);\n      markTermAsChild(pWC, idxNew, idxTerm);\n    }\n  }\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  /* Add a WO_AUX auxiliary term to the constraint set if the\n  ** current expression is of the form \"column OP expr\" where OP\n  ** is an operator that gets passed into virtual tables but which is\n  ** not normally optimized for ordinary tables.  In other words, OP\n  ** is one of MATCH, LIKE, GLOB, REGEXP, !=, IS, IS NOT, or NOT NULL.\n  ** This information is used by the xBestIndex methods of\n  ** virtual tables.  The native query optimizer does not attempt\n  ** to do anything with MATCH functions.\n  */\n  else if( pWC->op==TK_AND ){\n    Expr *pRight = 0, *pLeft = 0;\n    int res = isAuxiliaryVtabOperator(db, pExpr, &eOp2, &pLeft, &pRight);\n    while( res-- > 0 ){\n      int idxNew;\n      WhereTerm *pNewTerm;\n      Bitmask prereqColumn, prereqExpr;\n\n      prereqExpr = sqlite3WhereExprUsage(pMaskSet, pRight);\n      prereqColumn = sqlite3WhereExprUsage(pMaskSet, pLeft);\n      if( (prereqExpr & prereqColumn)==0 ){\n        Expr *pNewExpr;\n        pNewExpr = sqlite3PExpr(pParse, TK_MATCH,\n            0, sqlite3ExprDup(db, pRight, 0));\n        if( ExprHasProperty(pExpr, EP_OuterON) && pNewExpr ){\n          ExprSetProperty(pNewExpr, EP_OuterON);\n          pNewExpr->w.iJoin = pExpr->w.iJoin;\n        }\n        idxNew = whereClauseInsert(pWC, pNewExpr, TERM_VIRTUAL|TERM_DYNAMIC);\n        testcase( idxNew==0 );\n        pNewTerm = &pWC->a[idxNew];\n        pNewTerm->prereqRight = prereqExpr | extraRight;\n        pNewTerm->leftCursor = pLeft->iTable;\n        pNewTerm->u.x.leftColumn = pLeft->iColumn;\n        pNewTerm->eOperator = WO_AUX;\n        pNewTerm->eMatchOp = eOp2;\n        markTermAsChild(pWC, idxNew, idxTerm);\n        pTerm = &pWC->a[idxTerm];\n        pTerm->wtFlags |= TERM_COPIED;\n        pNewTerm->prereqAll = pTerm->prereqAll;\n      }\n      SWAP(Expr*, pLeft, pRight);\n    }\n  }\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n\n  /* Prevent ON clause terms of a LEFT JOIN from being used to drive\n  ** an index for tables to the left of the join.\n  */\n  testcase( pTerm!=&pWC->a[idxTerm] );\n  pTerm = &pWC->a[idxTerm];\n  pTerm->prereqRight |= extraRight;\n}\n\n/***************************************************************************\n** Routines with file scope above.  Interface to the rest of the where.c\n** subsystem follows.\n***************************************************************************/\n\n/*\n** This routine identifies subexpressions in the WHERE clause where\n** each subexpression is separated by the AND operator or some other\n** operator specified in the op parameter.  The WhereClause structure\n** is filled with pointers to subexpressions.  For example:\n**\n**    WHERE  a=='hello' AND coalesce(b,11)<10 AND (c+12!=d OR c==22)\n**           \\________/     \\_______________/     \\________________/\n**            slot[0]            slot[1]               slot[2]\n**\n** The original WHERE clause in pExpr is unaltered.  All this routine\n** does is make slot[] entries point to substructure within pExpr.\n**\n** In the previous sentence and in the diagram, \"slot[]\" refers to\n** the WhereClause.a[] array.  The slot[] array grows as needed to contain\n** all terms of the WHERE clause.\n*/\nvoid sqlite3WhereSplit(WhereClause *pWC, Expr *pExpr, u8 op){\n  Expr *pE2 = sqlite3ExprSkipCollateAndLikely(pExpr);\n  pWC->op = op;\n  assert( pE2!=0 || pExpr==0 );\n  if( pE2==0 ) return;\n  if( pE2->op!=op ){\n    whereClauseInsert(pWC, pExpr, 0);\n  }else{\n    sqlite3WhereSplit(pWC, pE2->pLeft, op);\n    sqlite3WhereSplit(pWC, pE2->pRight, op);\n  }\n}\n\n/*\n** Add either a LIMIT (if eMatchOp==SQLITE_INDEX_CONSTRAINT_LIMIT) or\n** OFFSET (if eMatchOp==SQLITE_INDEX_CONSTRAINT_OFFSET) term to the\n** where-clause passed as the first argument. The value for the term\n** is found in register iReg.\n**\n** In the common case where the value is a simple integer\n** (example: \"LIMIT 5 OFFSET 10\") then the expression codes as a\n** TK_INTEGER so that it will be available to sqlite3_vtab_rhs_value().\n** If not, then it codes as a TK_REGISTER expression.\n*/\nstatic void whereAddLimitExpr(\n  WhereClause *pWC,   /* Add the constraint to this WHERE clause */\n  int iReg,           /* Register that will hold value of the limit/offset */\n  Expr *pExpr,        /* Expression that defines the limit/offset */\n  int iCsr,           /* Cursor to which the constraint applies */\n  int eMatchOp        /* SQLITE_INDEX_CONSTRAINT_LIMIT or _OFFSET */\n){\n  Parse *pParse = pWC->pWInfo->pParse;\n  sqlite3 *db = pParse->db;\n  Expr *pNew;\n  int iVal = 0;\n\n  if( sqlite3ExprIsInteger(pExpr, &iVal, pParse) && iVal>=0 ){\n    Expr *pVal = sqlite3ExprInt32(db, iVal);\n    if( pVal==0 ) return;\n    pNew = sqlite3PExpr(pParse, TK_MATCH, 0, pVal);\n  }else{\n    Expr *pVal = sqlite3ExprAlloc(db, TK_REGISTER, 0, 0);\n    if( pVal==0 ) return;\n    pVal->iTable = iReg;\n    pNew = sqlite3PExpr(pParse, TK_MATCH, 0, pVal);\n  }\n  if( pNew ){\n    WhereTerm *pTerm;\n    int idx;\n    idx = whereClauseInsert(pWC, pNew, TERM_DYNAMIC|TERM_VIRTUAL);\n    pTerm = &pWC->a[idx];\n    pTerm->leftCursor = iCsr;\n    pTerm->eOperator = WO_AUX;\n    pTerm->eMatchOp = eMatchOp;\n  }\n}\n\n/*\n** Possibly add terms corresponding to the LIMIT and OFFSET clauses of the\n** SELECT statement passed as the second argument. These terms are only\n** added if:\n**\n**   1. The SELECT statement has a LIMIT clause, and\n**   2. The SELECT statement is not an aggregate or DISTINCT query, and\n**   3. The SELECT statement has exactly one object in its FROM clause, and\n**      that object is a virtual table, and\n**   4. There are no terms in the WHERE clause that will not be passed\n**      to the virtual table xBestIndex method.\n**   5. The ORDER BY clause, if any, will be made available to the xBestIndex\n**      method.\n**\n** LIMIT and OFFSET terms are ignored by most of the planner code. They\n** exist only so that they may be passed to the xBestIndex method of the\n** single virtual table in the FROM clause of the SELECT.\n*/\nvoid SQLITE_NOINLINE sqlite3WhereAddLimit(WhereClause *pWC, Select *p){\n  assert( p!=0 && p->pLimit!=0 );                 /* 1 -- checked by caller */\n  if( p->pGroupBy==0\n   && (p->selFlags & (SF_Distinct|SF_Aggregate))==0             /* 2 */\n   && (p->pSrc->nSrc==1 && IsVirtual(p->pSrc->a[0].pSTab))      /* 3 */\n  ){\n    ExprList *pOrderBy = p->pOrderBy;\n    int iCsr = p->pSrc->a[0].iCursor;\n    int ii;\n\n    /* Check condition (4). Return early if it is not met. */\n    for(ii=0; ii<pWC->nTerm; ii++){\n      if( pWC->a[ii].wtFlags & TERM_CODED ){\n        /* This term is a vector operation that has been decomposed into\n        ** other, subsequent terms.  It can be ignored. See tag-20220128a */\n        assert( pWC->a[ii].wtFlags & TERM_VIRTUAL );\n        assert( pWC->a[ii].eOperator==WO_ROWVAL );\n        continue;\n      }\n      if( pWC->a[ii].nChild ){\n        /* If this term has child terms, then they are also part of the\n        ** pWC->a[] array. So this term can be ignored, as a LIMIT clause\n        ** will only be added if each of the child terms passes the\n        ** (leftCursor==iCsr) test below.  */\n        continue;\n      }\n      if( pWC->a[ii].leftCursor==iCsr && pWC->a[ii].prereqRight==0 ) continue;\n\n      /* If this term has a parent with exactly one child, and the parent will\n      ** be passed through to xBestIndex, then this term can be ignored.  */\n      if( pWC->a[ii].iParent>=0 ){\n        WhereTerm *pParent = &pWC->a[ pWC->a[ii].iParent ];\n        if( pParent->leftCursor==iCsr\n         && pParent->prereqRight==0\n         && pParent->nChild==1\n        ){\n          continue;\n        }\n      }\n\n      /* This term will not be passed through. Do not add a LIMIT clause. */\n      return;\n    }\n\n    /* Check condition (5). Return early if it is not met. */\n    if( pOrderBy ){\n      for(ii=0; ii<pOrderBy->nExpr; ii++){\n        Expr *pExpr = pOrderBy->a[ii].pExpr;\n        if( pExpr->op!=TK_COLUMN ) return;\n        if( pExpr->iTable!=iCsr ) return;\n        if( pOrderBy->a[ii].fg.sortFlags & KEYINFO_ORDER_BIGNULL ) return;\n      }\n    }\n\n    /* All conditions are met. Add the terms to the where-clause object. */\n    assert( p->pLimit->op==TK_LIMIT );\n    if( p->iOffset!=0 && (p->selFlags & SF_Compound)==0 ){\n      whereAddLimitExpr(pWC, p->iOffset, p->pLimit->pRight,\n                        iCsr, SQLITE_INDEX_CONSTRAINT_OFFSET);\n    }\n    if( p->iOffset==0 || (p->selFlags & SF_Compound)==0 ){\n      whereAddLimitExpr(pWC, p->iLimit, p->pLimit->pLeft,\n                        iCsr, SQLITE_INDEX_CONSTRAINT_LIMIT);\n    }\n  }\n}\n\n/*\n** Initialize a preallocated WhereClause structure.\n*/\nvoid sqlite3WhereClauseInit(\n  WhereClause *pWC,        /* The WhereClause to be initialized */\n  WhereInfo *pWInfo        /* The WHERE processing context */\n){\n  pWC->pWInfo = pWInfo;\n  pWC->hasOr = 0;\n  pWC->pOuter = 0;\n  pWC->nTerm = 0;\n  pWC->nBase = 0;\n  pWC->nSlot = ArraySize(pWC->aStatic);\n  pWC->a = pWC->aStatic;\n}\n\n/*\n** Deallocate a WhereClause structure.  The WhereClause structure\n** itself is not freed.  This routine is the inverse of\n** sqlite3WhereClauseInit().\n*/\nvoid sqlite3WhereClauseClear(WhereClause *pWC){\n  sqlite3 *db = pWC->pWInfo->pParse->db;\n  assert( pWC->nTerm>=pWC->nBase );\n  if( pWC->nTerm>0 ){\n    WhereTerm *a = pWC->a;\n    WhereTerm *aLast = &pWC->a[pWC->nTerm-1];\n#ifdef SQLITE_DEBUG\n    int i;\n    /* Verify that every term past pWC->nBase is virtual */\n    for(i=pWC->nBase; i<pWC->nTerm; i++){\n      assert( (pWC->a[i].wtFlags & TERM_VIRTUAL)!=0 );\n    }\n#endif\n    while(1){\n      assert( a->eMatchOp==0 || a->eOperator==WO_AUX );\n      if( a->wtFlags & TERM_DYNAMIC ){\n        sqlite3ExprDelete(db, a->pExpr);\n      }\n      if( a->wtFlags & (TERM_ORINFO|TERM_ANDINFO) ){\n        if( a->wtFlags & TERM_ORINFO ){\n          assert( (a->wtFlags & TERM_ANDINFO)==0 );\n          whereOrInfoDelete(db, a->u.pOrInfo);\n        }else{\n          assert( (a->wtFlags & TERM_ANDINFO)!=0 );\n          whereAndInfoDelete(db, a->u.pAndInfo);\n        }\n      }\n      if( a==aLast ) break;\n      a++;\n    }\n  }\n}\n\n\n/*\n** These routines walk (recursively) an expression tree and generate\n** a bitmask indicating which tables are used in that expression\n** tree.\n**\n** sqlite3WhereExprUsage(MaskSet, Expr) ->\n**\n**       Return a Bitmask of all tables referenced by Expr.  Expr can be\n**       be NULL, in which case 0 is returned.\n**\n** sqlite3WhereExprUsageNN(MaskSet, Expr) ->\n**\n**       Same as sqlite3WhereExprUsage() except that Expr must not be\n**       NULL.  The \"NN\" suffix on the name stands for \"Not Null\".\n**\n** sqlite3WhereExprListUsage(MaskSet, ExprList) ->\n**\n**       Return a Bitmask of all tables referenced by every expression\n**       in the expression list ExprList.  ExprList can be NULL, in which\n**       case 0 is returned.\n**\n** sqlite3WhereExprUsageFull(MaskSet, ExprList) ->\n**\n**       Internal use only.  Called only by sqlite3WhereExprUsageNN() for\n**       complex expressions that require pushing register values onto\n**       the stack.  Many calls to sqlite3WhereExprUsageNN() do not need\n**       the more complex analysis done by this routine.  Hence, the\n**       computations done by this routine are broken out into a separate\n**       \"no-inline\" function to avoid the stack push overhead in the\n**       common case where it is not needed.\n*/\nstatic SQLITE_NOINLINE Bitmask sqlite3WhereExprUsageFull(\n  WhereMaskSet *pMaskSet,\n  Expr *p\n){\n  Bitmask mask;\n  mask = (p->op==TK_IF_NULL_ROW) ? sqlite3WhereGetMask(pMaskSet, p->iTable) : 0;\n  if( p->pLeft ) mask |= sqlite3WhereExprUsageNN(pMaskSet, p->pLeft);\n  if( p->pRight ){\n    mask |= sqlite3WhereExprUsageNN(pMaskSet, p->pRight);\n    assert( p->x.pList==0 );\n  }else if( ExprUseXSelect(p) ){\n    if( ExprHasProperty(p, EP_VarSelect) ) pMaskSet->bVarSelect = 1;\n    mask |= exprSelectUsage(pMaskSet, p->x.pSelect);\n  }else if( p->x.pList ){\n    mask |= sqlite3WhereExprListUsage(pMaskSet, p->x.pList);\n  }\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  if( (p->op==TK_FUNCTION || p->op==TK_AGG_FUNCTION) && ExprUseYWin(p) ){\n    assert( p->y.pWin!=0 );\n    mask |= sqlite3WhereExprListUsage(pMaskSet, p->y.pWin->pPartition);\n    mask |= sqlite3WhereExprListUsage(pMaskSet, p->y.pWin->pOrderBy);\n    mask |= sqlite3WhereExprUsage(pMaskSet, p->y.pWin->pFilter);\n  }\n#endif\n  return mask;\n}\nBitmask sqlite3WhereExprUsageNN(WhereMaskSet *pMaskSet, Expr *p){\n  if( p->op==TK_COLUMN && !ExprHasProperty(p, EP_FixedCol) ){\n    return sqlite3WhereGetMask(pMaskSet, p->iTable);\n  }else if( ExprHasProperty(p, EP_TokenOnly|EP_Leaf) ){\n    assert( p->op!=TK_IF_NULL_ROW );\n    return 0;\n  }\n  return sqlite3WhereExprUsageFull(pMaskSet, p);\n}\nBitmask sqlite3WhereExprUsage(WhereMaskSet *pMaskSet, Expr *p){\n  return p ? sqlite3WhereExprUsageNN(pMaskSet,p) : 0;\n}\nBitmask sqlite3WhereExprListUsage(WhereMaskSet *pMaskSet, ExprList *pList){\n  int i;\n  Bitmask mask = 0;\n  if( pList ){\n    for(i=0; i<pList->nExpr; i++){\n      mask |= sqlite3WhereExprUsage(pMaskSet, pList->a[i].pExpr);\n    }\n  }\n  return mask;\n}\n\n\n/*\n** Call exprAnalyze on all terms in a WHERE clause. \n**\n** Note that exprAnalyze() might add new virtual terms onto the\n** end of the WHERE clause.  We do not want to analyze these new\n** virtual terms, so start analyzing at the end and work forward\n** so that the added virtual terms are never processed.\n*/\nvoid sqlite3WhereExprAnalyze(\n  SrcList *pTabList,       /* the FROM clause */\n  WhereClause *pWC         /* the WHERE clause to be analyzed */\n){\n  int i;\n  for(i=pWC->nTerm-1; i>=0; i--){\n    exprAnalyze(pTabList, pWC, i);\n  }\n}\n\n/*\n** For table-valued-functions, transform the function arguments into\n** new WHERE clause terms. \n**\n** Each function argument translates into an equality constraint against\n** a HIDDEN column in the table.\n*/\nvoid sqlite3WhereTabFuncArgs(\n  Parse *pParse,                    /* Parsing context */\n  SrcItem *pItem,                   /* The FROM clause term to process */\n  WhereClause *pWC                  /* Xfer function arguments to here */\n){\n  Table *pTab;\n  int j, k;\n  ExprList *pArgs;\n  Expr *pColRef;\n  Expr *pTerm;\n  if( pItem->fg.isTabFunc==0 ) return;\n  pTab = pItem->pSTab;\n  assert( pTab!=0 );\n  pArgs = pItem->u1.pFuncArg;\n  if( pArgs==0 ) return;\n  for(j=k=0; j<pArgs->nExpr; j++){\n    Expr *pRhs;\n    u32 joinType;\n    while( k<pTab->nCol && (pTab->aCol[k].colFlags & COLFLAG_HIDDEN)==0 ){k++;}\n    if( k>=pTab->nCol ){\n      sqlite3ErrorMsg(pParse, \"too many arguments on %s() - max %d\",\n                      pTab->zName, j);\n      return;\n    }\n    pColRef = sqlite3ExprAlloc(pParse->db, TK_COLUMN, 0, 0);\n    if( pColRef==0 ) return;\n    pColRef->iTable = pItem->iCursor;\n    pColRef->iColumn = k++;\n    assert( ExprUseYTab(pColRef) );\n    pColRef->y.pTab = pTab;\n    pItem->colUsed |= sqlite3ExprColUsed(pColRef);\n    pRhs = sqlite3PExpr(pParse, TK_UPLUS,\n        sqlite3ExprDup(pParse->db, pArgs->a[j].pExpr, 0), 0);\n    pTerm = sqlite3PExpr(pParse, TK_EQ, pColRef, pRhs);\n    if( pItem->fg.jointype & (JT_LEFT|JT_RIGHT) ){\n      testcase( pItem->fg.jointype & JT_LEFT );  /* testtag-20230227a */\n      testcase( pItem->fg.jointype & JT_RIGHT ); /* testtag-20230227b */\n      joinType = EP_OuterON;\n    }else{\n      testcase( pItem->fg.jointype & JT_LTORJ ); /* testtag-20230227c */\n      joinType = EP_InnerON;\n    }\n    sqlite3SetJoinExpr(pTerm, pItem->iCursor, joinType);\n    whereClauseInsert(pWC, pTerm, TERM_DYNAMIC);\n  }\n}\n"}
{"repo": "sqlite", "file": "test_md5.c", "lang": "C++", "code": "/*\n** 2017-10-13\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains code to implement an MD5 extension to TCL.\n*/\n#include \"sqlite3.h\"\n#include <stdlib.h>\n#include <string.h>\n#include \"sqlite3.h\"\n#include \"tclsqlite.h\"\n\n/*\n * This code implements the MD5 message-digest algorithm.\n * The algorithm is due to Ron Rivest.  This code was\n * written by Colin Plumb in 1993, no copyright is claimed.\n * This code is in the public domain; do with it what you wish.\n *\n * Equivalent code is available from RSA Data Security, Inc.\n * This code has been tested against that, and is equivalent,\n * except that you don't need to include two pages of legalese\n * with every copy.\n *\n * To compute the message digest of a chunk of bytes, declare an\n * MD5Context structure, pass it to MD5Init, call MD5Update as\n * needed on buffers full of bytes, and then call MD5Final, which\n * will fill a supplied 16-byte array with the digest.\n */\n\n/*\n * If compiled on a machine that doesn't have a 32-bit integer,\n * you just set \"uint32\" to the appropriate datatype for an\n * unsigned 32-bit integer.  For example:\n *\n *       cc -Duint32='unsigned long' md5.c\n *\n */\n#ifndef uint32\n#  define uint32 unsigned int\n#endif\n\nstruct MD5Context {\n  int isInit;\n  uint32 buf[4];\n  uint32 bits[2];\n  unsigned char in[64];\n};\ntypedef struct MD5Context MD5Context;\n\n/*\n * Note: this code is harmless on little-endian machines.\n */\nstatic void byteReverse (unsigned char *buf, unsigned longs){\n        uint32 t;\n        do {\n                t = (uint32)((unsigned)buf[3]<<8 | buf[2]) << 16 |\n                            ((unsigned)buf[1]<<8 | buf[0]);\n                *(uint32 *)buf = t;\n                buf += 4;\n        } while (--longs);\n}\n/* The four core functions - F1 is optimized somewhat */\n\n/* #define F1(x, y, z) (x & y | ~x & z) */\n#define F1(x, y, z) (z ^ (x & (y ^ z)))\n#define F2(x, y, z) F1(z, x, y)\n#define F3(x, y, z) (x ^ y ^ z)\n#define F4(x, y, z) (y ^ (x | ~z))\n\n/* This is the central step in the MD5 algorithm. */\n#define MD5STEP(f, w, x, y, z, data, s) \\\n        ( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )\n\n/*\n * The core of the MD5 algorithm, this alters an existing MD5 hash to\n * reflect the addition of 16 longwords of new data.  MD5Update blocks\n * the data and converts bytes into longwords for this routine.\n */\nstatic void MD5Transform(uint32 buf[4], const uint32 in[16]){\n        register uint32 a, b, c, d;\n\n        a = buf[0];\n        b = buf[1];\n        c = buf[2];\n        d = buf[3];\n\n        MD5STEP(F1, a, b, c, d, in[ 0]+0xd76aa478,  7);\n        MD5STEP(F1, d, a, b, c, in[ 1]+0xe8c7b756, 12);\n        MD5STEP(F1, c, d, a, b, in[ 2]+0x242070db, 17);\n        MD5STEP(F1, b, c, d, a, in[ 3]+0xc1bdceee, 22);\n        MD5STEP(F1, a, b, c, d, in[ 4]+0xf57c0faf,  7);\n        MD5STEP(F1, d, a, b, c, in[ 5]+0x4787c62a, 12);\n        MD5STEP(F1, c, d, a, b, in[ 6]+0xa8304613, 17);\n        MD5STEP(F1, b, c, d, a, in[ 7]+0xfd469501, 22);\n        MD5STEP(F1, a, b, c, d, in[ 8]+0x698098d8,  7);\n        MD5STEP(F1, d, a, b, c, in[ 9]+0x8b44f7af, 12);\n        MD5STEP(F1, c, d, a, b, in[10]+0xffff5bb1, 17);\n        MD5STEP(F1, b, c, d, a, in[11]+0x895cd7be, 22);\n        MD5STEP(F1, a, b, c, d, in[12]+0x6b901122,  7);\n        MD5STEP(F1, d, a, b, c, in[13]+0xfd987193, 12);\n        MD5STEP(F1, c, d, a, b, in[14]+0xa679438e, 17);\n        MD5STEP(F1, b, c, d, a, in[15]+0x49b40821, 22);\n\n        MD5STEP(F2, a, b, c, d, in[ 1]+0xf61e2562,  5);\n        MD5STEP(F2, d, a, b, c, in[ 6]+0xc040b340,  9);\n        MD5STEP(F2, c, d, a, b, in[11]+0x265e5a51, 14);\n        MD5STEP(F2, b, c, d, a, in[ 0]+0xe9b6c7aa, 20);\n        MD5STEP(F2, a, b, c, d, in[ 5]+0xd62f105d,  5);\n        MD5STEP(F2, d, a, b, c, in[10]+0x02441453,  9);\n        MD5STEP(F2, c, d, a, b, in[15]+0xd8a1e681, 14);\n        MD5STEP(F2, b, c, d, a, in[ 4]+0xe7d3fbc8, 20);\n        MD5STEP(F2, a, b, c, d, in[ 9]+0x21e1cde6,  5);\n        MD5STEP(F2, d, a, b, c, in[14]+0xc33707d6,  9);\n        MD5STEP(F2, c, d, a, b, in[ 3]+0xf4d50d87, 14);\n        MD5STEP(F2, b, c, d, a, in[ 8]+0x455a14ed, 20);\n        MD5STEP(F2, a, b, c, d, in[13]+0xa9e3e905,  5);\n        MD5STEP(F2, d, a, b, c, in[ 2]+0xfcefa3f8,  9);\n        MD5STEP(F2, c, d, a, b, in[ 7]+0x676f02d9, 14);\n        MD5STEP(F2, b, c, d, a, in[12]+0x8d2a4c8a, 20);\n\n        MD5STEP(F3, a, b, c, d, in[ 5]+0xfffa3942,  4);\n        MD5STEP(F3, d, a, b, c, in[ 8]+0x8771f681, 11);\n        MD5STEP(F3, c, d, a, b, in[11]+0x6d9d6122, 16);\n        MD5STEP(F3, b, c, d, a, in[14]+0xfde5380c, 23);\n        MD5STEP(F3, a, b, c, d, in[ 1]+0xa4beea44,  4);\n        MD5STEP(F3, d, a, b, c, in[ 4]+0x4bdecfa9, 11);\n        MD5STEP(F3, c, d, a, b, in[ 7]+0xf6bb4b60, 16);\n        MD5STEP(F3, b, c, d, a, in[10]+0xbebfbc70, 23);\n        MD5STEP(F3, a, b, c, d, in[13]+0x289b7ec6,  4);\n        MD5STEP(F3, d, a, b, c, in[ 0]+0xeaa127fa, 11);\n        MD5STEP(F3, c, d, a, b, in[ 3]+0xd4ef3085, 16);\n        MD5STEP(F3, b, c, d, a, in[ 6]+0x04881d05, 23);\n        MD5STEP(F3, a, b, c, d, in[ 9]+0xd9d4d039,  4);\n        MD5STEP(F3, d, a, b, c, in[12]+0xe6db99e5, 11);\n        MD5STEP(F3, c, d, a, b, in[15]+0x1fa27cf8, 16);\n        MD5STEP(F3, b, c, d, a, in[ 2]+0xc4ac5665, 23);\n\n        MD5STEP(F4, a, b, c, d, in[ 0]+0xf4292244,  6);\n        MD5STEP(F4, d, a, b, c, in[ 7]+0x432aff97, 10);\n        MD5STEP(F4, c, d, a, b, in[14]+0xab9423a7, 15);\n        MD5STEP(F4, b, c, d, a, in[ 5]+0xfc93a039, 21);\n        MD5STEP(F4, a, b, c, d, in[12]+0x655b59c3,  6);\n        MD5STEP(F4, d, a, b, c, in[ 3]+0x8f0ccc92, 10);\n        MD5STEP(F4, c, d, a, b, in[10]+0xffeff47d, 15);\n        MD5STEP(F4, b, c, d, a, in[ 1]+0x85845dd1, 21);\n        MD5STEP(F4, a, b, c, d, in[ 8]+0x6fa87e4f,  6);\n        MD5STEP(F4, d, a, b, c, in[15]+0xfe2ce6e0, 10);\n        MD5STEP(F4, c, d, a, b, in[ 6]+0xa3014314, 15);\n        MD5STEP(F4, b, c, d, a, in[13]+0x4e0811a1, 21);\n        MD5STEP(F4, a, b, c, d, in[ 4]+0xf7537e82,  6);\n        MD5STEP(F4, d, a, b, c, in[11]+0xbd3af235, 10);\n        MD5STEP(F4, c, d, a, b, in[ 2]+0x2ad7d2bb, 15);\n        MD5STEP(F4, b, c, d, a, in[ 9]+0xeb86d391, 21);\n\n        buf[0] += a;\n        buf[1] += b;\n        buf[2] += c;\n        buf[3] += d;\n}\n\n/*\n * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious\n * initialization constants.\n */\nstatic void MD5Init(MD5Context *ctx){\n        ctx->isInit = 1;\n        ctx->buf[0] = 0x67452301;\n        ctx->buf[1] = 0xefcdab89;\n        ctx->buf[2] = 0x98badcfe;\n        ctx->buf[3] = 0x10325476;\n        ctx->bits[0] = 0;\n        ctx->bits[1] = 0;\n}\n\n/*\n * Update context to reflect the concatenation of another buffer full\n * of bytes.\n */\nstatic\nvoid MD5Update(MD5Context *ctx, const unsigned char *buf, unsigned int len){\n        uint32 t;\n\n        /* Update bitcount */\n\n        t = ctx->bits[0];\n        if ((ctx->bits[0] = t + ((uint32)len << 3)) < t)\n                ctx->bits[1]++; /* Carry from low to high */\n        ctx->bits[1] += len >> 29;\n\n        t = (t >> 3) & 0x3f;    /* Bytes already in shsInfo->data */\n\n        /* Handle any leading odd-sized chunks */\n\n        if ( t ) {\n                unsigned char *p = (unsigned char *)ctx->in + t;\n\n                t = 64-t;\n                if (len < t) {\n                        memcpy(p, buf, len);\n                        return;\n                }\n                memcpy(p, buf, t);\n                byteReverse(ctx->in, 16);\n                MD5Transform(ctx->buf, (uint32 *)ctx->in);\n                buf += t;\n                len -= t;\n        }\n\n        /* Process data in 64-byte chunks */\n\n        while (len >= 64) {\n                memcpy(ctx->in, buf, 64);\n                byteReverse(ctx->in, 16);\n                MD5Transform(ctx->buf, (uint32 *)ctx->in);\n                buf += 64;\n                len -= 64;\n        }\n\n        /* Handle any remaining bytes of data. */\n\n        memcpy(ctx->in, buf, len);\n}\n\n/*\n * Final wrapup - pad to 64-byte boundary with the bit pattern\n * 1 0* (64-bit count of bits processed, MSB-first)\n */\nstatic void MD5Final(unsigned char digest[16], MD5Context *ctx){\n        unsigned count;\n        unsigned char *p;\n\n        /* Compute number of bytes mod 64 */\n        count = (ctx->bits[0] >> 3) & 0x3F;\n\n        /* Set the first char of padding to 0x80.  This is safe since there is\n           always at least one byte free */\n        p = ctx->in + count;\n        *p++ = 0x80;\n\n        /* Bytes of padding needed to make 64 bytes */\n        count = 64 - 1 - count;\n\n        /* Pad out to 56 mod 64 */\n        if (count < 8) {\n                /* Two lots of padding:  Pad the first block to 64 bytes */\n                memset(p, 0, count);\n                byteReverse(ctx->in, 16);\n                MD5Transform(ctx->buf, (uint32 *)ctx->in);\n\n                /* Now fill the next block with 56 bytes */\n                memset(ctx->in, 0, 56);\n        } else {\n                /* Pad block to 56 bytes */\n                memset(p, 0, count-8);\n        }\n        byteReverse(ctx->in, 14);\n\n        /* Append length in bits and transform */\n        memcpy(ctx->in + 14*4, ctx->bits, 8);\n\n        MD5Transform(ctx->buf, (uint32 *)ctx->in);\n        byteReverse((unsigned char *)ctx->buf, 4);\n        memcpy(digest, ctx->buf, 16);\n}\n\n/*\n** Convert a 128-bit MD5 digest into a 32-digit base-16 number.\n*/\nstatic void MD5DigestToBase16(unsigned char *digest, char *zBuf){\n  static char const zEncode[] = \"0123456789abcdef\";\n  int i, j;\n\n  for(j=i=0; i<16; i++){\n    int a = digest[i];\n    zBuf[j++] = zEncode[(a>>4)&0xf];\n    zBuf[j++] = zEncode[a & 0xf];\n  }\n  zBuf[j] = 0;\n}\n\n\n/*\n** Convert a 128-bit MD5 digest into sequences of eight 5-digit integers\n** each representing 16 bits of the digest and separated from each\n** other by a \"-\" character.\n*/\nstatic void MD5DigestToBase10x8(unsigned char digest[16], char zDigest[50]){\n  int i, j;\n  unsigned int x;\n  for(i=j=0; i<16; i+=2){\n    x = digest[i]*256 + digest[i+1];\n    if( i>0 ) zDigest[j++] = '-';\n    sqlite3_snprintf(50-j, &zDigest[j], \"%05u\", x);\n    j += 5;\n  }\n  zDigest[j] = 0;\n}\n\n/*\n** A TCL command for md5.  The argument is the text to be hashed.  The\n** Result is the hash in base64.\n*/\nstatic int SQLITE_TCLAPI md5_cmd(\n  void*cd,\n  Tcl_Interp *interp,\n  int argc,\n  const char **argv\n){\n  MD5Context ctx;\n  unsigned char digest[16];\n  char zBuf[50];\n  void (*converter)(unsigned char*, char*);\n\n  if( argc!=2 ){\n    Tcl_AppendResult(interp,\"wrong # args: should be \\\"\", argv[0],\n        \" TEXT\\\"\", (char*)0);\n    return TCL_ERROR;\n  }\n  MD5Init(&ctx);\n  MD5Update(&ctx, (unsigned char*)argv[1], (unsigned)strlen(argv[1]));\n  MD5Final(digest, &ctx);\n  converter = (void(*)(unsigned char*,char*))cd;\n  converter(digest, zBuf);\n  Tcl_AppendResult(interp, zBuf, (char*)0);\n  return TCL_OK;\n}\n\n/*\n** A TCL command to take the md5 hash of a file.  The argument is the\n** name of the file.\n*/\nstatic int SQLITE_TCLAPI md5file_cmd(\n  void*cd,\n  Tcl_Interp *interp,\n  int argc,\n  const char **argv\n){\n  FILE *in;\n  int ofst;\n  int amt;\n  MD5Context ctx;\n  void (*converter)(unsigned char*, char*);\n  unsigned char digest[16];\n  char zBuf[10240];\n\n  if( argc!=2 && argc!=4 ){\n    Tcl_AppendResult(interp,\"wrong # args: should be \\\"\", argv[0],\n        \" FILENAME [OFFSET AMT]\\\"\", (char*)0);\n    return TCL_ERROR;\n  }\n  if( argc==4 ){\n    ofst = atoi(argv[2]);\n    amt = atoi(argv[3]);\n  }else{\n    ofst = 0;\n    amt = 2147483647;\n  }\n  in = fopen(argv[1],\"rb\");\n  if( in==0 ){\n    Tcl_AppendResult(interp,\"unable to open file \\\"\", argv[1],\n         \"\\\" for reading\", (char*)0);\n    return TCL_ERROR;\n  }\n  fseek(in, ofst, SEEK_SET);\n  MD5Init(&ctx);\n  while( amt>0 ){\n    int n;\n    n = (int)fread(zBuf, 1, sizeof(zBuf)<=amt ? sizeof(zBuf) : amt, in);\n    if( n<=0 ) break;\n    MD5Update(&ctx, (unsigned char*)zBuf, (unsigned)n);\n    amt -= n;\n  }\n  fclose(in);\n  MD5Final(digest, &ctx);\n  converter = (void(*)(unsigned char*,char*))cd;\n  converter(digest, zBuf);\n  Tcl_AppendResult(interp, zBuf, (char*)0);\n  return TCL_OK;\n}\n\n/*\n** Register the four new TCL commands for generating MD5 checksums\n** with the TCL interpreter.\n*/\nint Md5_Init(Tcl_Interp *interp){\n  Tcl_CreateCommand(interp, \"md5\", (Tcl_CmdProc*)md5_cmd,\n                    MD5DigestToBase16, 0);\n  Tcl_CreateCommand(interp, \"md5-10x8\", (Tcl_CmdProc*)md5_cmd,\n                    MD5DigestToBase10x8, 0);\n  Tcl_CreateCommand(interp, \"md5file\", (Tcl_CmdProc*)md5file_cmd,\n                    MD5DigestToBase16, 0);\n  Tcl_CreateCommand(interp, \"md5file-10x8\", (Tcl_CmdProc*)md5file_cmd,\n                    MD5DigestToBase10x8, 0);\n  return TCL_OK;\n}\n\n/*\n** During testing, the special md5sum() aggregate function is available.\n** inside SQLite.  The following routines implement that function.\n*/\nstatic void md5step(sqlite3_context *context, int argc, sqlite3_value **argv){\n  MD5Context *p;\n  int i;\n  if( argc<1 ) return;\n  p = sqlite3_aggregate_context(context, sizeof(*p));\n  if( p==0 ) return;\n  if( !p->isInit ){\n    MD5Init(p);\n  }\n  for(i=0; i<argc; i++){\n    const char *zData = (char*)sqlite3_value_text(argv[i]);\n    if( zData ){\n      MD5Update(p, (unsigned char*)zData, (int)strlen(zData));\n    }\n  }\n}\nstatic void md5finalize(sqlite3_context *context){\n  MD5Context *p;\n  unsigned char digest[16];\n  char zBuf[33];\n  p = sqlite3_aggregate_context(context, sizeof(*p));\n  MD5Final(digest,p);\n  MD5DigestToBase16(digest, zBuf);\n  sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);\n}\nint Md5_Register(\n  sqlite3 *db,\n  char **pzErrMsg,\n  const sqlite3_api_routines *pThunk\n){\n  int rc = sqlite3_create_function(db, \"md5sum\", -1, SQLITE_UTF8, 0, 0,\n                                 md5step, md5finalize);\n  sqlite3_overload_function(db, \"md5sum\", -1);  /* To exercise this API */\n  return rc;\n}\n"}
{"repo": "sqlite", "file": "mutex.h", "lang": "C++", "code": "/*\n** 2007 August 28\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains the common header for all mutex implementations.\n** The sqliteInt.h header #includes this file so that it is available\n** to all source files.  We break it out in an effort to keep the code\n** better organized.\n**\n** NOTE:  source files should *not* #include this header file directly.\n** Source files should #include the sqliteInt.h file and let that file\n** include this one indirectly.\n*/\n\n\n/*\n** Figure out what version of the code to use.  The choices are\n**\n**   SQLITE_MUTEX_OMIT         No mutex logic.  Not even stubs.  The\n**                             mutexes implementation cannot be overridden\n**                             at start-time.\n**\n**   SQLITE_MUTEX_NOOP         For single-threaded applications.  No\n**                             mutual exclusion is provided.  But this\n**                             implementation can be overridden at\n**                             start-time.\n**\n**   SQLITE_MUTEX_PTHREADS     For multi-threaded applications on Unix.\n**\n**   SQLITE_MUTEX_W32          For multi-threaded applications on Win32.\n*/\n#if !SQLITE_THREADSAFE\n# define SQLITE_MUTEX_OMIT\n#endif\n#if SQLITE_THREADSAFE && !defined(SQLITE_MUTEX_NOOP)\n#  if SQLITE_OS_UNIX\n#    define SQLITE_MUTEX_PTHREADS\n#  elif SQLITE_OS_WIN\n#    define SQLITE_MUTEX_W32\n#  else\n#    define SQLITE_MUTEX_NOOP\n#  endif\n#endif\n\n#ifdef SQLITE_MUTEX_OMIT\n/*\n** If this is a no-op implementation, implement everything as macros.\n*/\n#define sqlite3_mutex_alloc(X)    ((sqlite3_mutex*)8)\n#define sqlite3_mutex_free(X)\n#define sqlite3_mutex_enter(X)    \n#define sqlite3_mutex_try(X)      SQLITE_OK\n#define sqlite3_mutex_leave(X)    \n#define sqlite3_mutex_held(X)     ((void)(X),1)\n#define sqlite3_mutex_notheld(X)  ((void)(X),1)\n#define sqlite3MutexAlloc(X)      ((sqlite3_mutex*)8)\n#define sqlite3MutexInit()        SQLITE_OK\n#define sqlite3MutexEnd()\n#define MUTEX_LOGIC(X)\n#else\n#define MUTEX_LOGIC(X)            X\nint sqlite3_mutex_held(sqlite3_mutex*);\n#endif /* defined(SQLITE_MUTEX_OMIT) */\n"}
{"repo": "sqlite", "file": "global.c", "lang": "C++", "code": "/*\n** 2008 June 13\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains definitions of global variables and constants.\n*/\n#include \"sqliteInt.h\"\n\n/* An array to map all upper-case characters into their corresponding\n** lower-case character. \n**\n** SQLite only considers US-ASCII (or EBCDIC) characters.  We do not\n** handle case conversions for the UTF character set since the tables\n** involved are nearly as big or bigger than SQLite itself.\n*/\nconst unsigned char sqlite3UpperToLower[] = {\n#ifdef SQLITE_ASCII\n      0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n     18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,\n     36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,\n     54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99,100,101,102,103,\n    104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,\n    122, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,102,103,104,105,106,107,\n    108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,\n    126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,\n    144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,\n    162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,\n    180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,\n    198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,\n    216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,\n    234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,\n    252,253,254,255,\n#endif\n#ifdef SQLITE_EBCDIC\n      0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, /* 0x */\n     16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, /* 1x */\n     32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, /* 2x */\n     48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, /* 3x */\n     64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, /* 4x */\n     80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, /* 5x */\n     96, 97, 98, 99,100,101,102,103,104,105,106,107,108,109,110,111, /* 6x */\n    112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127, /* 7x */\n    128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143, /* 8x */\n    144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159, /* 9x */\n    160,161,162,163,164,165,166,167,168,169,170,171,140,141,142,175, /* Ax */\n    176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191, /* Bx */\n    192,129,130,131,132,133,134,135,136,137,202,203,204,205,206,207, /* Cx */\n    208,145,146,147,148,149,150,151,152,153,218,219,220,221,222,223, /* Dx */\n    224,225,162,163,164,165,166,167,168,169,234,235,236,237,238,239, /* Ex */\n    240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255, /* Fx */\n#endif\n/* All of the upper-to-lower conversion data is above.  The following\n** 18 integers are completely unrelated.  They are appended to the\n** sqlite3UpperToLower[] array to avoid UBSAN warnings.  Here's what is\n** going on:\n**\n** The SQL comparison operators (<>, =, >, <=, <, and >=) are implemented\n** by invoking sqlite3MemCompare(A,B) which compares values A and B and\n** returns negative, zero, or positive if A is less then, equal to, or\n** greater than B, respectively.  Then the true false results is found by\n** consulting sqlite3aLTb[opcode], sqlite3aEQb[opcode], or \n** sqlite3aGTb[opcode] depending on whether the result of compare(A,B)\n** is negative, zero, or positive, where opcode is the specific opcode.\n** The only works because the comparison opcodes are consecutive and in\n** this order: NE EQ GT LE LT GE.  Various assert()s throughout the code\n** ensure that is the case.\n**\n** These elements must be appended to another array.  Otherwise the\n** index (here shown as [256-OP_Ne]) would be out-of-bounds and thus\n** be undefined behavior.  That's goofy, but the C-standards people thought\n** it was a good idea, so here we are.\n*/\n/* NE  EQ  GT  LE  LT  GE  */\n   1,  0,  0,  1,  1,  0,  /* aLTb[]: Use when compare(A,B) less than zero */\n   0,  1,  0,  1,  0,  1,  /* aEQb[]: Use when compare(A,B) equals zero */\n   1,  0,  1,  0,  0,  1   /* aGTb[]: Use when compare(A,B) greater than zero*/\n};\nconst unsigned char *sqlite3aLTb = &sqlite3UpperToLower[256-OP_Ne];\nconst unsigned char *sqlite3aEQb = &sqlite3UpperToLower[256+6-OP_Ne];\nconst unsigned char *sqlite3aGTb = &sqlite3UpperToLower[256+12-OP_Ne];\n\n/*\n** The following 256 byte lookup table is used to support SQLites built-in\n** equivalents to the following standard library functions:\n**\n**   isspace()                        0x01\n**   isalpha()                        0x02\n**   isdigit()                        0x04\n**   isalnum()                        0x06\n**   isxdigit()                       0x08\n**   toupper()                        0x20\n**   SQLite identifier character      0x40   $, _, or non-ascii\n**   Quote character                  0x80\n**\n** Bit 0x20 is set if the mapped character requires translation to upper\n** case. i.e. if the character is a lower-case ASCII character.\n** If x is a lower-case ASCII character, then its upper-case equivalent\n** is (x - 0x20). Therefore toupper() can be implemented as:\n**\n**   (x & ~(map[x]&0x20))\n**\n** The equivalent of tolower() is implemented using the sqlite3UpperToLower[]\n** array. tolower() is used more often than toupper() by SQLite.\n**\n** Bit 0x40 is set if the character is non-alphanumeric and can be used in an \n** SQLite identifier.  Identifiers are alphanumerics, \"_\", \"$\", and any\n** non-ASCII UTF character. Hence the test for whether or not a character is\n** part of an identifier is 0x46.\n*/\nconst unsigned char sqlite3CtypeMap[256] = {\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 00..07    ........ */\n  0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,  /* 08..0f    ........ */\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 10..17    ........ */\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 18..1f    ........ */\n  0x01, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x80,  /* 20..27     !\"#$%&' */\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 28..2f    ()*+,-./ */\n  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,  /* 30..37    01234567 */\n  0x0c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 38..3f    89:;<=>? */\n\n  0x00, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x02,  /* 40..47    @ABCDEFG */\n  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  /* 48..4f    HIJKLMNO */\n  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  /* 50..57    PQRSTUVW */\n  0x02, 0x02, 0x02, 0x80, 0x00, 0x00, 0x00, 0x40,  /* 58..5f    XYZ[\\]^_ */\n  0x80, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x22,  /* 60..67    `abcdefg */\n  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,  /* 68..6f    hijklmno */\n  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,  /* 70..77    pqrstuvw */\n  0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 78..7f    xyz{|}~. */\n\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 80..87    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 88..8f    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 90..97    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 98..9f    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* a0..a7    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* a8..af    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* b0..b7    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* b8..bf    ........ */\n\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* c0..c7    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* c8..cf    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* d0..d7    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* d8..df    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* e0..e7    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* e8..ef    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* f0..f7    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40   /* f8..ff    ........ */\n};\n\n/* EVIDENCE-OF: R-02982-34736 In order to maintain full backwards\n** compatibility for legacy applications, the URI filename capability is\n** disabled by default.\n**\n** EVIDENCE-OF: R-38799-08373 URI filenames can be enabled or disabled\n** using the SQLITE_USE_URI=1 or SQLITE_USE_URI=0 compile-time options.\n**\n** EVIDENCE-OF: R-43642-56306 By default, URI handling is globally\n** disabled. The default value may be changed by compiling with the\n** SQLITE_USE_URI symbol defined.\n*/\n#ifndef SQLITE_USE_URI\n# define SQLITE_USE_URI 0\n#endif\n\n/* EVIDENCE-OF: R-38720-18127 The default setting is determined by the\n** SQLITE_ALLOW_COVERING_INDEX_SCAN compile-time option, or is \"on\" if\n** that compile-time option is omitted.\n*/\n#if !defined(SQLITE_ALLOW_COVERING_INDEX_SCAN)\n# define SQLITE_ALLOW_COVERING_INDEX_SCAN 1\n#else\n# if !SQLITE_ALLOW_COVERING_INDEX_SCAN \n#   error \"Compile-time disabling of covering index scan using the\\\n -DSQLITE_ALLOW_COVERING_INDEX_SCAN=0 option is deprecated.\\\n Contact SQLite developers if this is a problem for you, and\\\n delete this #error macro to continue with your build.\"\n# endif\n#endif\n\n/* The minimum PMA size is set to this value multiplied by the database\n** page size in bytes.\n*/\n#ifndef SQLITE_SORTER_PMASZ\n# define SQLITE_SORTER_PMASZ 250\n#endif\n\n/* Statement journals spill to disk when their size exceeds the following\n** threshold (in bytes). 0 means that statement journals are created and\n** written to disk immediately (the default behavior for SQLite versions\n** before 3.12.0).  -1 means always keep the entire statement journal in\n** memory.  (The statement journal is also always held entirely in memory\n** if journal_mode=MEMORY or if temp_store=MEMORY, regardless of this\n** setting.)\n*/\n#ifndef SQLITE_STMTJRNL_SPILL \n# define SQLITE_STMTJRNL_SPILL (64*1024)\n#endif\n\n/*\n** The default lookaside-configuration, the format \"SZ,N\".  SZ is the\n** number of bytes in each lookaside slot (should be a multiple of 8)\n** and N is the number of slots.  The lookaside-configuration can be\n** changed as start-time using sqlite3_config(SQLITE_CONFIG_LOOKASIDE)\n** or at run-time for an individual database connection using\n** sqlite3_db_config(db, SQLITE_DBCONFIG_LOOKASIDE);\n**\n** With the two-size-lookaside enhancement, less lookaside is required.\n** The default configuration of 1200,40 actually provides 30 1200-byte slots\n** and 93 128-byte slots, which is more lookaside than is available\n** using the older 1200,100 configuration without two-size-lookaside.\n*/\n#ifndef SQLITE_DEFAULT_LOOKASIDE\n# ifdef SQLITE_OMIT_TWOSIZE_LOOKASIDE\n#   define SQLITE_DEFAULT_LOOKASIDE 1200,100  /* 120KB of memory */\n# else\n#   define SQLITE_DEFAULT_LOOKASIDE 1200,40   /* 48KB of memory */\n# endif\n#endif\n\n\n/* The default maximum size of an in-memory database created using\n** sqlite3_deserialize()\n*/\n#ifndef SQLITE_MEMDB_DEFAULT_MAXSIZE\n# define SQLITE_MEMDB_DEFAULT_MAXSIZE 1073741824\n#endif\n\n/*\n** The following singleton contains the global configuration for\n** the SQLite library.\n*/\nSQLITE_WSD struct Sqlite3Config sqlite3Config = {\n   SQLITE_DEFAULT_MEMSTATUS,  /* bMemstat */\n   1,                         /* bCoreMutex */\n   SQLITE_THREADSAFE==1,      /* bFullMutex */\n   SQLITE_USE_URI,            /* bOpenUri */\n   SQLITE_ALLOW_COVERING_INDEX_SCAN,   /* bUseCis */\n   0,                         /* bSmallMalloc */\n   1,                         /* bExtraSchemaChecks */\n#ifdef SQLITE_DEBUG\n   0,                         /* bJsonSelfcheck */\n#endif\n   0x7ffffffe,                /* mxStrlen */\n   0,                         /* neverCorrupt */\n   SQLITE_DEFAULT_LOOKASIDE,  /* szLookaside, nLookaside */\n   SQLITE_STMTJRNL_SPILL,     /* nStmtSpill */\n   {0,0,0,0,0,0,0,0},         /* m */\n   {0,0,0,0,0,0,0,0,0},       /* mutex */\n   {0,0,0,0,0,0,0,0,0,0,0,0,0},/* pcache2 */\n   (void*)0,                  /* pHeap */\n   0,                         /* nHeap */\n   0, 0,                      /* mnHeap, mxHeap */\n   SQLITE_DEFAULT_MMAP_SIZE,  /* szMmap */\n   SQLITE_MAX_MMAP_SIZE,      /* mxMmap */\n   (void*)0,                  /* pPage */\n   0,                         /* szPage */\n   SQLITE_DEFAULT_PCACHE_INITSZ, /* nPage */\n   0,                         /* mxParserStack */\n   0,                         /* sharedCacheEnabled */\n   SQLITE_SORTER_PMASZ,       /* szPma */\n   /* All the rest should always be initialized to zero */\n   0,                         /* isInit */\n   0,                         /* inProgress */\n   0,                         /* isMutexInit */\n   0,                         /* isMallocInit */\n   0,                         /* isPCacheInit */\n   0,                         /* nRefInitMutex */\n   0,                         /* pInitMutex */\n   0,                         /* xLog */\n   0,                         /* pLogArg */\n#ifdef SQLITE_ENABLE_SQLLOG\n   0,                         /* xSqllog */\n   0,                         /* pSqllogArg */\n#endif\n#ifdef SQLITE_VDBE_COVERAGE\n   0,                         /* xVdbeBranch */\n   0,                         /* pVbeBranchArg */\n#endif\n#ifndef SQLITE_OMIT_DESERIALIZE\n   SQLITE_MEMDB_DEFAULT_MAXSIZE,   /* mxMemdbSize */\n#endif\n#ifndef SQLITE_UNTESTABLE\n   0,                         /* xTestCallback */\n#endif\n#ifdef SQLITE_ALLOW_ROWID_IN_VIEW\n   0,                         /* mNoVisibleRowid.  0 == allow rowid-in-view */\n#endif\n   0,                         /* bLocaltimeFault */\n   0,                         /* xAltLocaltime */\n   0x7ffffffe,                /* iOnceResetThreshold */\n   SQLITE_DEFAULT_SORTERREF_SIZE,   /* szSorterRef */\n   0,                         /* iPrngSeed */\n#ifdef SQLITE_DEBUG\n   {0,0,0,0,0,0},             /* aTune */\n#endif\n};\n\n/*\n** Hash table for global functions - functions common to all\n** database connections.  After initialization, this table is\n** read-only.\n*/\nFuncDefHash sqlite3BuiltinFunctions;\n\n#if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_DEBUG)\n/*\n** Counter used for coverage testing.  Does not come into play for\n** release builds.\n**\n** Access to this global variable is not mutex protected.  This might\n** result in TSAN warnings.  But as the variable does not exist in\n** release builds, that should not be a concern.\n*/\nunsigned int sqlite3CoverageCounter;\n#endif /* SQLITE_COVERAGE_TEST || SQLITE_DEBUG */\n\n#ifdef VDBE_PROFILE\n/*\n** The following performance counter can be used in place of\n** sqlite3Hwtime() for profiling.  This is a no-op on standard builds.\n*/\nsqlite3_uint64 sqlite3NProfileCnt = 0;\n#endif\n\n/*\n** The value of the \"pending\" byte must be 0x40000000 (1 byte past the\n** 1-gibabyte boundary) in a compatible database.  SQLite never uses\n** the database page that contains the pending byte.  It never attempts\n** to read or write that page.  The pending byte page is set aside\n** for use by the VFS layers as space for managing file locks.\n**\n** During testing, it is often desirable to move the pending byte to\n** a different position in the file.  This allows code that has to\n** deal with the pending byte to run on files that are much smaller\n** than 1 GiB.  The sqlite3_test_control() interface can be used to\n** move the pending byte.\n**\n** IMPORTANT:  Changing the pending byte to any value other than\n** 0x40000000 results in an incompatible database file format!\n** Changing the pending byte during operation will result in undefined\n** and incorrect behavior.\n*/\n#ifndef SQLITE_OMIT_WSD\nint sqlite3PendingByte = 0x40000000;\n#endif\n\n/*\n** Tracing flags set by SQLITE_TESTCTRL_TRACEFLAGS.\n*/\nu32 sqlite3TreeTrace = 0;\nu32 sqlite3WhereTrace = 0;\n\n#include \"opcodes.h\"\n/*\n** Properties of opcodes.  The OPFLG_INITIALIZER macro is\n** created by mkopcodeh.awk during compilation.  Data is obtained\n** from the comments following the \"case OP_xxxx:\" statements in\n** the vdbe.c file.  \n*/\nconst unsigned char sqlite3OpcodeProperty[] = OPFLG_INITIALIZER;\n\n/*\n** Name of the default collating sequence\n*/\nconst char sqlite3StrBINARY[] = \"BINARY\";\n\n/*\n** Standard typenames.  These names must match the COLTYPE_* definitions.\n** Adjust the SQLITE_N_STDTYPE value if adding or removing entries.\n**\n**    sqlite3StdType[]            The actual names of the datatypes.\n**\n**    sqlite3StdTypeLen[]         The length (in bytes) of each entry\n**                                in sqlite3StdType[].\n**\n**    sqlite3StdTypeAffinity[]    The affinity associated with each entry\n**                                in sqlite3StdType[].\n*/\nconst unsigned char sqlite3StdTypeLen[] = { 3, 4, 3, 7, 4, 4 };\nconst char sqlite3StdTypeAffinity[] = {\n  SQLITE_AFF_NUMERIC,\n  SQLITE_AFF_BLOB,\n  SQLITE_AFF_INTEGER,\n  SQLITE_AFF_INTEGER,\n  SQLITE_AFF_REAL,\n  SQLITE_AFF_TEXT\n};\nconst char *sqlite3StdType[] = {\n  \"ANY\",\n  \"BLOB\",\n  \"INT\",\n  \"INTEGER\",\n  \"REAL\",\n  \"TEXT\"\n};\n"}
{"repo": "sqlite", "file": "test_vfs.c", "lang": "C++", "code": "/*\n** 2010 May 05\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This file contains the implementation of the Tcl [testvfs] command,\n** used to create SQLite VFS implementations with various properties and\n** instrumentation to support testing SQLite.\n**\n**   testvfs VFSNAME ?OPTIONS?\n**\n** Available options are:\n**\n**   -noshm      BOOLEAN        (True to omit shm methods. Default false)\n**   -default    BOOLEAN        (True to make the vfs default. Default false)\n**   -szosfile   INTEGER        (Value for sqlite3_vfs.szOsFile)\n**   -mxpathname INTEGER        (Value for sqlite3_vfs.mxPathname)\n**   -iversion   INTEGER        (Value for sqlite3_vfs.iVersion)\n*/\n#if SQLITE_TEST          /* This file is used for testing only */\n\n#include \"sqlite3.h\"\n#include \"sqliteInt.h\"\n#include \"tclsqlite.h\"\n\ntypedef struct Testvfs Testvfs;\ntypedef struct TestvfsShm TestvfsShm;\ntypedef struct TestvfsBuffer TestvfsBuffer;\ntypedef struct TestvfsFile TestvfsFile;\ntypedef struct TestvfsFd TestvfsFd;\n\n/*\n** An open file handle.\n*/\nstruct TestvfsFile {\n  sqlite3_file base;              /* Base class.  Must be first */\n  TestvfsFd *pFd;                 /* File data */\n};\n#define tvfsGetFd(pFile) (((TestvfsFile *)pFile)->pFd)\n\nstruct TestvfsFd {\n  sqlite3_vfs *pVfs;              /* The VFS */\n  const char *zFilename;          /* Filename as passed to xOpen() */\n  sqlite3_file *pReal;            /* The real, underlying file descriptor */\n  Tcl_Obj *pShmId;                /* Shared memory id for Tcl callbacks */\n\n  TestvfsBuffer *pShm;            /* Shared memory buffer */\n  u32 excllock;                   /* Mask of exclusive locks */\n  u32 sharedlock;                 /* Mask of shared locks */\n  TestvfsFd *pNext;               /* Next handle opened on the same file */\n};\n\n\n#define FAULT_INJECT_NONE       0\n#define FAULT_INJECT_TRANSIENT  1\n#define FAULT_INJECT_PERSISTENT 2\n\ntypedef struct TestFaultInject TestFaultInject;\nstruct TestFaultInject {\n  int iCnt;                       /* Remaining calls before fault injection */\n  int eFault;                     /* A FAULT_INJECT_* value */\n  int nFail;                      /* Number of faults injected */\n};\n\n/*\n** An instance of this structure is allocated for each VFS created. The\n** sqlite3_vfs.pAppData field of the VFS structure registered with SQLite\n** is set to point to it.\n*/\nstruct Testvfs {\n  char *zName;                    /* Name of this VFS */\n  sqlite3_vfs *pParent;           /* The VFS to use for file IO */\n  sqlite3_vfs *pVfs;              /* The testvfs registered with SQLite */\n  Tcl_Interp *interp;             /* Interpreter to run script in */\n  Tcl_Obj *pScript;               /* Script to execute */\n  TestvfsBuffer *pBuffer;         /* List of shared buffers */\n  int isNoshm;\n  int isFullshm;\n\n  int mask;                       /* Mask controlling [script] and [ioerr] */\n\n  TestFaultInject ioerr_err;\n  TestFaultInject full_err;\n  TestFaultInject cantopen_err;\n\n#if 0\n  int iIoerrCnt;\n  int ioerr;\n  int nIoerrFail;\n  int iFullCnt;\n  int fullerr;\n  int nFullFail;\n#endif\n\n  int iDevchar;\n  int iSectorsize;\n};\n\n/*\n** The Testvfs.mask variable is set to a combination of the following.\n** If a bit is clear in Testvfs.mask, then calls made by SQLite to the \n** corresponding VFS method is ignored for purposes of:\n**\n**   + Simulating IO errors, and\n**   + Invoking the Tcl callback script.\n*/\n#define TESTVFS_SHMOPEN_MASK      0x00000001\n#define TESTVFS_SHMLOCK_MASK      0x00000010\n#define TESTVFS_SHMMAP_MASK       0x00000020\n#define TESTVFS_SHMBARRIER_MASK   0x00000040\n#define TESTVFS_SHMCLOSE_MASK     0x00000080\n\n#define TESTVFS_OPEN_MASK         0x00000100\n#define TESTVFS_SYNC_MASK         0x00000200\n#define TESTVFS_DELETE_MASK       0x00000400\n#define TESTVFS_CLOSE_MASK        0x00000800\n#define TESTVFS_WRITE_MASK        0x00001000\n#define TESTVFS_TRUNCATE_MASK     0x00002000\n#define TESTVFS_ACCESS_MASK       0x00004000\n#define TESTVFS_FULLPATHNAME_MASK 0x00008000\n#define TESTVFS_READ_MASK         0x00010000\n#define TESTVFS_UNLOCK_MASK       0x00020000\n#define TESTVFS_LOCK_MASK         0x00040000\n#define TESTVFS_CKLOCK_MASK       0x00080000\n#define TESTVFS_FCNTL_MASK        0x00100000\n#define TESTVFS_SLEEP_MASK        0x00200000\n\n#define TESTVFS_ALL_MASK          0x003FFFFF\n\n\n#define TESTVFS_MAX_PAGES 1024\n\n/*\n** A shared-memory buffer. There is one of these objects for each shared\n** memory region opened by clients. If two clients open the same file,\n** there are two TestvfsFile structures but only one TestvfsBuffer structure.\n*/\nstruct TestvfsBuffer {\n  char *zFile;                    /* Associated file name */\n  int pgsz;                       /* Page size */\n  u8 *aPage[TESTVFS_MAX_PAGES];   /* Array of ckalloc'd pages */\n  TestvfsFd *pFile;               /* List of open handles */\n  TestvfsBuffer *pNext;           /* Next in linked list of all buffers */\n};\n\n\n#define PARENTVFS(x) (((Testvfs *)((x)->pAppData))->pParent)\n\n#define TESTVFS_MAX_ARGS 12\n\n\n/*\n** Method declarations for TestvfsFile.\n*/\nstatic int tvfsClose(sqlite3_file*);\nstatic int tvfsRead(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);\nstatic int tvfsWrite(sqlite3_file*,const void*,int iAmt, sqlite3_int64 iOfst);\nstatic int tvfsTruncate(sqlite3_file*, sqlite3_int64 size);\nstatic int tvfsSync(sqlite3_file*, int flags);\nstatic int tvfsFileSize(sqlite3_file*, sqlite3_int64 *pSize);\nstatic int tvfsLock(sqlite3_file*, int);\nstatic int tvfsUnlock(sqlite3_file*, int);\nstatic int tvfsCheckReservedLock(sqlite3_file*, int *);\nstatic int tvfsFileControl(sqlite3_file*, int op, void *pArg);\nstatic int tvfsSectorSize(sqlite3_file*);\nstatic int tvfsDeviceCharacteristics(sqlite3_file*);\n\n/*\n** Method declarations for tvfs_vfs.\n*/\nstatic int tvfsOpen(sqlite3_vfs*, const char *, sqlite3_file*, int , int *);\nstatic int tvfsDelete(sqlite3_vfs*, const char *zName, int syncDir);\nstatic int tvfsAccess(sqlite3_vfs*, const char *zName, int flags, int *);\nstatic int tvfsFullPathname(sqlite3_vfs*, const char *zName, int, char *zOut);\n#ifndef SQLITE_OMIT_LOAD_EXTENSION\nstatic void *tvfsDlOpen(sqlite3_vfs*, const char *zFilename);\nstatic void tvfsDlError(sqlite3_vfs*, int nByte, char *zErrMsg);\nstatic void (*tvfsDlSym(sqlite3_vfs*,void*, const char *zSymbol))(void);\nstatic void tvfsDlClose(sqlite3_vfs*, void*);\n#endif /* SQLITE_OMIT_LOAD_EXTENSION */\nstatic int tvfsRandomness(sqlite3_vfs*, int nByte, char *zOut);\nstatic int tvfsSleep(sqlite3_vfs*, int microseconds);\nstatic int tvfsCurrentTime(sqlite3_vfs*, double*);\n\nstatic int tvfsShmOpen(sqlite3_file*);\nstatic int tvfsShmLock(sqlite3_file*, int , int, int);\nstatic int tvfsShmMap(sqlite3_file*,int,int,int, void volatile **);\nstatic void tvfsShmBarrier(sqlite3_file*);\nstatic int tvfsShmUnmap(sqlite3_file*, int);\n\nstatic int tvfsFetch(sqlite3_file*, sqlite3_int64, int, void**);\nstatic int tvfsUnfetch(sqlite3_file*, sqlite3_int64, void*);\n\nstatic sqlite3_io_methods tvfs_io_methods = {\n  3,                              /* iVersion */\n  tvfsClose,                      /* xClose */\n  tvfsRead,                       /* xRead */\n  tvfsWrite,                      /* xWrite */\n  tvfsTruncate,                   /* xTruncate */\n  tvfsSync,                       /* xSync */\n  tvfsFileSize,                   /* xFileSize */\n  tvfsLock,                       /* xLock */\n  tvfsUnlock,                     /* xUnlock */\n  tvfsCheckReservedLock,          /* xCheckReservedLock */\n  tvfsFileControl,                /* xFileControl */\n  tvfsSectorSize,                 /* xSectorSize */\n  tvfsDeviceCharacteristics,      /* xDeviceCharacteristics */\n  tvfsShmMap,                     /* xShmMap */\n  tvfsShmLock,                    /* xShmLock */\n  tvfsShmBarrier,                 /* xShmBarrier */\n  tvfsShmUnmap,                   /* xShmUnmap */\n  tvfsFetch,\n  tvfsUnfetch\n};\n\nstatic int tvfsResultCode(Testvfs *p, int *pRc){\n  struct errcode {\n    int eCode;\n    const char *zCode;\n  } aCode[] = {\n    { SQLITE_OK,       \"SQLITE_OK\"     },\n    { SQLITE_ERROR,    \"SQLITE_ERROR\"  },\n    { SQLITE_IOERR,    \"SQLITE_IOERR\"  },\n    { SQLITE_LOCKED,   \"SQLITE_LOCKED\" },\n    { SQLITE_BUSY,     \"SQLITE_BUSY\"   },\n    { SQLITE_READONLY, \"SQLITE_READONLY\"   },\n    { SQLITE_READONLY_CANTINIT, \"SQLITE_READONLY_CANTINIT\"   },\n    { SQLITE_NOTFOUND, \"SQLITE_NOTFOUND\"   },\n    { -1,              \"SQLITE_OMIT\"   },\n  };\n\n  const char *z;\n  int i;\n\n  z = Tcl_GetStringResult(p->interp);\n  for(i=0; i<ArraySize(aCode); i++){\n    if( 0==strcmp(z, aCode[i].zCode) ){\n      *pRc = aCode[i].eCode;\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\nstatic int tvfsInjectFault(TestFaultInject *p){\n  int ret = 0;\n  if( p->eFault ){\n    p->iCnt--;\n    if( p->iCnt==0 || (p->iCnt<0 && p->eFault==FAULT_INJECT_PERSISTENT ) ){\n      ret = 1;\n      p->nFail++;\n    }\n  }\n  return ret;\n}\n\n\nstatic int tvfsInjectIoerr(Testvfs *p){\n  return tvfsInjectFault(&p->ioerr_err);\n}\n\nstatic int tvfsInjectFullerr(Testvfs *p){\n  return tvfsInjectFault(&p->full_err);\n}\nstatic int tvfsInjectCantopenerr(Testvfs *p){\n  return tvfsInjectFault(&p->cantopen_err);\n}\n\n\nstatic void tvfsExecTcl(\n  Testvfs *p, \n  const char *zMethod,\n  Tcl_Obj *arg1,\n  Tcl_Obj *arg2,\n  Tcl_Obj *arg3,\n  Tcl_Obj *arg4\n){\n  int rc;                         /* Return code from Tcl_EvalObj() */\n  Tcl_Obj *pEval;\n  assert( p->pScript );\n\n  assert( zMethod );\n  assert( p );\n  assert( arg2==0 || arg1!=0 );\n  assert( arg3==0 || arg2!=0 );\n\n  pEval = Tcl_DuplicateObj(p->pScript);\n  Tcl_IncrRefCount(p->pScript);\n  Tcl_ListObjAppendElement(p->interp, pEval, Tcl_NewStringObj(zMethod, -1));\n  if( arg1 ) Tcl_ListObjAppendElement(p->interp, pEval, arg1);\n  if( arg2 ) Tcl_ListObjAppendElement(p->interp, pEval, arg2);\n  if( arg3 ) Tcl_ListObjAppendElement(p->interp, pEval, arg3);\n  if( arg4 ) Tcl_ListObjAppendElement(p->interp, pEval, arg4);\n\n  rc = Tcl_EvalObjEx(p->interp, pEval, TCL_EVAL_GLOBAL);\n  if( rc!=TCL_OK ){\n    Tcl_BackgroundError(p->interp);\n    Tcl_ResetResult(p->interp);\n  }\n}\n\n\n/*\n** Close an tvfs-file.\n*/\nstatic int tvfsClose(sqlite3_file *pFile){\n  TestvfsFile *pTestfile = (TestvfsFile *)pFile;\n  TestvfsFd *pFd = pTestfile->pFd;\n  Testvfs *p = (Testvfs *)pFd->pVfs->pAppData;\n\n  if( p->pScript && p->mask&TESTVFS_CLOSE_MASK ){\n    tvfsExecTcl(p, \"xClose\", \n        Tcl_NewStringObj(pFd->zFilename, -1), pFd->pShmId, 0, 0\n    );\n  }\n\n  if( pFd->pShmId ){\n    Tcl_DecrRefCount(pFd->pShmId);\n    pFd->pShmId = 0;\n  }\n  if( pFile->pMethods ){\n    ckfree((char *)pFile->pMethods);\n  }\n  sqlite3OsClose(pFd->pReal);\n  ckfree((char *)pFd);\n  pTestfile->pFd = 0;\n  return SQLITE_OK;\n}\n\n/*\n** Read data from an tvfs-file.\n*/\nstatic int tvfsRead(\n  sqlite3_file *pFile, \n  void *zBuf, \n  int iAmt, \n  sqlite_int64 iOfst\n){\n  int rc = SQLITE_OK;\n  TestvfsFd *pFd = tvfsGetFd(pFile);\n  Testvfs *p = (Testvfs *)pFd->pVfs->pAppData;\n  if( p->pScript && p->mask&TESTVFS_READ_MASK ){\n    tvfsExecTcl(p, \"xRead\", \n        Tcl_NewStringObj(pFd->zFilename, -1), pFd->pShmId, 0, 0\n    );\n    tvfsResultCode(p, &rc);\n  }\n  if( rc==SQLITE_OK && p->mask&TESTVFS_READ_MASK && tvfsInjectIoerr(p) ){\n    rc = SQLITE_IOERR;\n  }\n  if( rc==SQLITE_OK ){\n    rc = sqlite3OsRead(pFd->pReal, zBuf, iAmt, iOfst);\n  }\n  return rc;\n}\n\n/*\n** Write data to an tvfs-file.\n*/\nstatic int tvfsWrite(\n  sqlite3_file *pFile, \n  const void *zBuf, \n  int iAmt, \n  sqlite_int64 iOfst\n){\n  int rc = SQLITE_OK;\n  TestvfsFd *pFd = tvfsGetFd(pFile);\n  Testvfs *p = (Testvfs *)pFd->pVfs->pAppData;\n\n  if( p->pScript && p->mask&TESTVFS_WRITE_MASK ){\n    tvfsExecTcl(p, \"xWrite\", \n        Tcl_NewStringObj(pFd->zFilename, -1), pFd->pShmId, \n        Tcl_NewWideIntObj(iOfst), Tcl_NewIntObj(iAmt)\n    );\n    tvfsResultCode(p, &rc);\n    if( rc<0 ) return SQLITE_OK;\n  }\n\n  if( rc==SQLITE_OK && tvfsInjectFullerr(p) ){\n    rc = SQLITE_FULL;\n  }\n  if( rc==SQLITE_OK && p->mask&TESTVFS_WRITE_MASK && tvfsInjectIoerr(p) ){\n    rc = SQLITE_IOERR;\n  }\n  \n  if( rc==SQLITE_OK ){\n    rc = sqlite3OsWrite(pFd->pReal, zBuf, iAmt, iOfst);\n  }\n  return rc;\n}\n\n/*\n** Truncate an tvfs-file.\n*/\nstatic int tvfsTruncate(sqlite3_file *pFile, sqlite_int64 size){\n  int rc = SQLITE_OK;\n  TestvfsFd *pFd = tvfsGetFd(pFile);\n  Testvfs *p = (Testvfs *)pFd->pVfs->pAppData;\n\n  if( p->pScript && p->mask&TESTVFS_TRUNCATE_MASK ){\n    tvfsExecTcl(p, \"xTruncate\", \n        Tcl_NewStringObj(pFd->zFilename, -1), pFd->pShmId, 0, 0\n    );\n    tvfsResultCode(p, &rc);\n  }\n  \n  if( rc==SQLITE_OK ){\n    rc = sqlite3OsTruncate(pFd->pReal, size);\n  }\n  return rc;\n}\n\n/*\n** Sync an tvfs-file.\n*/\nstatic int tvfsSync(sqlite3_file *pFile, int flags){\n  int rc = SQLITE_OK;\n  TestvfsFd *pFd = tvfsGetFd(pFile);\n  Testvfs *p = (Testvfs *)pFd->pVfs->pAppData;\n\n  if( p->pScript && p->mask&TESTVFS_SYNC_MASK ){\n    char *zFlags = 0;\n\n    switch( flags ){\n      case SQLITE_SYNC_NORMAL:\n        zFlags = \"normal\";\n        break;\n      case SQLITE_SYNC_FULL:\n        zFlags = \"full\";\n        break;\n      case SQLITE_SYNC_NORMAL|SQLITE_SYNC_DATAONLY:\n        zFlags = \"normal|dataonly\";\n        break;\n      case SQLITE_SYNC_FULL|SQLITE_SYNC_DATAONLY:\n        zFlags = \"full|dataonly\";\n        break;\n      default:\n        assert(0);\n    }\n\n    tvfsExecTcl(p, \"xSync\", \n        Tcl_NewStringObj(pFd->zFilename, -1), pFd->pShmId,\n        Tcl_NewStringObj(zFlags, -1), 0\n    );\n    tvfsResultCode(p, &rc);\n  }\n\n  if( rc==SQLITE_OK && tvfsInjectFullerr(p) ) rc = SQLITE_FULL;\n\n  if( rc==SQLITE_OK ){\n    rc = sqlite3OsSync(pFd->pReal, flags);\n  }\n\n  return rc;\n}\n\n/*\n** Return the current file-size of an tvfs-file.\n*/\nstatic int tvfsFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){\n  TestvfsFd *p = tvfsGetFd(pFile);\n  return sqlite3OsFileSize(p->pReal, pSize);\n}\n\n/*\n** Lock an tvfs-file.\n*/\nstatic int tvfsLock(sqlite3_file *pFile, int eLock){\n  TestvfsFd *pFd = tvfsGetFd(pFile);\n  Testvfs *p = (Testvfs *)pFd->pVfs->pAppData;\n  if( p->pScript && p->mask&TESTVFS_LOCK_MASK ){\n    char zLock[30];\n    sqlite3_snprintf(sizeof(zLock),zLock,\"%d\",eLock);\n    tvfsExecTcl(p, \"xLock\", Tcl_NewStringObj(pFd->zFilename, -1), \n                   Tcl_NewStringObj(zLock, -1), 0, 0);\n  }\n  if( p->mask&TESTVFS_LOCK_MASK && tvfsInjectIoerr(p) ){\n    return SQLITE_IOERR_LOCK;\n  }\n  return sqlite3OsLock(pFd->pReal, eLock);\n}\n\n/*\n** Unlock an tvfs-file.\n*/\nstatic int tvfsUnlock(sqlite3_file *pFile, int eLock){\n  TestvfsFd *pFd = tvfsGetFd(pFile);\n  Testvfs *p = (Testvfs *)pFd->pVfs->pAppData;\n  if( p->pScript && p->mask&TESTVFS_UNLOCK_MASK ){\n    char zLock[30];\n    sqlite3_snprintf(sizeof(zLock),zLock,\"%d\",eLock);\n    tvfsExecTcl(p, \"xUnlock\", Tcl_NewStringObj(pFd->zFilename, -1), \n                   Tcl_NewStringObj(zLock, -1), 0, 0);\n  }\n  if( p->mask&TESTVFS_UNLOCK_MASK && tvfsInjectIoerr(p) ){\n    return SQLITE_IOERR_UNLOCK;\n  }\n  return sqlite3OsUnlock(pFd->pReal, eLock);\n}\n\n/*\n** Check if another file-handle holds a RESERVED lock on an tvfs-file.\n*/\nstatic int tvfsCheckReservedLock(sqlite3_file *pFile, int *pResOut){\n  TestvfsFd *pFd = tvfsGetFd(pFile);\n  Testvfs *p = (Testvfs *)pFd->pVfs->pAppData;\n  if( p->pScript && p->mask&TESTVFS_CKLOCK_MASK ){\n    tvfsExecTcl(p, \"xCheckReservedLock\", Tcl_NewStringObj(pFd->zFilename, -1),\n                   0, 0, 0);\n  }\n  return sqlite3OsCheckReservedLock(pFd->pReal, pResOut);\n}\n\n/*\n** File control method. For custom operations on an tvfs-file.\n*/\nstatic int tvfsFileControl(sqlite3_file *pFile, int op, void *pArg){\n  TestvfsFd *pFd = tvfsGetFd(pFile);\n  Testvfs *p = (Testvfs *)pFd->pVfs->pAppData;\n  if( op==SQLITE_FCNTL_PRAGMA ){\n    char **argv = (char**)pArg;\n    if( sqlite3_stricmp(argv[1],\"error\")==0 ){\n      int rc = SQLITE_ERROR;\n      if( argv[2] ){\n        const char *z = argv[2];\n        int x = atoi(z);\n        if( x ){\n          rc = x;\n          while( sqlite3Isdigit(z[0]) ){ z++; }\n          while( sqlite3Isspace(z[0]) ){ z++; }\n        }\n        if( z[0] ) argv[0] = sqlite3_mprintf(\"%s\", z);\n      }\n      return rc;\n    }\n    if( sqlite3_stricmp(argv[1], \"filename\")==0 ){\n      argv[0] = sqlite3_mprintf(\"%s\", pFd->zFilename);\n      return SQLITE_OK;\n    }\n  }\n  if( p->pScript && (p->mask&TESTVFS_FCNTL_MASK) ){\n    struct Fcntl {\n      int iFnctl;\n      const char *zFnctl;\n    } aF[] = {\n      { SQLITE_FCNTL_BEGIN_ATOMIC_WRITE, \"BEGIN_ATOMIC_WRITE\" },\n      { SQLITE_FCNTL_COMMIT_ATOMIC_WRITE, \"COMMIT_ATOMIC_WRITE\" },\n      { SQLITE_FCNTL_ZIPVFS, \"ZIPVFS\" },\n    };\n    int i;\n    for(i=0; i<sizeof(aF)/sizeof(aF[0]); i++){\n      if( op==aF[i].iFnctl ) break;\n    }\n    if( i<sizeof(aF)/sizeof(aF[0]) ){\n      int rc = 0;\n      tvfsExecTcl(p, \"xFileControl\", \n          Tcl_NewStringObj(pFd->zFilename, -1), \n          Tcl_NewStringObj(aF[i].zFnctl, -1),\n          0, 0\n      );\n      tvfsResultCode(p, &rc);\n      if( rc ) return (rc<0 ? SQLITE_OK : rc);\n    }\n  }\n  return sqlite3OsFileControl(pFd->pReal, op, pArg);\n}\n\n/*\n** Return the sector-size in bytes for an tvfs-file.\n*/\nstatic int tvfsSectorSize(sqlite3_file *pFile){\n  TestvfsFd *pFd = tvfsGetFd(pFile);\n  Testvfs *p = (Testvfs *)pFd->pVfs->pAppData;\n  if( p->iSectorsize>=0 ){\n    return p->iSectorsize;\n  }\n  return sqlite3OsSectorSize(pFd->pReal);\n}\n\n/*\n** Return the device characteristic flags supported by an tvfs-file.\n*/\nstatic int tvfsDeviceCharacteristics(sqlite3_file *pFile){\n  TestvfsFd *pFd = tvfsGetFd(pFile);\n  Testvfs *p = (Testvfs *)pFd->pVfs->pAppData;\n  if( p->iDevchar>=0 ){\n    return p->iDevchar;\n  }\n  return sqlite3OsDeviceCharacteristics(pFd->pReal);\n}\n\n/*\n** Open an tvfs file handle.\n*/\nstatic int tvfsOpen(\n  sqlite3_vfs *pVfs,\n  const char *zName,\n  sqlite3_file *pFile,\n  int flags,\n  int *pOutFlags\n){\n  int rc;\n  TestvfsFile *pTestfile = (TestvfsFile *)pFile;\n  TestvfsFd *pFd;\n  Tcl_Obj *pId = 0;\n  Testvfs *p = (Testvfs *)pVfs->pAppData;\n\n  pFd = (TestvfsFd *)ckalloc(sizeof(TestvfsFd) + PARENTVFS(pVfs)->szOsFile);\n  memset(pFd, 0, sizeof(TestvfsFd) + PARENTVFS(pVfs)->szOsFile);\n  pFd->pShm = 0;\n  pFd->pShmId = 0;\n  pFd->zFilename = zName;\n  pFd->pVfs = pVfs;\n  pFd->pReal = (sqlite3_file *)&pFd[1];\n  memset(pTestfile, 0, sizeof(TestvfsFile));\n  pTestfile->pFd = pFd;\n\n  /* Evaluate the Tcl script: \n  **\n  **   SCRIPT xOpen FILENAME KEY-VALUE-ARGS\n  **\n  ** If the script returns an SQLite error code other than SQLITE_OK, an\n  ** error is returned to the caller. If it returns SQLITE_OK, the new\n  ** connection is named \"anon\". Otherwise, the value returned by the\n  ** script is used as the connection name.\n  */\n  Tcl_ResetResult(p->interp);\n  if( p->pScript && p->mask&TESTVFS_OPEN_MASK ){\n    Tcl_Obj *pArg = Tcl_NewObj();\n    Tcl_IncrRefCount(pArg);\n    if( flags&SQLITE_OPEN_MAIN_DB ){\n      const char *z = &zName[strlen(zName)+1];\n      while( *z ){\n        Tcl_ListObjAppendElement(0, pArg, Tcl_NewStringObj(z, -1));\n        z += strlen(z) + 1;\n        Tcl_ListObjAppendElement(0, pArg, Tcl_NewStringObj(z, -1));\n        z += strlen(z) + 1;\n      }\n    }\n    tvfsExecTcl(p, \"xOpen\", Tcl_NewStringObj(pFd->zFilename, -1), pArg, 0, 0);\n    Tcl_DecrRefCount(pArg);\n    if( tvfsResultCode(p, &rc) ){\n      if( rc!=SQLITE_OK ) return rc;\n    }else{\n      pId = Tcl_GetObjResult(p->interp);\n    }\n  }\n\n  if( (p->mask&TESTVFS_OPEN_MASK) &&  tvfsInjectIoerr(p) ) return SQLITE_IOERR;\n  if( tvfsInjectCantopenerr(p) ) return SQLITE_CANTOPEN;\n  if( tvfsInjectFullerr(p) ) return SQLITE_FULL;\n\n  if( !pId ){\n    pId = Tcl_NewStringObj(\"anon\", -1);\n  }\n  Tcl_IncrRefCount(pId);\n  pFd->pShmId = pId;\n  Tcl_ResetResult(p->interp);\n\n  rc = sqlite3OsOpen(PARENTVFS(pVfs), zName, pFd->pReal, flags, pOutFlags);\n  if( pFd->pReal->pMethods ){\n    sqlite3_io_methods *pMethods;\n    int nByte;\n\n    if( pVfs->iVersion>1 ){\n      nByte = sizeof(sqlite3_io_methods);\n    }else{\n      nByte = offsetof(sqlite3_io_methods, xShmMap);\n    }\n\n    pMethods = (sqlite3_io_methods *)ckalloc(nByte);\n    memcpy(pMethods, &tvfs_io_methods, nByte);\n    pMethods->iVersion = pFd->pReal->pMethods->iVersion;\n    if( pMethods->iVersion>pVfs->iVersion ){\n      pMethods->iVersion = pVfs->iVersion;\n    }\n    if( pVfs->iVersion>1 && ((Testvfs *)pVfs->pAppData)->isNoshm ){\n      pMethods->xShmUnmap = 0;\n      pMethods->xShmLock = 0;\n      pMethods->xShmBarrier = 0;\n      pMethods->xShmMap = 0;\n    }\n    pFile->pMethods = pMethods;\n  }\n\n  return rc;\n}\n\n/*\n** Delete the file located at zPath. If the dirSync argument is true,\n** ensure the file-system modifications are synced to disk before\n** returning.\n*/\nstatic int tvfsDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){\n  int rc = SQLITE_OK;\n  Testvfs *p = (Testvfs *)pVfs->pAppData;\n\n  if( p->pScript && p->mask&TESTVFS_DELETE_MASK ){\n    tvfsExecTcl(p, \"xDelete\", \n        Tcl_NewStringObj(zPath, -1), Tcl_NewIntObj(dirSync), 0, 0\n    );\n    tvfsResultCode(p, &rc);\n  }\n  if( rc==SQLITE_OK ){\n    rc = sqlite3OsDelete(PARENTVFS(pVfs), zPath, dirSync);\n  }\n  return rc;\n}\n\n/*\n** Test for access permissions. Return true if the requested permission\n** is available, or false otherwise.\n*/\nstatic int tvfsAccess(\n  sqlite3_vfs *pVfs, \n  const char *zPath, \n  int flags, \n  int *pResOut\n){\n  Testvfs *p = (Testvfs *)pVfs->pAppData;\n  if( p->pScript && p->mask&TESTVFS_ACCESS_MASK ){\n    int rc;\n    char *zArg = 0;\n    if( flags==SQLITE_ACCESS_EXISTS ) zArg = \"SQLITE_ACCESS_EXISTS\";\n    if( flags==SQLITE_ACCESS_READWRITE ) zArg = \"SQLITE_ACCESS_READWRITE\";\n    if( flags==SQLITE_ACCESS_READ ) zArg = \"SQLITE_ACCESS_READ\";\n    tvfsExecTcl(p, \"xAccess\", \n        Tcl_NewStringObj(zPath, -1), Tcl_NewStringObj(zArg, -1), 0, 0\n    );\n    if( tvfsResultCode(p, &rc) ){\n      if( rc!=SQLITE_OK ) return rc;\n    }else{\n      Tcl_Interp *interp = p->interp;\n      if( TCL_OK==Tcl_GetBooleanFromObj(0, Tcl_GetObjResult(interp), pResOut) ){\n        return SQLITE_OK;\n      }\n    }\n  }\n  return sqlite3OsAccess(PARENTVFS(pVfs), zPath, flags, pResOut);\n}\n\n/*\n** Populate buffer zOut with the full canonical pathname corresponding\n** to the pathname in zPath. zOut is guaranteed to point to a buffer\n** of at least (DEVSYM_MAX_PATHNAME+1) bytes.\n*/\nstatic int tvfsFullPathname(\n  sqlite3_vfs *pVfs, \n  const char *zPath, \n  int nOut, \n  char *zOut\n){\n  Testvfs *p = (Testvfs *)pVfs->pAppData;\n  if( p->pScript && p->mask&TESTVFS_FULLPATHNAME_MASK ){\n    int rc;\n    tvfsExecTcl(p, \"xFullPathname\", Tcl_NewStringObj(zPath, -1), 0, 0, 0);\n    if( tvfsResultCode(p, &rc) ){\n      if( rc!=SQLITE_OK ) return rc;\n    }\n  }\n  return sqlite3OsFullPathname(PARENTVFS(pVfs), zPath, nOut, zOut);\n}\n\n#ifndef SQLITE_OMIT_LOAD_EXTENSION\n/*\n** Open the dynamic library located at zPath and return a handle.\n*/\nstatic void *tvfsDlOpen(sqlite3_vfs *pVfs, const char *zPath){\n  return sqlite3OsDlOpen(PARENTVFS(pVfs), zPath);\n}\n\n/*\n** Populate the buffer zErrMsg (size nByte bytes) with a human readable\n** utf-8 string describing the most recent error encountered associated \n** with dynamic libraries.\n*/\nstatic void tvfsDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){\n  sqlite3OsDlError(PARENTVFS(pVfs), nByte, zErrMsg);\n}\n\n/*\n** Return a pointer to the symbol zSymbol in the dynamic library pHandle.\n*/\nstatic void (*tvfsDlSym(sqlite3_vfs *pVfs, void *p, const char *zSym))(void){\n  return sqlite3OsDlSym(PARENTVFS(pVfs), p, zSym);\n}\n\n/*\n** Close the dynamic library handle pHandle.\n*/\nstatic void tvfsDlClose(sqlite3_vfs *pVfs, void *pHandle){\n  sqlite3OsDlClose(PARENTVFS(pVfs), pHandle);\n}\n#endif /* SQLITE_OMIT_LOAD_EXTENSION */\n\n/*\n** Populate the buffer pointed to by zBufOut with nByte bytes of \n** random data.\n*/\nstatic int tvfsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){\n  return sqlite3OsRandomness(PARENTVFS(pVfs), nByte, zBufOut);\n}\n\n/*\n** Sleep for nMicro microseconds. Return the number of microseconds \n** actually slept.\n*/\nstatic int tvfsSleep(sqlite3_vfs *pVfs, int nMicro){\n  Testvfs *p = (Testvfs *)pVfs->pAppData;\n  if( p->pScript && (p->mask&TESTVFS_SLEEP_MASK) ){\n    tvfsExecTcl(p, \"xSleep\", Tcl_NewIntObj(nMicro), 0, 0, 0);\n  }\n  return sqlite3OsSleep(PARENTVFS(pVfs), nMicro);\n}\n\n/*\n** Return the current time as a Julian Day number in *pTimeOut.\n*/\nstatic int tvfsCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){\n  return PARENTVFS(pVfs)->xCurrentTime(PARENTVFS(pVfs), pTimeOut);\n}\n\nstatic int tvfsShmOpen(sqlite3_file *pFile){\n  Testvfs *p;\n  int rc = SQLITE_OK;             /* Return code */\n  TestvfsBuffer *pBuffer;         /* Buffer to open connection to */\n  TestvfsFd *pFd;                 /* The testvfs file structure */\n\n  pFd = tvfsGetFd(pFile);\n  p = (Testvfs *)pFd->pVfs->pAppData;\n  assert( 0==p->isFullshm );\n  assert( pFd->pShmId && pFd->pShm==0 && pFd->pNext==0 );\n\n  /* Evaluate the Tcl script: \n  **\n  **   SCRIPT xShmOpen FILENAME\n  */\n  Tcl_ResetResult(p->interp);\n  if( p->pScript && p->mask&TESTVFS_SHMOPEN_MASK ){\n    tvfsExecTcl(p, \"xShmOpen\", Tcl_NewStringObj(pFd->zFilename, -1), 0, 0, 0);\n    if( tvfsResultCode(p, &rc) ){\n      if( rc!=SQLITE_OK ) return rc;\n    }\n  }\n\n  assert( rc==SQLITE_OK );\n  if( p->mask&TESTVFS_SHMOPEN_MASK && tvfsInjectIoerr(p) ){\n    return SQLITE_IOERR;\n  }\n\n  /* Search for a TestvfsBuffer. Create a new one if required. */\n  for(pBuffer=p->pBuffer; pBuffer; pBuffer=pBuffer->pNext){\n    if( 0==strcmp(pFd->zFilename, pBuffer->zFile) ) break;\n  }\n  if( !pBuffer ){\n    int szName = (int)strlen(pFd->zFilename);\n    int nByte = sizeof(TestvfsBuffer) + szName + 1;\n    pBuffer = (TestvfsBuffer *)ckalloc(nByte);\n    memset(pBuffer, 0, nByte);\n    pBuffer->zFile = (char *)&pBuffer[1];\n    memcpy(pBuffer->zFile, pFd->zFilename, szName+1);\n    pBuffer->pNext = p->pBuffer;\n    p->pBuffer = pBuffer;\n  }\n\n  /* Connect the TestvfsBuffer to the new TestvfsShm handle and return. */\n  pFd->pNext = pBuffer->pFile;\n  pBuffer->pFile = pFd;\n  pFd->pShm = pBuffer;\n  return rc;\n}\n\nstatic void tvfsAllocPage(TestvfsBuffer *p, int iPage, int pgsz){\n  assert( iPage<TESTVFS_MAX_PAGES );\n  if( p->aPage[iPage]==0 ){\n    p->aPage[iPage] = (u8 *)ckalloc(pgsz);\n    memset(p->aPage[iPage], 0, pgsz);\n    p->pgsz = pgsz;\n  }\n}\n\nstatic int tvfsShmMap(\n  sqlite3_file *pFile,            /* Handle open on database file */\n  int iPage,                      /* Page to retrieve */\n  int pgsz,                       /* Size of pages */\n  int isWrite,                    /* True to extend file if necessary */\n  void volatile **pp              /* OUT: Mapped memory */\n){\n  int rc = SQLITE_OK;\n  TestvfsFd *pFd = tvfsGetFd(pFile);\n  Testvfs *p = (Testvfs *)(pFd->pVfs->pAppData);\n\n  if( p->isFullshm ){\n    sqlite3_file *pReal = pFd->pReal;\n    return pReal->pMethods->xShmMap(pReal, iPage, pgsz, isWrite, pp);\n  }\n\n  if( 0==pFd->pShm ){\n    rc = tvfsShmOpen(pFile);\n    if( rc!=SQLITE_OK ){\n      return rc;\n    }\n  }\n\n  if( p->pScript && p->mask&TESTVFS_SHMMAP_MASK ){\n    Tcl_Obj *pArg = Tcl_NewObj();\n    Tcl_IncrRefCount(pArg);\n    Tcl_ListObjAppendElement(p->interp, pArg, Tcl_NewIntObj(iPage));\n    Tcl_ListObjAppendElement(p->interp, pArg, Tcl_NewIntObj(pgsz));\n    Tcl_ListObjAppendElement(p->interp, pArg, Tcl_NewIntObj(isWrite));\n    tvfsExecTcl(p, \"xShmMap\", \n        Tcl_NewStringObj(pFd->pShm->zFile, -1), pFd->pShmId, pArg, 0\n    );\n    tvfsResultCode(p, &rc);\n    Tcl_DecrRefCount(pArg);\n  }\n  if( rc==SQLITE_OK && p->mask&TESTVFS_SHMMAP_MASK && tvfsInjectIoerr(p) ){\n    rc = SQLITE_IOERR;\n  }\n\n  if( rc==SQLITE_OK && isWrite && !pFd->pShm->aPage[iPage] ){\n    tvfsAllocPage(pFd->pShm, iPage, pgsz);\n  }\n  if( rc==SQLITE_OK || rc==SQLITE_READONLY ){\n    *pp = (void volatile *)pFd->pShm->aPage[iPage];\n  }\n\n  return rc;\n}\n\n\nstatic int tvfsShmLock(\n  sqlite3_file *pFile,\n  int ofst,\n  int n,\n  int flags\n){\n  int rc = SQLITE_OK;\n  TestvfsFd *pFd = tvfsGetFd(pFile);\n  Testvfs *p = (Testvfs *)(pFd->pVfs->pAppData);\n  int nLock;\n  char zLock[80];\n\n  if( p->isFullshm ){\n    sqlite3_file *pReal = pFd->pReal;\n    return pReal->pMethods->xShmLock(pReal, ofst, n, flags);\n  }\n\n  if( p->pScript && p->mask&TESTVFS_SHMLOCK_MASK ){\n    sqlite3_snprintf(sizeof(zLock), zLock, \"%d %d\", ofst, n);\n    nLock = (int)strlen(zLock);\n    if( flags & SQLITE_SHM_LOCK ){\n      strcpy(&zLock[nLock], \" lock\");\n    }else{\n      strcpy(&zLock[nLock], \" unlock\");\n    }\n    nLock += (int)strlen(&zLock[nLock]);\n    if( flags & SQLITE_SHM_SHARED ){\n      strcpy(&zLock[nLock], \" shared\");\n    }else{\n      strcpy(&zLock[nLock], \" exclusive\");\n    }\n    tvfsExecTcl(p, \"xShmLock\", \n        Tcl_NewStringObj(pFd->pShm->zFile, -1), pFd->pShmId,\n        Tcl_NewStringObj(zLock, -1), 0\n    );\n    tvfsResultCode(p, &rc);\n  }\n\n  if( rc==SQLITE_OK && p->mask&TESTVFS_SHMLOCK_MASK && tvfsInjectIoerr(p) ){\n    rc = SQLITE_IOERR;\n  }\n\n  if( rc==SQLITE_OK ){\n    int isLock = (flags & SQLITE_SHM_LOCK);\n    int isExcl = (flags & SQLITE_SHM_EXCLUSIVE);\n    u32 mask = (((1<<n)-1) << ofst);\n    if( isLock ){\n      TestvfsFd *p2;\n      for(p2=pFd->pShm->pFile; p2; p2=p2->pNext){\n        if( p2==pFd ) continue;\n        if( (p2->excllock&mask) || (isExcl && p2->sharedlock&mask) ){\n          rc = SQLITE_BUSY;\n          break;\n        }\n      }\n      if( rc==SQLITE_OK ){\n        if( isExcl )  pFd->excllock |= mask;\n        if( !isExcl ) pFd->sharedlock |= mask;\n      }\n    }else{\n      if( isExcl )  pFd->excllock &= (~mask);\n      if( !isExcl ) pFd->sharedlock &= (~mask);\n    }\n  }\n\n  return rc;\n}\n\nstatic void tvfsShmBarrier(sqlite3_file *pFile){\n  TestvfsFd *pFd = tvfsGetFd(pFile);\n  Testvfs *p = (Testvfs *)(pFd->pVfs->pAppData);\n\n  if( p->pScript && p->mask&TESTVFS_SHMBARRIER_MASK ){\n    const char *z = pFd->pShm ? pFd->pShm->zFile : \"\";\n    tvfsExecTcl(p, \"xShmBarrier\", Tcl_NewStringObj(z, -1), pFd->pShmId, 0, 0);\n  }\n\n  if( p->isFullshm ){\n    sqlite3_file *pReal = pFd->pReal;\n    pReal->pMethods->xShmBarrier(pReal);\n    return;\n  }\n}\n\nstatic int tvfsShmUnmap(\n  sqlite3_file *pFile,\n  int deleteFlag\n){\n  int rc = SQLITE_OK;\n  TestvfsFd *pFd = tvfsGetFd(pFile);\n  Testvfs *p = (Testvfs *)(pFd->pVfs->pAppData);\n  TestvfsBuffer *pBuffer = pFd->pShm;\n  TestvfsFd **ppFd;\n\n  if( p->isFullshm ){\n    sqlite3_file *pReal = pFd->pReal;\n    return pReal->pMethods->xShmUnmap(pReal, deleteFlag);\n  }\n\n  if( !pBuffer ) return SQLITE_OK;\n  assert( pFd->pShmId && pFd->pShm );\n\n  if( p->pScript && p->mask&TESTVFS_SHMCLOSE_MASK ){\n    tvfsExecTcl(p, \"xShmUnmap\", \n        Tcl_NewStringObj(pFd->pShm->zFile, -1), pFd->pShmId, 0, 0\n    );\n    tvfsResultCode(p, &rc);\n  }\n\n  for(ppFd=&pBuffer->pFile; *ppFd!=pFd; ppFd=&((*ppFd)->pNext));\n  assert( (*ppFd)==pFd );\n  *ppFd = pFd->pNext;\n  pFd->pNext = 0;\n\n  if( pBuffer->pFile==0 ){\n    int i;\n    TestvfsBuffer **pp;\n    for(pp=&p->pBuffer; *pp!=pBuffer; pp=&((*pp)->pNext));\n    *pp = (*pp)->pNext;\n    for(i=0; pBuffer->aPage[i]; i++){\n      ckfree((char *)pBuffer->aPage[i]);\n    }\n    ckfree((char *)pBuffer);\n  }\n  pFd->pShm = 0;\n\n  return rc;\n}\n\nstatic int tvfsFetch(\n    sqlite3_file *pFile, \n    sqlite3_int64 iOfst, \n    int iAmt, \n    void **pp\n){\n  TestvfsFd *pFd = tvfsGetFd(pFile);\n  return sqlite3OsFetch(pFd->pReal, iOfst, iAmt, pp);\n}\n\nstatic int tvfsUnfetch(sqlite3_file *pFile, sqlite3_int64 iOfst, void *p){\n  TestvfsFd *pFd = tvfsGetFd(pFile);\n  return sqlite3OsUnfetch(pFd->pReal, iOfst, p);\n}\n\nstatic int SQLITE_TCLAPI testvfs_obj_cmd(\n  ClientData cd,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  Testvfs *p = (Testvfs *)cd;\n\n  enum DB_enum { \n    CMD_SHM, CMD_DELETE, CMD_FILTER, CMD_IOERR, CMD_SCRIPT, \n    CMD_DEVCHAR, CMD_SECTORSIZE, CMD_FULLERR, CMD_CANTOPENERR\n  };\n  struct TestvfsSubcmd {\n    char *zName;\n    enum DB_enum eCmd;\n  } aSubcmd[] = {\n    { \"shm\",         CMD_SHM         },\n    { \"delete\",      CMD_DELETE      },\n    { \"filter\",      CMD_FILTER      },\n    { \"ioerr\",       CMD_IOERR       },\n    { \"fullerr\",     CMD_FULLERR     },\n    { \"cantopenerr\", CMD_CANTOPENERR },\n    { \"script\",      CMD_SCRIPT      },\n    { \"devchar\",     CMD_DEVCHAR     },\n    { \"sectorsize\",  CMD_SECTORSIZE  },\n    { 0, 0 }\n  };\n  int i;\n  \n  if( objc<2 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"SUBCOMMAND ...\");\n    return TCL_ERROR;\n  }\n  if( Tcl_GetIndexFromObjStruct(\n        interp, objv[1], aSubcmd, sizeof(aSubcmd[0]), \"subcommand\", 0, &i) \n  ){\n    return TCL_ERROR;\n  }\n  Tcl_ResetResult(interp);\n\n  switch( aSubcmd[i].eCmd ){\n    case CMD_SHM: {\n      Tcl_Obj *pObj;\n      int rc;\n      TestvfsBuffer *pBuffer;\n      char *zName;\n      if( objc!=3 && objc!=4 ){\n        Tcl_WrongNumArgs(interp, 2, objv, \"FILE ?VALUE?\");\n        return TCL_ERROR;\n      }\n      zName = ckalloc(p->pParent->mxPathname);\n      rc = p->pParent->xFullPathname(\n          p->pParent, Tcl_GetString(objv[2]), \n          p->pParent->mxPathname, zName\n      );\n      if( rc!=SQLITE_OK ){\n        Tcl_AppendResult(interp, \"failed to get full path: \",\n                         Tcl_GetString(objv[2]), NULL);\n        ckfree(zName);\n        return TCL_ERROR;\n      }\n      for(pBuffer=p->pBuffer; pBuffer; pBuffer=pBuffer->pNext){\n        if( 0==strcmp(pBuffer->zFile, zName) ) break;\n      }\n      ckfree(zName);\n      if( !pBuffer ){\n        Tcl_AppendResult(interp, \"no such file: \", Tcl_GetString(objv[2]), NULL);\n        return TCL_ERROR;\n      }\n      if( objc==4 ){\n        Tcl_Size n;\n        u8 *a = Tcl_GetByteArrayFromObj(objv[3], &n);\n        int pgsz = pBuffer->pgsz;\n        if( pgsz==0 ) pgsz = 65536;\n        for(i=0; i*pgsz<(int)n; i++){\n          int nByte = pgsz;\n          tvfsAllocPage(pBuffer, i, pgsz);\n          if( n-i*pgsz<pgsz ){\n            nByte = (int)n;\n          }\n          memcpy(pBuffer->aPage[i], &a[i*pgsz], nByte);\n        }\n      }\n\n      pObj = Tcl_NewObj();\n      for(i=0; pBuffer->aPage[i]; i++){\n        int pgsz = pBuffer->pgsz;\n        if( pgsz==0 ) pgsz = 65536;\n        Tcl_AppendObjToObj(pObj, Tcl_NewByteArrayObj(pBuffer->aPage[i], pgsz));\n      }\n      Tcl_SetObjResult(interp, pObj);\n      break;\n    }\n\n    /*  TESTVFS filter METHOD-LIST\n    **\n    **     Activate special processing for those methods contained in the list\n    */\n    case CMD_FILTER: {\n      static struct VfsMethod {\n        char *zName;\n        int mask;\n      } vfsmethod [] = {\n        { \"xShmOpen\",           TESTVFS_SHMOPEN_MASK },\n        { \"xShmLock\",           TESTVFS_SHMLOCK_MASK },\n        { \"xShmBarrier\",        TESTVFS_SHMBARRIER_MASK },\n        { \"xShmUnmap\",          TESTVFS_SHMCLOSE_MASK },\n        { \"xShmMap\",            TESTVFS_SHMMAP_MASK },\n        { \"xSync\",              TESTVFS_SYNC_MASK },\n        { \"xDelete\",            TESTVFS_DELETE_MASK },\n        { \"xWrite\",             TESTVFS_WRITE_MASK },\n        { \"xRead\",              TESTVFS_READ_MASK },\n        { \"xTruncate\",          TESTVFS_TRUNCATE_MASK },\n        { \"xOpen\",              TESTVFS_OPEN_MASK },\n        { \"xClose\",             TESTVFS_CLOSE_MASK },\n        { \"xAccess\",            TESTVFS_ACCESS_MASK },\n        { \"xFullPathname\",      TESTVFS_FULLPATHNAME_MASK },\n        { \"xUnlock\",            TESTVFS_UNLOCK_MASK },\n        { \"xLock\",              TESTVFS_LOCK_MASK },\n        { \"xCheckReservedLock\", TESTVFS_CKLOCK_MASK },\n        { \"xFileControl\",       TESTVFS_FCNTL_MASK },\n        { \"xSleep\",             TESTVFS_SLEEP_MASK },\n      };\n      Tcl_Obj **apElem = 0;\n      Tcl_Size nElem = 0;\n      int mask = 0;\n      if( objc!=3 ){\n        Tcl_WrongNumArgs(interp, 2, objv, \"LIST\");\n        return TCL_ERROR;\n      }\n      if( Tcl_ListObjGetElements(interp, objv[2], &nElem, &apElem) ){\n        return TCL_ERROR;\n      }\n      Tcl_ResetResult(interp);\n      for(i=0; i<(int)nElem; i++){\n        int iMethod;\n        char *zElem = Tcl_GetString(apElem[i]);\n        for(iMethod=0; iMethod<ArraySize(vfsmethod); iMethod++){\n          if( strcmp(zElem, vfsmethod[iMethod].zName)==0 ){\n            mask |= vfsmethod[iMethod].mask;\n            break;\n          }\n        }\n        if( iMethod==ArraySize(vfsmethod) ){\n          Tcl_AppendResult(interp, \"unknown method: \", zElem, NULL);\n          return TCL_ERROR;\n        }\n      }\n      p->mask = mask;\n      break;\n    }\n\n    /*\n    **  TESTVFS script ?SCRIPT?\n    **\n    **  Query or set the script to be run when filtered VFS events\n    **  occur.\n    */\n    case CMD_SCRIPT: {\n      if( objc==3 ){\n        Tcl_Size nByte;\n        if( p->pScript ){\n          Tcl_DecrRefCount(p->pScript);\n          p->pScript = 0;\n        }\n        Tcl_GetStringFromObj(objv[2], &nByte);\n        if( nByte>0 ){\n          p->pScript = Tcl_DuplicateObj(objv[2]);\n          Tcl_IncrRefCount(p->pScript);\n        }\n      }else if( objc!=2 ){\n        Tcl_WrongNumArgs(interp, 2, objv, \"?SCRIPT?\");\n        return TCL_ERROR;\n      }\n\n      Tcl_ResetResult(interp);\n      if( p->pScript ) Tcl_SetObjResult(interp, p->pScript);\n\n      break;\n    }\n\n    /*\n    ** TESTVFS ioerr ?IFAIL PERSIST?\n    **\n    **   Where IFAIL is an integer and PERSIST is boolean.\n    */\n    case CMD_CANTOPENERR:\n    case CMD_IOERR:\n    case CMD_FULLERR: {\n      TestFaultInject *pTest = 0;\n      int iRet;\n\n      switch( aSubcmd[i].eCmd ){\n        case CMD_IOERR: pTest = &p->ioerr_err; break;\n        case CMD_FULLERR: pTest = &p->full_err; break;\n        case CMD_CANTOPENERR: pTest = &p->cantopen_err; break;\n        default: assert(0);\n      }\n      iRet = pTest->nFail;\n      pTest->nFail = 0;\n      pTest->eFault = 0;\n      pTest->iCnt = 0;\n\n      if( objc==4 ){\n        int iCnt, iPersist;\n        if( TCL_OK!=Tcl_GetIntFromObj(interp, objv[2], &iCnt)\n         || TCL_OK!=Tcl_GetBooleanFromObj(interp, objv[3], &iPersist)\n        ){\n          return TCL_ERROR;\n        }\n        pTest->eFault = iPersist?FAULT_INJECT_PERSISTENT:FAULT_INJECT_TRANSIENT;\n        pTest->iCnt = iCnt;\n      }else if( objc!=2 ){\n        Tcl_WrongNumArgs(interp, 2, objv, \"?CNT PERSIST?\");\n        return TCL_ERROR;\n      }\n      Tcl_SetObjResult(interp, Tcl_NewIntObj(iRet));\n      break;\n    }\n\n    case CMD_DELETE: {\n      Tcl_DeleteCommand(interp, Tcl_GetString(objv[0]));\n      break;\n    }\n\n    case CMD_DEVCHAR: {\n      struct DeviceFlag {\n        char *zName;\n        int iValue;\n      } aFlag[] = {\n        { \"default\",               -1 },\n        { \"atomic\",                SQLITE_IOCAP_ATOMIC                },\n        { \"atomic512\",             SQLITE_IOCAP_ATOMIC512             },\n        { \"atomic1k\",              SQLITE_IOCAP_ATOMIC1K              },\n        { \"atomic2k\",              SQLITE_IOCAP_ATOMIC2K              },\n        { \"atomic4k\",              SQLITE_IOCAP_ATOMIC4K              },\n        { \"atomic8k\",              SQLITE_IOCAP_ATOMIC8K              },\n        { \"atomic16k\",             SQLITE_IOCAP_ATOMIC16K             },\n        { \"atomic32k\",             SQLITE_IOCAP_ATOMIC32K             },\n        { \"atomic64k\",             SQLITE_IOCAP_ATOMIC64K             },\n        { \"sequential\",            SQLITE_IOCAP_SEQUENTIAL            },\n        { \"safe_append\",           SQLITE_IOCAP_SAFE_APPEND           },\n        { \"undeletable_when_open\", SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN },\n        { \"powersafe_overwrite\",   SQLITE_IOCAP_POWERSAFE_OVERWRITE   },\n        { \"immutable\",             SQLITE_IOCAP_IMMUTABLE             },\n        { 0, 0 }\n      };\n      Tcl_Obj *pRet;\n      int iFlag;\n\n      if( objc>3 ){\n        Tcl_WrongNumArgs(interp, 2, objv, \"?ATTR-LIST?\");\n        return TCL_ERROR;\n      }\n      if( objc==3 ){\n        int j;\n        int iNew = 0;\n        Tcl_Obj **flags = 0;\n        Tcl_Size nFlags = 0;\n\n        if( Tcl_ListObjGetElements(interp, objv[2], &nFlags, &flags) ){\n          return TCL_ERROR;\n        }\n\n        for(j=0; j<(int)nFlags; j++){\n          int idx = 0;\n          if( Tcl_GetIndexFromObjStruct(interp, flags[j], aFlag, \n                sizeof(aFlag[0]), \"flag\", 0, &idx) \n          ){\n            return TCL_ERROR;\n          }\n          if( aFlag[idx].iValue<0 && nFlags>1 ){\n            Tcl_AppendResult(interp, \"bad flags: \", Tcl_GetString(objv[2]), NULL);\n            return TCL_ERROR;\n          }\n          iNew |= aFlag[idx].iValue;\n        }\n\n        p->iDevchar = iNew| 0x10000000;\n      }\n\n      pRet = Tcl_NewObj();\n      for(iFlag=0; iFlag<sizeof(aFlag)/sizeof(aFlag[0]); iFlag++){\n        if( p->iDevchar & aFlag[iFlag].iValue ){\n          Tcl_ListObjAppendElement(\n              interp, pRet, Tcl_NewStringObj(aFlag[iFlag].zName, -1)\n          );\n        }\n      }\n      Tcl_SetObjResult(interp, pRet);\n\n      break;\n    }\n\n    case CMD_SECTORSIZE: {\n      if( objc>3 ){\n        Tcl_WrongNumArgs(interp, 2, objv, \"?VALUE?\");\n        return TCL_ERROR;\n      }\n      if( objc==3 ){\n        int iNew = 0;\n        if( Tcl_GetIntFromObj(interp, objv[2], &iNew) ){\n          return TCL_ERROR;\n        }\n        p->iSectorsize = iNew;\n      }\n      Tcl_SetObjResult(interp, Tcl_NewIntObj(p->iSectorsize));\n      break;\n    }\n  }\n\n  return TCL_OK;\n}\n\nstatic void SQLITE_TCLAPI testvfs_obj_del(ClientData cd){\n  Testvfs *p = (Testvfs *)cd;\n  if( p->pScript ) Tcl_DecrRefCount(p->pScript);\n  sqlite3_vfs_unregister(p->pVfs);\n  memset(p->pVfs, 0, sizeof(sqlite3_vfs));\n  ckfree((char *)p->pVfs);\n  memset(p, 0, sizeof(Testvfs));\n  ckfree((char *)p);\n}\n\n/*\n** Usage:  testvfs VFSNAME ?SWITCHES?\n**\n** Switches are:\n**\n**   -noshm   BOOLEAN             (True to omit shm methods. Default false)\n**   -default BOOLEAN             (True to make the vfs default. Default false)\n**\n** This command creates two things when it is invoked: an SQLite VFS, and\n** a Tcl command. Both are named VFSNAME. The VFS is installed. It is not\n** installed as the default VFS.\n**\n** The VFS passes all file I/O calls through to the underlying VFS.\n**\n** Whenever the xShmMap method of the VFS\n** is invoked, the SCRIPT is executed as follows:\n**\n**   SCRIPT xShmMap    FILENAME ID\n**\n** The value returned by the invocation of SCRIPT above is interpreted as\n** an SQLite error code and returned to SQLite. Either a symbolic \n** \"SQLITE_OK\" or numeric \"0\" value may be returned.\n**\n** The contents of the shared-memory buffer associated with a given file\n** may be read and set using the following command:\n**\n**   VFSNAME shm FILENAME ?NEWVALUE?\n**\n** When the xShmLock method is invoked by SQLite, the following script is\n** run:\n**\n**   SCRIPT xShmLock    FILENAME ID LOCK\n**\n** where LOCK is of the form \"OFFSET NBYTE lock/unlock shared/exclusive\"\n*/\nstatic int SQLITE_TCLAPI testvfs_cmd(\n  ClientData cd,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  static sqlite3_vfs tvfs_vfs = {\n    3,                            /* iVersion */\n    0,                            /* szOsFile */\n    0,                            /* mxPathname */\n    0,                            /* pNext */\n    0,                            /* zName */\n    0,                            /* pAppData */\n    tvfsOpen,                     /* xOpen */\n    tvfsDelete,                   /* xDelete */\n    tvfsAccess,                   /* xAccess */\n    tvfsFullPathname,             /* xFullPathname */\n#ifndef SQLITE_OMIT_LOAD_EXTENSION\n    tvfsDlOpen,                   /* xDlOpen */\n    tvfsDlError,                  /* xDlError */\n    tvfsDlSym,                    /* xDlSym */\n    tvfsDlClose,                  /* xDlClose */\n#else\n    0,                            /* xDlOpen */\n    0,                            /* xDlError */\n    0,                            /* xDlSym */\n    0,                            /* xDlClose */\n#endif /* SQLITE_OMIT_LOAD_EXTENSION */\n    tvfsRandomness,               /* xRandomness */\n    tvfsSleep,                    /* xSleep */\n    tvfsCurrentTime,              /* xCurrentTime */\n    0,                            /* xGetLastError */\n    0,                            /* xCurrentTimeInt64 */\n    0,                            /* xSetSystemCall */\n    0,                            /* xGetSystemCall */\n    0,                            /* xNextSystemCall */\n  };\n\n  Testvfs *p;                     /* New object */\n  sqlite3_vfs *pVfs;              /* New VFS */\n  char *zVfs;\n  int nByte;                      /* Bytes of space to allocate at p */\n\n  int i;\n  int isNoshm = 0;                /* True if -noshm is passed */\n  int isFullshm = 0;              /* True if -fullshm is passed */\n  int isDefault = 0;              /* True if -default is passed */\n  int szOsFile = 0;               /* Value passed to -szosfile */\n  int mxPathname = -1;            /* Value passed to -mxpathname */\n  int iVersion = 3;               /* Value passed to -iversion */\n\n  if( objc<2 || 0!=(objc%2) ) goto bad_args;\n  for(i=2; i<objc; i += 2){\n    Tcl_Size nSwitch;\n    char *zSwitch;\n    zSwitch = Tcl_GetStringFromObj(objv[i], &nSwitch); \n\n    if( nSwitch>2 && 0==strncmp(\"-noshm\", zSwitch, nSwitch) ){\n      if( Tcl_GetBooleanFromObj(interp, objv[i+1], &isNoshm) ){\n        return TCL_ERROR;\n      }\n      if( isNoshm ) isFullshm = 0;\n    }\n    else if( nSwitch>2 && 0==strncmp(\"-default\", zSwitch, nSwitch) ){\n      if( Tcl_GetBooleanFromObj(interp, objv[i+1], &isDefault) ){\n        return TCL_ERROR;\n      }\n    }\n    else if( nSwitch>2 && 0==strncmp(\"-szosfile\", zSwitch, nSwitch) ){\n      if( Tcl_GetIntFromObj(interp, objv[i+1], &szOsFile) ){\n        return TCL_ERROR;\n      }\n    }\n    else if( nSwitch>2 && 0==strncmp(\"-mxpathname\", zSwitch, nSwitch) ){\n      if( Tcl_GetIntFromObj(interp, objv[i+1], &mxPathname) ){\n        return TCL_ERROR;\n      }\n    }\n    else if( nSwitch>2 && 0==strncmp(\"-iversion\", zSwitch, nSwitch) ){\n      if( Tcl_GetIntFromObj(interp, objv[i+1], &iVersion) ){\n        return TCL_ERROR;\n      }\n    }\n    else if( nSwitch>2 && 0==strncmp(\"-fullshm\", zSwitch, nSwitch) ){\n      if( Tcl_GetBooleanFromObj(interp, objv[i+1], &isFullshm) ){\n        return TCL_ERROR;\n      }\n      if( isFullshm ) isNoshm = 0;\n    }\n    else{\n      goto bad_args;\n    }\n  }\n\n  if( szOsFile<sizeof(TestvfsFile) ){\n    szOsFile = sizeof(TestvfsFile);\n  }\n\n  zVfs = Tcl_GetString(objv[1]);\n  nByte = sizeof(Testvfs) + (int)strlen(zVfs)+1;\n  p = (Testvfs *)ckalloc(nByte);\n  memset(p, 0, nByte);\n  p->iDevchar = -1;\n  p->iSectorsize = -1;\n\n  /* Create the new object command before querying SQLite for a default VFS\n  ** to use for 'real' IO operations. This is because creating the new VFS\n  ** may delete an existing [testvfs] VFS of the same name. If such a VFS\n  ** is currently the default, the new [testvfs] may end up calling the \n  ** methods of a deleted object.\n  */\n  Tcl_CreateObjCommand(interp, zVfs, testvfs_obj_cmd, p, testvfs_obj_del);\n  p->pParent = sqlite3_vfs_find(0);\n  p->interp = interp;\n\n  p->zName = (char *)&p[1];\n  memcpy(p->zName, zVfs, strlen(zVfs)+1);\n\n  pVfs = (sqlite3_vfs *)ckalloc(sizeof(sqlite3_vfs));\n  memcpy(pVfs, &tvfs_vfs, sizeof(sqlite3_vfs));\n  pVfs->pAppData = (void *)p;\n  pVfs->iVersion = iVersion;\n  pVfs->zName = p->zName;\n  pVfs->mxPathname = p->pParent->mxPathname;\n  if( mxPathname>=0 && mxPathname<pVfs->mxPathname ){\n    pVfs->mxPathname = mxPathname;\n  }\n  pVfs->szOsFile = szOsFile;\n  p->pVfs = pVfs;\n  p->isNoshm = isNoshm;\n  p->isFullshm = isFullshm;\n  p->mask = TESTVFS_ALL_MASK;\n\n  sqlite3_vfs_register(pVfs, isDefault);\n\n  return TCL_OK;\n\n bad_args:\n  Tcl_WrongNumArgs(interp, 1, objv, \"VFSNAME ?-noshm BOOL? ?-fullshm BOOL? ?-default BOOL? ?-mxpathname INT? ?-szosfile INT? ?-iversion INT?\");\n  return TCL_ERROR;\n}\n\nextern int getDbPointer(Tcl_Interp *interp, const char *zA, sqlite3 **ppDb);\nextern const char *sqlite3ErrName(int);\n\n/*\n** tclcmd: vfs_shmlock DB DBNAME (shared|exclusive) (lock|unlock) OFFSET N\n*/\nstatic int SQLITE_TCLAPI test_vfs_shmlock(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  const char *azArg1[] = {\"shared\", \"exclusive\", 0};\n  const char *azArg2[] = {\"lock\", \"unlock\", 0};\n  sqlite3 *db = 0;\n  int rc = SQLITE_OK;\n  const char *zDbname = 0;\n  int iArg1 = 0;\n  int iArg2 = 0;\n  int iOffset = 0;\n  int n = 0;\n  sqlite3_file *pFd;\n\n  if( objc!=7 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \n        \"DB DBNAME (shared|exclusive) (lock|unlock) OFFSET N\"\n    );\n    return TCL_ERROR;\n  }\n\n  zDbname = Tcl_GetString(objv[2]);\n  if( getDbPointer(interp, Tcl_GetString(objv[1]), &db) \n   || Tcl_GetIndexFromObj(interp, objv[3], azArg1, \"ARG\", 0, &iArg1) \n   || Tcl_GetIndexFromObj(interp, objv[4], azArg2, \"ARG\", 0, &iArg2) \n   || Tcl_GetIntFromObj(interp, objv[5], &iOffset)\n   || Tcl_GetIntFromObj(interp, objv[6], &n)\n  ){\n    return TCL_ERROR;\n  }\n\n  sqlite3_file_control(db, zDbname, SQLITE_FCNTL_FILE_POINTER, (void*)&pFd);\n  if( pFd==0 ){\n    return TCL_ERROR;\n  }\n  rc = pFd->pMethods->xShmLock(pFd, iOffset, n, \n      (iArg1==0 ? SQLITE_SHM_SHARED : SQLITE_SHM_EXCLUSIVE)\n    | (iArg2==0 ? SQLITE_SHM_LOCK : SQLITE_SHM_UNLOCK)\n  );\n  Tcl_SetObjResult(interp, Tcl_NewStringObj(sqlite3ErrName(rc), -1));\n  return TCL_OK;\n}\n\nstatic int SQLITE_TCLAPI test_vfs_set_readmark(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  sqlite3 *db = 0;\n  int rc = SQLITE_OK;\n  const char *zDbname = 0;\n  int iSlot = 0;\n  int iVal = -1;\n  sqlite3_file *pFd;\n  void volatile *pShm = 0;\n  u32 *aShm;\n  int iOff;\n\n  if( objc!=4 && objc!=5 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"DB DBNAME SLOT ?VALUE?\");\n    return TCL_ERROR;\n  }\n\n  zDbname = Tcl_GetString(objv[2]);\n  if( getDbPointer(interp, Tcl_GetString(objv[1]), &db) \n   || Tcl_GetIntFromObj(interp, objv[3], &iSlot)\n   || (objc==5 && Tcl_GetIntFromObj(interp, objv[4], &iVal))\n  ){\n    return TCL_ERROR;\n  }\n\n  sqlite3_file_control(db, zDbname, SQLITE_FCNTL_FILE_POINTER, (void*)&pFd);\n  if( pFd==0 ){\n    return TCL_ERROR;\n  }\n  rc = pFd->pMethods->xShmMap(pFd, 0, 32*1024, 0, &pShm);\n  if( rc!=SQLITE_OK ){\n    Tcl_SetObjResult(interp, Tcl_NewStringObj(sqlite3ErrName(rc), -1));\n    return TCL_ERROR;\n  }\n  if( pShm==0 ){\n    Tcl_AppendResult(interp, \"*-shm is not yet mapped\", NULL);\n    return TCL_ERROR;\n  }\n  aShm = (u32*)pShm;\n  iOff = 12*2+1+iSlot;\n\n  if( objc==5 ){\n    aShm[iOff] = iVal;\n  }\n  Tcl_SetObjResult(interp, Tcl_NewIntObj(aShm[iOff]));\n\n  return TCL_OK;\n}\n\nint Sqlitetestvfs_Init(Tcl_Interp *interp){\n  Tcl_CreateObjCommand(interp, \"testvfs\", testvfs_cmd, 0, 0);\n  Tcl_CreateObjCommand(interp, \"vfs_shmlock\", test_vfs_shmlock, 0, 0);\n  Tcl_CreateObjCommand(interp, \"vfs_set_readmark\", test_vfs_set_readmark, 0, 0);\n  return TCL_OK;\n}\n\n#endif\n"}
{"repo": "sqlite", "file": "treeview.c", "lang": "C++", "code": "/*\n** 2015-06-08\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains C code to implement the TreeView debugging routines.\n** These routines print a parse tree to standard output for debugging and\n** analysis. \n**\n** The interfaces in this file is only available when compiling\n** with SQLITE_DEBUG.\n*/\n#include \"sqliteInt.h\"\n#ifdef SQLITE_DEBUG\n\n/*\n** Add a new subitem to the tree.  The moreToFollow flag indicates that this\n** is not the last item in the tree.\n*/\nstatic void sqlite3TreeViewPush(TreeView **pp, u8 moreToFollow){\n  TreeView *p = *pp;\n  if( p==0 ){\n    *pp = p = sqlite3_malloc64( sizeof(*p) );\n    if( p==0 ) return;\n    memset(p, 0, sizeof(*p));\n  }else{\n    p->iLevel++;\n  }\n  assert( moreToFollow==0 || moreToFollow==1 );\n  if( p->iLevel<(int)sizeof(p->bLine) ) p->bLine[p->iLevel] = moreToFollow;\n}\n\n/*\n** Finished with one layer of the tree\n*/\nstatic void sqlite3TreeViewPop(TreeView **pp){\n  TreeView *p = *pp;\n  if( p==0 ) return;\n  p->iLevel--;\n  if( p->iLevel<0 ){\n    sqlite3_free(p);\n    *pp = 0;\n  }\n}\n\n/*\n** Generate a single line of output for the tree, with a prefix that contains\n** all the appropriate tree lines\n*/\nvoid sqlite3TreeViewLine(TreeView *p, const char *zFormat, ...){\n  va_list ap;\n  int i;\n  StrAccum acc;\n  char zBuf[1000];\n  sqlite3StrAccumInit(&acc, 0, zBuf, sizeof(zBuf), 0);\n  if( p ){\n    for(i=0; i<p->iLevel && i<(int)sizeof(p->bLine)-1; i++){\n      sqlite3_str_append(&acc, p->bLine[i] ? \"|   \" : \"    \", 4);\n    }\n    sqlite3_str_append(&acc, p->bLine[i] ? \"|-- \" : \"'-- \", 4);\n  }\n  if( zFormat!=0 ){\n    va_start(ap, zFormat);\n    sqlite3_str_vappendf(&acc, zFormat, ap);\n    va_end(ap);\n    assert( acc.nChar>0 || acc.accError );\n    sqlite3_str_append(&acc, \"\\n\", 1);\n  }\n  sqlite3StrAccumFinish(&acc);\n  fprintf(stdout,\"%s\", zBuf);\n  fflush(stdout);\n}\n\n/*\n** Shorthand for starting a new tree item that consists of a single label\n*/\nstatic void sqlite3TreeViewItem(TreeView *p, const char *zLabel,u8 moreFollows){\n  sqlite3TreeViewPush(&p, moreFollows);\n  sqlite3TreeViewLine(p, \"%s\", zLabel);\n}\n\n/*\n** Show a list of Column objects in tree format.\n*/\nvoid sqlite3TreeViewColumnList(\n  TreeView *pView,\n  const Column *aCol,\n  int nCol,\n  u8 moreToFollow\n){\n  int i;\n  sqlite3TreeViewPush(&pView, moreToFollow);\n  sqlite3TreeViewLine(pView, \"COLUMNS\");\n  for(i=0; i<nCol; i++){\n    u16 flg = aCol[i].colFlags;\n    int colMoreToFollow = i<(nCol - 1);\n    sqlite3TreeViewPush(&pView, colMoreToFollow);\n    sqlite3TreeViewLine(pView, 0);\n    printf(\" %s\", aCol[i].zCnName);\n    switch( aCol[i].eCType ){\n      case COLTYPE_ANY:      printf(\" ANY\");        break;\n      case COLTYPE_BLOB:     printf(\" BLOB\");       break;\n      case COLTYPE_INT:      printf(\" INT\");        break;\n      case COLTYPE_INTEGER:  printf(\" INTEGER\");    break;\n      case COLTYPE_REAL:     printf(\" REAL\");       break;\n      case COLTYPE_TEXT:     printf(\" TEXT\");       break;\n      case COLTYPE_CUSTOM: {\n        if( flg & COLFLAG_HASTYPE ){\n          const char *z = aCol[i].zCnName;\n          z += strlen(z)+1;\n          printf(\" X-%s\", z);\n          break;\n        }\n      }\n    }\n    if( flg & COLFLAG_PRIMKEY ) printf(\" PRIMARY KEY\");\n    if( flg & COLFLAG_HIDDEN ) printf(\" HIDDEN\");\n#ifdef COLFLAG_NOEXPAND\n    if( flg & COLFLAG_NOEXPAND ) printf(\" NO-EXPAND\");\n#endif\n    if( flg ) printf(\" flags=%04x\", flg);\n    printf(\"\\n\");      \n    fflush(stdout);\n    sqlite3TreeViewPop(&pView);\n  }\n  sqlite3TreeViewPop(&pView);\n}\n\n/*\n** Generate a human-readable description of a WITH clause.\n*/\nvoid sqlite3TreeViewWith(TreeView *pView, const With *pWith, u8 moreToFollow){\n  int i;\n  if( pWith==0 ) return;\n  if( pWith->nCte==0 ) return;\n  if( pWith->pOuter ){\n    sqlite3TreeViewLine(pView, \"WITH (0x%p, pOuter=0x%p)\",pWith,pWith->pOuter);\n  }else{\n    sqlite3TreeViewLine(pView, \"WITH (0x%p)\", pWith);\n  }\n  if( pWith->nCte>0 ){\n    sqlite3TreeViewPush(&pView, moreToFollow);\n    for(i=0; i<pWith->nCte; i++){\n      StrAccum x;\n      char zLine[1000];\n      const struct Cte *pCte = &pWith->a[i];\n      sqlite3StrAccumInit(&x, 0, zLine, sizeof(zLine), 0);\n      sqlite3_str_appendf(&x, \"%s\", pCte->zName);\n      if( pCte->pCols && pCte->pCols->nExpr>0 ){\n        char cSep = '(';\n        int j;\n        for(j=0; j<pCte->pCols->nExpr; j++){\n          sqlite3_str_appendf(&x, \"%c%s\", cSep, pCte->pCols->a[j].zEName);\n          cSep = ',';\n        }\n        sqlite3_str_appendf(&x, \")\");\n      }\n      if( pCte->eM10d!=M10d_Any ){\n        sqlite3_str_appendf(&x, \" %sMATERIALIZED\", \n           pCte->eM10d==M10d_No ? \"NOT \" : \"\");\n      }\n      if( pCte->pUse ){\n        sqlite3_str_appendf(&x, \" (pUse=0x%p, nUse=%d)\", pCte->pUse,\n                 pCte->pUse->nUse);\n      }\n      sqlite3StrAccumFinish(&x);\n      sqlite3TreeViewItem(pView, zLine, i<pWith->nCte-1);\n      sqlite3TreeViewSelect(pView, pCte->pSelect, 0);\n      sqlite3TreeViewPop(&pView);\n    }\n    sqlite3TreeViewPop(&pView);\n  }\n}\n\n/*\n** Generate a human-readable description of a SrcList object.\n*/\nvoid sqlite3TreeViewSrcList(TreeView *pView, const SrcList *pSrc){\n  int i;\n  if( pSrc==0 ) return;\n  for(i=0; i<pSrc->nSrc; i++){\n    const SrcItem *pItem = &pSrc->a[i];\n    StrAccum x;\n    int n = 0;\n    char zLine[1000];\n    sqlite3StrAccumInit(&x, 0, zLine, sizeof(zLine), 0);\n    x.printfFlags |= SQLITE_PRINTF_INTERNAL;\n    sqlite3_str_appendf(&x, \"{%d:*} %!S\", pItem->iCursor, pItem);\n    if( pItem->pSTab ){\n      sqlite3_str_appendf(&x, \" tab=%Q nCol=%d ptr=%p used=%llx%s\",\n           pItem->pSTab->zName, pItem->pSTab->nCol, pItem->pSTab, \n           pItem->colUsed,\n           pItem->fg.rowidUsed ? \"+rowid\" : \"\");\n    }\n    if( (pItem->fg.jointype & (JT_LEFT|JT_RIGHT))==(JT_LEFT|JT_RIGHT) ){\n      sqlite3_str_appendf(&x, \" FULL-OUTER-JOIN\");\n    }else if( pItem->fg.jointype & JT_LEFT ){\n      sqlite3_str_appendf(&x, \" LEFT-JOIN\");\n    }else if( pItem->fg.jointype & JT_RIGHT ){\n      sqlite3_str_appendf(&x, \" RIGHT-JOIN\");\n    }else if( pItem->fg.jointype & JT_CROSS ){\n      sqlite3_str_appendf(&x, \" CROSS-JOIN\");\n    }\n    if( pItem->fg.jointype & JT_LTORJ ){\n      sqlite3_str_appendf(&x, \" LTORJ\");\n    }\n    if( pItem->fg.fromDDL ){\n      sqlite3_str_appendf(&x, \" DDL\");\n    }\n    if( pItem->fg.isCte ){\n      static const char *aMat[] = {\",MAT\", \"\", \",NO-MAT\"};\n      sqlite3_str_appendf(&x, \" CteUse=%d%s\",\n                          pItem->u2.pCteUse->nUse,\n                          aMat[pItem->u2.pCteUse->eM10d]);\n    }\n    if( pItem->fg.isOn || (pItem->fg.isUsing==0 && pItem->u3.pOn!=0) ){\n      sqlite3_str_appendf(&x, \" isOn\");\n    }\n    if( pItem->fg.isTabFunc )      sqlite3_str_appendf(&x, \" isTabFunc\");\n    if( pItem->fg.isCorrelated )   sqlite3_str_appendf(&x, \" isCorrelated\");\n    if( pItem->fg.isMaterialized ) sqlite3_str_appendf(&x, \" isMaterialized\");\n    if( pItem->fg.viaCoroutine )   sqlite3_str_appendf(&x, \" viaCoroutine\");\n    if( pItem->fg.notCte )         sqlite3_str_appendf(&x, \" notCte\");\n    if( pItem->fg.isNestedFrom )   sqlite3_str_appendf(&x, \" isNestedFrom\");\n    if( pItem->fg.fixedSchema )    sqlite3_str_appendf(&x, \" fixedSchema\");\n    if( pItem->fg.hadSchema )      sqlite3_str_appendf(&x, \" hadSchema\");\n    if( pItem->fg.isSubquery )     sqlite3_str_appendf(&x, \" isSubquery\");\n\n    sqlite3StrAccumFinish(&x);\n    sqlite3TreeViewItem(pView, zLine, i<pSrc->nSrc-1);\n    n = 0;\n    if( pItem->fg.isSubquery ) n++;\n    if( pItem->fg.isTabFunc ) n++;\n    if( pItem->fg.isUsing || pItem->u3.pOn!=0 ) n++;\n    if( pItem->fg.isUsing ){\n      sqlite3TreeViewIdList(pView, pItem->u3.pUsing, (--n)>0, \"USING\");\n    }else if( pItem->u3.pOn!=0 ){\n      sqlite3TreeViewItem(pView, \"ON\", (--n)>0);\n      sqlite3TreeViewExpr(pView, pItem->u3.pOn, 0);\n      sqlite3TreeViewPop(&pView);\n    }\n    if( pItem->fg.isSubquery ){\n      assert( n==1 );\n      if( pItem->pSTab ){\n        Table *pTab = pItem->pSTab;\n        sqlite3TreeViewColumnList(pView, pTab->aCol, pTab->nCol, 1);\n      }\n      assert( (int)pItem->fg.isNestedFrom == IsNestedFrom(pItem) );\n      sqlite3TreeViewSelect(pView, pItem->u4.pSubq->pSelect, 0);\n    }\n    if( pItem->fg.isTabFunc ){\n      sqlite3TreeViewExprList(pView, pItem->u1.pFuncArg, 0, \"func-args:\");\n    }\n    sqlite3TreeViewPop(&pView);\n  }\n}\n\n/*\n** Generate a human-readable description of a Select object.\n*/\nvoid sqlite3TreeViewSelect(TreeView *pView, const Select *p, u8 moreToFollow){\n  int n = 0;\n  int cnt = 0;\n  if( p==0 ){\n    sqlite3TreeViewLine(pView, \"nil-SELECT\");\n    return;\n  } \n  sqlite3TreeViewPush(&pView, moreToFollow);\n  if( p->pWith ){\n    sqlite3TreeViewWith(pView, p->pWith, 1);\n    cnt = 1;\n    sqlite3TreeViewPush(&pView, 1);\n  }\n  do{\n    if( p->selFlags & SF_WhereBegin ){\n      sqlite3TreeViewLine(pView, \"sqlite3WhereBegin()\");\n    }else{\n      sqlite3TreeViewLine(pView,\n        \"SELECT%s%s (%u/%p) selFlags=0x%x nSelectRow=%d\",\n        ((p->selFlags & SF_Distinct) ? \" DISTINCT\" : \"\"),\n        ((p->selFlags & SF_Aggregate) ? \" agg_flag\" : \"\"),\n        p->selId, p, p->selFlags,\n        (int)p->nSelectRow\n      );\n    }\n    if( cnt++ ) sqlite3TreeViewPop(&pView);\n    if( p->pPrior ){\n      n = 1000;\n    }else{\n      n = 0;\n      if( p->pSrc && p->pSrc->nSrc && p->pSrc->nAlloc ) n++;\n      if( p->pWhere ) n++;\n      if( p->pGroupBy ) n++;\n      if( p->pHaving ) n++;\n      if( p->pOrderBy ) n++;\n      if( p->pLimit ) n++;\n#ifndef SQLITE_OMIT_WINDOWFUNC\n      if( p->pWin ) n++;\n      if( p->pWinDefn ) n++;\n#endif\n    }\n    if( p->pEList ){\n      sqlite3TreeViewExprList(pView, p->pEList, n>0, \"result-set\");\n    }\n    n--;\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    if( p->pWin ){\n      Window *pX;\n      sqlite3TreeViewPush(&pView, (n--)>0);\n      sqlite3TreeViewLine(pView, \"window-functions\");\n      for(pX=p->pWin; pX; pX=pX->pNextWin){\n        sqlite3TreeViewWinFunc(pView, pX, pX->pNextWin!=0);\n      }\n      sqlite3TreeViewPop(&pView);\n    }\n#endif\n    if( p->pSrc && p->pSrc->nSrc && p->pSrc->nAlloc ){\n      sqlite3TreeViewPush(&pView, (n--)>0);\n      sqlite3TreeViewLine(pView, \"FROM\");\n      sqlite3TreeViewSrcList(pView, p->pSrc);\n      sqlite3TreeViewPop(&pView);\n    }\n    if( p->pWhere ){\n      sqlite3TreeViewItem(pView, \"WHERE\", (n--)>0);\n      sqlite3TreeViewExpr(pView, p->pWhere, 0);\n      sqlite3TreeViewPop(&pView);\n    }\n    if( p->pGroupBy ){\n      sqlite3TreeViewExprList(pView, p->pGroupBy, (n--)>0, \"GROUPBY\");\n    }\n    if( p->pHaving ){\n      sqlite3TreeViewItem(pView, \"HAVING\", (n--)>0);\n      sqlite3TreeViewExpr(pView, p->pHaving, 0);\n      sqlite3TreeViewPop(&pView);\n    }\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    if( p->pWinDefn ){\n      Window *pX;\n      sqlite3TreeViewItem(pView, \"WINDOW\", (n--)>0);\n      for(pX=p->pWinDefn; pX; pX=pX->pNextWin){\n        sqlite3TreeViewWindow(pView, pX, pX->pNextWin!=0);\n      }\n      sqlite3TreeViewPop(&pView);\n    }\n#endif\n    if( p->pOrderBy ){\n      sqlite3TreeViewExprList(pView, p->pOrderBy, (n--)>0, \"ORDERBY\");\n    }\n    if( p->pLimit ){\n      sqlite3TreeViewItem(pView, \"LIMIT\", (n--)>0);\n      sqlite3TreeViewExpr(pView, p->pLimit->pLeft, p->pLimit->pRight!=0);\n      if( p->pLimit->pRight ){\n        sqlite3TreeViewItem(pView, \"OFFSET\", 0);\n        sqlite3TreeViewExpr(pView, p->pLimit->pRight, 0);\n        sqlite3TreeViewPop(&pView);\n      }\n      sqlite3TreeViewPop(&pView);\n    }\n    if( p->pPrior ){\n      const char *zOp = \"UNION\";\n      switch( p->op ){\n        case TK_ALL:         zOp = \"UNION ALL\";  break;\n        case TK_INTERSECT:   zOp = \"INTERSECT\";  break;\n        case TK_EXCEPT:      zOp = \"EXCEPT\";     break;\n      }\n      sqlite3TreeViewItem(pView, zOp, 1);\n    }\n    p = p->pPrior;\n  }while( p!=0 );\n  sqlite3TreeViewPop(&pView);\n}\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n/*\n** Generate a description of starting or stopping bounds\n*/\nvoid sqlite3TreeViewBound(\n  TreeView *pView,        /* View context */\n  u8 eBound,              /* UNBOUNDED, CURRENT, PRECEDING, FOLLOWING */\n  Expr *pExpr,            /* Value for PRECEDING or FOLLOWING */\n  u8 moreToFollow         /* True if more to follow */\n){\n  switch( eBound ){\n    case TK_UNBOUNDED: {\n      sqlite3TreeViewItem(pView, \"UNBOUNDED\", moreToFollow);\n      sqlite3TreeViewPop(&pView);\n      break;\n    }\n    case TK_CURRENT: {\n      sqlite3TreeViewItem(pView, \"CURRENT\", moreToFollow);\n      sqlite3TreeViewPop(&pView);\n      break;\n    }\n    case TK_PRECEDING: {\n      sqlite3TreeViewItem(pView, \"PRECEDING\", moreToFollow);\n      sqlite3TreeViewExpr(pView, pExpr, 0);\n      sqlite3TreeViewPop(&pView);\n      break;\n    }\n    case TK_FOLLOWING: {\n      sqlite3TreeViewItem(pView, \"FOLLOWING\", moreToFollow);\n      sqlite3TreeViewExpr(pView, pExpr, 0);\n      sqlite3TreeViewPop(&pView);\n      break;\n    }\n  }\n}\n#endif /* SQLITE_OMIT_WINDOWFUNC */\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n/*\n** Generate a human-readable explanation for a Window object\n*/\nvoid sqlite3TreeViewWindow(TreeView *pView, const Window *pWin, u8 more){\n  int nElement = 0;\n  if( pWin==0 ) return;\n  if( pWin->pFilter ){\n    sqlite3TreeViewItem(pView, \"FILTER\", 1);\n    sqlite3TreeViewExpr(pView, pWin->pFilter, 0);\n    sqlite3TreeViewPop(&pView);\n    if( pWin->eFrmType==TK_FILTER ) return;\n  }\n  sqlite3TreeViewPush(&pView, more);\n  if( pWin->zName ){\n    sqlite3TreeViewLine(pView, \"OVER %s (%p)\", pWin->zName, pWin);\n  }else{\n    sqlite3TreeViewLine(pView, \"OVER (%p)\", pWin);\n  }\n  if( pWin->zBase )    nElement++;\n  if( pWin->pOrderBy ) nElement++;\n  if( pWin->eFrmType!=0 && pWin->eFrmType!=TK_FILTER ) nElement++;\n  if( pWin->eExclude ) nElement++;\n  if( pWin->zBase ){\n    sqlite3TreeViewPush(&pView, (--nElement)>0);\n    sqlite3TreeViewLine(pView, \"window: %s\", pWin->zBase);\n    sqlite3TreeViewPop(&pView);\n  }\n  if( pWin->pPartition ){\n    sqlite3TreeViewExprList(pView, pWin->pPartition, nElement>0,\"PARTITION-BY\");\n  }\n  if( pWin->pOrderBy ){\n    sqlite3TreeViewExprList(pView, pWin->pOrderBy, (--nElement)>0, \"ORDER-BY\");\n  }\n  if( pWin->eFrmType!=0 && pWin->eFrmType!=TK_FILTER ){\n    char zBuf[30];\n    const char *zFrmType = \"ROWS\";\n    if( pWin->eFrmType==TK_RANGE ) zFrmType = \"RANGE\";\n    if( pWin->eFrmType==TK_GROUPS ) zFrmType = \"GROUPS\";\n    sqlite3_snprintf(sizeof(zBuf),zBuf,\"%s%s\",zFrmType,\n        pWin->bImplicitFrame ? \" (implied)\" : \"\");\n    sqlite3TreeViewItem(pView, zBuf, (--nElement)>0);\n    sqlite3TreeViewBound(pView, pWin->eStart, pWin->pStart, 1);\n    sqlite3TreeViewBound(pView, pWin->eEnd, pWin->pEnd, 0);\n    sqlite3TreeViewPop(&pView);\n  }\n  if( pWin->eExclude ){\n    char zBuf[30];\n    const char *zExclude;\n    switch( pWin->eExclude ){\n      case TK_NO:      zExclude = \"NO OTHERS\";   break;\n      case TK_CURRENT: zExclude = \"CURRENT ROW\"; break;\n      case TK_GROUP:   zExclude = \"GROUP\";       break;\n      case TK_TIES:    zExclude = \"TIES\";        break;\n      default:\n        sqlite3_snprintf(sizeof(zBuf),zBuf,\"invalid(%d)\", pWin->eExclude);\n        zExclude = zBuf;\n        break;\n    }\n    sqlite3TreeViewPush(&pView, 0);\n    sqlite3TreeViewLine(pView, \"EXCLUDE %s\", zExclude);\n    sqlite3TreeViewPop(&pView);\n  }\n  sqlite3TreeViewPop(&pView);\n}\n#endif /* SQLITE_OMIT_WINDOWFUNC */\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n/*\n** Generate a human-readable explanation for a Window Function object\n*/\nvoid sqlite3TreeViewWinFunc(TreeView *pView, const Window *pWin, u8 more){\n  if( pWin==0 ) return;\n  sqlite3TreeViewPush(&pView, more);\n  sqlite3TreeViewLine(pView, \"WINFUNC %s(%d)\",\n                       pWin->pWFunc->zName, pWin->pWFunc->nArg);\n  sqlite3TreeViewWindow(pView, pWin, 0);\n  sqlite3TreeViewPop(&pView);\n}\n#endif /* SQLITE_OMIT_WINDOWFUNC */\n\n/*\n** Generate a human-readable explanation of an expression tree.\n*/\nvoid sqlite3TreeViewExpr(TreeView *pView, const Expr *pExpr, u8 moreToFollow){\n  const char *zBinOp = 0;   /* Binary operator */\n  const char *zUniOp = 0;   /* Unary operator */\n  char zFlgs[200];\n  sqlite3TreeViewPush(&pView, moreToFollow);\n  if( pExpr==0 ){\n    sqlite3TreeViewLine(pView, \"nil\");\n    sqlite3TreeViewPop(&pView);\n    return;\n  }\n  if( pExpr->flags || pExpr->affExpr || pExpr->vvaFlags || pExpr->pAggInfo ){\n    StrAccum x;\n    sqlite3StrAccumInit(&x, 0, zFlgs, sizeof(zFlgs), 0);\n    sqlite3_str_appendf(&x, \" fg.af=%x.%c\",\n      pExpr->flags, pExpr->affExpr ? pExpr->affExpr : 'n');\n    if( ExprHasProperty(pExpr, EP_OuterON) ){\n      sqlite3_str_appendf(&x, \" outer.iJoin=%d\", pExpr->w.iJoin);\n    }\n    if( ExprHasProperty(pExpr, EP_InnerON) ){\n      sqlite3_str_appendf(&x, \" inner.iJoin=%d\", pExpr->w.iJoin);\n    }\n    if( ExprHasProperty(pExpr, EP_FromDDL) ){\n      sqlite3_str_appendf(&x, \" DDL\");\n    }\n    if( ExprHasVVAProperty(pExpr, EP_Immutable) ){\n      sqlite3_str_appendf(&x, \" IMMUTABLE\");\n    }\n    if( pExpr->pAggInfo!=0 ){\n      sqlite3_str_appendf(&x, \" agg-column[%d]\", pExpr->iAgg);\n    }\n    sqlite3StrAccumFinish(&x);\n  }else{\n    zFlgs[0] = 0;\n  }\n  switch( pExpr->op ){\n    case TK_AGG_COLUMN: {\n      sqlite3TreeViewLine(pView, \"AGG{%d:%d}%s\",\n            pExpr->iTable, pExpr->iColumn, zFlgs);\n      break;\n    }\n    case TK_COLUMN: {\n      if( pExpr->iTable<0 ){\n        /* This only happens when coding check constraints */\n        char zOp2[16];\n        if( pExpr->op2 ){\n          sqlite3_snprintf(sizeof(zOp2),zOp2,\" op2=0x%02x\",pExpr->op2);\n        }else{\n          zOp2[0] = 0;\n        }\n        sqlite3TreeViewLine(pView, \"COLUMN(%d)%s%s\",\n                                    pExpr->iColumn, zFlgs, zOp2);\n      }else{\n        assert( ExprUseYTab(pExpr) );\n        sqlite3TreeViewLine(pView, \"{%d:%d} pTab=%p%s\",\n                        pExpr->iTable, pExpr->iColumn,\n                        pExpr->y.pTab, zFlgs);\n      }\n      if( ExprHasProperty(pExpr, EP_FixedCol) ){\n        sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);\n      }\n      break;\n    }\n    case TK_INTEGER: {\n      if( pExpr->flags & EP_IntValue ){\n        sqlite3TreeViewLine(pView, \"%d\", pExpr->u.iValue);\n      }else{\n        sqlite3TreeViewLine(pView, \"%s\", pExpr->u.zToken);\n      }\n      break;\n    }\n#ifndef SQLITE_OMIT_FLOATING_POINT\n    case TK_FLOAT: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      sqlite3TreeViewLine(pView,\"%s\", pExpr->u.zToken);\n      break;\n    }\n#endif\n    case TK_STRING: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      sqlite3TreeViewLine(pView,\"%Q\", pExpr->u.zToken);\n      break;\n    }\n    case TK_NULL: {\n      sqlite3TreeViewLine(pView,\"NULL\");\n      break;\n    }\n    case TK_TRUEFALSE: {\n      sqlite3TreeViewLine(pView,\"%s%s\",\n         sqlite3ExprTruthValue(pExpr) ? \"TRUE\" : \"FALSE\", zFlgs);\n      break;\n    }\n#ifndef SQLITE_OMIT_BLOB_LITERAL\n    case TK_BLOB: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      sqlite3TreeViewLine(pView,\"%s\", pExpr->u.zToken);\n      break;\n    }\n#endif\n    case TK_VARIABLE: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      sqlite3TreeViewLine(pView,\"VARIABLE(%s,%d)\",\n                          pExpr->u.zToken, pExpr->iColumn);\n      break;\n    }\n    case TK_REGISTER: {\n      sqlite3TreeViewLine(pView,\"REGISTER(%d)\", pExpr->iTable);\n      break;\n    }\n    case TK_ID: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      sqlite3TreeViewLine(pView,\"ID \\\"%w\\\"\", pExpr->u.zToken);\n      break;\n    }\n#ifndef SQLITE_OMIT_CAST\n    case TK_CAST: {\n      /* Expressions of the form:   CAST(pLeft AS token) */\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      sqlite3TreeViewLine(pView,\"CAST %Q\", pExpr->u.zToken);\n      sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);\n      break;\n    }\n#endif /* SQLITE_OMIT_CAST */\n    case TK_LT:      zBinOp = \"LT\";     break;\n    case TK_LE:      zBinOp = \"LE\";     break;\n    case TK_GT:      zBinOp = \"GT\";     break;\n    case TK_GE:      zBinOp = \"GE\";     break;\n    case TK_NE:      zBinOp = \"NE\";     break;\n    case TK_EQ:      zBinOp = \"EQ\";     break;\n    case TK_IS:      zBinOp = \"IS\";     break;\n    case TK_ISNOT:   zBinOp = \"ISNOT\";  break;\n    case TK_AND:     zBinOp = \"AND\";    break;\n    case TK_OR:      zBinOp = \"OR\";     break;\n    case TK_PLUS:    zBinOp = \"ADD\";    break;\n    case TK_STAR:    zBinOp = \"MUL\";    break;\n    case TK_MINUS:   zBinOp = \"SUB\";    break;\n    case TK_REM:     zBinOp = \"REM\";    break;\n    case TK_BITAND:  zBinOp = \"BITAND\"; break;\n    case TK_BITOR:   zBinOp = \"BITOR\";  break;\n    case TK_SLASH:   zBinOp = \"DIV\";    break;\n    case TK_LSHIFT:  zBinOp = \"LSHIFT\"; break;\n    case TK_RSHIFT:  zBinOp = \"RSHIFT\"; break;\n    case TK_CONCAT:  zBinOp = \"CONCAT\"; break;\n    case TK_DOT:     zBinOp = \"DOT\";    break;\n    case TK_LIMIT:   zBinOp = \"LIMIT\";  break;\n\n    case TK_UMINUS:  zUniOp = \"UMINUS\"; break;\n    case TK_UPLUS:   zUniOp = \"UPLUS\";  break;\n    case TK_BITNOT:  zUniOp = \"BITNOT\"; break;\n    case TK_NOT:     zUniOp = \"NOT\";    break;\n    case TK_ISNULL:  zUniOp = \"ISNULL\"; break;\n    case TK_NOTNULL: zUniOp = \"NOTNULL\"; break;\n\n    case TK_TRUTH: {\n      int x;\n      const char *azOp[] = {\n         \"IS-FALSE\", \"IS-TRUE\", \"IS-NOT-FALSE\", \"IS-NOT-TRUE\"\n      };\n      assert( pExpr->op2==TK_IS || pExpr->op2==TK_ISNOT );\n      assert( pExpr->pRight );\n      assert( sqlite3ExprSkipCollateAndLikely(pExpr->pRight)->op\n                  == TK_TRUEFALSE );\n      x = (pExpr->op2==TK_ISNOT)*2 + sqlite3ExprTruthValue(pExpr->pRight);\n      zUniOp = azOp[x];\n      break;\n    }\n\n    case TK_SPAN: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      sqlite3TreeViewLine(pView, \"SPAN %Q\", pExpr->u.zToken);\n      sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);\n      break;\n    }\n\n    case TK_COLLATE: {\n      /* COLLATE operators without the EP_Collate flag are intended to\n      ** emulate collation associated with a table column.  These show\n      ** up in the treeview output as \"SOFT-COLLATE\".  Explicit COLLATE\n      ** operators that appear in the original SQL always have the\n      ** EP_Collate bit set and appear in treeview output as just \"COLLATE\" */\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      sqlite3TreeViewLine(pView, \"%sCOLLATE %Q%s\",\n        !ExprHasProperty(pExpr, EP_Collate) ? \"SOFT-\" : \"\",\n        pExpr->u.zToken, zFlgs);\n      sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);\n      break;\n    }\n\n    case TK_AGG_FUNCTION:\n    case TK_FUNCTION: {\n      ExprList *pFarg;       /* List of function arguments */\n      Window *pWin;\n      if( ExprHasProperty(pExpr, EP_TokenOnly) ){\n        pFarg = 0;\n        pWin = 0;\n      }else{\n        assert( ExprUseXList(pExpr) );\n        pFarg = pExpr->x.pList;\n#ifndef SQLITE_OMIT_WINDOWFUNC\n        pWin = IsWindowFunc(pExpr) ? pExpr->y.pWin : 0;\n#else\n        pWin = 0;\n#endif \n      }\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      if( pExpr->op==TK_AGG_FUNCTION ){\n        sqlite3TreeViewLine(pView, \"AGG_FUNCTION%d %Q%s agg=%d[%d]/%p\",\n                             pExpr->op2, pExpr->u.zToken, zFlgs,\n                             pExpr->pAggInfo ? pExpr->pAggInfo->selId : 0,\n                             pExpr->iAgg, pExpr->pAggInfo);\n      }else if( pExpr->op2!=0 ){\n        const char *zOp2;\n        char zBuf[8];\n        sqlite3_snprintf(sizeof(zBuf),zBuf,\"0x%02x\",pExpr->op2);\n        zOp2 = zBuf;\n        if( pExpr->op2==NC_IsCheck ) zOp2 = \"NC_IsCheck\";\n        if( pExpr->op2==NC_IdxExpr ) zOp2 = \"NC_IdxExpr\";\n        if( pExpr->op2==NC_PartIdx ) zOp2 = \"NC_PartIdx\";\n        if( pExpr->op2==NC_GenCol ) zOp2 = \"NC_GenCol\";\n        sqlite3TreeViewLine(pView, \"FUNCTION %Q%s op2=%s\",\n                            pExpr->u.zToken, zFlgs, zOp2);\n      }else{\n        sqlite3TreeViewLine(pView, \"FUNCTION %Q%s\", pExpr->u.zToken, zFlgs);\n      }\n      if( pFarg ){\n        sqlite3TreeViewExprList(pView, pFarg, pWin!=0 || pExpr->pLeft, 0);\n        if( pExpr->pLeft ){\n          Expr *pOB = pExpr->pLeft;\n          assert( pOB->op==TK_ORDER );\n          assert( ExprUseXList(pOB) );\n          sqlite3TreeViewExprList(pView, pOB->x.pList, pWin!=0, \"ORDERBY\");\n        }\n      }\n#ifndef SQLITE_OMIT_WINDOWFUNC\n      if( pWin ){\n        sqlite3TreeViewWindow(pView, pWin, 0);\n      }\n#endif\n      break;\n    }\n    case TK_ORDER: {\n      sqlite3TreeViewExprList(pView, pExpr->x.pList, 0, \"ORDERBY\");\n      break;\n    }\n#ifndef SQLITE_OMIT_SUBQUERY\n    case TK_EXISTS: {\n      assert( ExprUseXSelect(pExpr) );\n      sqlite3TreeViewLine(pView, \"EXISTS-expr flags=0x%x\", pExpr->flags);\n      sqlite3TreeViewSelect(pView, pExpr->x.pSelect, 0);\n      break;\n    }\n    case TK_SELECT: {\n      assert( ExprUseXSelect(pExpr) );\n      sqlite3TreeViewLine(pView, \"subquery-expr flags=0x%x\", pExpr->flags);\n      sqlite3TreeViewSelect(pView, pExpr->x.pSelect, 0);\n      break;\n    }\n    case TK_IN: {\n      sqlite3_str *pStr = sqlite3_str_new(0);\n      char *z;\n      sqlite3_str_appendf(pStr, \"IN flags=0x%x\", pExpr->flags);\n      if( pExpr->iTable ) sqlite3_str_appendf(pStr, \" iTable=%d\",pExpr->iTable);\n      if( ExprHasProperty(pExpr, EP_Subrtn) ){\n        sqlite3_str_appendf(pStr, \" subrtn(%d,%d)\",\n            pExpr->y.sub.regReturn, pExpr->y.sub.iAddr);\n      }\n      z = sqlite3_str_finish(pStr);\n      sqlite3TreeViewLine(pView, z);\n      sqlite3_free(z);\n      sqlite3TreeViewExpr(pView, pExpr->pLeft, 1);\n      if( ExprUseXSelect(pExpr) ){\n        sqlite3TreeViewSelect(pView, pExpr->x.pSelect, 0);\n      }else{\n        sqlite3TreeViewExprList(pView, pExpr->x.pList, 0, 0);\n      }\n      break;\n    }\n#endif /* SQLITE_OMIT_SUBQUERY */\n\n    /*\n    **    x BETWEEN y AND z\n    **\n    ** This is equivalent to\n    **\n    **    x>=y AND x<=z\n    **\n    ** X is stored in pExpr->pLeft.\n    ** Y is stored in pExpr->pList->a[0].pExpr.\n    ** Z is stored in pExpr->pList->a[1].pExpr.\n    */\n    case TK_BETWEEN: {\n      const Expr *pX, *pY, *pZ;\n      pX = pExpr->pLeft;\n      assert( ExprUseXList(pExpr) );\n      assert( pExpr->x.pList->nExpr==2 );\n      pY = pExpr->x.pList->a[0].pExpr;\n      pZ = pExpr->x.pList->a[1].pExpr;\n      sqlite3TreeViewLine(pView, \"BETWEEN%s\", zFlgs);\n      sqlite3TreeViewExpr(pView, pX, 1);\n      sqlite3TreeViewExpr(pView, pY, 1);\n      sqlite3TreeViewExpr(pView, pZ, 0);\n      break;\n    }\n    case TK_TRIGGER: {\n      /* If the opcode is TK_TRIGGER, then the expression is a reference\n      ** to a column in the new.* or old.* pseudo-tables available to\n      ** trigger programs. In this case Expr.iTable is set to 1 for the\n      ** new.* pseudo-table, or 0 for the old.* pseudo-table. Expr.iColumn\n      ** is set to the column of the pseudo-table to read, or to -1 to\n      ** read the rowid field.\n      */\n      sqlite3TreeViewLine(pView, \"%s(%d)\", \n          pExpr->iTable ? \"NEW\" : \"OLD\", pExpr->iColumn);\n      break;\n    }\n    case TK_CASE: {\n      sqlite3TreeViewLine(pView, \"CASE\");\n      sqlite3TreeViewExpr(pView, pExpr->pLeft, 1);\n      assert( ExprUseXList(pExpr) );\n      sqlite3TreeViewExprList(pView, pExpr->x.pList, 0, 0);\n      break;\n    }\n#ifndef SQLITE_OMIT_TRIGGER\n    case TK_RAISE: {\n      const char *zType = \"unk\";\n      switch( pExpr->affExpr ){\n        case OE_Rollback:   zType = \"rollback\";  break;\n        case OE_Abort:      zType = \"abort\";     break;\n        case OE_Fail:       zType = \"fail\";      break;\n        case OE_Ignore:     zType = \"ignore\";    break;\n      }\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      sqlite3TreeViewLine(pView, \"RAISE %s\", zType);\n      sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);\n      break;\n    }\n#endif\n    case TK_MATCH: {\n      sqlite3TreeViewLine(pView, \"MATCH {%d:%d}%s\",\n                          pExpr->iTable, pExpr->iColumn, zFlgs);\n      sqlite3TreeViewExpr(pView, pExpr->pRight, 0);\n      break;\n    }\n    case TK_VECTOR: {\n      char *z = sqlite3_mprintf(\"VECTOR%s\",zFlgs);\n      assert( ExprUseXList(pExpr) );\n      sqlite3TreeViewBareExprList(pView, pExpr->x.pList, z);\n      sqlite3_free(z);\n      break;\n    }\n    case TK_SELECT_COLUMN: {\n      sqlite3TreeViewLine(pView, \"SELECT-COLUMN %d of [0..%d]%s\",\n              pExpr->iColumn, pExpr->iTable-1,\n              pExpr->pRight==pExpr->pLeft ? \" (SELECT-owner)\" : \"\");\n      assert( ExprUseXSelect(pExpr->pLeft) );\n      sqlite3TreeViewSelect(pView, pExpr->pLeft->x.pSelect, 0);\n      break;\n    }\n    case TK_IF_NULL_ROW: {\n      sqlite3TreeViewLine(pView, \"IF-NULL-ROW %d\", pExpr->iTable);\n      sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);\n      break;\n    }\n    case TK_ERROR: {\n      Expr tmp;\n      sqlite3TreeViewLine(pView, \"ERROR\");\n      tmp = *pExpr;\n      tmp.op = pExpr->op2;\n      sqlite3TreeViewExpr(pView, &tmp, 0);\n      break;\n    }\n    case TK_ROW: {\n      if( pExpr->iColumn<=0 ){\n        sqlite3TreeViewLine(pView, \"First FROM table rowid\");\n      }else{\n        sqlite3TreeViewLine(pView, \"First FROM table column %d\",\n            pExpr->iColumn-1);\n      }\n      break;\n    }\n    default: {\n      sqlite3TreeViewLine(pView, \"op=%d\", pExpr->op);\n      break;\n    }\n  }\n  if( zBinOp ){\n    sqlite3TreeViewLine(pView, \"%s%s\", zBinOp, zFlgs);\n    sqlite3TreeViewExpr(pView, pExpr->pLeft, 1);\n    sqlite3TreeViewExpr(pView, pExpr->pRight, 0);\n  }else if( zUniOp ){\n    sqlite3TreeViewLine(pView, \"%s%s\", zUniOp, zFlgs);\n   sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);\n  }\n  sqlite3TreeViewPop(&pView);\n}\n\n\n/*\n** Generate a human-readable explanation of an expression list.\n*/\nvoid sqlite3TreeViewBareExprList(\n  TreeView *pView,\n  const ExprList *pList,\n  const char *zLabel\n){\n  if( zLabel==0 || zLabel[0]==0 ) zLabel = \"LIST\";\n  if( pList==0 ){\n    sqlite3TreeViewLine(pView, \"%s (empty)\", zLabel);\n  }else{\n    int i;\n    sqlite3TreeViewLine(pView, \"%s\", zLabel);\n    for(i=0; i<pList->nExpr; i++){\n      int j = pList->a[i].u.x.iOrderByCol;\n      u8 sortFlags = pList->a[i].fg.sortFlags;\n      char *zName = pList->a[i].zEName;\n      int moreToFollow = i<pList->nExpr - 1;\n      if( j || zName || sortFlags ){\n        sqlite3TreeViewPush(&pView, moreToFollow);\n        moreToFollow = 0;\n        sqlite3TreeViewLine(pView, 0);\n        if( zName ){\n          switch( pList->a[i].fg.eEName ){\n            default:\n              fprintf(stdout, \"AS %s \", zName);\n              break;\n            case ENAME_TAB:\n              fprintf(stdout, \"TABLE-ALIAS-NAME(\\\"%s\\\") \", zName);\n              if( pList->a[i].fg.bUsed ) fprintf(stdout, \"(used) \");\n              if( pList->a[i].fg.bUsingTerm ) fprintf(stdout, \"(USING-term) \");\n              if( pList->a[i].fg.bNoExpand ) fprintf(stdout, \"(NoExpand) \");\n              break;\n            case ENAME_SPAN:\n              fprintf(stdout, \"SPAN(\\\"%s\\\") \", zName);\n              break;\n          }\n        }\n        if( j ){\n          fprintf(stdout, \"iOrderByCol=%d \", j);\n        }\n        if( sortFlags & KEYINFO_ORDER_DESC ){\n          fprintf(stdout, \"DESC \");\n        }else if( sortFlags & KEYINFO_ORDER_BIGNULL ){\n          fprintf(stdout, \"NULLS-LAST\");\n        }\n        fprintf(stdout, \"\\n\");\n        fflush(stdout);\n      }\n      sqlite3TreeViewExpr(pView, pList->a[i].pExpr, moreToFollow);\n      if( j || zName || sortFlags ){\n        sqlite3TreeViewPop(&pView);\n      }\n    }\n  }\n}\nvoid sqlite3TreeViewExprList(\n  TreeView *pView,\n  const ExprList *pList,\n  u8 moreToFollow,\n  const char *zLabel\n){\n  sqlite3TreeViewPush(&pView, moreToFollow);\n  sqlite3TreeViewBareExprList(pView, pList, zLabel);\n  sqlite3TreeViewPop(&pView);\n}\n\n/*\n** Generate a human-readable explanation of an id-list.\n*/\nvoid sqlite3TreeViewBareIdList(\n  TreeView *pView,\n  const IdList *pList,\n  const char *zLabel\n){\n  if( zLabel==0 || zLabel[0]==0 ) zLabel = \"LIST\";\n  if( pList==0 ){\n    sqlite3TreeViewLine(pView, \"%s (empty)\", zLabel);\n  }else{\n    int i;\n    sqlite3TreeViewLine(pView, \"%s\", zLabel);\n    for(i=0; i<pList->nId; i++){\n      char *zName = pList->a[i].zName;\n      int moreToFollow = i<pList->nId - 1;\n      if( zName==0 ) zName = \"(null)\";\n      sqlite3TreeViewPush(&pView, moreToFollow);\n      sqlite3TreeViewLine(pView, 0);\n      fprintf(stdout, \"%s\\n\", zName);\n      sqlite3TreeViewPop(&pView);\n    }\n  }\n}\nvoid sqlite3TreeViewIdList(\n  TreeView *pView,\n  const IdList *pList,\n  u8 moreToFollow,\n  const char *zLabel\n){\n  sqlite3TreeViewPush(&pView, moreToFollow);\n  sqlite3TreeViewBareIdList(pView, pList, zLabel);\n  sqlite3TreeViewPop(&pView);\n}\n\n/*\n** Generate a human-readable explanation of a list of Upsert objects\n*/\nvoid sqlite3TreeViewUpsert(\n  TreeView *pView,\n  const Upsert *pUpsert,\n  u8 moreToFollow\n){\n  if( pUpsert==0 ) return;\n  sqlite3TreeViewPush(&pView, moreToFollow);\n  while( pUpsert ){\n    int n;\n    sqlite3TreeViewPush(&pView, pUpsert->pNextUpsert!=0 || moreToFollow);\n    sqlite3TreeViewLine(pView, \"ON CONFLICT DO %s\", \n         pUpsert->isDoUpdate ? \"UPDATE\" : \"NOTHING\");\n    n = (pUpsert->pUpsertSet!=0) + (pUpsert->pUpsertWhere!=0);\n    sqlite3TreeViewExprList(pView, pUpsert->pUpsertTarget, (n--)>0, \"TARGET\");\n    sqlite3TreeViewExprList(pView, pUpsert->pUpsertSet, (n--)>0, \"SET\");\n    if( pUpsert->pUpsertWhere ){\n      sqlite3TreeViewItem(pView, \"WHERE\", (n--)>0);\n      sqlite3TreeViewExpr(pView, pUpsert->pUpsertWhere, 0);\n      sqlite3TreeViewPop(&pView);\n    }\n    sqlite3TreeViewPop(&pView);\n    pUpsert = pUpsert->pNextUpsert;\n  }\n  sqlite3TreeViewPop(&pView);\n}\n\n#if TREETRACE_ENABLED\n/*\n** Generate a human-readable diagram of the data structure that go\n** into generating an DELETE statement.\n*/\nvoid sqlite3TreeViewDelete(\n  const With *pWith,\n  const SrcList *pTabList,\n  const Expr *pWhere,\n  const ExprList *pOrderBy,\n  const Expr *pLimit,\n  const Trigger *pTrigger\n){\n  int n = 0;\n  TreeView *pView = 0;\n  sqlite3TreeViewPush(&pView, 0);\n  sqlite3TreeViewLine(pView, \"DELETE\");\n  if( pWith ) n++;\n  if( pTabList ) n++;\n  if( pWhere ) n++;\n  if( pOrderBy ) n++;\n  if( pLimit ) n++;\n  if( pTrigger ) n++;\n  if( pWith ){\n    sqlite3TreeViewPush(&pView, (--n)>0);\n    sqlite3TreeViewWith(pView, pWith, 0);\n    sqlite3TreeViewPop(&pView);\n  }\n  if( pTabList ){\n    sqlite3TreeViewPush(&pView, (--n)>0);\n    sqlite3TreeViewLine(pView, \"FROM\");\n    sqlite3TreeViewSrcList(pView, pTabList);\n    sqlite3TreeViewPop(&pView);\n  }\n  if( pWhere ){\n    sqlite3TreeViewPush(&pView, (--n)>0);\n    sqlite3TreeViewLine(pView, \"WHERE\");\n    sqlite3TreeViewExpr(pView, pWhere, 0);\n    sqlite3TreeViewPop(&pView);\n  }\n  if( pOrderBy ){\n    sqlite3TreeViewExprList(pView, pOrderBy, (--n)>0, \"ORDER-BY\");\n  }\n  if( pLimit ){\n    sqlite3TreeViewPush(&pView, (--n)>0);\n    sqlite3TreeViewLine(pView, \"LIMIT\");\n    sqlite3TreeViewExpr(pView, pLimit, 0);\n    sqlite3TreeViewPop(&pView);\n  }\n  if( pTrigger ){\n    sqlite3TreeViewTrigger(pView, pTrigger, (--n)>0, 1);\n  }\n  sqlite3TreeViewPop(&pView);\n}\n#endif /* TREETRACE_ENABLED */\n\n#if TREETRACE_ENABLED\n/*\n** Generate a human-readable diagram of the data structure that go\n** into generating an INSERT statement.\n*/\nvoid sqlite3TreeViewInsert(\n  const With *pWith,\n  const SrcList *pTabList,\n  const IdList *pColumnList,\n  const Select *pSelect,\n  const ExprList *pExprList,\n  int onError,\n  const Upsert *pUpsert,\n  const Trigger *pTrigger\n){\n  TreeView *pView = 0;\n  int n = 0;\n  const char *zLabel = \"INSERT\";\n  switch( onError ){\n    case OE_Replace:  zLabel = \"REPLACE\";             break;\n    case OE_Ignore:   zLabel = \"INSERT OR IGNORE\";    break;\n    case OE_Rollback: zLabel = \"INSERT OR ROLLBACK\";  break;\n    case OE_Abort:    zLabel = \"INSERT OR ABORT\";     break;\n    case OE_Fail:     zLabel = \"INSERT OR FAIL\";      break;\n  }\n  sqlite3TreeViewPush(&pView, 0);\n  sqlite3TreeViewLine(pView, zLabel);\n  if( pWith ) n++;\n  if( pTabList ) n++;\n  if( pColumnList ) n++;\n  if( pSelect ) n++;\n  if( pExprList ) n++;\n  if( pUpsert ) n++;\n  if( pTrigger ) n++;\n  if( pWith ){\n    sqlite3TreeViewPush(&pView, (--n)>0);\n    sqlite3TreeViewWith(pView, pWith, 0);\n    sqlite3TreeViewPop(&pView);\n  }\n  if( pTabList ){\n    sqlite3TreeViewPush(&pView, (--n)>0);\n    sqlite3TreeViewLine(pView, \"INTO\");\n    sqlite3TreeViewSrcList(pView, pTabList);\n    sqlite3TreeViewPop(&pView);\n  }\n  if( pColumnList ){\n    sqlite3TreeViewIdList(pView, pColumnList, (--n)>0, \"COLUMNS\");\n  }\n  if( pSelect ){\n    sqlite3TreeViewPush(&pView, (--n)>0);\n    sqlite3TreeViewLine(pView, \"DATA-SOURCE\");\n    sqlite3TreeViewSelect(pView, pSelect, 0);\n    sqlite3TreeViewPop(&pView);\n  }\n  if( pExprList ){\n    sqlite3TreeViewExprList(pView, pExprList, (--n)>0, \"VALUES\");\n  }\n  if( pUpsert ){\n    sqlite3TreeViewPush(&pView, (--n)>0);\n    sqlite3TreeViewLine(pView, \"UPSERT\");\n    sqlite3TreeViewUpsert(pView, pUpsert, 0);\n    sqlite3TreeViewPop(&pView);\n  }\n  if( pTrigger ){\n    sqlite3TreeViewTrigger(pView, pTrigger, (--n)>0, 1);\n  }\n  sqlite3TreeViewPop(&pView);\n}\n#endif /* TREETRACE_ENABLED */\n\n#if TREETRACE_ENABLED\n/*\n** Generate a human-readable diagram of the data structure that go\n** into generating an UPDATE statement.\n*/\nvoid sqlite3TreeViewUpdate(\n  const With *pWith,\n  const SrcList *pTabList,\n  const ExprList *pChanges,\n  const Expr *pWhere,\n  int onError,\n  const ExprList *pOrderBy,\n  const Expr *pLimit,\n  const Upsert *pUpsert,\n  const Trigger *pTrigger\n){\n  int n = 0;\n  TreeView *pView = 0;\n  const char *zLabel = \"UPDATE\";\n  switch( onError ){\n    case OE_Replace:  zLabel = \"UPDATE OR REPLACE\";   break;\n    case OE_Ignore:   zLabel = \"UPDATE OR IGNORE\";    break;\n    case OE_Rollback: zLabel = \"UPDATE OR ROLLBACK\";  break;\n    case OE_Abort:    zLabel = \"UPDATE OR ABORT\";     break;\n    case OE_Fail:     zLabel = \"UPDATE OR FAIL\";      break;\n  }\n  sqlite3TreeViewPush(&pView, 0);\n  sqlite3TreeViewLine(pView, zLabel);\n  if( pWith ) n++;\n  if( pTabList ) n++;\n  if( pChanges ) n++;\n  if( pWhere ) n++;\n  if( pOrderBy ) n++;\n  if( pLimit ) n++;\n  if( pUpsert ) n++;\n  if( pTrigger ) n++;\n  if( pWith ){\n    sqlite3TreeViewPush(&pView, (--n)>0);\n    sqlite3TreeViewWith(pView, pWith, 0);\n    sqlite3TreeViewPop(&pView);\n  }\n  if( pTabList ){\n    sqlite3TreeViewPush(&pView, (--n)>0);\n    sqlite3TreeViewLine(pView, \"FROM\");\n    sqlite3TreeViewSrcList(pView, pTabList);\n    sqlite3TreeViewPop(&pView);\n  }\n  if( pChanges ){\n    sqlite3TreeViewExprList(pView, pChanges, (--n)>0, \"SET\");\n  }\n  if( pWhere ){\n    sqlite3TreeViewPush(&pView, (--n)>0);\n    sqlite3TreeViewLine(pView, \"WHERE\");\n    sqlite3TreeViewExpr(pView, pWhere, 0);\n    sqlite3TreeViewPop(&pView);\n  }\n  if( pOrderBy ){\n    sqlite3TreeViewExprList(pView, pOrderBy, (--n)>0, \"ORDER-BY\");\n  }\n  if( pLimit ){\n    sqlite3TreeViewPush(&pView, (--n)>0);\n    sqlite3TreeViewLine(pView, \"LIMIT\");\n    sqlite3TreeViewExpr(pView, pLimit, 0);\n    sqlite3TreeViewPop(&pView);\n  }\n  if( pUpsert ){\n    sqlite3TreeViewPush(&pView, (--n)>0);\n    sqlite3TreeViewLine(pView, \"UPSERT\");\n    sqlite3TreeViewUpsert(pView, pUpsert, 0);\n    sqlite3TreeViewPop(&pView);\n  }\n  if( pTrigger ){\n    sqlite3TreeViewTrigger(pView, pTrigger, (--n)>0, 1);\n  }\n  sqlite3TreeViewPop(&pView);\n}\n#endif /* TREETRACE_ENABLED */\n\n#ifndef SQLITE_OMIT_TRIGGER\n/*\n** Show a human-readable graph of a TriggerStep\n*/\nvoid sqlite3TreeViewTriggerStep(\n  TreeView *pView,\n  const TriggerStep *pStep,\n  u8 moreToFollow,\n  u8 showFullList\n){\n  int cnt = 0;\n  if( pStep==0 ) return;\n  sqlite3TreeViewPush(&pView, \n      moreToFollow || (showFullList && pStep->pNext!=0));\n  do{\n    if( cnt++ && pStep->pNext==0 ){\n      sqlite3TreeViewPop(&pView);\n      sqlite3TreeViewPush(&pView, 0);\n    }\n    sqlite3TreeViewLine(pView, \"%s\", pStep->zSpan ? pStep->zSpan : \"RETURNING\");\n  }while( showFullList && (pStep = pStep->pNext)!=0 );\n  sqlite3TreeViewPop(&pView);\n}\n  \n/*\n** Show a human-readable graph of a Trigger\n*/\nvoid sqlite3TreeViewTrigger(\n  TreeView *pView,\n  const Trigger *pTrigger,\n  u8 moreToFollow,\n  u8 showFullList\n){\n  int cnt = 0;\n  if( pTrigger==0 ) return;\n  sqlite3TreeViewPush(&pView,\n     moreToFollow || (showFullList && pTrigger->pNext!=0));\n  do{\n    if( cnt++ && pTrigger->pNext==0 ){\n      sqlite3TreeViewPop(&pView);\n      sqlite3TreeViewPush(&pView, 0);\n    }\n    sqlite3TreeViewLine(pView, \"TRIGGER %s\", pTrigger->zName);\n    sqlite3TreeViewPush(&pView, 0);\n    sqlite3TreeViewTriggerStep(pView, pTrigger->step_list, 0, 1);\n    sqlite3TreeViewPop(&pView);\n  }while( showFullList && (pTrigger = pTrigger->pNext)!=0 );\n  sqlite3TreeViewPop(&pView);\n}\n#endif /* SQLITE_OMIT_TRIGGER */\n  \n\n/*\n** These simplified versions of the tree-view routines omit unnecessary\n** parameters.  These variants are intended to be used from a symbolic\n** debugger, such as \"gdb\", during interactive debugging sessions.\n**\n** This routines are given external linkage so that they will always be\n** accessible to the debugging, and to avoid warnings about unused\n** functions.  But these routines only exist in debugging builds, so they\n** do not contaminate the interface.\n**\n** See Also:\n**\n**     sqlite3ShowWhereTerm() in where.c\n*/\nvoid sqlite3ShowExpr(const Expr *p){ sqlite3TreeViewExpr(0,p,0); }\nvoid sqlite3ShowExprList(const ExprList *p){ sqlite3TreeViewExprList(0,p,0,0);}\nvoid sqlite3ShowIdList(const IdList *p){ sqlite3TreeViewIdList(0,p,0,0); }\nvoid sqlite3ShowSrcList(const SrcList *p){\n  TreeView *pView = 0;\n  sqlite3TreeViewPush(&pView, 0);\n  sqlite3TreeViewLine(pView, \"SRCLIST\");\n  sqlite3TreeViewSrcList(pView,p);\n  sqlite3TreeViewPop(&pView);\n}\nvoid sqlite3ShowSelect(const Select *p){ sqlite3TreeViewSelect(0,p,0); }\nvoid sqlite3ShowWith(const With *p){ sqlite3TreeViewWith(0,p,0); }\nvoid sqlite3ShowUpsert(const Upsert *p){ sqlite3TreeViewUpsert(0,p,0); }\n#ifndef SQLITE_OMIT_TRIGGER\nvoid sqlite3ShowTriggerStep(const TriggerStep *p){\n  sqlite3TreeViewTriggerStep(0,p,0,0);\n}\nvoid sqlite3ShowTriggerStepList(const TriggerStep *p){\n  sqlite3TreeViewTriggerStep(0,p,0,1);\n}\nvoid sqlite3ShowTrigger(const Trigger *p){ sqlite3TreeViewTrigger(0,p,0,0); }\nvoid sqlite3ShowTriggerList(const Trigger *p){ sqlite3TreeViewTrigger(0,p,0,1);}\n#endif\n#ifndef SQLITE_OMIT_WINDOWFUNC\nvoid sqlite3ShowWindow(const Window *p){ sqlite3TreeViewWindow(0,p,0); }\nvoid sqlite3ShowWinFunc(const Window *p){ sqlite3TreeViewWinFunc(0,p,0); }\n#endif\n\n#endif /* SQLITE_DEBUG */\n"}
{"repo": "sqlite", "file": "sqlite3ext.h", "lang": "C++", "code": "/*\n** 2006 June 7\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This header file defines the SQLite interface for use by\n** shared libraries that want to be imported as extensions into\n** an SQLite instance.  Shared libraries that intend to be loaded\n** as extensions by SQLite should #include this file instead of \n** sqlite3.h.\n*/\n#ifndef SQLITE3EXT_H\n#define SQLITE3EXT_H\n#include \"sqlite3.h\"\n\n/*\n** The following structure holds pointers to all of the SQLite API\n** routines.\n**\n** WARNING:  In order to maintain backwards compatibility, add new\n** interfaces to the end of this structure only.  If you insert new\n** interfaces in the middle of this structure, then older different\n** versions of SQLite will not be able to load each other's shared\n** libraries!\n*/\nstruct sqlite3_api_routines {\n  void * (*aggregate_context)(sqlite3_context*,int nBytes);\n  int  (*aggregate_count)(sqlite3_context*);\n  int  (*bind_blob)(sqlite3_stmt*,int,const void*,int n,void(*)(void*));\n  int  (*bind_double)(sqlite3_stmt*,int,double);\n  int  (*bind_int)(sqlite3_stmt*,int,int);\n  int  (*bind_int64)(sqlite3_stmt*,int,sqlite_int64);\n  int  (*bind_null)(sqlite3_stmt*,int);\n  int  (*bind_parameter_count)(sqlite3_stmt*);\n  int  (*bind_parameter_index)(sqlite3_stmt*,const char*zName);\n  const char * (*bind_parameter_name)(sqlite3_stmt*,int);\n  int  (*bind_text)(sqlite3_stmt*,int,const char*,int n,void(*)(void*));\n  int  (*bind_text16)(sqlite3_stmt*,int,const void*,int,void(*)(void*));\n  int  (*bind_value)(sqlite3_stmt*,int,const sqlite3_value*);\n  int  (*busy_handler)(sqlite3*,int(*)(void*,int),void*);\n  int  (*busy_timeout)(sqlite3*,int ms);\n  int  (*changes)(sqlite3*);\n  int  (*close)(sqlite3*);\n  int  (*collation_needed)(sqlite3*,void*,void(*)(void*,sqlite3*,\n                           int eTextRep,const char*));\n  int  (*collation_needed16)(sqlite3*,void*,void(*)(void*,sqlite3*,\n                             int eTextRep,const void*));\n  const void * (*column_blob)(sqlite3_stmt*,int iCol);\n  int  (*column_bytes)(sqlite3_stmt*,int iCol);\n  int  (*column_bytes16)(sqlite3_stmt*,int iCol);\n  int  (*column_count)(sqlite3_stmt*pStmt);\n  const char * (*column_database_name)(sqlite3_stmt*,int);\n  const void * (*column_database_name16)(sqlite3_stmt*,int);\n  const char * (*column_decltype)(sqlite3_stmt*,int i);\n  const void * (*column_decltype16)(sqlite3_stmt*,int);\n  double  (*column_double)(sqlite3_stmt*,int iCol);\n  int  (*column_int)(sqlite3_stmt*,int iCol);\n  sqlite_int64  (*column_int64)(sqlite3_stmt*,int iCol);\n  const char * (*column_name)(sqlite3_stmt*,int);\n  const void * (*column_name16)(sqlite3_stmt*,int);\n  const char * (*column_origin_name)(sqlite3_stmt*,int);\n  const void * (*column_origin_name16)(sqlite3_stmt*,int);\n  const char * (*column_table_name)(sqlite3_stmt*,int);\n  const void * (*column_table_name16)(sqlite3_stmt*,int);\n  const unsigned char * (*column_text)(sqlite3_stmt*,int iCol);\n  const void * (*column_text16)(sqlite3_stmt*,int iCol);\n  int  (*column_type)(sqlite3_stmt*,int iCol);\n  sqlite3_value* (*column_value)(sqlite3_stmt*,int iCol);\n  void * (*commit_hook)(sqlite3*,int(*)(void*),void*);\n  int  (*complete)(const char*sql);\n  int  (*complete16)(const void*sql);\n  int  (*create_collation)(sqlite3*,const char*,int,void*,\n                           int(*)(void*,int,const void*,int,const void*));\n  int  (*create_collation16)(sqlite3*,const void*,int,void*,\n                             int(*)(void*,int,const void*,int,const void*));\n  int  (*create_function)(sqlite3*,const char*,int,int,void*,\n                          void (*xFunc)(sqlite3_context*,int,sqlite3_value**),\n                          void (*xStep)(sqlite3_context*,int,sqlite3_value**),\n                          void (*xFinal)(sqlite3_context*));\n  int  (*create_function16)(sqlite3*,const void*,int,int,void*,\n                            void (*xFunc)(sqlite3_context*,int,sqlite3_value**),\n                            void (*xStep)(sqlite3_context*,int,sqlite3_value**),\n                            void (*xFinal)(sqlite3_context*));\n  int (*create_module)(sqlite3*,const char*,const sqlite3_module*,void*);\n  int  (*data_count)(sqlite3_stmt*pStmt);\n  sqlite3 * (*db_handle)(sqlite3_stmt*);\n  int (*declare_vtab)(sqlite3*,const char*);\n  int  (*enable_shared_cache)(int);\n  int  (*errcode)(sqlite3*db);\n  const char * (*errmsg)(sqlite3*);\n  const void * (*errmsg16)(sqlite3*);\n  int  (*exec)(sqlite3*,const char*,sqlite3_callback,void*,char**);\n  int  (*expired)(sqlite3_stmt*);\n  int  (*finalize)(sqlite3_stmt*pStmt);\n  void  (*free)(void*);\n  void  (*free_table)(char**result);\n  int  (*get_autocommit)(sqlite3*);\n  void * (*get_auxdata)(sqlite3_context*,int);\n  int  (*get_table)(sqlite3*,const char*,char***,int*,int*,char**);\n  int  (*global_recover)(void);\n  void  (*interruptx)(sqlite3*);\n  sqlite_int64  (*last_insert_rowid)(sqlite3*);\n  const char * (*libversion)(void);\n  int  (*libversion_number)(void);\n  void *(*malloc)(int);\n  char * (*mprintf)(const char*,...);\n  int  (*open)(const char*,sqlite3**);\n  int  (*open16)(const void*,sqlite3**);\n  int  (*prepare)(sqlite3*,const char*,int,sqlite3_stmt**,const char**);\n  int  (*prepare16)(sqlite3*,const void*,int,sqlite3_stmt**,const void**);\n  void * (*profile)(sqlite3*,void(*)(void*,const char*,sqlite_uint64),void*);\n  void  (*progress_handler)(sqlite3*,int,int(*)(void*),void*);\n  void *(*realloc)(void*,int);\n  int  (*reset)(sqlite3_stmt*pStmt);\n  void  (*result_blob)(sqlite3_context*,const void*,int,void(*)(void*));\n  void  (*result_double)(sqlite3_context*,double);\n  void  (*result_error)(sqlite3_context*,const char*,int);\n  void  (*result_error16)(sqlite3_context*,const void*,int);\n  void  (*result_int)(sqlite3_context*,int);\n  void  (*result_int64)(sqlite3_context*,sqlite_int64);\n  void  (*result_null)(sqlite3_context*);\n  void  (*result_text)(sqlite3_context*,const char*,int,void(*)(void*));\n  void  (*result_text16)(sqlite3_context*,const void*,int,void(*)(void*));\n  void  (*result_text16be)(sqlite3_context*,const void*,int,void(*)(void*));\n  void  (*result_text16le)(sqlite3_context*,const void*,int,void(*)(void*));\n  void  (*result_value)(sqlite3_context*,sqlite3_value*);\n  void * (*rollback_hook)(sqlite3*,void(*)(void*),void*);\n  int  (*set_authorizer)(sqlite3*,int(*)(void*,int,const char*,const char*,\n                         const char*,const char*),void*);\n  void  (*set_auxdata)(sqlite3_context*,int,void*,void (*)(void*));\n  char * (*xsnprintf)(int,char*,const char*,...);\n  int  (*step)(sqlite3_stmt*);\n  int  (*table_column_metadata)(sqlite3*,const char*,const char*,const char*,\n                                char const**,char const**,int*,int*,int*);\n  void  (*thread_cleanup)(void);\n  int  (*total_changes)(sqlite3*);\n  void * (*trace)(sqlite3*,void(*xTrace)(void*,const char*),void*);\n  int  (*transfer_bindings)(sqlite3_stmt*,sqlite3_stmt*);\n  void * (*update_hook)(sqlite3*,void(*)(void*,int ,char const*,char const*,\n                                         sqlite_int64),void*);\n  void * (*user_data)(sqlite3_context*);\n  const void * (*value_blob)(sqlite3_value*);\n  int  (*value_bytes)(sqlite3_value*);\n  int  (*value_bytes16)(sqlite3_value*);\n  double  (*value_double)(sqlite3_value*);\n  int  (*value_int)(sqlite3_value*);\n  sqlite_int64  (*value_int64)(sqlite3_value*);\n  int  (*value_numeric_type)(sqlite3_value*);\n  const unsigned char * (*value_text)(sqlite3_value*);\n  const void * (*value_text16)(sqlite3_value*);\n  const void * (*value_text16be)(sqlite3_value*);\n  const void * (*value_text16le)(sqlite3_value*);\n  int  (*value_type)(sqlite3_value*);\n  char *(*vmprintf)(const char*,va_list);\n  /* Added ??? */\n  int (*overload_function)(sqlite3*, const char *zFuncName, int nArg);\n  /* Added by 3.3.13 */\n  int (*prepare_v2)(sqlite3*,const char*,int,sqlite3_stmt**,const char**);\n  int (*prepare16_v2)(sqlite3*,const void*,int,sqlite3_stmt**,const void**);\n  int (*clear_bindings)(sqlite3_stmt*);\n  /* Added by 3.4.1 */\n  int (*create_module_v2)(sqlite3*,const char*,const sqlite3_module*,void*,\n                          void (*xDestroy)(void *));\n  /* Added by 3.5.0 */\n  int (*bind_zeroblob)(sqlite3_stmt*,int,int);\n  int (*blob_bytes)(sqlite3_blob*);\n  int (*blob_close)(sqlite3_blob*);\n  int (*blob_open)(sqlite3*,const char*,const char*,const char*,sqlite3_int64,\n                   int,sqlite3_blob**);\n  int (*blob_read)(sqlite3_blob*,void*,int,int);\n  int (*blob_write)(sqlite3_blob*,const void*,int,int);\n  int (*create_collation_v2)(sqlite3*,const char*,int,void*,\n                             int(*)(void*,int,const void*,int,const void*),\n                             void(*)(void*));\n  int (*file_control)(sqlite3*,const char*,int,void*);\n  sqlite3_int64 (*memory_highwater)(int);\n  sqlite3_int64 (*memory_used)(void);\n  sqlite3_mutex *(*mutex_alloc)(int);\n  void (*mutex_enter)(sqlite3_mutex*);\n  void (*mutex_free)(sqlite3_mutex*);\n  void (*mutex_leave)(sqlite3_mutex*);\n  int (*mutex_try)(sqlite3_mutex*);\n  int (*open_v2)(const char*,sqlite3**,int,const char*);\n  int (*release_memory)(int);\n  void (*result_error_nomem)(sqlite3_context*);\n  void (*result_error_toobig)(sqlite3_context*);\n  int (*sleep)(int);\n  void (*soft_heap_limit)(int);\n  sqlite3_vfs *(*vfs_find)(const char*);\n  int (*vfs_register)(sqlite3_vfs*,int);\n  int (*vfs_unregister)(sqlite3_vfs*);\n  int (*xthreadsafe)(void);\n  void (*result_zeroblob)(sqlite3_context*,int);\n  void (*result_error_code)(sqlite3_context*,int);\n  int (*test_control)(int, ...);\n  void (*randomness)(int,void*);\n  sqlite3 *(*context_db_handle)(sqlite3_context*);\n  int (*extended_result_codes)(sqlite3*,int);\n  int (*limit)(sqlite3*,int,int);\n  sqlite3_stmt *(*next_stmt)(sqlite3*,sqlite3_stmt*);\n  const char *(*sql)(sqlite3_stmt*);\n  int (*status)(int,int*,int*,int);\n  int (*backup_finish)(sqlite3_backup*);\n  sqlite3_backup *(*backup_init)(sqlite3*,const char*,sqlite3*,const char*);\n  int (*backup_pagecount)(sqlite3_backup*);\n  int (*backup_remaining)(sqlite3_backup*);\n  int (*backup_step)(sqlite3_backup*,int);\n  const char *(*compileoption_get)(int);\n  int (*compileoption_used)(const char*);\n  int (*create_function_v2)(sqlite3*,const char*,int,int,void*,\n                            void (*xFunc)(sqlite3_context*,int,sqlite3_value**),\n                            void (*xStep)(sqlite3_context*,int,sqlite3_value**),\n                            void (*xFinal)(sqlite3_context*),\n                            void(*xDestroy)(void*));\n  int (*db_config)(sqlite3*,int,...);\n  sqlite3_mutex *(*db_mutex)(sqlite3*);\n  int (*db_status)(sqlite3*,int,int*,int*,int);\n  int (*extended_errcode)(sqlite3*);\n  void (*log)(int,const char*,...);\n  sqlite3_int64 (*soft_heap_limit64)(sqlite3_int64);\n  const char *(*sourceid)(void);\n  int (*stmt_status)(sqlite3_stmt*,int,int);\n  int (*strnicmp)(const char*,const char*,int);\n  int (*unlock_notify)(sqlite3*,void(*)(void**,int),void*);\n  int (*wal_autocheckpoint)(sqlite3*,int);\n  int (*wal_checkpoint)(sqlite3*,const char*);\n  void *(*wal_hook)(sqlite3*,int(*)(void*,sqlite3*,const char*,int),void*);\n  int (*blob_reopen)(sqlite3_blob*,sqlite3_int64);\n  int (*vtab_config)(sqlite3*,int op,...);\n  int (*vtab_on_conflict)(sqlite3*);\n  /* Version 3.7.16 and later */\n  int (*close_v2)(sqlite3*);\n  const char *(*db_filename)(sqlite3*,const char*);\n  int (*db_readonly)(sqlite3*,const char*);\n  int (*db_release_memory)(sqlite3*);\n  const char *(*errstr)(int);\n  int (*stmt_busy)(sqlite3_stmt*);\n  int (*stmt_readonly)(sqlite3_stmt*);\n  int (*stricmp)(const char*,const char*);\n  int (*uri_boolean)(const char*,const char*,int);\n  sqlite3_int64 (*uri_int64)(const char*,const char*,sqlite3_int64);\n  const char *(*uri_parameter)(const char*,const char*);\n  char *(*xvsnprintf)(int,char*,const char*,va_list);\n  int (*wal_checkpoint_v2)(sqlite3*,const char*,int,int*,int*);\n  /* Version 3.8.7 and later */\n  int (*auto_extension)(void(*)(void));\n  int (*bind_blob64)(sqlite3_stmt*,int,const void*,sqlite3_uint64,\n                     void(*)(void*));\n  int (*bind_text64)(sqlite3_stmt*,int,const char*,sqlite3_uint64,\n                      void(*)(void*),unsigned char);\n  int (*cancel_auto_extension)(void(*)(void));\n  int (*load_extension)(sqlite3*,const char*,const char*,char**);\n  void *(*malloc64)(sqlite3_uint64);\n  sqlite3_uint64 (*msize)(void*);\n  void *(*realloc64)(void*,sqlite3_uint64);\n  void (*reset_auto_extension)(void);\n  void (*result_blob64)(sqlite3_context*,const void*,sqlite3_uint64,\n                        void(*)(void*));\n  void (*result_text64)(sqlite3_context*,const char*,sqlite3_uint64,\n                         void(*)(void*), unsigned char);\n  int (*strglob)(const char*,const char*);\n  /* Version 3.8.11 and later */\n  sqlite3_value *(*value_dup)(const sqlite3_value*);\n  void (*value_free)(sqlite3_value*);\n  int (*result_zeroblob64)(sqlite3_context*,sqlite3_uint64);\n  int (*bind_zeroblob64)(sqlite3_stmt*, int, sqlite3_uint64);\n  /* Version 3.9.0 and later */\n  unsigned int (*value_subtype)(sqlite3_value*);\n  void (*result_subtype)(sqlite3_context*,unsigned int);\n  /* Version 3.10.0 and later */\n  int (*status64)(int,sqlite3_int64*,sqlite3_int64*,int);\n  int (*strlike)(const char*,const char*,unsigned int);\n  int (*db_cacheflush)(sqlite3*);\n  /* Version 3.12.0 and later */\n  int (*system_errno)(sqlite3*);\n  /* Version 3.14.0 and later */\n  int (*trace_v2)(sqlite3*,unsigned,int(*)(unsigned,void*,void*,void*),void*);\n  char *(*expanded_sql)(sqlite3_stmt*);\n  /* Version 3.18.0 and later */\n  void (*set_last_insert_rowid)(sqlite3*,sqlite3_int64);\n  /* Version 3.20.0 and later */\n  int (*prepare_v3)(sqlite3*,const char*,int,unsigned int,\n                    sqlite3_stmt**,const char**);\n  int (*prepare16_v3)(sqlite3*,const void*,int,unsigned int,\n                      sqlite3_stmt**,const void**);\n  int (*bind_pointer)(sqlite3_stmt*,int,void*,const char*,void(*)(void*));\n  void (*result_pointer)(sqlite3_context*,void*,const char*,void(*)(void*));\n  void *(*value_pointer)(sqlite3_value*,const char*);\n  int (*vtab_nochange)(sqlite3_context*);\n  int (*value_nochange)(sqlite3_value*);\n  const char *(*vtab_collation)(sqlite3_index_info*,int);\n  /* Version 3.24.0 and later */\n  int (*keyword_count)(void);\n  int (*keyword_name)(int,const char**,int*);\n  int (*keyword_check)(const char*,int);\n  sqlite3_str *(*str_new)(sqlite3*);\n  char *(*str_finish)(sqlite3_str*);\n  void (*str_appendf)(sqlite3_str*, const char *zFormat, ...);\n  void (*str_vappendf)(sqlite3_str*, const char *zFormat, va_list);\n  void (*str_append)(sqlite3_str*, const char *zIn, int N);\n  void (*str_appendall)(sqlite3_str*, const char *zIn);\n  void (*str_appendchar)(sqlite3_str*, int N, char C);\n  void (*str_reset)(sqlite3_str*);\n  int (*str_errcode)(sqlite3_str*);\n  int (*str_length)(sqlite3_str*);\n  char *(*str_value)(sqlite3_str*);\n  /* Version 3.25.0 and later */\n  int (*create_window_function)(sqlite3*,const char*,int,int,void*,\n                            void (*xStep)(sqlite3_context*,int,sqlite3_value**),\n                            void (*xFinal)(sqlite3_context*),\n                            void (*xValue)(sqlite3_context*),\n                            void (*xInv)(sqlite3_context*,int,sqlite3_value**),\n                            void(*xDestroy)(void*));\n  /* Version 3.26.0 and later */\n  const char *(*normalized_sql)(sqlite3_stmt*);\n  /* Version 3.28.0 and later */\n  int (*stmt_isexplain)(sqlite3_stmt*);\n  int (*value_frombind)(sqlite3_value*);\n  /* Version 3.30.0 and later */\n  int (*drop_modules)(sqlite3*,const char**);\n  /* Version 3.31.0 and later */\n  sqlite3_int64 (*hard_heap_limit64)(sqlite3_int64);\n  const char *(*uri_key)(const char*,int);\n  const char *(*filename_database)(const char*);\n  const char *(*filename_journal)(const char*);\n  const char *(*filename_wal)(const char*);\n  /* Version 3.32.0 and later */\n  const char *(*create_filename)(const char*,const char*,const char*,\n                           int,const char**);\n  void (*free_filename)(const char*);\n  sqlite3_file *(*database_file_object)(const char*);\n  /* Version 3.34.0 and later */\n  int (*txn_state)(sqlite3*,const char*);\n  /* Version 3.36.1 and later */\n  sqlite3_int64 (*changes64)(sqlite3*);\n  sqlite3_int64 (*total_changes64)(sqlite3*);\n  /* Version 3.37.0 and later */\n  int (*autovacuum_pages)(sqlite3*,\n     unsigned int(*)(void*,const char*,unsigned int,unsigned int,unsigned int),\n     void*, void(*)(void*));\n  /* Version 3.38.0 and later */\n  int (*error_offset)(sqlite3*);\n  int (*vtab_rhs_value)(sqlite3_index_info*,int,sqlite3_value**);\n  int (*vtab_distinct)(sqlite3_index_info*);\n  int (*vtab_in)(sqlite3_index_info*,int,int);\n  int (*vtab_in_first)(sqlite3_value*,sqlite3_value**);\n  int (*vtab_in_next)(sqlite3_value*,sqlite3_value**);\n  /* Version 3.39.0 and later */\n  int (*deserialize)(sqlite3*,const char*,unsigned char*,\n                     sqlite3_int64,sqlite3_int64,unsigned);\n  unsigned char *(*serialize)(sqlite3*,const char *,sqlite3_int64*,\n                              unsigned int);\n  const char *(*db_name)(sqlite3*,int);\n  /* Version 3.40.0 and later */\n  int (*value_encoding)(sqlite3_value*);\n  /* Version 3.41.0 and later */\n  int (*is_interrupted)(sqlite3*);\n  /* Version 3.43.0 and later */\n  int (*stmt_explain)(sqlite3_stmt*,int);\n  /* Version 3.44.0 and later */\n  void *(*get_clientdata)(sqlite3*,const char*);\n  int (*set_clientdata)(sqlite3*, const char*, void*, void(*)(void*));\n  /* Version 3.50.0 and later */\n  int (*setlk_timeout)(sqlite3*,int,int);\n  /* Version 3.51.0 and later */\n  int (*set_errmsg)(sqlite3*,int,const char*);\n  int (*db_status64)(sqlite3*,int,sqlite3_int64*,sqlite3_int64*,int);\n  /* Version 3.52.0 and later */\n  void (*str_truncate)(sqlite3_str*,int);\n  void (*str_free)(sqlite3_str*);\n  int (*carray_bind)(sqlite3_stmt*,int,void*,int,int,void(*)(void*));\n  int (*carray_bind_v2)(sqlite3_stmt*,int,void*,int,int,void(*)(void*),void*);\n};\n\n/*\n** This is the function signature used for all extension entry points.  It\n** is also defined in the file \"loadext.c\".\n*/\ntypedef int (*sqlite3_loadext_entry)(\n  sqlite3 *db,                       /* Handle to the database. */\n  char **pzErrMsg,                   /* Used to set error string on failure. */\n  const sqlite3_api_routines *pThunk /* Extension API function pointers. */\n);\n\n/*\n** The following macros redefine the API routines so that they are\n** redirected through the global sqlite3_api structure.\n**\n** This header file is also used by the loadext.c source file\n** (part of the main SQLite library - not an extension) so that\n** it can get access to the sqlite3_api_routines structure\n** definition.  But the main library does not want to redefine\n** the API.  So the redefinition macros are only valid if the\n** SQLITE_CORE macros is undefined.\n*/\n#if !defined(SQLITE_CORE) && !defined(SQLITE_OMIT_LOAD_EXTENSION)\n#define sqlite3_aggregate_context      sqlite3_api->aggregate_context\n#ifndef SQLITE_OMIT_DEPRECATED\n#define sqlite3_aggregate_count        sqlite3_api->aggregate_count\n#endif\n#define sqlite3_bind_blob              sqlite3_api->bind_blob\n#define sqlite3_bind_double            sqlite3_api->bind_double\n#define sqlite3_bind_int               sqlite3_api->bind_int\n#define sqlite3_bind_int64             sqlite3_api->bind_int64\n#define sqlite3_bind_null              sqlite3_api->bind_null\n#define sqlite3_bind_parameter_count   sqlite3_api->bind_parameter_count\n#define sqlite3_bind_parameter_index   sqlite3_api->bind_parameter_index\n#define sqlite3_bind_parameter_name    sqlite3_api->bind_parameter_name\n#define sqlite3_bind_text              sqlite3_api->bind_text\n#define sqlite3_bind_text16            sqlite3_api->bind_text16\n#define sqlite3_bind_value             sqlite3_api->bind_value\n#define sqlite3_busy_handler           sqlite3_api->busy_handler\n#define sqlite3_busy_timeout           sqlite3_api->busy_timeout\n#define sqlite3_changes                sqlite3_api->changes\n#define sqlite3_close                  sqlite3_api->close\n#define sqlite3_collation_needed       sqlite3_api->collation_needed\n#define sqlite3_collation_needed16     sqlite3_api->collation_needed16\n#define sqlite3_column_blob            sqlite3_api->column_blob\n#define sqlite3_column_bytes           sqlite3_api->column_bytes\n#define sqlite3_column_bytes16         sqlite3_api->column_bytes16\n#define sqlite3_column_count           sqlite3_api->column_count\n#define sqlite3_column_database_name   sqlite3_api->column_database_name\n#define sqlite3_column_database_name16 sqlite3_api->column_database_name16\n#define sqlite3_column_decltype        sqlite3_api->column_decltype\n#define sqlite3_column_decltype16      sqlite3_api->column_decltype16\n#define sqlite3_column_double          sqlite3_api->column_double\n#define sqlite3_column_int             sqlite3_api->column_int\n#define sqlite3_column_int64           sqlite3_api->column_int64\n#define sqlite3_column_name            sqlite3_api->column_name\n#define sqlite3_column_name16          sqlite3_api->column_name16\n#define sqlite3_column_origin_name     sqlite3_api->column_origin_name\n#define sqlite3_column_origin_name16   sqlite3_api->column_origin_name16\n#define sqlite3_column_table_name      sqlite3_api->column_table_name\n#define sqlite3_column_table_name16    sqlite3_api->column_table_name16\n#define sqlite3_column_text            sqlite3_api->column_text\n#define sqlite3_column_text16          sqlite3_api->column_text16\n#define sqlite3_column_type            sqlite3_api->column_type\n#define sqlite3_column_value           sqlite3_api->column_value\n#define sqlite3_commit_hook            sqlite3_api->commit_hook\n#define sqlite3_complete               sqlite3_api->complete\n#define sqlite3_complete16             sqlite3_api->complete16\n#define sqlite3_create_collation       sqlite3_api->create_collation\n#define sqlite3_create_collation16     sqlite3_api->create_collation16\n#define sqlite3_create_function        sqlite3_api->create_function\n#define sqlite3_create_function16      sqlite3_api->create_function16\n#define sqlite3_create_module          sqlite3_api->create_module\n#define sqlite3_create_module_v2       sqlite3_api->create_module_v2\n#define sqlite3_data_count             sqlite3_api->data_count\n#define sqlite3_db_handle              sqlite3_api->db_handle\n#define sqlite3_declare_vtab           sqlite3_api->declare_vtab\n#define sqlite3_enable_shared_cache    sqlite3_api->enable_shared_cache\n#define sqlite3_errcode                sqlite3_api->errcode\n#define sqlite3_errmsg                 sqlite3_api->errmsg\n#define sqlite3_errmsg16               sqlite3_api->errmsg16\n#define sqlite3_exec                   sqlite3_api->exec\n#ifndef SQLITE_OMIT_DEPRECATED\n#define sqlite3_expired                sqlite3_api->expired\n#endif\n#define sqlite3_finalize               sqlite3_api->finalize\n#define sqlite3_free                   sqlite3_api->free\n#define sqlite3_free_table             sqlite3_api->free_table\n#define sqlite3_get_autocommit         sqlite3_api->get_autocommit\n#define sqlite3_get_auxdata            sqlite3_api->get_auxdata\n#define sqlite3_get_table              sqlite3_api->get_table\n#ifndef SQLITE_OMIT_DEPRECATED\n#define sqlite3_global_recover         sqlite3_api->global_recover\n#endif\n#define sqlite3_interrupt              sqlite3_api->interruptx\n#define sqlite3_last_insert_rowid      sqlite3_api->last_insert_rowid\n#define sqlite3_libversion             sqlite3_api->libversion\n#define sqlite3_libversion_number      sqlite3_api->libversion_number\n#define sqlite3_malloc                 sqlite3_api->malloc\n#define sqlite3_mprintf                sqlite3_api->mprintf\n#define sqlite3_open                   sqlite3_api->open\n#define sqlite3_open16                 sqlite3_api->open16\n#define sqlite3_prepare                sqlite3_api->prepare\n#define sqlite3_prepare16              sqlite3_api->prepare16\n#define sqlite3_prepare_v2             sqlite3_api->prepare_v2\n#define sqlite3_prepare16_v2           sqlite3_api->prepare16_v2\n#define sqlite3_profile                sqlite3_api->profile\n#define sqlite3_progress_handler       sqlite3_api->progress_handler\n#define sqlite3_realloc                sqlite3_api->realloc\n#define sqlite3_reset                  sqlite3_api->reset\n#define sqlite3_result_blob            sqlite3_api->result_blob\n#define sqlite3_result_double          sqlite3_api->result_double\n#define sqlite3_result_error           sqlite3_api->result_error\n#define sqlite3_result_error16         sqlite3_api->result_error16\n#define sqlite3_result_int             sqlite3_api->result_int\n#define sqlite3_result_int64           sqlite3_api->result_int64\n#define sqlite3_result_null            sqlite3_api->result_null\n#define sqlite3_result_text            sqlite3_api->result_text\n#define sqlite3_result_text16          sqlite3_api->result_text16\n#define sqlite3_result_text16be        sqlite3_api->result_text16be\n#define sqlite3_result_text16le        sqlite3_api->result_text16le\n#define sqlite3_result_value           sqlite3_api->result_value\n#define sqlite3_rollback_hook          sqlite3_api->rollback_hook\n#define sqlite3_set_authorizer         sqlite3_api->set_authorizer\n#define sqlite3_set_auxdata            sqlite3_api->set_auxdata\n#define sqlite3_snprintf               sqlite3_api->xsnprintf\n#define sqlite3_step                   sqlite3_api->step\n#define sqlite3_table_column_metadata  sqlite3_api->table_column_metadata\n#define sqlite3_thread_cleanup         sqlite3_api->thread_cleanup\n#define sqlite3_total_changes          sqlite3_api->total_changes\n#define sqlite3_trace                  sqlite3_api->trace\n#ifndef SQLITE_OMIT_DEPRECATED\n#define sqlite3_transfer_bindings      sqlite3_api->transfer_bindings\n#endif\n#define sqlite3_update_hook            sqlite3_api->update_hook\n#define sqlite3_user_data              sqlite3_api->user_data\n#define sqlite3_value_blob             sqlite3_api->value_blob\n#define sqlite3_value_bytes            sqlite3_api->value_bytes\n#define sqlite3_value_bytes16          sqlite3_api->value_bytes16\n#define sqlite3_value_double           sqlite3_api->value_double\n#define sqlite3_value_int              sqlite3_api->value_int\n#define sqlite3_value_int64            sqlite3_api->value_int64\n#define sqlite3_value_numeric_type     sqlite3_api->value_numeric_type\n#define sqlite3_value_text             sqlite3_api->value_text\n#define sqlite3_value_text16           sqlite3_api->value_text16\n#define sqlite3_value_text16be         sqlite3_api->value_text16be\n#define sqlite3_value_text16le         sqlite3_api->value_text16le\n#define sqlite3_value_type             sqlite3_api->value_type\n#define sqlite3_vmprintf               sqlite3_api->vmprintf\n#define sqlite3_vsnprintf              sqlite3_api->xvsnprintf\n#define sqlite3_overload_function      sqlite3_api->overload_function\n#define sqlite3_prepare_v2             sqlite3_api->prepare_v2\n#define sqlite3_prepare16_v2           sqlite3_api->prepare16_v2\n#define sqlite3_clear_bindings         sqlite3_api->clear_bindings\n#define sqlite3_bind_zeroblob          sqlite3_api->bind_zeroblob\n#define sqlite3_blob_bytes             sqlite3_api->blob_bytes\n#define sqlite3_blob_close             sqlite3_api->blob_close\n#define sqlite3_blob_open              sqlite3_api->blob_open\n#define sqlite3_blob_read              sqlite3_api->blob_read\n#define sqlite3_blob_write             sqlite3_api->blob_write\n#define sqlite3_create_collation_v2    sqlite3_api->create_collation_v2\n#define sqlite3_file_control           sqlite3_api->file_control\n#define sqlite3_memory_highwater       sqlite3_api->memory_highwater\n#define sqlite3_memory_used            sqlite3_api->memory_used\n#define sqlite3_mutex_alloc            sqlite3_api->mutex_alloc\n#define sqlite3_mutex_enter            sqlite3_api->mutex_enter\n#define sqlite3_mutex_free             sqlite3_api->mutex_free\n#define sqlite3_mutex_leave            sqlite3_api->mutex_leave\n#define sqlite3_mutex_try              sqlite3_api->mutex_try\n#define sqlite3_open_v2                sqlite3_api->open_v2\n#define sqlite3_release_memory         sqlite3_api->release_memory\n#define sqlite3_result_error_nomem     sqlite3_api->result_error_nomem\n#define sqlite3_result_error_toobig    sqlite3_api->result_error_toobig\n#define sqlite3_sleep                  sqlite3_api->sleep\n#define sqlite3_soft_heap_limit        sqlite3_api->soft_heap_limit\n#define sqlite3_vfs_find               sqlite3_api->vfs_find\n#define sqlite3_vfs_register           sqlite3_api->vfs_register\n#define sqlite3_vfs_unregister         sqlite3_api->vfs_unregister\n#define sqlite3_threadsafe             sqlite3_api->xthreadsafe\n#define sqlite3_result_zeroblob        sqlite3_api->result_zeroblob\n#define sqlite3_result_error_code      sqlite3_api->result_error_code\n#define sqlite3_test_control           sqlite3_api->test_control\n#define sqlite3_randomness             sqlite3_api->randomness\n#define sqlite3_context_db_handle      sqlite3_api->context_db_handle\n#define sqlite3_extended_result_codes  sqlite3_api->extended_result_codes\n#define sqlite3_limit                  sqlite3_api->limit\n#define sqlite3_next_stmt              sqlite3_api->next_stmt\n#define sqlite3_sql                    sqlite3_api->sql\n#define sqlite3_status                 sqlite3_api->status\n#define sqlite3_backup_finish          sqlite3_api->backup_finish\n#define sqlite3_backup_init            sqlite3_api->backup_init\n#define sqlite3_backup_pagecount       sqlite3_api->backup_pagecount\n#define sqlite3_backup_remaining       sqlite3_api->backup_remaining\n#define sqlite3_backup_step            sqlite3_api->backup_step\n#define sqlite3_compileoption_get      sqlite3_api->compileoption_get\n#define sqlite3_compileoption_used     sqlite3_api->compileoption_used\n#define sqlite3_create_function_v2     sqlite3_api->create_function_v2\n#define sqlite3_db_config              sqlite3_api->db_config\n#define sqlite3_db_mutex               sqlite3_api->db_mutex\n#define sqlite3_db_status              sqlite3_api->db_status\n#define sqlite3_extended_errcode       sqlite3_api->extended_errcode\n#define sqlite3_log                    sqlite3_api->log\n#define sqlite3_soft_heap_limit64      sqlite3_api->soft_heap_limit64\n#define sqlite3_sourceid               sqlite3_api->sourceid\n#define sqlite3_stmt_status            sqlite3_api->stmt_status\n#define sqlite3_strnicmp               sqlite3_api->strnicmp\n#define sqlite3_unlock_notify          sqlite3_api->unlock_notify\n#define sqlite3_wal_autocheckpoint     sqlite3_api->wal_autocheckpoint\n#define sqlite3_wal_checkpoint         sqlite3_api->wal_checkpoint\n#define sqlite3_wal_hook               sqlite3_api->wal_hook\n#define sqlite3_blob_reopen            sqlite3_api->blob_reopen\n#define sqlite3_vtab_config            sqlite3_api->vtab_config\n#define sqlite3_vtab_on_conflict       sqlite3_api->vtab_on_conflict\n/* Version 3.7.16 and later */\n#define sqlite3_close_v2               sqlite3_api->close_v2\n#define sqlite3_db_filename            sqlite3_api->db_filename\n#define sqlite3_db_readonly            sqlite3_api->db_readonly\n#define sqlite3_db_release_memory      sqlite3_api->db_release_memory\n#define sqlite3_errstr                 sqlite3_api->errstr\n#define sqlite3_stmt_busy              sqlite3_api->stmt_busy\n#define sqlite3_stmt_readonly          sqlite3_api->stmt_readonly\n#define sqlite3_stricmp                sqlite3_api->stricmp\n#define sqlite3_uri_boolean            sqlite3_api->uri_boolean\n#define sqlite3_uri_int64              sqlite3_api->uri_int64\n#define sqlite3_uri_parameter          sqlite3_api->uri_parameter\n#define sqlite3_uri_vsnprintf          sqlite3_api->xvsnprintf\n#define sqlite3_wal_checkpoint_v2      sqlite3_api->wal_checkpoint_v2\n/* Version 3.8.7 and later */\n#define sqlite3_auto_extension         sqlite3_api->auto_extension\n#define sqlite3_bind_blob64            sqlite3_api->bind_blob64\n#define sqlite3_bind_text64            sqlite3_api->bind_text64\n#define sqlite3_cancel_auto_extension  sqlite3_api->cancel_auto_extension\n#define sqlite3_load_extension         sqlite3_api->load_extension\n#define sqlite3_malloc64               sqlite3_api->malloc64\n#define sqlite3_msize                  sqlite3_api->msize\n#define sqlite3_realloc64              sqlite3_api->realloc64\n#define sqlite3_reset_auto_extension   sqlite3_api->reset_auto_extension\n#define sqlite3_result_blob64          sqlite3_api->result_blob64\n#define sqlite3_result_text64          sqlite3_api->result_text64\n#define sqlite3_strglob                sqlite3_api->strglob\n/* Version 3.8.11 and later */\n#define sqlite3_value_dup              sqlite3_api->value_dup\n#define sqlite3_value_free             sqlite3_api->value_free\n#define sqlite3_result_zeroblob64      sqlite3_api->result_zeroblob64\n#define sqlite3_bind_zeroblob64        sqlite3_api->bind_zeroblob64\n/* Version 3.9.0 and later */\n#define sqlite3_value_subtype          sqlite3_api->value_subtype\n#define sqlite3_result_subtype         sqlite3_api->result_subtype\n/* Version 3.10.0 and later */\n#define sqlite3_status64               sqlite3_api->status64\n#define sqlite3_strlike                sqlite3_api->strlike\n#define sqlite3_db_cacheflush          sqlite3_api->db_cacheflush\n/* Version 3.12.0 and later */\n#define sqlite3_system_errno           sqlite3_api->system_errno\n/* Version 3.14.0 and later */\n#define sqlite3_trace_v2               sqlite3_api->trace_v2\n#define sqlite3_expanded_sql           sqlite3_api->expanded_sql\n/* Version 3.18.0 and later */\n#define sqlite3_set_last_insert_rowid  sqlite3_api->set_last_insert_rowid\n/* Version 3.20.0 and later */\n#define sqlite3_prepare_v3             sqlite3_api->prepare_v3\n#define sqlite3_prepare16_v3           sqlite3_api->prepare16_v3\n#define sqlite3_bind_pointer           sqlite3_api->bind_pointer\n#define sqlite3_result_pointer         sqlite3_api->result_pointer\n#define sqlite3_value_pointer          sqlite3_api->value_pointer\n/* Version 3.22.0 and later */\n#define sqlite3_vtab_nochange          sqlite3_api->vtab_nochange\n#define sqlite3_value_nochange         sqlite3_api->value_nochange\n#define sqlite3_vtab_collation         sqlite3_api->vtab_collation\n/* Version 3.24.0 and later */\n#define sqlite3_keyword_count          sqlite3_api->keyword_count\n#define sqlite3_keyword_name           sqlite3_api->keyword_name\n#define sqlite3_keyword_check          sqlite3_api->keyword_check\n#define sqlite3_str_new                sqlite3_api->str_new\n#define sqlite3_str_finish             sqlite3_api->str_finish\n#define sqlite3_str_appendf            sqlite3_api->str_appendf\n#define sqlite3_str_vappendf           sqlite3_api->str_vappendf\n#define sqlite3_str_append             sqlite3_api->str_append\n#define sqlite3_str_appendall          sqlite3_api->str_appendall\n#define sqlite3_str_appendchar         sqlite3_api->str_appendchar\n#define sqlite3_str_reset              sqlite3_api->str_reset\n#define sqlite3_str_errcode            sqlite3_api->str_errcode\n#define sqlite3_str_length             sqlite3_api->str_length\n#define sqlite3_str_value              sqlite3_api->str_value\n/* Version 3.25.0 and later */\n#define sqlite3_create_window_function sqlite3_api->create_window_function\n/* Version 3.26.0 and later */\n#define sqlite3_normalized_sql         sqlite3_api->normalized_sql\n/* Version 3.28.0 and later */\n#define sqlite3_stmt_isexplain         sqlite3_api->stmt_isexplain\n#define sqlite3_value_frombind         sqlite3_api->value_frombind\n/* Version 3.30.0 and later */\n#define sqlite3_drop_modules           sqlite3_api->drop_modules\n/* Version 3.31.0 and later */\n#define sqlite3_hard_heap_limit64      sqlite3_api->hard_heap_limit64\n#define sqlite3_uri_key                sqlite3_api->uri_key\n#define sqlite3_filename_database      sqlite3_api->filename_database\n#define sqlite3_filename_journal       sqlite3_api->filename_journal\n#define sqlite3_filename_wal           sqlite3_api->filename_wal\n/* Version 3.32.0 and later */\n#define sqlite3_create_filename        sqlite3_api->create_filename\n#define sqlite3_free_filename          sqlite3_api->free_filename\n#define sqlite3_database_file_object   sqlite3_api->database_file_object\n/* Version 3.34.0 and later */\n#define sqlite3_txn_state              sqlite3_api->txn_state\n/* Version 3.36.1 and later */\n#define sqlite3_changes64              sqlite3_api->changes64\n#define sqlite3_total_changes64        sqlite3_api->total_changes64\n/* Version 3.37.0 and later */\n#define sqlite3_autovacuum_pages       sqlite3_api->autovacuum_pages\n/* Version 3.38.0 and later */\n#define sqlite3_error_offset           sqlite3_api->error_offset\n#define sqlite3_vtab_rhs_value         sqlite3_api->vtab_rhs_value\n#define sqlite3_vtab_distinct          sqlite3_api->vtab_distinct\n#define sqlite3_vtab_in                sqlite3_api->vtab_in\n#define sqlite3_vtab_in_first          sqlite3_api->vtab_in_first\n#define sqlite3_vtab_in_next           sqlite3_api->vtab_in_next\n/* Version 3.39.0 and later */\n#ifndef SQLITE_OMIT_DESERIALIZE\n#define sqlite3_deserialize            sqlite3_api->deserialize\n#define sqlite3_serialize              sqlite3_api->serialize\n#endif\n#define sqlite3_db_name                sqlite3_api->db_name\n/* Version 3.40.0 and later */\n#define sqlite3_value_encoding         sqlite3_api->value_encoding\n/* Version 3.41.0 and later */\n#define sqlite3_is_interrupted         sqlite3_api->is_interrupted\n/* Version 3.43.0 and later */\n#define sqlite3_stmt_explain           sqlite3_api->stmt_explain\n/* Version 3.44.0 and later */\n#define sqlite3_get_clientdata         sqlite3_api->get_clientdata\n#define sqlite3_set_clientdata         sqlite3_api->set_clientdata\n/* Version 3.50.0 and later */\n#define sqlite3_setlk_timeout          sqlite3_api->setlk_timeout\n/* Version 3.51.0 and later */\n#define sqlite3_set_errmsg             sqlite3_api->set_errmsg\n#define sqlite3_db_status64            sqlite3_api->db_status64\n/* Version 3.52.0 and later */\n#define sqlite3_str_truncate           sqlite3_api->str_truncate\n#define sqlite3_str_free               sqlite3_api->str_free\n#define sqlite3_carray_bind            sqlite3_api->carray_bind\n#define sqlite3_carray_bind_v2         sqlite3_api->carray_bind_v2\n#endif /* !defined(SQLITE_CORE) && !defined(SQLITE_OMIT_LOAD_EXTENSION) */\n\n#if !defined(SQLITE_CORE) && !defined(SQLITE_OMIT_LOAD_EXTENSION)\n  /* This case when the file really is being compiled as a loadable \n  ** extension */\n# define SQLITE_EXTENSION_INIT1     const sqlite3_api_routines *sqlite3_api=0;\n# define SQLITE_EXTENSION_INIT2(v)  sqlite3_api=v;\n# define SQLITE_EXTENSION_INIT3     \\\n    extern const sqlite3_api_routines *sqlite3_api;\n#else\n  /* This case when the file is being statically linked into the \n  ** application */\n# define SQLITE_EXTENSION_INIT1     /*no-op*/\n# define SQLITE_EXTENSION_INIT2(v)  (void)v; /* unused parameter */\n# define SQLITE_EXTENSION_INIT3     /*no-op*/\n#endif\n\n#endif /* SQLITE3EXT_H */\n"}
{"repo": "sqlite", "file": "mem2.c", "lang": "C++", "code": "/*\n** 2007 August 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains low-level memory allocation drivers for when\n** SQLite will use the standard C-library malloc/realloc/free interface\n** to obtain the memory it needs while adding lots of additional debugging\n** information to each allocation in order to help detect and fix memory\n** leaks and memory usage errors.\n**\n** This file contains implementations of the low-level memory allocation\n** routines specified in the sqlite3_mem_methods object.\n*/\n#include \"sqliteInt.h\"\n\n/*\n** This version of the memory allocator is used only if the\n** SQLITE_MEMDEBUG macro is defined\n*/\n#ifdef SQLITE_MEMDEBUG\n\n/*\n** The backtrace functionality is only available with GLIBC\n*/\n#ifdef __GLIBC__\n  extern int backtrace(void**,int);\n  extern void backtrace_symbols_fd(void*const*,int,int);\n#else\n# define backtrace(A,B) 1\n# define backtrace_symbols_fd(A,B,C)\n#endif\n#include <stdio.h>\n\n/*\n** Each memory allocation looks like this:\n**\n**  ------------------------------------------------------------------------\n**  | Title |  backtrace pointers |  MemBlockHdr |  allocation |  EndGuard |\n**  ------------------------------------------------------------------------\n**\n** The application code sees only a pointer to the allocation.  We have\n** to back up from the allocation pointer to find the MemBlockHdr.  The\n** MemBlockHdr tells us the size of the allocation and the number of\n** backtrace pointers.  There is also a guard word at the end of the\n** MemBlockHdr.\n*/\nstruct MemBlockHdr {\n  i64 iSize;                          /* Size of this allocation */\n  struct MemBlockHdr *pNext, *pPrev;  /* Linked list of all unfreed memory */\n  char nBacktrace;                    /* Number of backtraces on this alloc */\n  char nBacktraceSlots;               /* Available backtrace slots */\n  u8 nTitle;                          /* Bytes of title; includes '\\0' */\n  u8 eType;                           /* Allocation type code */\n  int iForeGuard;                     /* Guard word for sanity */\n};\n\n/*\n** Guard words\n*/\n#define FOREGUARD 0x80F5E153\n#define REARGUARD 0xE4676B53\n\n/*\n** Number of malloc size increments to track.\n*/\n#define NCSIZE  1000\n\n/*\n** All of the static variables used by this module are collected\n** into a single structure named \"mem\".  This is to keep the\n** static variables organized and to reduce namespace pollution\n** when this module is combined with other in the amalgamation.\n*/\nstatic struct {\n  \n  /*\n  ** Mutex to control access to the memory allocation subsystem.\n  */\n  sqlite3_mutex *mutex;\n\n  /*\n  ** Head and tail of a linked list of all outstanding allocations\n  */\n  struct MemBlockHdr *pFirst;\n  struct MemBlockHdr *pLast;\n  \n  /*\n  ** The number of levels of backtrace to save in new allocations.\n  */\n  int nBacktrace;\n  void (*xBacktrace)(int, int, void **);\n\n  /*\n  ** Title text to insert in front of each block\n  */\n  int nTitle;        /* Bytes of zTitle to save.  Includes '\\0' and padding */\n  char zTitle[100];  /* The title text */\n\n  /* \n  ** sqlite3MallocDisallow() increments the following counter.\n  ** sqlite3MallocAllow() decrements it.\n  */\n  int disallow; /* Do not allow memory allocation */\n\n  /*\n  ** Gather statistics on the sizes of memory allocations.\n  ** nAlloc[i] is the number of allocation attempts of i*8\n  ** bytes.  i==NCSIZE is the number of allocation attempts for\n  ** sizes more than NCSIZE*8 bytes.\n  */\n  int nAlloc[NCSIZE];      /* Total number of allocations */\n  int nCurrent[NCSIZE];    /* Current number of allocations */\n  int mxCurrent[NCSIZE];   /* Highwater mark for nCurrent */\n\n} mem;\n\n\n/*\n** Adjust memory usage statistics\n*/\nstatic void adjustStats(int iSize, int increment){\n  int i = ROUND8(iSize)/8;\n  if( i>NCSIZE-1 ){\n    i = NCSIZE - 1;\n  }\n  if( increment>0 ){\n    mem.nAlloc[i]++;\n    mem.nCurrent[i]++;\n    if( mem.nCurrent[i]>mem.mxCurrent[i] ){\n      mem.mxCurrent[i] = mem.nCurrent[i];\n    }\n  }else{\n    mem.nCurrent[i]--;\n    assert( mem.nCurrent[i]>=0 );\n  }\n}\n\n/*\n** Given an allocation, find the MemBlockHdr for that allocation.\n**\n** This routine checks the guards at either end of the allocation and\n** if they are incorrect it asserts.\n*/\nstatic struct MemBlockHdr *sqlite3MemsysGetHeader(const void *pAllocation){\n  struct MemBlockHdr *p;\n  int *pInt;\n  u8 *pU8;\n  int nReserve;\n\n  p = (struct MemBlockHdr*)pAllocation;\n  p--;\n  assert( p->iForeGuard==(int)FOREGUARD );\n  nReserve = ROUND8(p->iSize);\n  pInt = (int*)pAllocation;\n  pU8 = (u8*)pAllocation;\n  assert( pInt[nReserve/sizeof(int)]==(int)REARGUARD );\n  /* This checks any of the \"extra\" bytes allocated due\n  ** to rounding up to an 8 byte boundary to ensure \n  ** they haven't been overwritten.\n  */\n  while( nReserve-- > p->iSize ) assert( pU8[nReserve]==0x65 );\n  return p;\n}\n\n/*\n** Return the number of bytes currently allocated at address p.\n*/\nstatic int sqlite3MemSize(void *p){\n  struct MemBlockHdr *pHdr;\n  if( !p ){\n    return 0;\n  }\n  pHdr = sqlite3MemsysGetHeader(p);\n  return (int)pHdr->iSize;\n}\n\n/*\n** Initialize the memory allocation subsystem.\n*/\nstatic int sqlite3MemInit(void *NotUsed){\n  UNUSED_PARAMETER(NotUsed);\n  assert( (sizeof(struct MemBlockHdr)&7) == 0 );\n  if( !sqlite3GlobalConfig.bMemstat ){\n    /* If memory status is enabled, then the malloc.c wrapper will already\n    ** hold the STATIC_MEM mutex when the routines here are invoked. */\n    mem.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Deinitialize the memory allocation subsystem.\n*/\nstatic void sqlite3MemShutdown(void *NotUsed){\n  UNUSED_PARAMETER(NotUsed);\n  mem.mutex = 0;\n}\n\n/*\n** Round up a request size to the next valid allocation size.\n*/\nstatic int sqlite3MemRoundup(int n){\n  return ROUND8(n);\n}\n\n/*\n** Fill a buffer with pseudo-random bytes.  This is used to preset\n** the content of a new memory allocation to unpredictable values and\n** to clear the content of a freed allocation to unpredictable values.\n*/\nstatic void randomFill(char *pBuf, int nByte){\n  unsigned int x, y, r;\n  x = SQLITE_PTR_TO_INT(pBuf);\n  y = nByte | 1;\n  while( nByte >= 4 ){\n    x = (x>>1) ^ (-(int)(x&1) & 0xd0000001);\n    y = y*1103515245 + 12345;\n    r = x ^ y;\n    *(int*)pBuf = r;\n    pBuf += 4;\n    nByte -= 4;\n  }\n  while( nByte-- > 0 ){\n    x = (x>>1) ^ (-(int)(x&1) & 0xd0000001);\n    y = y*1103515245 + 12345;\n    r = x ^ y;\n    *(pBuf++) = r & 0xff;\n  }\n}\n\n/*\n** Allocate nByte bytes of memory.\n*/\nstatic void *sqlite3MemMalloc(int nByte){\n  struct MemBlockHdr *pHdr;\n  void **pBt;\n  char *z;\n  int *pInt;\n  void *p = 0;\n  int totalSize;\n  int nReserve;\n  sqlite3_mutex_enter(mem.mutex);\n  assert( mem.disallow==0 );\n  nReserve = ROUND8(nByte);\n  totalSize = nReserve + sizeof(*pHdr) + sizeof(int) +\n               mem.nBacktrace*sizeof(void*) + mem.nTitle;\n  p = malloc(totalSize);\n  if( p ){\n    z = p;\n    pBt = (void**)&z[mem.nTitle];\n    pHdr = (struct MemBlockHdr*)&pBt[mem.nBacktrace];\n    pHdr->pNext = 0;\n    pHdr->pPrev = mem.pLast;\n    if( mem.pLast ){\n      mem.pLast->pNext = pHdr;\n    }else{\n      mem.pFirst = pHdr;\n    }\n    mem.pLast = pHdr;\n    pHdr->iForeGuard = FOREGUARD;\n    pHdr->eType = MEMTYPE_HEAP;\n    pHdr->nBacktraceSlots = mem.nBacktrace;\n    pHdr->nTitle = mem.nTitle;\n    if( mem.nBacktrace ){\n      void *aAddr[40];\n      pHdr->nBacktrace = backtrace(aAddr, mem.nBacktrace+1)-1;\n      memcpy(pBt, &aAddr[1], pHdr->nBacktrace*sizeof(void*));\n      assert(pBt[0]);\n      if( mem.xBacktrace ){\n        mem.xBacktrace(nByte, pHdr->nBacktrace-1, &aAddr[1]);\n      }\n    }else{\n      pHdr->nBacktrace = 0;\n    }\n    if( mem.nTitle ){\n      memcpy(z, mem.zTitle, mem.nTitle);\n    }\n    pHdr->iSize = nByte;\n    adjustStats(nByte, +1);\n    pInt = (int*)&pHdr[1];\n    pInt[nReserve/sizeof(int)] = REARGUARD;\n    randomFill((char*)pInt, nByte);\n    memset(((char*)pInt)+nByte, 0x65, nReserve-nByte);\n    p = (void*)pInt;\n  }\n  sqlite3_mutex_leave(mem.mutex);\n  return p; \n}\n\n/*\n** Free memory.\n*/\nstatic void sqlite3MemFree(void *pPrior){\n  struct MemBlockHdr *pHdr;\n  void **pBt;\n  char *z;\n  assert( sqlite3GlobalConfig.bMemstat || sqlite3GlobalConfig.bCoreMutex==0 \n       || mem.mutex!=0 );\n  pHdr = sqlite3MemsysGetHeader(pPrior);\n  pBt = (void**)pHdr;\n  pBt -= pHdr->nBacktraceSlots;\n  sqlite3_mutex_enter(mem.mutex);\n  if( pHdr->pPrev ){\n    assert( pHdr->pPrev->pNext==pHdr );\n    pHdr->pPrev->pNext = pHdr->pNext;\n  }else{\n    assert( mem.pFirst==pHdr );\n    mem.pFirst = pHdr->pNext;\n  }\n  if( pHdr->pNext ){\n    assert( pHdr->pNext->pPrev==pHdr );\n    pHdr->pNext->pPrev = pHdr->pPrev;\n  }else{\n    assert( mem.pLast==pHdr );\n    mem.pLast = pHdr->pPrev;\n  }\n  z = (char*)pBt;\n  z -= pHdr->nTitle;\n  adjustStats((int)pHdr->iSize, -1);\n  randomFill(z, sizeof(void*)*pHdr->nBacktraceSlots + sizeof(*pHdr) +\n                (int)pHdr->iSize + sizeof(int) + pHdr->nTitle);\n  free(z);\n  sqlite3_mutex_leave(mem.mutex);  \n}\n\n/*\n** Change the size of an existing memory allocation.\n**\n** For this debugging implementation, we *always* make a copy of the\n** allocation into a new place in memory.  In this way, if the \n** higher level code is using pointer to the old allocation, it is \n** much more likely to break and we are much more liking to find\n** the error.\n*/\nstatic void *sqlite3MemRealloc(void *pPrior, int nByte){\n  struct MemBlockHdr *pOldHdr;\n  void *pNew;\n  assert( mem.disallow==0 );\n  assert( (nByte & 7)==0 );     /* EV: R-46199-30249 */\n  pOldHdr = sqlite3MemsysGetHeader(pPrior);\n  pNew = sqlite3MemMalloc(nByte);\n  if( pNew ){\n    memcpy(pNew, pPrior, (int)(nByte<pOldHdr->iSize ? nByte : pOldHdr->iSize));\n    if( nByte>pOldHdr->iSize ){\n      randomFill(&((char*)pNew)[pOldHdr->iSize], nByte - (int)pOldHdr->iSize);\n    }\n    sqlite3MemFree(pPrior);\n  }\n  return pNew;\n}\n\n/*\n** Populate the low-level memory allocation function pointers in\n** sqlite3GlobalConfig.m with pointers to the routines in this file.\n*/\nvoid sqlite3MemSetDefault(void){\n  static const sqlite3_mem_methods defaultMethods = {\n     sqlite3MemMalloc,\n     sqlite3MemFree,\n     sqlite3MemRealloc,\n     sqlite3MemSize,\n     sqlite3MemRoundup,\n     sqlite3MemInit,\n     sqlite3MemShutdown,\n     0\n  };\n  sqlite3_config(SQLITE_CONFIG_MALLOC, &defaultMethods);\n}\n\n/*\n** Set the \"type\" of an allocation.\n*/\nvoid sqlite3MemdebugSetType(void *p, u8 eType){\n  if( p && sqlite3GlobalConfig.m.xFree==sqlite3MemFree ){\n    struct MemBlockHdr *pHdr;\n    pHdr = sqlite3MemsysGetHeader(p);\n    assert( pHdr->iForeGuard==FOREGUARD );\n    pHdr->eType = eType;\n  }\n}\n\n/*\n** Return TRUE if the mask of type in eType matches the type of the\n** allocation p.  Also return true if p==NULL.\n**\n** This routine is designed for use within an assert() statement, to\n** verify the type of an allocation.  For example:\n**\n**     assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );\n*/\nint sqlite3MemdebugHasType(const void *p, u8 eType){\n  int rc = 1;\n  if( p && sqlite3GlobalConfig.m.xFree==sqlite3MemFree ){\n    struct MemBlockHdr *pHdr;\n    pHdr = sqlite3MemsysGetHeader(p);\n    assert( pHdr->iForeGuard==FOREGUARD );         /* Allocation is valid */\n    if( (pHdr->eType&eType)==0 ){\n      rc = 0;\n    }\n  }\n  return rc;\n}\n\n/*\n** Return TRUE if the mask of type in eType matches no bits of the type of the\n** allocation p.  Also return true if p==NULL.\n**\n** This routine is designed for use within an assert() statement, to\n** verify the type of an allocation.  For example:\n**\n**     assert( sqlite3MemdebugNoType(p, MEMTYPE_LOOKASIDE) );\n*/\nint sqlite3MemdebugNoType(const void *p, u8 eType){\n  int rc = 1;\n  if( p && sqlite3GlobalConfig.m.xFree==sqlite3MemFree ){\n    struct MemBlockHdr *pHdr;\n    pHdr = sqlite3MemsysGetHeader(p);\n    assert( pHdr->iForeGuard==FOREGUARD );         /* Allocation is valid */\n    if( (pHdr->eType&eType)!=0 ){\n      rc = 0;\n    }\n  }\n  return rc;\n}\n\n/*\n** Set the number of backtrace levels kept for each allocation.\n** A value of zero turns off backtracing.  The number is always rounded\n** up to a multiple of 2.\n*/\nvoid sqlite3MemdebugBacktrace(int depth){\n  if( depth<0 ){ depth = 0; }\n  if( depth>20 ){ depth = 20; }\n  depth = (depth+1)&0xfe;\n  mem.nBacktrace = depth;\n}\n\nvoid sqlite3MemdebugBacktraceCallback(void (*xBacktrace)(int, int, void **)){\n  mem.xBacktrace = xBacktrace;\n}\n\n/*\n** Set the title string for subsequent allocations.\n*/\nvoid sqlite3MemdebugSettitle(const char *zTitle){\n  unsigned int n = sqlite3Strlen30(zTitle) + 1;\n  sqlite3_mutex_enter(mem.mutex);\n  if( n>=sizeof(mem.zTitle) ) n = sizeof(mem.zTitle)-1;\n  memcpy(mem.zTitle, zTitle, n);\n  mem.zTitle[n] = 0;\n  mem.nTitle = ROUND8(n);\n  sqlite3_mutex_leave(mem.mutex);\n}\n\nvoid sqlite3MemdebugSync(){\n  struct MemBlockHdr *pHdr;\n  for(pHdr=mem.pFirst; pHdr; pHdr=pHdr->pNext){\n    void **pBt = (void**)pHdr;\n    pBt -= pHdr->nBacktraceSlots;\n    mem.xBacktrace((int)pHdr->iSize, pHdr->nBacktrace-1, &pBt[1]);\n  }\n}\n\n/*\n** Open the file indicated and write a log of all unfreed memory \n** allocations into that log.\n*/\nvoid sqlite3MemdebugDump(const char *zFilename){\n  FILE *out;\n  struct MemBlockHdr *pHdr;\n  void **pBt;\n  int i;\n  out = fopen(zFilename, \"w\");\n  if( out==0 ){\n    fprintf(stderr, \"** Unable to output memory debug output log: %s **\\n\",\n                    zFilename);\n    return;\n  }\n  for(pHdr=mem.pFirst; pHdr; pHdr=pHdr->pNext){\n    char *z = (char*)pHdr;\n    z -= pHdr->nBacktraceSlots*sizeof(void*) + pHdr->nTitle;\n    fprintf(out, \"**** %lld bytes at %p from %s ****\\n\", \n            pHdr->iSize, &pHdr[1], pHdr->nTitle ? z : \"???\");\n    if( pHdr->nBacktrace ){\n      fflush(out);\n      pBt = (void**)pHdr;\n      pBt -= pHdr->nBacktraceSlots;\n      backtrace_symbols_fd(pBt, pHdr->nBacktrace, fileno(out));\n      fprintf(out, \"\\n\");\n    }\n  }\n  fprintf(out, \"COUNTS:\\n\");\n  for(i=0; i<NCSIZE-1; i++){\n    if( mem.nAlloc[i] ){\n      fprintf(out, \"   %5d: %10d %10d %10d\\n\", \n            i*8, mem.nAlloc[i], mem.nCurrent[i], mem.mxCurrent[i]);\n    }\n  }\n  if( mem.nAlloc[NCSIZE-1] ){\n    fprintf(out, \"   %5d: %10d %10d %10d\\n\",\n             NCSIZE*8-8, mem.nAlloc[NCSIZE-1],\n             mem.nCurrent[NCSIZE-1], mem.mxCurrent[NCSIZE-1]);\n  }\n  fclose(out);\n}\n\n/*\n** Return the number of times sqlite3MemMalloc() has been called.\n*/\nint sqlite3MemdebugMallocCount(){\n  int i;\n  int nTotal = 0;\n  for(i=0; i<NCSIZE; i++){\n    nTotal += mem.nAlloc[i];\n  }\n  return nTotal;\n}\n\n\n#endif /* SQLITE_MEMDEBUG */\n"}
{"repo": "sqlite", "file": "bitvec.c", "lang": "C++", "code": "/*\n** 2008 February 16\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file implements an object that represents a fixed-length\n** bitmap.  Bits are numbered starting with 1.\n**\n** A bitmap is used to record which pages of a database file have been\n** journalled during a transaction, or which pages have the \"dont-write\"\n** property.  Usually only a few pages are meet either condition.\n** So the bitmap is usually sparse and has low cardinality.\n** But sometimes (for example when during a DROP of a large table) most\n** or all of the pages in a database can get journalled.  In those cases,\n** the bitmap becomes dense with high cardinality.  The algorithm needs\n** to handle both cases well.\n**\n** The size of the bitmap is fixed when the object is created.\n**\n** All bits are clear when the bitmap is created.  Individual bits\n** may be set or cleared one at a time.\n**\n** Test operations are about 100 times more common that set operations.\n** Clear operations are exceedingly rare.  There are usually between\n** 5 and 500 set operations per Bitvec object, though the number of sets can\n** sometimes grow into tens of thousands or larger.  The size of the\n** Bitvec object is the number of pages in the database file at the\n** start of a transaction, and is thus usually less than a few thousand,\n** but can be as large as 2 billion for a really big database.\n*/\n#include \"sqliteInt.h\"\n\n/* Size of the Bitvec structure in bytes. */\n#define BITVEC_SZ        512\n\n/* Round the union size down to the nearest pointer boundary, since that's how\n** it will be aligned within the Bitvec struct. */\n#define BITVEC_USIZE \\\n    (((BITVEC_SZ-(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))\n\n/* Type of the array \"element\" for the bitmap representation.\n** Should be a power of 2, and ideally, evenly divide into BITVEC_USIZE.\n** Setting this to the \"natural word\" size of your CPU may improve\n** performance. */\n#define BITVEC_TELEM     u8\n/* Size, in bits, of the bitmap element. */\n#define BITVEC_SZELEM    8\n/* Number of elements in a bitmap array. */\n#define BITVEC_NELEM     (BITVEC_USIZE/sizeof(BITVEC_TELEM))\n/* Number of bits in the bitmap array. */\n#define BITVEC_NBIT      (BITVEC_NELEM*BITVEC_SZELEM)\n\n/* Number of u32 values in hash table. */\n#define BITVEC_NINT      (BITVEC_USIZE/sizeof(u32))\n/* Maximum number of entries in hash table before\n** sub-dividing and re-hashing. */\n#define BITVEC_MXHASH    (BITVEC_NINT/2)\n/* Hashing function for the aHash representation.\n** Empirical testing showed that the *37 multiplier\n** (an arbitrary prime)in the hash function provided\n** no fewer collisions than the no-op *1. */\n#define BITVEC_HASH(X)   (((X)*1)%BITVEC_NINT)\n\n#define BITVEC_NPTR      ((u32)(BITVEC_USIZE/sizeof(Bitvec *)))\n\n\n/*\n** A bitmap is an instance of the following structure.\n**\n** This bitmap records the existence of zero or more bits\n** with values between 1 and iSize, inclusive.\n**\n** There are three possible representations of the bitmap.\n** If iSize<=BITVEC_NBIT, then Bitvec.u.aBitmap[] is a straight\n** bitmap.  The least significant bit is bit 1.\n**\n** If iSize>BITVEC_NBIT and iDivisor==0 then Bitvec.u.aHash[] is\n** a hash table that will hold up to BITVEC_MXHASH distinct values.\n**\n** Otherwise, the value i is redirected into one of BITVEC_NPTR\n** sub-bitmaps pointed to by Bitvec.u.apSub[].  Each subbitmap\n** handles up to iDivisor separate values of i.  apSub[0] holds\n** values between 1 and iDivisor.  apSub[1] holds values between\n** iDivisor+1 and 2*iDivisor.  apSub[N] holds values between\n** N*iDivisor+1 and (N+1)*iDivisor.  Each subbitmap is normalized\n** to hold deal with values between 1 and iDivisor.\n*/\nstruct Bitvec {\n  u32 iSize;      /* Maximum bit index.  Max iSize is 4,294,967,296. */\n  u32 nSet;       /* Number of bits that are set - only valid for aHash\n                  ** element.  Max is BITVEC_NINT.  For BITVEC_SZ of 512,\n                  ** this would be 125. */\n  u32 iDivisor;   /* Number of bits handled by each apSub[] entry. */\n                  /* Should >=0 for apSub element. */\n                  /* Max iDivisor is max(u32) / BITVEC_NPTR + 1.  */\n                  /* For a BITVEC_SZ of 512, this would be 34,359,739. */\n  union {\n    BITVEC_TELEM aBitmap[BITVEC_NELEM];    /* Bitmap representation */\n    u32 aHash[BITVEC_NINT];      /* Hash table representation */\n    Bitvec *apSub[BITVEC_NPTR];  /* Recursive representation */\n  } u;\n};\n\n\n/*\n** Create a new bitmap object able to handle bits between 0 and iSize,\n** inclusive.  Return a pointer to the new object.  Return NULL if\n** malloc fails.\n*/\nBitvec *sqlite3BitvecCreate(u32 iSize){\n  Bitvec *p;\n  assert( sizeof(*p)==BITVEC_SZ );\n  p = sqlite3MallocZero( sizeof(*p) );\n  if( p ){\n    p->iSize = iSize;\n  }\n  return p;\n}\n\n/*\n** Check to see if the i-th bit is set.  Return true or false.\n** If p is NULL (if the bitmap has not been created) or if\n** i is out of range, then return false.\n*/\nint sqlite3BitvecTestNotNull(Bitvec *p, u32 i){\n  assert( p!=0 );\n  i--;\n  if( i>=p->iSize ) return 0;\n  while( p->iDivisor ){\n    u32 bin = i/p->iDivisor;\n    i = i%p->iDivisor;\n    p = p->u.apSub[bin];\n    if (!p) {\n      return 0;\n    }\n  }\n  if( p->iSize<=BITVEC_NBIT ){\n    return (p->u.aBitmap[i/BITVEC_SZELEM] & (1<<(i&(BITVEC_SZELEM-1))))!=0;\n  } else{\n    u32 h = BITVEC_HASH(i++);\n    while( p->u.aHash[h] ){\n      if( p->u.aHash[h]==i ) return 1;\n      h = (h+1) % BITVEC_NINT;\n    }\n    return 0;\n  }\n}\nint sqlite3BitvecTest(Bitvec *p, u32 i){\n  return p!=0 && sqlite3BitvecTestNotNull(p,i);\n}\n\n/*\n** Set the i-th bit.  Return 0 on success and an error code if\n** anything goes wrong.\n**\n** This routine might cause sub-bitmaps to be allocated.  Failing\n** to get the memory needed to hold the sub-bitmap is the only\n** that can go wrong with an insert, assuming p and i are valid.\n**\n** The calling function must ensure that p is a valid Bitvec object\n** and that the value for \"i\" is within range of the Bitvec object.\n** Otherwise the behavior is undefined.\n*/\nint sqlite3BitvecSet(Bitvec *p, u32 i){\n  u32 h;\n  if( p==0 ) return SQLITE_OK;\n  assert( i>0 );\n  assert( i<=p->iSize );\n  i--;\n  while((p->iSize > BITVEC_NBIT) && p->iDivisor) {\n    u32 bin = i/p->iDivisor;\n    i = i%p->iDivisor;\n    if( p->u.apSub[bin]==0 ){\n      p->u.apSub[bin] = sqlite3BitvecCreate( p->iDivisor );\n      if( p->u.apSub[bin]==0 ) return SQLITE_NOMEM_BKPT;\n    }\n    p = p->u.apSub[bin];\n  }\n  if( p->iSize<=BITVEC_NBIT ){\n    p->u.aBitmap[i/BITVEC_SZELEM] |= 1 << (i&(BITVEC_SZELEM-1));\n    return SQLITE_OK;\n  }\n  h = BITVEC_HASH(i++);\n  /* if there wasn't a hash collision, and this doesn't */\n  /* completely fill the hash, then just add it without */\n  /* worrying about sub-dividing and re-hashing. */\n  if( !p->u.aHash[h] ){\n    if (p->nSet<(BITVEC_NINT-1)) {\n      goto bitvec_set_end;\n    } else {\n      goto bitvec_set_rehash;\n    }\n  }\n  /* there was a collision, check to see if it's already */\n  /* in hash, if not, try to find a spot for it */\n  do {\n    if( p->u.aHash[h]==i ) return SQLITE_OK;\n    h++;\n    if( h>=BITVEC_NINT ) h = 0;\n  } while( p->u.aHash[h] );\n  /* we didn't find it in the hash.  h points to the first */\n  /* available free spot. check to see if this is going to */\n  /* make our hash too \"full\".  */\nbitvec_set_rehash:\n  if( p->nSet>=BITVEC_MXHASH ){\n    unsigned int j;\n    int rc;\n    u32 *aiValues = sqlite3StackAllocRaw(0, sizeof(p->u.aHash));\n    if( aiValues==0 ){\n      return SQLITE_NOMEM_BKPT;\n    }else{\n      memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));\n      memset(p->u.apSub, 0, sizeof(p->u.apSub));\n      p->iDivisor = p->iSize/BITVEC_NPTR;\n      if( (p->iSize%BITVEC_NPTR)!=0 ) p->iDivisor++;\n      if( p->iDivisor<BITVEC_NBIT ) p->iDivisor = BITVEC_NBIT;\n      rc = sqlite3BitvecSet(p, i);\n      for(j=0; j<BITVEC_NINT; j++){\n        if( aiValues[j] ) rc |= sqlite3BitvecSet(p, aiValues[j]);\n      }\n      sqlite3StackFree(0, aiValues);\n      return rc;\n    }\n  }\nbitvec_set_end:\n  p->nSet++;\n  p->u.aHash[h] = i;\n  return SQLITE_OK;\n}\n\n/*\n** Clear the i-th bit.\n**\n** pBuf must be a pointer to at least BITVEC_SZ bytes of temporary storage\n** that BitvecClear can use to rebuilt its hash table.\n*/\nvoid sqlite3BitvecClear(Bitvec *p, u32 i, void *pBuf){\n  if( p==0 ) return;\n  assert( i>0 );\n  i--;\n  while( p->iDivisor ){\n    u32 bin = i/p->iDivisor;\n    i = i%p->iDivisor;\n    p = p->u.apSub[bin];\n    if (!p) {\n      return;\n    }\n  }\n  if( p->iSize<=BITVEC_NBIT ){\n    p->u.aBitmap[i/BITVEC_SZELEM] &= ~(BITVEC_TELEM)(1<<(i&(BITVEC_SZELEM-1)));\n  }else{\n    unsigned int j;\n    u32 *aiValues = pBuf;\n    memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));\n    memset(p->u.aHash, 0, sizeof(p->u.aHash));\n    p->nSet = 0;\n    for(j=0; j<BITVEC_NINT; j++){\n      if( aiValues[j] && aiValues[j]!=(i+1) ){\n        u32 h = BITVEC_HASH(aiValues[j]-1);\n        p->nSet++;\n        while( p->u.aHash[h] ){\n          h++;\n          if( h>=BITVEC_NINT ) h = 0;\n        }\n        p->u.aHash[h] = aiValues[j];\n      }\n    }\n  }\n}\n\n/*\n** Destroy a bitmap object.  Reclaim all memory used.\n*/\nvoid sqlite3BitvecDestroy(Bitvec *p){\n  if( p==0 ) return;\n  if( p->iDivisor ){\n    unsigned int i;\n    for(i=0; i<BITVEC_NPTR; i++){\n      sqlite3BitvecDestroy(p->u.apSub[i]);\n    }\n  }\n  sqlite3_free(p);\n}\n\n/*\n** Return the value of the iSize parameter specified when Bitvec *p\n** was created.\n*/\nu32 sqlite3BitvecSize(Bitvec *p){\n  return p->iSize;\n}\n\n#ifdef SQLITE_DEBUG\n/*\n** Show the content of a Bitvec option and its children.  Indent\n** everything by n spaces.  Add x to each bitvec value.\n**\n** From a debugger such as gdb, one can type:\n**\n**    call sqlite3ShowBitvec(p)\n**\n** For some Bitvec p and see a recursive view of the Bitvec's content.\n*/\nstatic void showBitvec(Bitvec *p, int n, unsigned x){\n  int i;\n  if( p==0 ){\n    printf(\"NULL\\n\");\n    return;\n  }\n  printf(\"Bitvec 0x%p iSize=%u\", p, p->iSize);\n  if( p->iSize<=BITVEC_NBIT ){\n    printf(\" bitmap\\n\");\n    printf(\"%*s   bits:\", n, \"\");\n    for(i=1; i<=BITVEC_NBIT; i++){\n      if( sqlite3BitvecTest(p,i) ) printf(\" %u\", x+(unsigned)i);\n    }\n    printf(\"\\n\");\n  }else if( p->iDivisor==0 ){\n    printf(\" hash with %u entries\\n\", p->nSet);\n    printf(\"%*s   bits:\", n, \"\");\n    for(i=0; i<BITVEC_NINT; i++){\n      if( p->u.aHash[i] ) printf(\" %u\", x+(unsigned)p->u.aHash[i]);\n    }\n    printf(\"\\n\");\n  }else{\n    printf(\" sub-bitvec with iDivisor=%u\\n\", p->iDivisor);\n    for(i=0; i<BITVEC_NPTR; i++){\n      if( p->u.apSub[i]==0 ) continue;\n      printf(\"%*s   apSub[%d]=\", n, \"\", i);\n      showBitvec(p->u.apSub[i], n+4, i*p->iDivisor);\n    }\n  }\n}\nvoid sqlite3ShowBitvec(Bitvec *p){\n  showBitvec(p, 0, 0);\n}\n#endif\n\n#ifndef SQLITE_UNTESTABLE\n/*\n** Let V[] be an array of unsigned characters sufficient to hold\n** up to N bits.  Let I be an integer between 0 and N.  0<=I<N.\n** Then the following macros can be used to set, clear, or test\n** individual bits within V.\n*/\n#define SETBIT(V,I)      V[I>>3] |= (1<<(I&7))\n#define CLEARBIT(V,I)    V[I>>3] &= ~(BITVEC_TELEM)(1<<(I&7))\n#define TESTBIT(V,I)     (V[I>>3]&(1<<(I&7)))!=0\n\n\n/*\n** This routine runs an extensive test of the Bitvec code.\n**\n** The input is an array of integers that acts as a program\n** to test the Bitvec.  The integers are opcodes followed\n** by 0, 1, or 3 operands, depending on the opcode.  Another\n** opcode follows immediately after the last operand.\n**\n** There are opcodes numbered starting with 0.  0 is the\n** \"halt\" opcode and causes the test to end.\n**\n**    0          Halt and return the number of errors\n**    1 N S X    Set N bits beginning with S and incrementing by X\n**    2 N S X    Clear N bits beginning with S and incrementing by X\n**    3 N        Set N randomly chosen bits\n**    4 N        Clear N randomly chosen bits\n**    5 N S X    Set N bits from S increment X in array only, not in bitvec\n**    6          Invoice sqlite3ShowBitvec() on the Bitvec object so far\n**    7 X        Show compile-time parameters and the hash of X         \n**\n** The opcodes 1 through 4 perform set and clear operations are performed\n** on both a Bitvec object and on a linear array of bits obtained from malloc.\n** Opcode 5 works on the linear array only, not on the Bitvec.\n** Opcode 5 is used to deliberately induce a fault in order to\n** confirm that error detection works.  Opcodes 6 and greater are\n** state output opcodes.  Opcodes 6 and greater are no-ops unless\n** SQLite has been compiled with SQLITE_DEBUG.\n**\n** At the conclusion of the test the linear array is compared\n** against the Bitvec object.  If there are any differences,\n** an error is returned.  If they are the same, zero is returned.\n**\n** If a memory allocation error occurs, return -1.\n**\n** sz is the size of the Bitvec.  Or if sz is negative, make the size\n** 2*(unsigned)(-sz) and disabled the linear vector check.\n*/\nint sqlite3BitvecBuiltinTest(int sz, int *aOp){\n  Bitvec *pBitvec = 0;\n  unsigned char *pV = 0;\n  int rc = -1;\n  int i, nx, pc, op;\n  void *pTmpSpace;\n\n  /* Allocate the Bitvec to be tested and a linear array of\n  ** bits to act as the reference */\n  if( sz<=0 ){\n    pBitvec = sqlite3BitvecCreate( 2*(unsigned)(-sz) );\n    pV = 0;\n  }else{\n    pBitvec = sqlite3BitvecCreate( sz );\n    pV = sqlite3MallocZero( (7+(i64)sz)/8 + 1 );\n  }\n  pTmpSpace = sqlite3_malloc64(BITVEC_SZ);\n  if( pBitvec==0 || pTmpSpace==0 || (pV==0 && sz>0) ) goto bitvec_end;\n\n  /* NULL pBitvec tests */\n  sqlite3BitvecSet(0, 1);\n  sqlite3BitvecClear(0, 1, pTmpSpace);\n\n  /* Run the program */\n  pc = i = 0;\n  while( (op = aOp[pc])!=0 ){\n    if( op>=6 ){\n#ifdef SQLITE_DEBUG\n      if( op==6 ){\n        sqlite3ShowBitvec(pBitvec);\n      }else if( op==7 ){\n        printf(\"BITVEC_SZ     = %d (%d by sizeof)\\n\",\n               BITVEC_SZ, (int)sizeof(Bitvec));\n        printf(\"BITVEC_USIZE  = %d\\n\", (int)BITVEC_USIZE);\n        printf(\"BITVEC_NELEM  = %d\\n\", (int)BITVEC_NELEM);\n        printf(\"BITVEC_NBIT   = %d\\n\", (int)BITVEC_NBIT);\n        printf(\"BITVEC_NINT   = %d\\n\", (int)BITVEC_NINT);\n        printf(\"BITVEC_MXHASH = %d\\n\", (int)BITVEC_MXHASH);\n        printf(\"BITVEC_NPTR   = %d\\n\", (int)BITVEC_NPTR);\n      }\n#endif\n      pc++;\n      continue;\n    }\n    switch( op ){\n      case 1:\n      case 2:\n      case 5: {\n        nx = 4;\n        i = aOp[pc+2] - 1;\n        aOp[pc+2] += aOp[pc+3];\n        break;\n      }\n      case 3:\n      case 4:\n      default: {\n        nx = 2;\n        sqlite3_randomness(sizeof(i), &i);\n        break;\n      }\n    }\n    if( (--aOp[pc+1]) > 0 ) nx = 0;\n    pc += nx;\n    i = (i & 0x7fffffff)%sz;\n    if( (op & 1)!=0 ){\n      if( pV ) SETBIT(pV, (i+1));\n      if( op!=5 ){\n        if( sqlite3BitvecSet(pBitvec, i+1) ) goto bitvec_end;\n      }\n    }else{\n      if( pV ) CLEARBIT(pV, (i+1));\n      sqlite3BitvecClear(pBitvec, i+1, pTmpSpace);\n    }\n  }\n\n  /* Test to make sure the linear array exactly matches the\n  ** Bitvec object.  Start with the assumption that they do\n  ** match (rc==0).  Change rc to non-zero if a discrepancy\n  ** is found.\n  */\n  if( pV ){\n    rc = sqlite3BitvecTest(0,0) + sqlite3BitvecTest(pBitvec, sz+1)\n            + sqlite3BitvecTest(pBitvec, 0)\n            + (sqlite3BitvecSize(pBitvec) - sz);\n    for(i=1; i<=sz; i++){\n      if( (TESTBIT(pV,i))!=sqlite3BitvecTest(pBitvec,i) ){\n        rc = i;\n        break;\n      }\n    }\n  }else{\n    rc = 0;\n  }\n\n  /* Free allocated structure */\nbitvec_end:\n  sqlite3_free(pTmpSpace);\n  sqlite3_free(pV);\n  sqlite3BitvecDestroy(pBitvec);\n  return rc;\n}\n#endif /* SQLITE_UNTESTABLE */\n"}
{"repo": "sqlite", "file": "memdb.c", "lang": "C++", "code": "/*\n** 2016-09-07\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This file implements an in-memory VFS. A database is held as a contiguous\n** block of memory.\n**\n** This file also implements interface sqlite3_serialize() and\n** sqlite3_deserialize().\n*/\n#include \"sqliteInt.h\"\n#ifndef SQLITE_OMIT_DESERIALIZE\n\n/*\n** Forward declaration of objects used by this utility\n*/\ntypedef struct sqlite3_vfs MemVfs;\ntypedef struct MemFile MemFile;\ntypedef struct MemStore MemStore;\n\n/* Access to a lower-level VFS that (might) implement dynamic loading,\n** access to randomness, etc.\n*/\n#define ORIGVFS(p) ((sqlite3_vfs*)((p)->pAppData))\n\n/* Storage for a memdb file.\n**\n** An memdb object can be shared or separate.  Shared memdb objects can be\n** used by more than one database connection.  Mutexes are used by shared\n** memdb objects to coordinate access.  Separate memdb objects are only\n** connected to a single database connection and do not require additional\n** mutexes.\n**\n** Shared memdb objects have .zFName!=0 and .pMutex!=0.  They are created\n** using \"file:/name?vfs=memdb\".  The first character of the name must be\n** \"/\" or else the object will be a separate memdb object.  All shared\n** memdb objects are stored in memdb_g.apMemStore[] in an arbitrary order.\n**\n** Separate memdb objects are created using a name that does not begin\n** with \"/\" or using sqlite3_deserialize().\n**\n** Access rules for shared MemStore objects:\n**\n**   *  .zFName is initialized when the object is created and afterwards\n**      is unchanged until the object is destroyed.  So it can be accessed\n**      at any time as long as we know the object is not being destroyed,\n**      which means while either the SQLITE_MUTEX_STATIC_VFS1 or\n**      .pMutex is held or the object is not part of memdb_g.apMemStore[].\n**\n**   *  Can .pMutex can only be changed while holding the \n**      SQLITE_MUTEX_STATIC_VFS1 mutex or while the object is not part\n**      of memdb_g.apMemStore[].\n**\n**   *  Other fields can only be changed while holding the .pMutex mutex\n**      or when the .nRef is less than zero and the object is not part of\n**      memdb_g.apMemStore[].\n**\n**   *  The .aData pointer has the added requirement that it can can only\n**      be changed (for resizing) when nMmap is zero.\n**      \n*/\nstruct MemStore {\n  sqlite3_int64 sz;               /* Size of the file */\n  sqlite3_int64 szAlloc;          /* Space allocated to aData */\n  sqlite3_int64 szMax;            /* Maximum allowed size of the file */\n  unsigned char *aData;           /* content of the file */\n  sqlite3_mutex *pMutex;          /* Used by shared stores only */\n  int nMmap;                      /* Number of memory mapped pages */\n  unsigned mFlags;                /* Flags */\n  int nRdLock;                    /* Number of readers */\n  int nWrLock;                    /* Number of writers.  (Always 0 or 1) */\n  int nRef;                       /* Number of users of this MemStore */\n  char *zFName;                   /* The filename for shared stores */\n};\n\n/* An open file */\nstruct MemFile {\n  sqlite3_file base;              /* IO methods */\n  MemStore *pStore;               /* The storage */\n  int eLock;                      /* Most recent lock against this file */\n};\n\n/*\n** File-scope variables for holding the memdb files that are accessible\n** to multiple database connections in separate threads.\n**\n** Must hold SQLITE_MUTEX_STATIC_VFS1 to access any part of this object.\n*/\nstatic struct MemFS {\n  int nMemStore;                  /* Number of shared MemStore objects */\n  MemStore **apMemStore;          /* Array of all shared MemStore objects */\n} memdb_g;\n\n/*\n** Methods for MemFile\n*/\nstatic int memdbClose(sqlite3_file*);\nstatic int memdbRead(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);\nstatic int memdbWrite(sqlite3_file*,const void*,int iAmt, sqlite3_int64 iOfst);\nstatic int memdbTruncate(sqlite3_file*, sqlite3_int64 size);\nstatic int memdbSync(sqlite3_file*, int flags);\nstatic int memdbFileSize(sqlite3_file*, sqlite3_int64 *pSize);\nstatic int memdbLock(sqlite3_file*, int);\nstatic int memdbUnlock(sqlite3_file*, int);\n/* static int memdbCheckReservedLock(sqlite3_file*, int *pResOut);// not used */\nstatic int memdbFileControl(sqlite3_file*, int op, void *pArg);\n/* static int memdbSectorSize(sqlite3_file*); // not used */\nstatic int memdbDeviceCharacteristics(sqlite3_file*);\nstatic int memdbFetch(sqlite3_file*, sqlite3_int64 iOfst, int iAmt, void **pp);\nstatic int memdbUnfetch(sqlite3_file*, sqlite3_int64 iOfst, void *p);\n\n/*\n** Methods for MemVfs\n*/\nstatic int memdbOpen(sqlite3_vfs*, const char *, sqlite3_file*, int , int *);\n/* static int memdbDelete(sqlite3_vfs*, const char *zName, int syncDir); */\nstatic int memdbAccess(sqlite3_vfs*, const char *zName, int flags, int *);\nstatic int memdbFullPathname(sqlite3_vfs*, const char *zName, int, char *zOut);\nstatic void *memdbDlOpen(sqlite3_vfs*, const char *zFilename);\nstatic void memdbDlError(sqlite3_vfs*, int nByte, char *zErrMsg);\nstatic void (*memdbDlSym(sqlite3_vfs *pVfs, void *p, const char*zSym))(void);\nstatic void memdbDlClose(sqlite3_vfs*, void*);\nstatic int memdbRandomness(sqlite3_vfs*, int nByte, char *zOut);\nstatic int memdbSleep(sqlite3_vfs*, int microseconds);\n/* static int memdbCurrentTime(sqlite3_vfs*, double*); */\nstatic int memdbGetLastError(sqlite3_vfs*, int, char *);\nstatic int memdbCurrentTimeInt64(sqlite3_vfs*, sqlite3_int64*);\n\nstatic sqlite3_vfs memdb_vfs = {\n  2,                           /* iVersion */\n  0,                           /* szOsFile (set when registered) */\n  1024,                        /* mxPathname */\n  0,                           /* pNext */\n  \"memdb\",                     /* zName */\n  0,                           /* pAppData (set when registered) */ \n  memdbOpen,                   /* xOpen */\n  0, /* memdbDelete, */        /* xDelete */\n  memdbAccess,                 /* xAccess */\n  memdbFullPathname,           /* xFullPathname */\n  memdbDlOpen,                 /* xDlOpen */\n  memdbDlError,                /* xDlError */\n  memdbDlSym,                  /* xDlSym */\n  memdbDlClose,                /* xDlClose */\n  memdbRandomness,             /* xRandomness */\n  memdbSleep,                  /* xSleep */\n  0, /* memdbCurrentTime, */   /* xCurrentTime */\n  memdbGetLastError,           /* xGetLastError */\n  memdbCurrentTimeInt64,       /* xCurrentTimeInt64 */\n  0,                           /* xSetSystemCall */\n  0,                           /* xGetSystemCall */\n  0,                           /* xNextSystemCall */\n};\n\nstatic const sqlite3_io_methods memdb_io_methods = {\n  3,                              /* iVersion */\n  memdbClose,                      /* xClose */\n  memdbRead,                       /* xRead */\n  memdbWrite,                      /* xWrite */\n  memdbTruncate,                   /* xTruncate */\n  memdbSync,                       /* xSync */\n  memdbFileSize,                   /* xFileSize */\n  memdbLock,                       /* xLock */\n  memdbUnlock,                     /* xUnlock */\n  0, /* memdbCheckReservedLock, */ /* xCheckReservedLock */\n  memdbFileControl,                /* xFileControl */\n  0, /* memdbSectorSize,*/         /* xSectorSize */\n  memdbDeviceCharacteristics,      /* xDeviceCharacteristics */\n  0,                               /* xShmMap */\n  0,                               /* xShmLock */\n  0,                               /* xShmBarrier */\n  0,                               /* xShmUnmap */\n  memdbFetch,                      /* xFetch */\n  memdbUnfetch                     /* xUnfetch */\n};\n\n/*\n** Enter/leave the mutex on a MemStore\n*/\n#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE==0\nstatic void memdbEnter(MemStore *p){\n  UNUSED_PARAMETER(p);\n}\nstatic void memdbLeave(MemStore *p){\n  UNUSED_PARAMETER(p);\n}\n#else\nstatic void memdbEnter(MemStore *p){\n  sqlite3_mutex_enter(p->pMutex);\n}\nstatic void memdbLeave(MemStore *p){\n  sqlite3_mutex_leave(p->pMutex);\n}\n#endif\n\n\n\n/*\n** Close an memdb-file.\n** Free the underlying MemStore object when its refcount drops to zero\n** or less.\n*/\nstatic int memdbClose(sqlite3_file *pFile){\n  MemStore *p = ((MemFile*)pFile)->pStore;\n  if( p->zFName ){\n    int i;\n#ifndef SQLITE_MUTEX_OMIT\n    sqlite3_mutex *pVfsMutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1);\n#endif\n    sqlite3_mutex_enter(pVfsMutex);\n    for(i=0; ALWAYS(i<memdb_g.nMemStore); i++){\n      if( memdb_g.apMemStore[i]==p ){\n        memdbEnter(p);\n        if( p->nRef==1 ){\n          memdb_g.apMemStore[i] = memdb_g.apMemStore[--memdb_g.nMemStore];\n          if( memdb_g.nMemStore==0 ){\n            sqlite3_free(memdb_g.apMemStore);\n            memdb_g.apMemStore = 0;\n          }\n        }\n        break;\n      }\n    }\n    sqlite3_mutex_leave(pVfsMutex);\n  }else{\n    memdbEnter(p);\n  }\n  p->nRef--;\n  if( p->nRef<=0 ){\n    if( p->mFlags & SQLITE_DESERIALIZE_FREEONCLOSE ){\n      sqlite3_free(p->aData);\n    }\n    memdbLeave(p);\n    sqlite3_mutex_free(p->pMutex);\n    sqlite3_free(p);\n  }else{\n    memdbLeave(p);\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Read data from an memdb-file.\n*/\nstatic int memdbRead(\n  sqlite3_file *pFile, \n  void *zBuf, \n  int iAmt, \n  sqlite_int64 iOfst\n){\n  MemStore *p = ((MemFile*)pFile)->pStore;\n  memdbEnter(p);\n  if( iOfst+iAmt>p->sz ){\n    memset(zBuf, 0, iAmt);\n    if( iOfst<p->sz ) memcpy(zBuf, p->aData+iOfst, p->sz - iOfst);\n    memdbLeave(p);\n    return SQLITE_IOERR_SHORT_READ;\n  }\n  memcpy(zBuf, p->aData+iOfst, iAmt);\n  memdbLeave(p);\n  return SQLITE_OK;\n}\n\n/*\n** Try to enlarge the memory allocation to hold at least sz bytes\n*/\nstatic int memdbEnlarge(MemStore *p, sqlite3_int64 newSz){\n  unsigned char *pNew;\n  if( (p->mFlags & SQLITE_DESERIALIZE_RESIZEABLE)==0 || NEVER(p->nMmap>0) ){\n    return SQLITE_FULL;\n  }\n  if( newSz>p->szMax ){\n    return SQLITE_FULL;\n  }\n  newSz *= 2;\n  if( newSz>p->szMax ) newSz = p->szMax;\n  pNew = sqlite3Realloc(p->aData, newSz);\n  if( pNew==0 ) return SQLITE_IOERR_NOMEM;\n  p->aData = pNew;\n  p->szAlloc = newSz;\n  return SQLITE_OK;\n}\n\n/*\n** Write data to an memdb-file.\n*/\nstatic int memdbWrite(\n  sqlite3_file *pFile,\n  const void *z,\n  int iAmt,\n  sqlite_int64 iOfst\n){\n  MemStore *p = ((MemFile*)pFile)->pStore;\n  memdbEnter(p);\n  if( NEVER(p->mFlags & SQLITE_DESERIALIZE_READONLY) ){\n    /* Can't happen: memdbLock() will return SQLITE_READONLY before\n    ** reaching this point */\n    memdbLeave(p);\n    return SQLITE_IOERR_WRITE;\n  }\n  if( iOfst+iAmt>p->sz ){\n    int rc;\n    if( iOfst+iAmt>p->szAlloc\n     && (rc = memdbEnlarge(p, iOfst+iAmt))!=SQLITE_OK\n    ){\n      memdbLeave(p);\n      return rc;\n    }\n    if( iOfst>p->sz ) memset(p->aData+p->sz, 0, iOfst-p->sz);\n    p->sz = iOfst+iAmt;\n  }\n  memcpy(p->aData+iOfst, z, iAmt);\n  memdbLeave(p);\n  return SQLITE_OK;\n}\n\n/*\n** Truncate an memdb-file.\n**\n** In rollback mode (which is always the case for memdb, as it does not\n** support WAL mode) the truncate() method is only used to reduce\n** the size of a file, never to increase the size.\n*/\nstatic int memdbTruncate(sqlite3_file *pFile, sqlite_int64 size){\n  MemStore *p = ((MemFile*)pFile)->pStore;\n  int rc = SQLITE_OK;\n  memdbEnter(p);\n  if( size>p->sz ){\n    /* This can only happen with a corrupt wal mode db */\n    rc = SQLITE_CORRUPT;\n  }else{\n    p->sz = size; \n  }\n  memdbLeave(p);\n  return rc;\n}\n\n/*\n** Sync an memdb-file.\n*/\nstatic int memdbSync(sqlite3_file *pFile, int flags){\n  UNUSED_PARAMETER(pFile);\n  UNUSED_PARAMETER(flags);\n  return SQLITE_OK;\n}\n\n/*\n** Return the current file-size of an memdb-file.\n*/\nstatic int memdbFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){\n  MemStore *p = ((MemFile*)pFile)->pStore;\n  memdbEnter(p);\n  *pSize = p->sz;\n  memdbLeave(p);\n  return SQLITE_OK;\n}\n\n/*\n** Lock an memdb-file.\n*/\nstatic int memdbLock(sqlite3_file *pFile, int eLock){\n  MemFile *pThis = (MemFile*)pFile;\n  MemStore *p = pThis->pStore;\n  int rc = SQLITE_OK;\n  if( eLock<=pThis->eLock ) return SQLITE_OK;\n  memdbEnter(p);\n\n  assert( p->nWrLock==0 || p->nWrLock==1 );\n  assert( pThis->eLock<=SQLITE_LOCK_SHARED || p->nWrLock==1 );\n  assert( pThis->eLock==SQLITE_LOCK_NONE || p->nRdLock>=1 );\n\n  if( eLock>SQLITE_LOCK_SHARED && (p->mFlags & SQLITE_DESERIALIZE_READONLY) ){\n    rc = SQLITE_READONLY;\n  }else{\n    switch( eLock ){\n      case SQLITE_LOCK_SHARED: {\n        assert( pThis->eLock==SQLITE_LOCK_NONE );\n        if( p->nWrLock>0 ){\n          rc = SQLITE_BUSY;\n        }else{\n          p->nRdLock++;\n        }\n        break;\n      };\n  \n      case SQLITE_LOCK_RESERVED:\n      case SQLITE_LOCK_PENDING: {\n        assert( pThis->eLock>=SQLITE_LOCK_SHARED );\n        if( ALWAYS(pThis->eLock==SQLITE_LOCK_SHARED) ){\n          if( p->nWrLock>0 ){\n            rc = SQLITE_BUSY;\n          }else{\n            p->nWrLock = 1;\n          }\n        }\n        break;\n      }\n  \n      default: {\n        assert(  eLock==SQLITE_LOCK_EXCLUSIVE );\n        assert( pThis->eLock>=SQLITE_LOCK_SHARED );\n        if( p->nRdLock>1 ){\n          rc = SQLITE_BUSY;\n        }else if( pThis->eLock==SQLITE_LOCK_SHARED ){\n          p->nWrLock = 1;\n        }\n        break;\n      }\n    }\n  }\n  if( rc==SQLITE_OK ) pThis->eLock = eLock;\n  memdbLeave(p);\n  return rc;\n}\n\n/*\n** Unlock an memdb-file.\n*/\nstatic int memdbUnlock(sqlite3_file *pFile, int eLock){\n  MemFile *pThis = (MemFile*)pFile;\n  MemStore *p = pThis->pStore;\n  if( eLock>=pThis->eLock ) return SQLITE_OK;\n  memdbEnter(p);\n\n  assert( eLock==SQLITE_LOCK_SHARED || eLock==SQLITE_LOCK_NONE );\n  if( eLock==SQLITE_LOCK_SHARED ){\n    if( ALWAYS(pThis->eLock>SQLITE_LOCK_SHARED) ){\n      p->nWrLock--;\n    }\n  }else{\n    if( pThis->eLock>SQLITE_LOCK_SHARED ){\n      p->nWrLock--;\n    }\n    p->nRdLock--;\n  }\n\n  pThis->eLock = eLock;\n  memdbLeave(p);\n  return SQLITE_OK;\n}\n\n#if 0\n/*\n** This interface is only used for crash recovery, which does not\n** occur on an in-memory database.\n*/\nstatic int memdbCheckReservedLock(sqlite3_file *pFile, int *pResOut){\n  *pResOut = 0;\n  return SQLITE_OK;\n}\n#endif\n\n\n/*\n** File control method. For custom operations on an memdb-file.\n*/\nstatic int memdbFileControl(sqlite3_file *pFile, int op, void *pArg){\n  MemStore *p = ((MemFile*)pFile)->pStore;\n  int rc = SQLITE_NOTFOUND;\n  memdbEnter(p);\n  if( op==SQLITE_FCNTL_VFSNAME ){\n    *(char**)pArg = sqlite3_mprintf(\"memdb(%p,%lld)\", p->aData, p->sz);\n    rc = SQLITE_OK;\n  }\n  if( op==SQLITE_FCNTL_SIZE_LIMIT ){\n    sqlite3_int64 iLimit = *(sqlite3_int64*)pArg;\n    if( iLimit<p->sz ){\n      if( iLimit<0 ){\n        iLimit = p->szMax;\n      }else{\n        iLimit = p->sz;\n      }\n    }\n    p->szMax = iLimit;\n    *(sqlite3_int64*)pArg = iLimit;\n    rc = SQLITE_OK;\n  }\n  memdbLeave(p);\n  return rc;\n}\n\n#if 0  /* Not used because of SQLITE_IOCAP_POWERSAFE_OVERWRITE */\n/*\n** Return the sector-size in bytes for an memdb-file.\n*/\nstatic int memdbSectorSize(sqlite3_file *pFile){\n  return 1024;\n}\n#endif\n\n/*\n** Return the device characteristic flags supported by an memdb-file.\n*/\nstatic int memdbDeviceCharacteristics(sqlite3_file *pFile){\n  UNUSED_PARAMETER(pFile);\n  return SQLITE_IOCAP_ATOMIC | \n         SQLITE_IOCAP_POWERSAFE_OVERWRITE |\n         SQLITE_IOCAP_SAFE_APPEND |\n         SQLITE_IOCAP_SEQUENTIAL;\n}\n\n/* Fetch a page of a memory-mapped file */\nstatic int memdbFetch(\n  sqlite3_file *pFile,\n  sqlite3_int64 iOfst,\n  int iAmt,\n  void **pp\n){\n  MemStore *p = ((MemFile*)pFile)->pStore;\n  memdbEnter(p);\n  if( iOfst+iAmt>p->sz || (p->mFlags & SQLITE_DESERIALIZE_RESIZEABLE)!=0 ){\n    *pp = 0;\n  }else{\n    p->nMmap++;\n    *pp = (void*)(p->aData + iOfst);\n  }\n  memdbLeave(p);\n  return SQLITE_OK;\n}\n\n/* Release a memory-mapped page */\nstatic int memdbUnfetch(sqlite3_file *pFile, sqlite3_int64 iOfst, void *pPage){\n  MemStore *p = ((MemFile*)pFile)->pStore;\n  UNUSED_PARAMETER(iOfst);\n  UNUSED_PARAMETER(pPage);\n  memdbEnter(p);\n  p->nMmap--;\n  memdbLeave(p);\n  return SQLITE_OK;\n}\n\n/*\n** Open an mem file handle.\n*/\nstatic int memdbOpen(\n  sqlite3_vfs *pVfs,\n  const char *zName,\n  sqlite3_file *pFd,\n  int flags,\n  int *pOutFlags\n){\n  MemFile *pFile = (MemFile*)pFd;\n  MemStore *p = 0;\n  int szName;\n  UNUSED_PARAMETER(pVfs);\n\n  memset(pFile, 0, sizeof(*pFile));\n  szName = sqlite3Strlen30(zName);\n  if( szName>1 && (zName[0]=='/' || zName[0]=='\\\\') ){\n    int i;\n#ifndef SQLITE_MUTEX_OMIT\n    sqlite3_mutex *pVfsMutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1);\n#endif\n    sqlite3_mutex_enter(pVfsMutex);\n    for(i=0; i<memdb_g.nMemStore; i++){\n      if( strcmp(memdb_g.apMemStore[i]->zFName,zName)==0 ){\n        p = memdb_g.apMemStore[i];\n        break;\n      }\n    }\n    if( p==0 ){\n      MemStore **apNew;\n      p = sqlite3Malloc( sizeof(*p) + (i64)szName + 3 );\n      if( p==0 ){\n        sqlite3_mutex_leave(pVfsMutex);\n        return SQLITE_NOMEM;\n      }\n      apNew = sqlite3Realloc(memdb_g.apMemStore,\n                             sizeof(apNew[0])*(1+(i64)memdb_g.nMemStore) );\n      if( apNew==0 ){\n        sqlite3_free(p);\n        sqlite3_mutex_leave(pVfsMutex);\n        return SQLITE_NOMEM;\n      }\n      apNew[memdb_g.nMemStore++] = p;\n      memdb_g.apMemStore = apNew;\n      memset(p, 0, sizeof(*p));\n      p->mFlags = SQLITE_DESERIALIZE_RESIZEABLE|SQLITE_DESERIALIZE_FREEONCLOSE;\n      p->szMax = sqlite3GlobalConfig.mxMemdbSize;\n      p->zFName = (char*)&p[1];\n      memcpy(p->zFName, zName, szName+1);\n      p->pMutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);\n      if( p->pMutex==0 ){\n        memdb_g.nMemStore--;\n        sqlite3_free(p);\n        sqlite3_mutex_leave(pVfsMutex);\n        return SQLITE_NOMEM;\n      }\n      p->nRef = 1;\n      memdbEnter(p);\n    }else{\n      memdbEnter(p);\n      p->nRef++;\n    }\n    sqlite3_mutex_leave(pVfsMutex);\n  }else{\n    p = sqlite3Malloc( sizeof(*p) );\n    if( p==0 ){\n      return SQLITE_NOMEM;\n    }\n    memset(p, 0, sizeof(*p));\n    p->mFlags = SQLITE_DESERIALIZE_RESIZEABLE | SQLITE_DESERIALIZE_FREEONCLOSE;\n    p->szMax = sqlite3GlobalConfig.mxMemdbSize;\n  }\n  pFile->pStore = p;\n  if( pOutFlags!=0 ){\n    *pOutFlags = flags | SQLITE_OPEN_MEMORY;\n  }\n  pFd->pMethods = &memdb_io_methods;\n  memdbLeave(p);\n  return SQLITE_OK;\n}\n\n#if 0 /* Only used to delete rollback journals, super-journals, and WAL\n      ** files, none of which exist in memdb.  So this routine is never used */\n/*\n** Delete the file located at zPath. If the dirSync argument is true,\n** ensure the file-system modifications are synced to disk before\n** returning.\n*/\nstatic int memdbDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){\n  return SQLITE_IOERR_DELETE;\n}\n#endif\n\n/*\n** Test for access permissions. Return true if the requested permission\n** is available, or false otherwise.\n**\n** With memdb, no files ever exist on disk.  So always return false.\n*/\nstatic int memdbAccess(\n  sqlite3_vfs *pVfs, \n  const char *zPath, \n  int flags, \n  int *pResOut\n){\n  UNUSED_PARAMETER(pVfs);\n  UNUSED_PARAMETER(zPath);\n  UNUSED_PARAMETER(flags);\n  *pResOut = 0;\n  return SQLITE_OK;\n}\n\n/*\n** Populate buffer zOut with the full canonical pathname corresponding\n** to the pathname in zPath. zOut is guaranteed to point to a buffer\n** of at least (INST_MAX_PATHNAME+1) bytes.\n*/\nstatic int memdbFullPathname(\n  sqlite3_vfs *pVfs, \n  const char *zPath, \n  int nOut, \n  char *zOut\n){\n  UNUSED_PARAMETER(pVfs);\n  sqlite3_snprintf(nOut, zOut, \"%s\", zPath);\n  return SQLITE_OK;\n}\n\n/*\n** Open the dynamic library located at zPath and return a handle.\n*/\nstatic void *memdbDlOpen(sqlite3_vfs *pVfs, const char *zPath){\n  return ORIGVFS(pVfs)->xDlOpen(ORIGVFS(pVfs), zPath);\n}\n\n/*\n** Populate the buffer zErrMsg (size nByte bytes) with a human readable\n** utf-8 string describing the most recent error encountered associated \n** with dynamic libraries.\n*/\nstatic void memdbDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){\n  ORIGVFS(pVfs)->xDlError(ORIGVFS(pVfs), nByte, zErrMsg);\n}\n\n/*\n** Return a pointer to the symbol zSymbol in the dynamic library pHandle.\n*/\nstatic void (*memdbDlSym(sqlite3_vfs *pVfs, void *p, const char *zSym))(void){\n  return ORIGVFS(pVfs)->xDlSym(ORIGVFS(pVfs), p, zSym);\n}\n\n/*\n** Close the dynamic library handle pHandle.\n*/\nstatic void memdbDlClose(sqlite3_vfs *pVfs, void *pHandle){\n  ORIGVFS(pVfs)->xDlClose(ORIGVFS(pVfs), pHandle);\n}\n\n/*\n** Populate the buffer pointed to by zBufOut with nByte bytes of \n** random data.\n*/\nstatic int memdbRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){\n  return ORIGVFS(pVfs)->xRandomness(ORIGVFS(pVfs), nByte, zBufOut);\n}\n\n/*\n** Sleep for nMicro microseconds. Return the number of microseconds \n** actually slept.\n*/\nstatic int memdbSleep(sqlite3_vfs *pVfs, int nMicro){\n  return ORIGVFS(pVfs)->xSleep(ORIGVFS(pVfs), nMicro);\n}\n\n#if 0  /* Never used.  Modern cores only call xCurrentTimeInt64() */\n/*\n** Return the current time as a Julian Day number in *pTimeOut.\n*/\nstatic int memdbCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){\n  return ORIGVFS(pVfs)->xCurrentTime(ORIGVFS(pVfs), pTimeOut);\n}\n#endif\n\nstatic int memdbGetLastError(sqlite3_vfs *pVfs, int a, char *b){\n  return ORIGVFS(pVfs)->xGetLastError(ORIGVFS(pVfs), a, b);\n}\nstatic int memdbCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *p){\n  return ORIGVFS(pVfs)->xCurrentTimeInt64(ORIGVFS(pVfs), p);\n}\n\n/*\n** Translate a database connection pointer and schema name into a\n** MemFile pointer.\n*/\nstatic MemFile *memdbFromDbSchema(sqlite3 *db, const char *zSchema){\n  MemFile *p = 0;\n  MemStore *pStore;\n  int rc = sqlite3_file_control(db, zSchema, SQLITE_FCNTL_FILE_POINTER, &p);\n  if( rc ) return 0;\n  if( p->base.pMethods!=&memdb_io_methods ) return 0;\n  pStore = p->pStore;\n  memdbEnter(pStore);\n  if( pStore->zFName!=0 ) p = 0;\n  memdbLeave(pStore);\n  return p;\n}\n\n/*\n** Return the serialization of a database\n*/\nunsigned char *sqlite3_serialize(\n  sqlite3 *db,              /* The database connection */\n  const char *zSchema,      /* Which database within the connection */\n  sqlite3_int64 *piSize,    /* Write size here, if not NULL */\n  unsigned int mFlags       /* Maybe SQLITE_SERIALIZE_NOCOPY */\n){\n  MemFile *p;\n  int iDb;\n  Btree *pBt;\n  sqlite3_int64 sz;\n  int szPage = 0;\n  sqlite3_stmt *pStmt = 0;\n  unsigned char *pOut;\n  char *zSql;\n  int rc;\n\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( !sqlite3SafetyCheckOk(db) ){\n    (void)SQLITE_MISUSE_BKPT;\n    return 0;\n  }\n#endif\n\n  if( zSchema==0 ) zSchema = db->aDb[0].zDbSName;\n  p = memdbFromDbSchema(db, zSchema);\n  iDb = sqlite3FindDbName(db, zSchema);\n  if( piSize ) *piSize = -1;\n  if( iDb<0 ) return 0;\n  if( p ){\n    MemStore *pStore = p->pStore;\n    assert( pStore->pMutex==0 );\n    if( piSize ) *piSize = pStore->sz;\n    if( mFlags & SQLITE_SERIALIZE_NOCOPY ){\n      pOut = pStore->aData;\n    }else{\n      pOut = sqlite3_malloc64( pStore->sz );\n      if( pOut ) memcpy(pOut, pStore->aData, pStore->sz);\n    }\n    return pOut;\n  }\n  pBt = db->aDb[iDb].pBt;\n  if( pBt==0 ) return 0;\n  szPage = sqlite3BtreeGetPageSize(pBt);\n  zSql = sqlite3_mprintf(\"PRAGMA \\\"%w\\\".page_count\", zSchema);\n  rc = zSql ? sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0) : SQLITE_NOMEM;\n  sqlite3_free(zSql);\n  if( rc ) return 0;\n  rc = sqlite3_step(pStmt);\n  if( rc!=SQLITE_ROW ){\n    pOut = 0;\n  }else{\n    sz = sqlite3_column_int64(pStmt, 0)*szPage;\n    if( sz==0 ){\n      sqlite3_reset(pStmt);\n      sqlite3_exec(db, \"BEGIN IMMEDIATE; COMMIT;\", 0, 0, 0);\n      rc = sqlite3_step(pStmt);\n      if( rc==SQLITE_ROW ){\n        sz = sqlite3_column_int64(pStmt, 0)*szPage;\n      }\n    }\n    if( piSize ) *piSize = sz;\n    if( mFlags & SQLITE_SERIALIZE_NOCOPY ){\n      pOut = 0;\n    }else{\n      pOut = sqlite3_malloc64( sz );\n      if( pOut ){\n        int nPage = sqlite3_column_int(pStmt, 0);\n        Pager *pPager = sqlite3BtreePager(pBt);\n        int pgno;\n        for(pgno=1; pgno<=nPage; pgno++){\n          DbPage *pPage = 0;\n          unsigned char *pTo = pOut + szPage*(sqlite3_int64)(pgno-1);\n          rc = sqlite3PagerGet(pPager, pgno, (DbPage**)&pPage, 0);\n          if( rc==SQLITE_OK ){\n            memcpy(pTo, sqlite3PagerGetData(pPage), szPage);\n          }else{\n            memset(pTo, 0, szPage);\n          }\n          sqlite3PagerUnref(pPage);       \n        }\n      }\n    }\n  }\n  sqlite3_finalize(pStmt);\n  return pOut;\n}\n\n/* Convert zSchema to a MemDB and initialize its content.\n*/\nint sqlite3_deserialize(\n  sqlite3 *db,            /* The database connection */\n  const char *zSchema,    /* Which DB to reopen with the deserialization */\n  unsigned char *pData,   /* The serialized database content */\n  sqlite3_int64 szDb,     /* Number bytes in the deserialization */\n  sqlite3_int64 szBuf,    /* Total size of buffer pData[] */\n  unsigned mFlags         /* Zero or more SQLITE_DESERIALIZE_* flags */\n){\n  MemFile *p;\n  char *zSql;\n  sqlite3_stmt *pStmt = 0;\n  int rc;\n  int iDb;\n\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( !sqlite3SafetyCheckOk(db) ){\n    return SQLITE_MISUSE_BKPT;\n  }\n  if( szDb<0 ) return SQLITE_MISUSE_BKPT;\n  if( szBuf<0 ) return SQLITE_MISUSE_BKPT;\n#endif\n\n  sqlite3_mutex_enter(db->mutex);\n  if( zSchema==0 ) zSchema = db->aDb[0].zDbSName;\n  iDb = sqlite3FindDbName(db, zSchema);\n  testcase( iDb==1 );\n  if( iDb<2 && iDb!=0 ){\n    rc = SQLITE_ERROR;\n    goto end_deserialize;\n  }\n  zSql = sqlite3_mprintf(\"ATTACH x AS %Q\", zSchema);\n  if( zSql==0 ){\n    rc = SQLITE_NOMEM;\n  }else{\n    rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);\n    sqlite3_free(zSql);\n  }\n  if( rc ) goto end_deserialize;\n  db->init.iDb = (u8)iDb;\n  db->init.reopenMemdb = 1;\n  rc = sqlite3_step(pStmt);\n  db->init.reopenMemdb = 0;\n  if( rc!=SQLITE_DONE ){\n    rc = SQLITE_ERROR;\n    goto end_deserialize;\n  }\n  p = memdbFromDbSchema(db, zSchema);\n  if( p==0 ){\n    rc = SQLITE_ERROR;\n  }else{\n    MemStore *pStore = p->pStore;\n    pStore->aData = pData;\n    pData = 0;\n    pStore->sz = szDb;\n    pStore->szAlloc = szBuf;\n    pStore->szMax = szBuf;\n    if( pStore->szMax<sqlite3GlobalConfig.mxMemdbSize ){\n      pStore->szMax = sqlite3GlobalConfig.mxMemdbSize;\n    }\n    pStore->mFlags = mFlags;\n    rc = SQLITE_OK;\n  }\n\nend_deserialize:\n  sqlite3_finalize(pStmt);\n  if( pData && (mFlags & SQLITE_DESERIALIZE_FREEONCLOSE)!=0 ){\n    sqlite3_free(pData);\n  }\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n/*\n** Return true if the VFS is the memvfs.\n*/\nint sqlite3IsMemdb(const sqlite3_vfs *pVfs){\n  return pVfs==&memdb_vfs;\n}\n\n/* \n** This routine is called when the extension is loaded.\n** Register the new VFS.\n*/\nint sqlite3MemdbInit(void){\n  sqlite3_vfs *pLower = sqlite3_vfs_find(0);\n  unsigned int sz;\n  if( NEVER(pLower==0) ) return SQLITE_ERROR;\n  sz = pLower->szOsFile;\n  memdb_vfs.pAppData = pLower;\n  /* The following conditional can only be true when compiled for\n  ** Windows x86 and SQLITE_MAX_MMAP_SIZE=0.  We always leave\n  ** it in, to be safe, but it is marked as NO_TEST since there\n  ** is no way to reach it under most builds. */\n  if( sz<sizeof(MemFile) ) sz = sizeof(MemFile); /*NO_TEST*/\n  memdb_vfs.szOsFile = sz;\n  return sqlite3_vfs_register(&memdb_vfs, 0);\n}\n#endif /* SQLITE_OMIT_DESERIALIZE */\n"}
{"repo": "sqlite", "file": "mutex_w32.c", "lang": "C++", "code": "/*\n** 2007 August 14\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains the C functions that implement mutexes for Win32.\n*/\n#include \"sqliteInt.h\"\n\n#if SQLITE_OS_WIN\n/*\n** Include code that is common to all os_*.c files\n*/\n#include \"os_common.h\"\n\n/*\n** Include the header file for the Windows VFS.\n*/\n#include \"os_win.h\"\n#endif\n\n/*\n** The code in this file is only used if we are compiling multithreaded\n** on a Win32 system.\n*/\n#ifdef SQLITE_MUTEX_W32\n\n/*\n** Each recursive mutex is an instance of the following structure.\n*/\nstruct sqlite3_mutex {\n  CRITICAL_SECTION mutex;    /* Mutex controlling the lock */\n  int id;                    /* Mutex type */\n#ifdef SQLITE_DEBUG\n  volatile int nRef;         /* Number of entrances */\n  volatile DWORD owner;      /* Thread holding this mutex */\n  volatile LONG trace;       /* True to trace changes */\n#endif\n};\n\n/*\n** These are the initializer values used when declaring a \"static\" mutex\n** on Win32.  It should be noted that all mutexes require initialization\n** on the Win32 platform.\n*/\n#define SQLITE_W32_MUTEX_INITIALIZER { 0 }\n\n#ifdef SQLITE_DEBUG\n#define SQLITE3_MUTEX_INITIALIZER(id) { SQLITE_W32_MUTEX_INITIALIZER, id, \\\n                                    0L, (DWORD)0, 0 }\n#else\n#define SQLITE3_MUTEX_INITIALIZER(id) { SQLITE_W32_MUTEX_INITIALIZER, id }\n#endif\n\n#ifdef SQLITE_DEBUG\n/*\n** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routine are\n** intended for use only inside assert() statements.\n*/\nstatic int winMutexHeld(sqlite3_mutex *p){\n  return p->nRef!=0 && p->owner==GetCurrentThreadId();\n}\n\nstatic int winMutexNotheld2(sqlite3_mutex *p, DWORD tid){\n  return p->nRef==0 || p->owner!=tid;\n}\n\nstatic int winMutexNotheld(sqlite3_mutex *p){\n  DWORD tid = GetCurrentThreadId();\n  return winMutexNotheld2(p, tid);\n}\n#endif\n\n/*\n** Try to provide a memory barrier operation, needed for initialization\n** and also for the xShmBarrier method of the VFS in cases when SQLite is\n** compiled without mutexes (SQLITE_THREADSAFE=0).\n*/\nvoid sqlite3MemoryBarrier(void){\n#if defined(SQLITE_MEMORY_BARRIER)\n  SQLITE_MEMORY_BARRIER;\n#elif defined(__GNUC__)\n  __sync_synchronize();\n#elif MSVC_VERSION>=1400\n  _ReadWriteBarrier();\n#elif defined(MemoryBarrier)\n  MemoryBarrier();\n#endif\n}\n\n/*\n** Initialize and deinitialize the mutex subsystem.\n*/\nstatic sqlite3_mutex winMutex_staticMutexes[] = {\n  SQLITE3_MUTEX_INITIALIZER(2),\n  SQLITE3_MUTEX_INITIALIZER(3),\n  SQLITE3_MUTEX_INITIALIZER(4),\n  SQLITE3_MUTEX_INITIALIZER(5),\n  SQLITE3_MUTEX_INITIALIZER(6),\n  SQLITE3_MUTEX_INITIALIZER(7),\n  SQLITE3_MUTEX_INITIALIZER(8),\n  SQLITE3_MUTEX_INITIALIZER(9),\n  SQLITE3_MUTEX_INITIALIZER(10),\n  SQLITE3_MUTEX_INITIALIZER(11),\n  SQLITE3_MUTEX_INITIALIZER(12),\n  SQLITE3_MUTEX_INITIALIZER(13)\n};\n\nstatic int winMutex_isInit = 0;\nstatic int winMutex_isNt = -1; /* <0 means \"need to query\" */\n\n/* As the winMutexInit() and winMutexEnd() functions are called as part\n** of the sqlite3_initialize() and sqlite3_shutdown() processing, the\n** \"interlocked\" magic used here is probably not strictly necessary.\n*/\nstatic LONG SQLITE_WIN32_VOLATILE winMutex_lock = 0;\n\nint sqlite3_win32_is_nt(void); /* os_win.c */\nvoid sqlite3_win32_sleep(DWORD milliseconds); /* os_win.c */\n\nstatic int winMutexInit(void){\n  /* The first to increment to 1 does actual initialization */\n  if( InterlockedCompareExchange(&winMutex_lock, 1, 0)==0 ){\n    int i;\n    for(i=0; i<ArraySize(winMutex_staticMutexes); i++){\n      InitializeCriticalSection(&winMutex_staticMutexes[i].mutex);\n    }\n    winMutex_isInit = 1;\n  }else{\n    /* Another thread is (in the process of) initializing the static\n    ** mutexes */\n    while( !winMutex_isInit ){\n      sqlite3_win32_sleep(1);\n    }\n  }\n  return SQLITE_OK;\n}\n\nstatic int winMutexEnd(void){\n  /* The first to decrement to 0 does actual shutdown\n  ** (which should be the last to shutdown.) */\n  if( InterlockedCompareExchange(&winMutex_lock, 0, 1)==1 ){\n    if( winMutex_isInit==1 ){\n      int i;\n      for(i=0; i<ArraySize(winMutex_staticMutexes); i++){\n        DeleteCriticalSection(&winMutex_staticMutexes[i].mutex);\n      }\n      winMutex_isInit = 0;\n    }\n  }\n  return SQLITE_OK;\n}\n\n/*\n** The sqlite3_mutex_alloc() routine allocates a new\n** mutex and returns a pointer to it.  If it returns NULL\n** that means that a mutex could not be allocated.  SQLite\n** will unwind its stack and return an error.  The argument\n** to sqlite3_mutex_alloc() is one of these integer constants:\n**\n** <ul>\n** <li>  SQLITE_MUTEX_FAST\n** <li>  SQLITE_MUTEX_RECURSIVE\n** <li>  SQLITE_MUTEX_STATIC_MAIN\n** <li>  SQLITE_MUTEX_STATIC_MEM\n** <li>  SQLITE_MUTEX_STATIC_OPEN\n** <li>  SQLITE_MUTEX_STATIC_PRNG\n** <li>  SQLITE_MUTEX_STATIC_LRU\n** <li>  SQLITE_MUTEX_STATIC_PMEM\n** <li>  SQLITE_MUTEX_STATIC_APP1\n** <li>  SQLITE_MUTEX_STATIC_APP2\n** <li>  SQLITE_MUTEX_STATIC_APP3\n** <li>  SQLITE_MUTEX_STATIC_VFS1\n** <li>  SQLITE_MUTEX_STATIC_VFS2\n** <li>  SQLITE_MUTEX_STATIC_VFS3\n** </ul>\n**\n** The first two constants cause sqlite3_mutex_alloc() to create\n** a new mutex.  The new mutex is recursive when SQLITE_MUTEX_RECURSIVE\n** is used but not necessarily so when SQLITE_MUTEX_FAST is used.\n** The mutex implementation does not need to make a distinction\n** between SQLITE_MUTEX_RECURSIVE and SQLITE_MUTEX_FAST if it does\n** not want to.  But SQLite will only request a recursive mutex in\n** cases where it really needs one.  If a faster non-recursive mutex\n** implementation is available on the host platform, the mutex subsystem\n** might return such a mutex in response to SQLITE_MUTEX_FAST.\n**\n** The other allowed parameters to sqlite3_mutex_alloc() each return\n** a pointer to a static preexisting mutex.  Six static mutexes are\n** used by the current version of SQLite.  Future versions of SQLite\n** may add additional static mutexes.  Static mutexes are for internal\n** use by SQLite only.  Applications that use SQLite mutexes should\n** use only the dynamic mutexes returned by SQLITE_MUTEX_FAST or\n** SQLITE_MUTEX_RECURSIVE.\n**\n** Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST\n** or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc()\n** returns a different mutex on every call.  But for the static\n** mutex types, the same mutex is returned on every call that has\n** the same type number.\n*/\nstatic sqlite3_mutex *winMutexAlloc(int iType){\n  sqlite3_mutex *p;\n\n  switch( iType ){\n    case SQLITE_MUTEX_FAST:\n    case SQLITE_MUTEX_RECURSIVE: {\n      p = sqlite3MallocZero( sizeof(*p) );\n      if( p ){\n        p->id = iType;\n#ifdef SQLITE_DEBUG\n#ifdef SQLITE_WIN32_MUTEX_TRACE_DYNAMIC\n        p->trace = 1;\n#endif\n#endif\n        InitializeCriticalSection(&p->mutex);\n      }\n      break;\n    }\n    default: {\n#ifdef SQLITE_ENABLE_API_ARMOR\n      if( iType-2<0 || iType-2>=ArraySize(winMutex_staticMutexes) ){\n        (void)SQLITE_MISUSE_BKPT;\n        return 0;\n      }\n#endif\n      p = &winMutex_staticMutexes[iType-2];\n#ifdef SQLITE_DEBUG\n#ifdef SQLITE_WIN32_MUTEX_TRACE_STATIC\n      InterlockedCompareExchange(&p->trace, 1, 0);\n#endif\n#endif\n      break;\n    }\n  }\n  assert( p==0 || p->id==iType );\n  return p;\n}\n\n\n/*\n** This routine deallocates a previously\n** allocated mutex.  SQLite is careful to deallocate every\n** mutex that it allocates.\n*/\nstatic void winMutexFree(sqlite3_mutex *p){\n  assert( p );\n  assert( p->nRef==0 && p->owner==0 );\n  if( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE ){\n    DeleteCriticalSection(&p->mutex);\n    sqlite3_free(p);\n  }else{\n#ifdef SQLITE_ENABLE_API_ARMOR\n    (void)SQLITE_MISUSE_BKPT;\n#endif\n  }\n}\n\n/*\n** The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt\n** to enter a mutex.  If another thread is already within the mutex,\n** sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return\n** SQLITE_BUSY.  The sqlite3_mutex_try() interface returns SQLITE_OK\n** upon successful entry.  Mutexes created using SQLITE_MUTEX_RECURSIVE can\n** be entered multiple times by the same thread.  In such cases the,\n** mutex must be exited an equal number of times before another thread\n** can enter.  If the same thread tries to enter any other kind of mutex\n** more than once, the behavior is undefined.\n*/\nstatic void winMutexEnter(sqlite3_mutex *p){\n#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)\n  DWORD tid = GetCurrentThreadId();\n#endif\n#ifdef SQLITE_DEBUG\n  assert( p );\n  assert( p->id==SQLITE_MUTEX_RECURSIVE || winMutexNotheld2(p, tid) );\n#else\n  assert( p );\n#endif\n  assert( winMutex_isInit==1 );\n  EnterCriticalSection(&p->mutex);\n#ifdef SQLITE_DEBUG\n  assert( p->nRef>0 || p->owner==0 );\n  p->owner = tid;\n  p->nRef++;\n  if( p->trace ){\n    OSTRACE((\"ENTER-MUTEX tid=%lu, mutex(%d)=%p (%d), nRef=%d\\n\",\n             tid, p->id, p, p->trace, p->nRef));\n  }\n#endif\n}\n\nstatic int winMutexTry(sqlite3_mutex *p){\n#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)\n  DWORD tid = GetCurrentThreadId();\n#endif\n  int rc = SQLITE_BUSY;\n  assert( p );\n  assert( p->id==SQLITE_MUTEX_RECURSIVE || winMutexNotheld2(p, tid) );\n  /*\n  ** The sqlite3_mutex_try() routine is very rarely used, and when it\n  ** is used it is merely an optimization.  So it is OK for it to always\n  ** fail.\n  **\n  ** The TryEnterCriticalSection() interface is only available on WinNT.\n  ** And some windows compilers complain if you try to use it without\n  ** first doing some #defines that prevent SQLite from building on Win98.\n  ** For that reason, we will omit this optimization for now.  See\n  ** ticket #2685.\n  */\n#if defined(_WIN32_WINNT) && _WIN32_WINNT >= 0x0400\n  assert( winMutex_isInit==1 );\n  assert( winMutex_isNt>=-1 && winMutex_isNt<=1 );\n  if( winMutex_isNt<0 ){\n    winMutex_isNt = sqlite3_win32_is_nt();\n  }\n  assert( winMutex_isNt==0 || winMutex_isNt==1 );\n  if( winMutex_isNt && TryEnterCriticalSection(&p->mutex) ){\n#ifdef SQLITE_DEBUG\n    p->owner = tid;\n    p->nRef++;\n#endif\n    rc = SQLITE_OK;\n  }\n#else\n  UNUSED_PARAMETER(p);\n#endif\n#ifdef SQLITE_DEBUG\n  if( p->trace ){\n    OSTRACE((\"TRY-MUTEX tid=%lu, mutex(%d)=%p (%d), owner=%lu, nRef=%d, rc=%s\\n\",\n             tid, p->id, p, p->trace, p->owner, p->nRef, sqlite3ErrName(rc)));\n  }\n#endif\n  return rc;\n}\n\n/*\n** The sqlite3_mutex_leave() routine exits a mutex that was\n** previously entered by the same thread.  The behavior\n** is undefined if the mutex is not currently entered or\n** is not currently allocated.  SQLite will never do either.\n*/\nstatic void winMutexLeave(sqlite3_mutex *p){\n#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)\n  DWORD tid = GetCurrentThreadId();\n#endif\n  assert( p );\n#ifdef SQLITE_DEBUG\n  assert( p->nRef>0 );\n  assert( p->owner==tid );\n  p->nRef--;\n  if( p->nRef==0 ) p->owner = 0;\n  assert( p->nRef==0 || p->id==SQLITE_MUTEX_RECURSIVE );\n#endif\n  assert( winMutex_isInit==1 );\n  LeaveCriticalSection(&p->mutex);\n#ifdef SQLITE_DEBUG\n  if( p->trace ){\n    OSTRACE((\"LEAVE-MUTEX tid=%lu, mutex(%d)=%p (%d), nRef=%d\\n\",\n             tid, p->id, p, p->trace, p->nRef));\n  }\n#endif\n}\n\nsqlite3_mutex_methods const *sqlite3DefaultMutex(void){\n  static const sqlite3_mutex_methods sMutex = {\n    winMutexInit,\n    winMutexEnd,\n    winMutexAlloc,\n    winMutexFree,\n    winMutexEnter,\n    winMutexTry,\n    winMutexLeave,\n#ifdef SQLITE_DEBUG\n    winMutexHeld,\n    winMutexNotheld\n#else\n    0,\n    0\n#endif\n  };\n  return &sMutex;\n}\n\n#endif /* SQLITE_MUTEX_W32 */\n"}
{"repo": "sqlite", "file": "test_devsym.c", "lang": "C++", "code": "/*\n** 2008 Jan 22\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This file contains code that modified the OS layer in order to simulate\n** different device types (by overriding the return values of the \n** xDeviceCharacteristics() and xSectorSize() methods).\n*/\n#if SQLITE_TEST          /* This file is used for testing only */\n\n#include \"sqlite3.h\"\n#include \"sqliteInt.h\"\n\n/*\n** Maximum pathname length supported by the devsym backend.\n*/\n#define DEVSYM_MAX_PATHNAME 512\n\n/*\n** Name used to identify this VFS.\n*/\n#define DEVSYM_VFS_NAME \"devsym\"\n#define WRITECRASH_NAME \"writecrash\"\n\ntypedef struct devsym_file devsym_file;\nstruct devsym_file {\n  sqlite3_file base;\n  sqlite3_file *pReal;\n};\n\n/*\n** Method declarations for devsym_file.\n*/\nstatic int devsymClose(sqlite3_file*);\nstatic int devsymRead(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);\nstatic int devsymWrite(sqlite3_file*,const void*,int iAmt, sqlite3_int64 iOfst);\nstatic int devsymTruncate(sqlite3_file*, sqlite3_int64 size);\nstatic int devsymSync(sqlite3_file*, int flags);\nstatic int devsymFileSize(sqlite3_file*, sqlite3_int64 *pSize);\nstatic int devsymLock(sqlite3_file*, int);\nstatic int devsymUnlock(sqlite3_file*, int);\nstatic int devsymCheckReservedLock(sqlite3_file*, int *);\nstatic int devsymFileControl(sqlite3_file*, int op, void *pArg);\nstatic int devsymSectorSize(sqlite3_file*);\nstatic int devsymDeviceCharacteristics(sqlite3_file*);\nstatic int devsymShmLock(sqlite3_file*,int,int,int);\nstatic int devsymShmMap(sqlite3_file*,int,int,int, void volatile **);\nstatic void devsymShmBarrier(sqlite3_file*);\nstatic int devsymShmUnmap(sqlite3_file*,int);\n\n/*\n** Method declarations for devsym_vfs.\n*/\nstatic int devsymOpen(sqlite3_vfs*, const char *, sqlite3_file*, int , int *);\nstatic int devsymDelete(sqlite3_vfs*, const char *zName, int syncDir);\nstatic int devsymAccess(sqlite3_vfs*, const char *zName, int flags, int *);\nstatic int devsymFullPathname(sqlite3_vfs*, const char *zName, int, char *zOut);\n#ifndef SQLITE_OMIT_LOAD_EXTENSION\nstatic void *devsymDlOpen(sqlite3_vfs*, const char *zFilename);\nstatic void devsymDlError(sqlite3_vfs*, int nByte, char *zErrMsg);\nstatic void (*devsymDlSym(sqlite3_vfs*,void*, const char *zSymbol))(void);\nstatic void devsymDlClose(sqlite3_vfs*, void*);\n#endif /* SQLITE_OMIT_LOAD_EXTENSION */\nstatic int devsymRandomness(sqlite3_vfs*, int nByte, char *zOut);\nstatic int devsymSleep(sqlite3_vfs*, int microseconds);\nstatic int devsymCurrentTime(sqlite3_vfs*, double*);\n\nstruct DevsymGlobal {\n  sqlite3_vfs *pVfs;\n  int iDeviceChar;\n  int iSectorSize;\n  int nWriteCrash;\n};\nstruct DevsymGlobal g = {0, 0, 512, 0};\n\n/*\n** Close an devsym-file.\n*/\nstatic int devsymClose(sqlite3_file *pFile){\n  devsym_file *p = (devsym_file *)pFile;\n  sqlite3OsClose(p->pReal);\n  return SQLITE_OK;\n}\n\n/*\n** Read data from an devsym-file.\n*/\nstatic int devsymRead(\n  sqlite3_file *pFile, \n  void *zBuf, \n  int iAmt, \n  sqlite_int64 iOfst\n){\n  devsym_file *p = (devsym_file *)pFile;\n  return sqlite3OsRead(p->pReal, zBuf, iAmt, iOfst);\n}\n\n/*\n** Write data to an devsym-file.\n*/\nstatic int devsymWrite(\n  sqlite3_file *pFile, \n  const void *zBuf, \n  int iAmt, \n  sqlite_int64 iOfst\n){\n  devsym_file *p = (devsym_file *)pFile;\n  return sqlite3OsWrite(p->pReal, zBuf, iAmt, iOfst);\n}\n\n/*\n** Truncate an devsym-file.\n*/\nstatic int devsymTruncate(sqlite3_file *pFile, sqlite_int64 size){\n  devsym_file *p = (devsym_file *)pFile;\n  return sqlite3OsTruncate(p->pReal, size);\n}\n\n/*\n** Sync an devsym-file.\n*/\nstatic int devsymSync(sqlite3_file *pFile, int flags){\n  devsym_file *p = (devsym_file *)pFile;\n  return sqlite3OsSync(p->pReal, flags);\n}\n\n/*\n** Return the current file-size of an devsym-file.\n*/\nstatic int devsymFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){\n  devsym_file *p = (devsym_file *)pFile;\n  return sqlite3OsFileSize(p->pReal, pSize);\n}\n\n/*\n** Lock an devsym-file.\n*/\nstatic int devsymLock(sqlite3_file *pFile, int eLock){\n  devsym_file *p = (devsym_file *)pFile;\n  return sqlite3OsLock(p->pReal, eLock);\n}\n\n/*\n** Unlock an devsym-file.\n*/\nstatic int devsymUnlock(sqlite3_file *pFile, int eLock){\n  devsym_file *p = (devsym_file *)pFile;\n  return sqlite3OsUnlock(p->pReal, eLock);\n}\n\n/*\n** Check if another file-handle holds a RESERVED lock on an devsym-file.\n*/\nstatic int devsymCheckReservedLock(sqlite3_file *pFile, int *pResOut){\n  devsym_file *p = (devsym_file *)pFile;\n  return sqlite3OsCheckReservedLock(p->pReal, pResOut);\n}\n\n/*\n** File control method. For custom operations on an devsym-file.\n*/\nstatic int devsymFileControl(sqlite3_file *pFile, int op, void *pArg){\n  devsym_file *p = (devsym_file *)pFile;\n  return sqlite3OsFileControl(p->pReal, op, pArg);\n}\n\n/*\n** Return the sector-size in bytes for an devsym-file.\n*/\nstatic int devsymSectorSize(sqlite3_file *pFile){\n  return g.iSectorSize;\n}\n\n/*\n** Return the device characteristic flags supported by an devsym-file.\n*/\nstatic int devsymDeviceCharacteristics(sqlite3_file *pFile){\n  return g.iDeviceChar;\n}\n\n/*\n** Shared-memory methods are all pass-throughs.\n*/\nstatic int devsymShmLock(sqlite3_file *pFile, int ofst, int n, int flags){\n  devsym_file *p = (devsym_file *)pFile;\n  return p->pReal->pMethods->xShmLock(p->pReal, ofst, n, flags);\n}\nstatic int devsymShmMap(\n  sqlite3_file *pFile, \n  int iRegion, \n  int szRegion, \n  int isWrite, \n  void volatile **pp\n){\n  devsym_file *p = (devsym_file *)pFile;\n  return p->pReal->pMethods->xShmMap(p->pReal, iRegion, szRegion, isWrite, pp);\n}\nstatic void devsymShmBarrier(sqlite3_file *pFile){\n  devsym_file *p = (devsym_file *)pFile;\n  p->pReal->pMethods->xShmBarrier(p->pReal);\n}\nstatic int devsymShmUnmap(sqlite3_file *pFile, int delFlag){\n  devsym_file *p = (devsym_file *)pFile;\n  return p->pReal->pMethods->xShmUnmap(p->pReal, delFlag);\n}\n\n\n\n/*\n** Open an devsym file handle.\n*/\nstatic int devsymOpen(\n  sqlite3_vfs *pVfs,\n  const char *zName,\n  sqlite3_file *pFile,\n  int flags,\n  int *pOutFlags\n){\nstatic sqlite3_io_methods devsym_io_methods = {\n  2,                                /* iVersion */\n  devsymClose,                      /* xClose */\n  devsymRead,                       /* xRead */\n  devsymWrite,                      /* xWrite */\n  devsymTruncate,                   /* xTruncate */\n  devsymSync,                       /* xSync */\n  devsymFileSize,                   /* xFileSize */\n  devsymLock,                       /* xLock */\n  devsymUnlock,                     /* xUnlock */\n  devsymCheckReservedLock,          /* xCheckReservedLock */\n  devsymFileControl,                /* xFileControl */\n  devsymSectorSize,                 /* xSectorSize */\n  devsymDeviceCharacteristics,      /* xDeviceCharacteristics */\n  devsymShmMap,                     /* xShmMap */\n  devsymShmLock,                    /* xShmLock */\n  devsymShmBarrier,                 /* xShmBarrier */\n  devsymShmUnmap                    /* xShmUnmap */\n};\n\n  int rc;\n  devsym_file *p = (devsym_file *)pFile;\n  p->pReal = (sqlite3_file *)&p[1];\n  rc = sqlite3OsOpen(g.pVfs, zName, p->pReal, flags, pOutFlags);\n  if( p->pReal->pMethods ){\n    pFile->pMethods = &devsym_io_methods;\n  }\n  return rc;\n}\n\n/*\n** Delete the file located at zPath. If the dirSync argument is true,\n** ensure the file-system modifications are synced to disk before\n** returning.\n*/\nstatic int devsymDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){\n  return sqlite3OsDelete(g.pVfs, zPath, dirSync);\n}\n\n/*\n** Test for access permissions. Return true if the requested permission\n** is available, or false otherwise.\n*/\nstatic int devsymAccess(\n  sqlite3_vfs *pVfs, \n  const char *zPath, \n  int flags, \n  int *pResOut\n){\n  return sqlite3OsAccess(g.pVfs, zPath, flags, pResOut);\n}\n\n/*\n** Populate buffer zOut with the full canonical pathname corresponding\n** to the pathname in zPath. zOut is guaranteed to point to a buffer\n** of at least (DEVSYM_MAX_PATHNAME+1) bytes.\n*/\nstatic int devsymFullPathname(\n  sqlite3_vfs *pVfs, \n  const char *zPath, \n  int nOut, \n  char *zOut\n){\n  return sqlite3OsFullPathname(g.pVfs, zPath, nOut, zOut);\n}\n\n#ifndef SQLITE_OMIT_LOAD_EXTENSION\n/*\n** Open the dynamic library located at zPath and return a handle.\n*/\nstatic void *devsymDlOpen(sqlite3_vfs *pVfs, const char *zPath){\n  return sqlite3OsDlOpen(g.pVfs, zPath);\n}\n\n/*\n** Populate the buffer zErrMsg (size nByte bytes) with a human readable\n** utf-8 string describing the most recent error encountered associated \n** with dynamic libraries.\n*/\nstatic void devsymDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){\n  sqlite3OsDlError(g.pVfs, nByte, zErrMsg);\n}\n\n/*\n** Return a pointer to the symbol zSymbol in the dynamic library pHandle.\n*/\nstatic void (*devsymDlSym(sqlite3_vfs *pVfs, void *p, const char *zSym))(void){\n  return sqlite3OsDlSym(g.pVfs, p, zSym);\n}\n\n/*\n** Close the dynamic library handle pHandle.\n*/\nstatic void devsymDlClose(sqlite3_vfs *pVfs, void *pHandle){\n  sqlite3OsDlClose(g.pVfs, pHandle);\n}\n#endif /* SQLITE_OMIT_LOAD_EXTENSION */\n\n/*\n** Populate the buffer pointed to by zBufOut with nByte bytes of \n** random data.\n*/\nstatic int devsymRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){\n  return sqlite3OsRandomness(g.pVfs, nByte, zBufOut);\n}\n\n/*\n** Sleep for nMicro microseconds. Return the number of microseconds \n** actually slept.\n*/\nstatic int devsymSleep(sqlite3_vfs *pVfs, int nMicro){\n  return sqlite3OsSleep(g.pVfs, nMicro);\n}\n\n/*\n** Return the current time as a Julian Day number in *pTimeOut.\n*/\nstatic int devsymCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){\n  return g.pVfs->xCurrentTime(g.pVfs, pTimeOut);\n}\n\n/*\n** Return the sector-size in bytes for an writecrash-file.\n*/\nstatic int writecrashSectorSize(sqlite3_file *pFile){\n  devsym_file *p = (devsym_file *)pFile;\n  return sqlite3OsSectorSize(p->pReal);\n}\n\n/*\n** Return the device characteristic flags supported by an writecrash-file.\n*/\nstatic int writecrashDeviceCharacteristics(sqlite3_file *pFile){\n  devsym_file *p = (devsym_file *)pFile;\n  return sqlite3OsDeviceCharacteristics(p->pReal);\n}\n\n/*\n** Write data to an writecrash-file.\n*/\nstatic int writecrashWrite(\n  sqlite3_file *pFile, \n  const void *zBuf, \n  int iAmt, \n  sqlite_int64 iOfst\n){\n  devsym_file *p = (devsym_file *)pFile;\n  if( g.nWriteCrash>0 ){\n    g.nWriteCrash--;\n    if( g.nWriteCrash==0 ) abort();\n  }\n  return sqlite3OsWrite(p->pReal, zBuf, iAmt, iOfst);\n}\n\n/*\n** Open an writecrash file handle.\n*/\nstatic int writecrashOpen(\n  sqlite3_vfs *pVfs,\n  const char *zName,\n  sqlite3_file *pFile,\n  int flags,\n  int *pOutFlags\n){\nstatic sqlite3_io_methods writecrash_io_methods = {\n  2,                                /* iVersion */\n  devsymClose,                      /* xClose */\n  devsymRead,                       /* xRead */\n  writecrashWrite,                  /* xWrite */\n  devsymTruncate,                   /* xTruncate */\n  devsymSync,                       /* xSync */\n  devsymFileSize,                   /* xFileSize */\n  devsymLock,                       /* xLock */\n  devsymUnlock,                     /* xUnlock */\n  devsymCheckReservedLock,          /* xCheckReservedLock */\n  devsymFileControl,                /* xFileControl */\n  writecrashSectorSize,             /* xSectorSize */\n  writecrashDeviceCharacteristics,  /* xDeviceCharacteristics */\n  devsymShmMap,                     /* xShmMap */\n  devsymShmLock,                    /* xShmLock */\n  devsymShmBarrier,                 /* xShmBarrier */\n  devsymShmUnmap                    /* xShmUnmap */\n};\n\n  int rc;\n  devsym_file *p = (devsym_file *)pFile;\n  p->pReal = (sqlite3_file *)&p[1];\n  rc = sqlite3OsOpen(g.pVfs, zName, p->pReal, flags, pOutFlags);\n  if( p->pReal->pMethods ){\n    pFile->pMethods = &writecrash_io_methods;\n  }\n  return rc;\n}\n\nstatic sqlite3_vfs devsym_vfs = {\n  2,                     /* iVersion */\n  sizeof(devsym_file),      /* szOsFile */\n  DEVSYM_MAX_PATHNAME,      /* mxPathname */\n  0,                     /* pNext */\n  DEVSYM_VFS_NAME,          /* zName */\n  0,                     /* pAppData */\n  devsymOpen,               /* xOpen */\n  devsymDelete,             /* xDelete */\n  devsymAccess,             /* xAccess */\n  devsymFullPathname,       /* xFullPathname */\n#ifndef SQLITE_OMIT_LOAD_EXTENSION\n  devsymDlOpen,             /* xDlOpen */\n  devsymDlError,            /* xDlError */\n  devsymDlSym,              /* xDlSym */\n  devsymDlClose,            /* xDlClose */\n#else\n  0,                        /* xDlOpen */\n  0,                        /* xDlError */\n  0,                        /* xDlSym */\n  0,                        /* xDlClose */\n#endif /* SQLITE_OMIT_LOAD_EXTENSION */\n  devsymRandomness,         /* xRandomness */\n  devsymSleep,              /* xSleep */\n  devsymCurrentTime,        /* xCurrentTime */\n  0,                        /* xGetLastError */\n  0                         /* xCurrentTimeInt64 */\n};\n\nstatic sqlite3_vfs writecrash_vfs = {\n  2,                     /* iVersion */\n  sizeof(devsym_file),      /* szOsFile */\n  DEVSYM_MAX_PATHNAME,      /* mxPathname */\n  0,                     /* pNext */\n  WRITECRASH_NAME,          /* zName */\n  0,                     /* pAppData */\n  writecrashOpen,           /* xOpen */\n  devsymDelete,             /* xDelete */\n  devsymAccess,             /* xAccess */\n  devsymFullPathname,       /* xFullPathname */\n#ifndef SQLITE_OMIT_LOAD_EXTENSION\n  devsymDlOpen,             /* xDlOpen */\n  devsymDlError,            /* xDlError */\n  devsymDlSym,              /* xDlSym */\n  devsymDlClose,            /* xDlClose */\n#else\n  0,                        /* xDlOpen */\n  0,                        /* xDlError */\n  0,                        /* xDlSym */\n  0,                        /* xDlClose */\n#endif /* SQLITE_OMIT_LOAD_EXTENSION */\n  devsymRandomness,         /* xRandomness */\n  devsymSleep,              /* xSleep */\n  devsymCurrentTime,        /* xCurrentTime */\n  0,                        /* xGetLastError */\n  0                         /* xCurrentTimeInt64 */\n};\n\n\n/*\n** This procedure registers the devsym vfs with SQLite. If the argument is\n** true, the devsym vfs becomes the new default vfs. It is the only publicly\n** available function in this file.\n*/\nvoid devsym_register(int iDeviceChar, int iSectorSize){\n\n  if( g.pVfs==0 ){\n    g.pVfs = sqlite3_vfs_find(0);\n    devsym_vfs.szOsFile += g.pVfs->szOsFile;\n    writecrash_vfs.szOsFile += g.pVfs->szOsFile;\n    sqlite3_vfs_register(&devsym_vfs, 0);\n    sqlite3_vfs_register(&writecrash_vfs, 0);\n  }\n  if( iDeviceChar>=0 ){\n    g.iDeviceChar = iDeviceChar;\n  }else{\n    g.iDeviceChar = 0;\n  }\n  if( iSectorSize>=0 ){\n    g.iSectorSize = iSectorSize;\n  }else{\n    g.iSectorSize = 512;\n  }\n}\n\nvoid devsym_unregister(){\n  sqlite3_vfs_unregister(&devsym_vfs);\n  sqlite3_vfs_unregister(&writecrash_vfs);\n  g.pVfs = 0;\n  g.iDeviceChar = 0;\n  g.iSectorSize = 0;\n}\n\nvoid devsym_crash_on_write(int nWrite){\n  if( g.pVfs==0 ){\n    g.pVfs = sqlite3_vfs_find(0);\n    devsym_vfs.szOsFile += g.pVfs->szOsFile;\n    writecrash_vfs.szOsFile += g.pVfs->szOsFile;\n    sqlite3_vfs_register(&devsym_vfs, 0);\n    sqlite3_vfs_register(&writecrash_vfs, 0);\n  }\n  g.nWriteCrash = nWrite;\n}\n\n#endif\n"}
{"repo": "sqlite", "file": "prepare.c", "lang": "C++", "code": "/*\n** 2005 May 25\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains the implementation of the sqlite3_prepare()\n** interface, and routines that contribute to loading the database schema\n** from disk.\n*/\n#include \"sqliteInt.h\"\n\n/*\n** Fill the InitData structure with an error message that indicates\n** that the database is corrupt.\n*/\nstatic void corruptSchema(\n  InitData *pData,     /* Initialization context */\n  char **azObj,        /* Type and name of object being parsed */\n  const char *zExtra   /* Error information */\n){\n  sqlite3 *db = pData->db;\n  if( db->mallocFailed ){\n    pData->rc = SQLITE_NOMEM_BKPT;\n  }else if( pData->pzErrMsg[0]!=0 ){\n    /* A error message has already been generated.  Do not overwrite it */\n  }else if( pData->mInitFlags & (INITFLAG_AlterMask) ){\n    static const char *azAlterType[] = {\n       \"rename\",\n       \"drop column\",\n       \"add column\",\n       \"drop constraint\"\n    };\n    *pData->pzErrMsg = sqlite3MPrintf(db, \n        \"error in %s %s after %s: %s\", azObj[0], azObj[1], \n        azAlterType[(pData->mInitFlags&INITFLAG_AlterMask)-1], \n        zExtra\n    );\n    pData->rc = SQLITE_ERROR;\n  }else if( db->flags & SQLITE_WriteSchema ){\n    pData->rc = SQLITE_CORRUPT_BKPT;\n  }else{\n    char *z;\n    const char *zObj = azObj[1] ? azObj[1] : \"?\";\n    z = sqlite3MPrintf(db, \"malformed database schema (%s)\", zObj);\n    if( zExtra && zExtra[0] ) z = sqlite3MPrintf(db, \"%z - %s\", z, zExtra);\n    *pData->pzErrMsg = z;\n    pData->rc = SQLITE_CORRUPT_BKPT;\n  }\n}\n\n/*\n** Check to see if any sibling index (another index on the same table)\n** of pIndex has the same root page number, and if it does, return true.\n** This would indicate a corrupt schema.\n*/\nint sqlite3IndexHasDuplicateRootPage(Index *pIndex){\n  Index *p;\n  for(p=pIndex->pTable->pIndex; p; p=p->pNext){\n    if( p->tnum==pIndex->tnum && p!=pIndex ) return 1;\n  }\n  return 0;\n}\n\n/* forward declaration */\nstatic int sqlite3Prepare(\n  sqlite3 *db,              /* Database handle. */\n  const char *zSql,         /* UTF-8 encoded SQL statement. */\n  int nBytes,               /* Length of zSql in bytes. */\n  u32 prepFlags,            /* Zero or more SQLITE_PREPARE_* flags */\n  Vdbe *pReprepare,         /* VM being reprepared */\n  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n  const char **pzTail       /* OUT: End of parsed string */\n);\n\n\n/*\n** This is the callback routine for the code that initializes the\n** database.  See sqlite3Init() below for additional information.\n** This routine is also called from the OP_ParseSchema opcode of the VDBE.\n**\n** Each callback contains the following information:\n**\n**     argv[0] = type of object: \"table\", \"index\", \"trigger\", or \"view\".\n**     argv[1] = name of thing being created\n**     argv[2] = associated table if an index or trigger\n**     argv[3] = root page number for table or index. 0 for trigger or view.\n**     argv[4] = SQL text for the CREATE statement.\n**\n*/\nint sqlite3InitCallback(void *pInit, int argc, char **argv, char **NotUsed){\n  InitData *pData = (InitData*)pInit;\n  sqlite3 *db = pData->db;\n  int iDb = pData->iDb;\n\n  assert( argc==5 );\n  UNUSED_PARAMETER2(NotUsed, argc);\n  assert( sqlite3_mutex_held(db->mutex) );\n  db->mDbFlags |= DBFLAG_EncodingFixed;\n  if( argv==0 ) return 0;   /* Might happen if EMPTY_RESULT_CALLBACKS are on */\n  pData->nInitRow++;\n  if( db->mallocFailed ){\n    corruptSchema(pData, argv, 0);\n    return 1;\n  }\n\n  assert( iDb>=0 && iDb<db->nDb );\n  if( argv[3]==0 ){\n    corruptSchema(pData, argv, 0);\n  }else if( argv[4]\n         && 'c'==sqlite3UpperToLower[(unsigned char)argv[4][0]]\n         && 'r'==sqlite3UpperToLower[(unsigned char)argv[4][1]] ){\n    /* Call the parser to process a CREATE TABLE, INDEX or VIEW.\n    ** But because db->init.busy is set to 1, no VDBE code is generated\n    ** or executed.  All the parser does is build the internal data\n    ** structures that describe the table, index, or view.\n    **\n    ** No other valid SQL statement, other than the variable CREATE statements,\n    ** can begin with the letters \"C\" and \"R\".  Thus, it is not possible run\n    ** any other kind of statement while parsing the schema, even a corrupt\n    ** schema.\n    */\n    int rc;\n    u8 saved_iDb = db->init.iDb;\n    sqlite3_stmt *pStmt;\n    TESTONLY(int rcp);            /* Return code from sqlite3_prepare() */\n\n    assert( db->init.busy );\n    db->init.iDb = iDb;\n    if( sqlite3GetUInt32(argv[3], &db->init.newTnum)==0\n     || (db->init.newTnum>pData->mxPage && pData->mxPage>0)\n    ){\n      if( sqlite3Config.bExtraSchemaChecks ){\n        corruptSchema(pData, argv, \"invalid rootpage\");\n      }\n    }\n    db->init.orphanTrigger = 0;\n    db->init.azInit = (const char**)argv;\n    pStmt = 0;\n    TESTONLY(rcp = ) sqlite3Prepare(db, argv[4], -1, 0, 0, &pStmt, 0);\n    rc = db->errCode;\n    assert( (rc&0xFF)==(rcp&0xFF) );\n    db->init.iDb = saved_iDb;\n    /* assert( saved_iDb==0 || (db->mDbFlags & DBFLAG_Vacuum)!=0 ); */\n    if( SQLITE_OK!=rc ){\n      if( db->init.orphanTrigger ){\n        assert( iDb==1 );\n      }else{\n        if( rc > pData->rc ) pData->rc = rc;\n        if( rc==SQLITE_NOMEM ){\n          sqlite3OomFault(db);\n        }else if( rc!=SQLITE_INTERRUPT && (rc&0xFF)!=SQLITE_LOCKED ){\n          corruptSchema(pData, argv, sqlite3_errmsg(db));\n        }\n      }\n    }\n    db->init.azInit = sqlite3StdType; /* Any array of string ptrs will do */\n    sqlite3_finalize(pStmt);\n  }else if( argv[1]==0 || (argv[4]!=0 && argv[4][0]!=0) ){\n    corruptSchema(pData, argv, 0);\n  }else{\n    /* If the SQL column is blank it means this is an index that\n    ** was created to be the PRIMARY KEY or to fulfill a UNIQUE\n    ** constraint for a CREATE TABLE.  The index should have already\n    ** been created when we processed the CREATE TABLE.  All we have\n    ** to do here is record the root page number for that index.\n    */\n    Index *pIndex;\n    pIndex = sqlite3FindIndex(db, argv[1], db->aDb[iDb].zDbSName);\n    if( pIndex==0 ){\n      corruptSchema(pData, argv, \"orphan index\");\n    }else\n    if( sqlite3GetUInt32(argv[3],&pIndex->tnum)==0\n     || pIndex->tnum<2\n     || pIndex->tnum>pData->mxPage\n     || sqlite3IndexHasDuplicateRootPage(pIndex)\n    ){\n      if( sqlite3Config.bExtraSchemaChecks ){\n        corruptSchema(pData, argv, \"invalid rootpage\");\n      }\n    }\n  }\n  return 0;\n}\n\n/*\n** Attempt to read the database schema and initialize internal\n** data structures for a single database file.  The index of the\n** database file is given by iDb.  iDb==0 is used for the main\n** database.  iDb==1 should never be used.  iDb>=2 is used for\n** auxiliary databases.  Return one of the SQLITE_ error codes to\n** indicate success or failure.\n*/\nint sqlite3InitOne(sqlite3 *db, int iDb, char **pzErrMsg, u32 mFlags){\n  int rc;\n  int i;\n#ifndef SQLITE_OMIT_DEPRECATED\n  int size;\n#endif\n  Db *pDb;\n  char const *azArg[6];\n  int meta[5];\n  InitData initData;\n  const char *zSchemaTabName;\n  int openedTransaction = 0;\n  int mask = ((db->mDbFlags & DBFLAG_EncodingFixed) | ~DBFLAG_EncodingFixed);\n\n  assert( (db->mDbFlags & DBFLAG_SchemaKnownOk)==0 );\n  assert( iDb>=0 && iDb<db->nDb );\n  assert( db->aDb[iDb].pSchema );\n  assert( sqlite3_mutex_held(db->mutex) );\n  assert( iDb==1 || sqlite3BtreeHoldsMutex(db->aDb[iDb].pBt) );\n\n  db->init.busy = 1;\n\n  /* Construct the in-memory representation schema tables (sqlite_schema or\n  ** sqlite_temp_schema) by invoking the parser directly.  The appropriate\n  ** table name will be inserted automatically by the parser so we can just\n  ** use the abbreviation \"x\" here.  The parser will also automatically tag\n  ** the schema table as read-only. */\n  azArg[0] = \"table\";\n  azArg[1] = zSchemaTabName = SCHEMA_TABLE(iDb);\n  azArg[2] = azArg[1];\n  azArg[3] = \"1\";\n  azArg[4] = \"CREATE TABLE x(type text,name text,tbl_name text,\"\n                            \"rootpage int,sql text)\";\n  azArg[5] = 0;\n  initData.db = db;\n  initData.iDb = iDb;\n  initData.rc = SQLITE_OK;\n  initData.pzErrMsg = pzErrMsg;\n  initData.mInitFlags = mFlags;\n  initData.nInitRow = 0;\n  initData.mxPage = 0;\n  sqlite3InitCallback(&initData, 5, (char **)azArg, 0);\n  db->mDbFlags &= mask;\n  if( initData.rc ){\n    rc = initData.rc;\n    goto error_out;\n  }\n\n  /* Create a cursor to hold the database open\n  */\n  pDb = &db->aDb[iDb];\n  if( pDb->pBt==0 ){\n    assert( iDb==1 );\n    DbSetProperty(db, 1, DB_SchemaLoaded);\n    rc = SQLITE_OK;\n    goto error_out;\n  }\n\n  /* If there is not already a read-only (or read-write) transaction opened\n  ** on the b-tree database, open one now. If a transaction is opened, it \n  ** will be closed before this function returns.  */\n  sqlite3BtreeEnter(pDb->pBt);\n  if( sqlite3BtreeTxnState(pDb->pBt)==SQLITE_TXN_NONE ){\n    rc = sqlite3BtreeBeginTrans(pDb->pBt, 0, 0);\n    if( rc!=SQLITE_OK ){\n      sqlite3SetString(pzErrMsg, db, sqlite3ErrStr(rc));\n      goto initone_error_out;\n    }\n    openedTransaction = 1;\n  }\n\n  /* Get the database meta information.\n  **\n  ** Meta values are as follows:\n  **    meta[0]   Schema cookie.  Changes with each schema change.\n  **    meta[1]   File format of schema layer.\n  **    meta[2]   Size of the page cache.\n  **    meta[3]   Largest rootpage (auto/incr_vacuum mode)\n  **    meta[4]   Db text encoding. 1:UTF-8 2:UTF-16LE 3:UTF-16BE\n  **    meta[5]   User version\n  **    meta[6]   Incremental vacuum mode\n  **    meta[7]   unused\n  **    meta[8]   unused\n  **    meta[9]   unused\n  **\n  ** Note: The #defined SQLITE_UTF* symbols in sqliteInt.h correspond to\n  ** the possible values of meta[4].\n  */\n  for(i=0; i<ArraySize(meta); i++){\n    sqlite3BtreeGetMeta(pDb->pBt, i+1, (u32 *)&meta[i]);\n  }\n  if( (db->flags & SQLITE_ResetDatabase)!=0 ){\n    memset(meta, 0, sizeof(meta));\n  }\n  pDb->pSchema->schema_cookie = meta[BTREE_SCHEMA_VERSION-1];\n\n  /* If opening a non-empty database, check the text encoding. For the\n  ** main database, set sqlite3.enc to the encoding of the main database.\n  ** For an attached db, it is an error if the encoding is not the same\n  ** as sqlite3.enc.\n  */\n  if( meta[BTREE_TEXT_ENCODING-1] ){  /* text encoding */\n    if( iDb==0 && (db->mDbFlags & DBFLAG_EncodingFixed)==0 ){\n      u8 encoding;\n#ifndef SQLITE_OMIT_UTF16\n      /* If opening the main database, set ENC(db). */\n      encoding = (u8)meta[BTREE_TEXT_ENCODING-1] & 3;\n      if( encoding==0 ) encoding = SQLITE_UTF8;\n#else\n      encoding = SQLITE_UTF8;\n#endif\n      sqlite3SetTextEncoding(db, encoding);\n    }else{\n      /* If opening an attached database, the encoding much match ENC(db) */\n      if( (meta[BTREE_TEXT_ENCODING-1] & 3)!=ENC(db) ){\n        sqlite3SetString(pzErrMsg, db, \"attached databases must use the same\"\n            \" text encoding as main database\");\n        rc = SQLITE_ERROR;\n        goto initone_error_out;\n      }\n    }\n  }\n  pDb->pSchema->enc = ENC(db);\n\n  if( pDb->pSchema->cache_size==0 ){\n#ifndef SQLITE_OMIT_DEPRECATED\n    size = sqlite3AbsInt32(meta[BTREE_DEFAULT_CACHE_SIZE-1]);\n    if( size==0 ){ size = SQLITE_DEFAULT_CACHE_SIZE; }\n    pDb->pSchema->cache_size = size;\n#else\n    pDb->pSchema->cache_size = SQLITE_DEFAULT_CACHE_SIZE;\n#endif\n    sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);\n  }\n\n  /*\n  ** file_format==1    Version 3.0.0.\n  ** file_format==2    Version 3.1.3.  // ALTER TABLE ADD COLUMN\n  ** file_format==3    Version 3.1.4.  // ditto but with non-NULL defaults\n  ** file_format==4    Version 3.3.0.  // DESC indices.  Boolean constants\n  */\n  pDb->pSchema->file_format = (u8)meta[BTREE_FILE_FORMAT-1];\n  if( pDb->pSchema->file_format==0 ){\n    pDb->pSchema->file_format = 1;\n  }\n  if( pDb->pSchema->file_format>SQLITE_MAX_FILE_FORMAT ){\n    sqlite3SetString(pzErrMsg, db, \"unsupported file format\");\n    rc = SQLITE_ERROR;\n    goto initone_error_out;\n  }\n\n  /* Ticket #2804:  When we open a database in the newer file format,\n  ** clear the legacy_file_format pragma flag so that a VACUUM will\n  ** not downgrade the database and thus invalidate any descending\n  ** indices that the user might have created.\n  */\n  if( iDb==0 && meta[BTREE_FILE_FORMAT-1]>=4 ){\n    db->flags &= ~(u64)SQLITE_LegacyFileFmt;\n  }\n\n  /* Read the schema information out of the schema tables\n  */\n  assert( db->init.busy );\n  initData.mxPage = sqlite3BtreeLastPage(pDb->pBt);\n  {\n    char *zSql;\n    zSql = sqlite3MPrintf(db, \n        \"SELECT*FROM\\\"%w\\\".%s ORDER BY rowid\",\n        db->aDb[iDb].zDbSName, zSchemaTabName);\n#ifndef SQLITE_OMIT_AUTHORIZATION\n    {\n      sqlite3_xauth xAuth;\n      xAuth = db->xAuth;\n      db->xAuth = 0;\n#endif\n      rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0);\n#ifndef SQLITE_OMIT_AUTHORIZATION\n      db->xAuth = xAuth;\n    }\n#endif\n    if( rc==SQLITE_OK ) rc = initData.rc;\n    sqlite3DbFree(db, zSql);\n#ifndef SQLITE_OMIT_ANALYZE\n    if( rc==SQLITE_OK ){\n      sqlite3AnalysisLoad(db, iDb);\n    }\n#endif\n  }\n  assert( pDb == &(db->aDb[iDb]) );\n  if( db->mallocFailed ){\n    rc = SQLITE_NOMEM_BKPT;\n    sqlite3ResetAllSchemasOfConnection(db);\n    pDb = &db->aDb[iDb];\n  }else\n  if( rc==SQLITE_OK || ((db->flags&SQLITE_NoSchemaError) && rc!=SQLITE_NOMEM)){\n    /* Hack: If the SQLITE_NoSchemaError flag is set, then consider\n    ** the schema loaded, even if errors (other than OOM) occurred. In\n    ** this situation the current sqlite3_prepare() operation will fail,\n    ** but the following one will attempt to compile the supplied statement\n    ** against whatever subset of the schema was loaded before the error\n    ** occurred.\n    **\n    ** The primary purpose of this is to allow access to the sqlite_schema\n    ** table even when its contents have been corrupted.\n    */\n    DbSetProperty(db, iDb, DB_SchemaLoaded);\n    rc = SQLITE_OK;\n  }\n\n  /* Jump here for an error that occurs after successfully allocating\n  ** curMain and calling sqlite3BtreeEnter(). For an error that occurs\n  ** before that point, jump to error_out.\n  */\ninitone_error_out:\n  if( openedTransaction ){\n    sqlite3BtreeCommit(pDb->pBt);\n  }\n  sqlite3BtreeLeave(pDb->pBt);\n\nerror_out:\n  if( rc ){\n    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ){\n      sqlite3OomFault(db);\n    }\n    sqlite3ResetOneSchema(db, iDb);\n  }\n  db->init.busy = 0;\n  return rc;\n}\n\n/*\n** Initialize all database files - the main database file, the file\n** used to store temporary tables, and any additional database files\n** created using ATTACH statements.  Return a success code.  If an\n** error occurs, write an error message into *pzErrMsg.\n**\n** After a database is initialized, the DB_SchemaLoaded bit is set\n** bit is set in the flags field of the Db structure. \n*/\nint sqlite3Init(sqlite3 *db, char **pzErrMsg){\n  int i, rc;\n  int commit_internal = !(db->mDbFlags&DBFLAG_SchemaChange);\n  \n  assert( sqlite3_mutex_held(db->mutex) );\n  assert( sqlite3BtreeHoldsMutex(db->aDb[0].pBt) );\n  assert( db->init.busy==0 );\n  ENC(db) = SCHEMA_ENC(db);\n  assert( db->nDb>0 );\n  /* Do the main schema first */\n  if( !DbHasProperty(db, 0, DB_SchemaLoaded) ){\n    rc = sqlite3InitOne(db, 0, pzErrMsg, 0);\n    if( rc ) return rc;\n  }\n  /* All other schemas after the main schema. The \"temp\" schema must be last */\n  for(i=db->nDb-1; i>0; i--){\n    assert( i==1 || sqlite3BtreeHoldsMutex(db->aDb[i].pBt) );\n    if( !DbHasProperty(db, i, DB_SchemaLoaded) ){\n      rc = sqlite3InitOne(db, i, pzErrMsg, 0);\n      if( rc ) return rc;\n    }\n  }\n  if( commit_internal ){\n    sqlite3CommitInternalChanges(db);\n  }\n  return SQLITE_OK;\n}\n\n/*\n** This routine is a no-op if the database schema is already initialized.\n** Otherwise, the schema is loaded. An error code is returned.\n*/\nint sqlite3ReadSchema(Parse *pParse){\n  int rc = SQLITE_OK;\n  sqlite3 *db = pParse->db;\n  assert( sqlite3_mutex_held(db->mutex) );\n  if( !db->init.busy ){\n    rc = sqlite3Init(db, &pParse->zErrMsg);\n    if( rc!=SQLITE_OK ){\n      pParse->rc = rc;\n      pParse->nErr++;\n    }else if( db->noSharedCache ){\n      db->mDbFlags |= DBFLAG_SchemaKnownOk;\n    }\n  }\n  return rc;\n}\n\n\n/*\n** Check schema cookies in all databases.  If any cookie is out\n** of date set pParse->rc to SQLITE_SCHEMA.  If all schema cookies\n** make no changes to pParse->rc.\n*/\nstatic void schemaIsValid(Parse *pParse){\n  sqlite3 *db = pParse->db;\n  int iDb;\n  int rc;\n  int cookie;\n\n  assert( pParse->checkSchema );\n  assert( sqlite3_mutex_held(db->mutex) );\n  for(iDb=0; iDb<db->nDb; iDb++){\n    int openedTransaction = 0;         /* True if a transaction is opened */\n    Btree *pBt = db->aDb[iDb].pBt;     /* Btree database to read cookie from */\n    if( pBt==0 ) continue;\n\n    /* If there is not already a read-only (or read-write) transaction opened\n    ** on the b-tree database, open one now. If a transaction is opened, it \n    ** will be closed immediately after reading the meta-value. */\n    if( sqlite3BtreeTxnState(pBt)==SQLITE_TXN_NONE ){\n      rc = sqlite3BtreeBeginTrans(pBt, 0, 0);\n      if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ){\n        sqlite3OomFault(db);\n        pParse->rc = SQLITE_NOMEM;\n      }\n      if( rc!=SQLITE_OK ) return;\n      openedTransaction = 1;\n    }\n\n    /* Read the schema cookie from the database. If it does not match the \n    ** value stored as part of the in-memory schema representation,\n    ** set Parse.rc to SQLITE_SCHEMA. */\n    sqlite3BtreeGetMeta(pBt, BTREE_SCHEMA_VERSION, (u32 *)&cookie);\n    assert( sqlite3SchemaMutexHeld(db, iDb, 0) );\n    if( cookie!=db->aDb[iDb].pSchema->schema_cookie ){\n      if( DbHasProperty(db, iDb, DB_SchemaLoaded) ) pParse->rc = SQLITE_SCHEMA;\n      sqlite3ResetOneSchema(db, iDb);\n    }\n\n    /* Close the transaction, if one was opened. */\n    if( openedTransaction ){\n      sqlite3BtreeCommit(pBt);\n    }\n  }\n}\n\n/*\n** Convert a schema pointer into the iDb index that indicates\n** which database file in db->aDb[] the schema refers to.\n**\n** If the same database is attached more than once, the first\n** attached database is returned.\n*/\nint sqlite3SchemaToIndex(sqlite3 *db, Schema *pSchema){\n  int i = -32768;\n\n  /* If pSchema is NULL, then return -32768. This happens when code in \n  ** expr.c is trying to resolve a reference to a transient table (i.e. one\n  ** created by a sub-select). In this case the return value of this \n  ** function should never be used.\n  **\n  ** We return -32768 instead of the more usual -1 simply because using\n  ** -32768 as the incorrect index into db->aDb[] is much \n  ** more likely to cause a segfault than -1 (of course there are assert()\n  ** statements too, but it never hurts to play the odds) and\n  ** -32768 will still fit into a 16-bit signed integer.\n  */\n  assert( sqlite3_mutex_held(db->mutex) );\n  if( pSchema ){\n    for(i=0; 1; i++){\n      assert( i<db->nDb );\n      if( db->aDb[i].pSchema==pSchema ){\n        break;\n      }\n    }\n    assert( i>=0 && i<db->nDb );\n  }\n  return i;\n}\n\n/*\n** Free all memory allocations in the pParse object\n*/\nvoid sqlite3ParseObjectReset(Parse *pParse){\n  sqlite3 *db = pParse->db;\n  assert( db!=0 );\n  assert( db->pParse==pParse );\n  assert( pParse->nested==0 );\n#ifndef SQLITE_OMIT_SHARED_CACHE\n  if( pParse->aTableLock ) sqlite3DbNNFreeNN(db, pParse->aTableLock);\n#endif\n  while( pParse->pCleanup ){\n    ParseCleanup *pCleanup = pParse->pCleanup;\n    pParse->pCleanup = pCleanup->pNext;\n    pCleanup->xCleanup(db, pCleanup->pPtr);\n    sqlite3DbNNFreeNN(db, pCleanup);\n  }\n  if( pParse->aLabel ) sqlite3DbNNFreeNN(db, pParse->aLabel);\n  if( pParse->pConstExpr ){\n    sqlite3ExprListDelete(db, pParse->pConstExpr);\n  }\n  assert( db->lookaside.bDisable >= pParse->disableLookaside );\n  db->lookaside.bDisable -= pParse->disableLookaside;\n  db->lookaside.sz = db->lookaside.bDisable ? 0 : db->lookaside.szTrue;\n  assert( pParse->db->pParse==pParse );\n  db->pParse = pParse->pOuterParse;\n}\n\n/*\n** Add a new cleanup operation to a Parser.  The cleanup should happen when\n** the parser object is destroyed.  But, beware: the cleanup might happen\n** immediately.\n**\n** Use this mechanism for uncommon cleanups.  There is a higher setup\n** cost for this mechanism (an extra malloc), so it should not be used\n** for common cleanups that happen on most calls.  But for less\n** common cleanups, we save a single NULL-pointer comparison in\n** sqlite3ParseObjectReset(), which reduces the total CPU cycle count.\n**\n** If a memory allocation error occurs, then the cleanup happens immediately.\n** When either SQLITE_DEBUG or SQLITE_COVERAGE_TEST are defined, the\n** pParse->earlyCleanup flag is set in that case.  Calling code show verify\n** that test cases exist for which this happens, to guard against possible\n** use-after-free errors following an OOM.  The preferred way to do this is\n** to immediately follow the call to this routine with:\n**\n**       testcase( pParse->earlyCleanup );\n**\n** This routine returns a copy of its pPtr input (the third parameter)\n** except if an early cleanup occurs, in which case it returns NULL.  So\n** another way to check for early cleanup is to check the return value.\n** Or, stop using the pPtr parameter with this call and use only its\n** return value thereafter.  Something like this:\n**\n**       pObj = sqlite3ParserAddCleanup(pParse, destructor, pObj);\n*/\nvoid *sqlite3ParserAddCleanup(\n  Parse *pParse,                      /* Destroy when this Parser finishes */\n  void (*xCleanup)(sqlite3*,void*),   /* The cleanup routine */\n  void *pPtr                          /* Pointer to object to be cleaned up */\n){\n  ParseCleanup *pCleanup;\n  if( sqlite3FaultSim(300) ){\n    pCleanup = 0;\n    sqlite3OomFault(pParse->db);\n  }else{\n    pCleanup = sqlite3DbMallocRaw(pParse->db, sizeof(*pCleanup));\n  }\n  if( pCleanup ){\n    pCleanup->pNext = pParse->pCleanup;\n    pParse->pCleanup = pCleanup;\n    pCleanup->pPtr = pPtr;\n    pCleanup->xCleanup = xCleanup;\n  }else{\n    xCleanup(pParse->db, pPtr);\n    pPtr = 0;\n#if defined(SQLITE_DEBUG) || defined(SQLITE_COVERAGE_TEST)\n    pParse->earlyCleanup = 1;\n#endif\n  }\n  return pPtr;\n}\n\n/*\n** Turn bulk memory into a valid Parse object and link that Parse object\n** into database connection db.\n**\n** Call sqlite3ParseObjectReset() to undo this operation.\n**\n** Caution:  Do not confuse this routine with sqlite3ParseObjectInit() which\n** is generated by Lemon.\n*/\nvoid sqlite3ParseObjectInit(Parse *pParse, sqlite3 *db){\n  memset(PARSE_HDR(pParse), 0, PARSE_HDR_SZ);\n  memset(PARSE_TAIL(pParse), 0, PARSE_TAIL_SZ);\n  assert( db->pParse!=pParse );\n  pParse->pOuterParse = db->pParse;\n  db->pParse = pParse;\n  pParse->db = db;\n  if( db->mallocFailed ) sqlite3ErrorMsg(pParse, \"out of memory\");\n}\n\n/*\n** Maximum number of times that we will try again to prepare a statement\n** that returns SQLITE_ERROR_RETRY.\n*/\n#ifndef SQLITE_MAX_PREPARE_RETRY\n# define SQLITE_MAX_PREPARE_RETRY 25\n#endif\n\n/*\n** Compile the UTF-8 encoded SQL statement zSql into a statement handle.\n*/\nstatic int sqlite3Prepare(\n  sqlite3 *db,              /* Database handle. */\n  const char *zSql,         /* UTF-8 encoded SQL statement. */\n  int nBytes,               /* Length of zSql in bytes. */\n  u32 prepFlags,            /* Zero or more SQLITE_PREPARE_* flags */\n  Vdbe *pReprepare,         /* VM being reprepared */\n  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n  const char **pzTail       /* OUT: End of parsed string */\n){\n  int rc = SQLITE_OK;       /* Result code */\n  int i;                    /* Loop counter */\n  Parse sParse;             /* Parsing context */\n\n  /* sqlite3ParseObjectInit(&sParse, db); // inlined for performance */\n  memset(PARSE_HDR(&sParse), 0, PARSE_HDR_SZ);\n  memset(PARSE_TAIL(&sParse), 0, PARSE_TAIL_SZ);\n  sParse.pOuterParse = db->pParse;\n  db->pParse = &sParse;\n  sParse.db = db;\n  if( pReprepare ){\n    sParse.pReprepare = pReprepare;\n    sParse.explain = sqlite3_stmt_isexplain((sqlite3_stmt*)pReprepare);\n  }else{\n    assert( sParse.pReprepare==0 );\n  }\n  assert( ppStmt && *ppStmt==0 );\n  if( db->mallocFailed ){\n    sqlite3ErrorMsg(&sParse, \"out of memory\");\n    db->errCode = rc = SQLITE_NOMEM;\n    goto end_prepare;\n  }\n  assert( sqlite3_mutex_held(db->mutex) );\n\n  /* For a long-term use prepared statement avoid the use of\n  ** lookaside memory.\n  */\n  if( prepFlags & SQLITE_PREPARE_PERSISTENT ){\n    sParse.disableLookaside++;\n    DisableLookaside;\n  }\n  sParse.prepFlags = prepFlags & 0xff;\n\n  /* Check to verify that it is possible to get a read lock on all\n  ** database schemas.  The inability to get a read lock indicates that\n  ** some other database connection is holding a write-lock, which in\n  ** turn means that the other connection has made uncommitted changes\n  ** to the schema.\n  **\n  ** Were we to proceed and prepare the statement against the uncommitted\n  ** schema changes and if those schema changes are subsequently rolled\n  ** back and different changes are made in their place, then when this\n  ** prepared statement goes to run the schema cookie would fail to detect\n  ** the schema change.  Disaster would follow.\n  **\n  ** This thread is currently holding mutexes on all Btrees (because\n  ** of the sqlite3BtreeEnterAll() in sqlite3LockAndPrepare()) so it\n  ** is not possible for another thread to start a new schema change\n  ** while this routine is running.  Hence, we do not need to hold \n  ** locks on the schema, we just need to make sure nobody else is \n  ** holding them.\n  **\n  ** Note that setting READ_UNCOMMITTED overrides most lock detection,\n  ** but it does *not* override schema lock detection, so this all still\n  ** works even if READ_UNCOMMITTED is set.\n  */\n  if( !db->noSharedCache ){\n    for(i=0; i<db->nDb; i++) {\n      Btree *pBt = db->aDb[i].pBt;\n      if( pBt ){\n        assert( sqlite3BtreeHoldsMutex(pBt) );\n        rc = sqlite3BtreeSchemaLocked(pBt);\n        if( rc ){\n          const char *zDb = db->aDb[i].zDbSName;\n          sqlite3ErrorWithMsg(db, rc, \"database schema is locked: %s\", zDb);\n          testcase( db->flags & SQLITE_ReadUncommit );\n          goto end_prepare;\n        }\n      }\n    }\n  }\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( db->pDisconnect ) sqlite3VtabUnlockList(db);\n#endif\n\n  if( nBytes>=0 && (nBytes==0 || zSql[nBytes-1]!=0) ){\n    char *zSqlCopy;\n    int mxLen = db->aLimit[SQLITE_LIMIT_SQL_LENGTH];\n    testcase( nBytes==mxLen );\n    testcase( nBytes==mxLen+1 );\n    if( nBytes>mxLen ){\n      sqlite3ErrorWithMsg(db, SQLITE_TOOBIG, \"statement too long\");\n      rc = sqlite3ApiExit(db, SQLITE_TOOBIG);\n      goto end_prepare;\n    }\n    zSqlCopy = sqlite3DbStrNDup(db, zSql, nBytes);\n    if( zSqlCopy ){\n      sqlite3RunParser(&sParse, zSqlCopy);\n      sParse.zTail = &zSql[sParse.zTail-zSqlCopy];\n      sqlite3DbFree(db, zSqlCopy);\n    }else{\n      sParse.zTail = &zSql[nBytes];\n    }\n  }else{\n    sqlite3RunParser(&sParse, zSql);\n  }\n  assert( 0==sParse.nQueryLoop );\n\n  if( pzTail ){\n    *pzTail = sParse.zTail;\n  }\n\n  if( db->init.busy==0 ){\n    sqlite3VdbeSetSql(sParse.pVdbe, zSql, (int)(sParse.zTail-zSql), prepFlags);\n  }\n  if( db->mallocFailed ){\n    sParse.rc = SQLITE_NOMEM_BKPT;\n    sParse.checkSchema = 0;\n  }\n  if( sParse.rc!=SQLITE_OK && sParse.rc!=SQLITE_DONE ){\n    if( sParse.checkSchema && db->init.busy==0 ){\n      schemaIsValid(&sParse);\n    }\n    if( sParse.pVdbe ){\n      sqlite3VdbeFinalize(sParse.pVdbe);\n    }\n    assert( 0==(*ppStmt) );\n    rc = sParse.rc;\n    if( sParse.zErrMsg ){\n      sqlite3ErrorWithMsg(db, rc, \"%s\", sParse.zErrMsg);\n      sqlite3DbFree(db, sParse.zErrMsg);\n    }else{\n      sqlite3Error(db, rc);\n    }\n  }else{\n    assert( sParse.zErrMsg==0 );\n    *ppStmt = (sqlite3_stmt*)sParse.pVdbe;\n    rc = SQLITE_OK;\n    sqlite3ErrorClear(db);\n  }\n\n\n  /* Delete any TriggerPrg structures allocated while parsing this statement. */\n  while( sParse.pTriggerPrg ){\n    TriggerPrg *pT = sParse.pTriggerPrg;\n    sParse.pTriggerPrg = pT->pNext;\n    sqlite3DbFree(db, pT);\n  }\n\nend_prepare:\n\n  sqlite3ParseObjectReset(&sParse);\n  return rc;\n}\nstatic int sqlite3LockAndPrepare(\n  sqlite3 *db,              /* Database handle. */\n  const char *zSql,         /* UTF-8 encoded SQL statement. */\n  int nBytes,               /* Length of zSql in bytes. */\n  u32 prepFlags,            /* Zero or more SQLITE_PREPARE_* flags */\n  Vdbe *pOld,               /* VM being reprepared */\n  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n  const char **pzTail       /* OUT: End of parsed string */\n){\n  int rc;\n  int cnt = 0;\n\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( ppStmt==0 ) return SQLITE_MISUSE_BKPT;\n#endif\n  *ppStmt = 0;\n  if( !sqlite3SafetyCheckOk(db)||zSql==0 ){\n    return SQLITE_MISUSE_BKPT;\n  }\n  sqlite3_mutex_enter(db->mutex);\n  sqlite3BtreeEnterAll(db);\n  do{\n    /* Make multiple attempts to compile the SQL, until it either succeeds\n    ** or encounters a permanent error.  A schema problem after one schema\n    ** reset is considered a permanent error. */\n    rc = sqlite3Prepare(db, zSql, nBytes, prepFlags, pOld, ppStmt, pzTail);\n    assert( rc==SQLITE_OK || *ppStmt==0 );\n    if( rc==SQLITE_OK || db->mallocFailed ) break;\n    cnt++;\n  }while( (rc==SQLITE_ERROR_RETRY && ALWAYS(cnt<=SQLITE_MAX_PREPARE_RETRY))\n       || (rc==SQLITE_SCHEMA && (sqlite3ResetOneSchema(db,-1), cnt)==1) );\n  sqlite3BtreeLeaveAll(db);\n  assert( rc!=SQLITE_ERROR_RETRY );\n  rc = sqlite3ApiExit(db, rc);\n  assert( (rc&db->errMask)==rc );\n  db->busyHandler.nBusy = 0;\n  sqlite3_mutex_leave(db->mutex);\n  assert( rc==SQLITE_OK || (*ppStmt)==0 );\n  return rc;\n}\n\n\n/*\n** Rerun the compilation of a statement after a schema change.\n**\n** If the statement is successfully recompiled, return SQLITE_OK. Otherwise,\n** if the statement cannot be recompiled because another connection has\n** locked the sqlite3_schema table, return SQLITE_LOCKED. If any other error\n** occurs, return SQLITE_SCHEMA.\n*/\nint sqlite3Reprepare(Vdbe *p){\n  int rc;\n  sqlite3_stmt *pNew;\n  const char *zSql;\n  sqlite3 *db;\n  u8 prepFlags;\n\n  assert( sqlite3_mutex_held(sqlite3VdbeDb(p)->mutex) );\n  zSql = sqlite3_sql((sqlite3_stmt *)p);\n  assert( zSql!=0 );  /* Reprepare only called for prepare_v2() statements */\n  db = sqlite3VdbeDb(p);\n  assert( sqlite3_mutex_held(db->mutex) );\n  prepFlags = sqlite3VdbePrepareFlags(p);\n  rc = sqlite3LockAndPrepare(db, zSql, -1, prepFlags, p, &pNew, 0);\n  if( rc ){\n    if( rc==SQLITE_NOMEM ){\n      sqlite3OomFault(db);\n    }\n    assert( pNew==0 );\n    return rc;\n  }else{\n    assert( pNew!=0 );\n  }\n  sqlite3VdbeSwap((Vdbe*)pNew, p);\n  sqlite3TransferBindings(pNew, (sqlite3_stmt*)p);\n  sqlite3VdbeResetStepResult((Vdbe*)pNew);\n  sqlite3VdbeFinalize((Vdbe*)pNew);\n  return SQLITE_OK;\n}\n\n\n/*\n** Two versions of the official API.  Legacy and new use.  In the legacy\n** version, the original SQL text is not saved in the prepared statement\n** and so if a schema change occurs, SQLITE_SCHEMA is returned by\n** sqlite3_step().  In the new version, the original SQL text is retained\n** and the statement is automatically recompiled if an schema change\n** occurs.\n*/\nint sqlite3_prepare(\n  sqlite3 *db,              /* Database handle. */\n  const char *zSql,         /* UTF-8 encoded SQL statement. */\n  int nBytes,               /* Length of zSql in bytes. */\n  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n  const char **pzTail       /* OUT: End of parsed string */\n){\n  int rc;\n  rc = sqlite3LockAndPrepare(db,zSql,nBytes,0,0,ppStmt,pzTail);\n  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */\n  return rc;\n}\nint sqlite3_prepare_v2(\n  sqlite3 *db,              /* Database handle. */\n  const char *zSql,         /* UTF-8 encoded SQL statement. */\n  int nBytes,               /* Length of zSql in bytes. */\n  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n  const char **pzTail       /* OUT: End of parsed string */\n){\n  int rc;\n  /* EVIDENCE-OF: R-37923-12173 The sqlite3_prepare_v2() interface works\n  ** exactly the same as sqlite3_prepare_v3() with a zero prepFlags\n  ** parameter.\n  **\n  ** Proof in that the 5th parameter to sqlite3LockAndPrepare is 0 */\n  rc = sqlite3LockAndPrepare(db,zSql,nBytes,SQLITE_PREPARE_SAVESQL,0,\n                             ppStmt,pzTail);\n  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );\n  return rc;\n}\nint sqlite3_prepare_v3(\n  sqlite3 *db,              /* Database handle. */\n  const char *zSql,         /* UTF-8 encoded SQL statement. */\n  int nBytes,               /* Length of zSql in bytes. */\n  unsigned int prepFlags,   /* Zero or more SQLITE_PREPARE_* flags */\n  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n  const char **pzTail       /* OUT: End of parsed string */\n){\n  int rc;\n  /* EVIDENCE-OF: R-56861-42673 sqlite3_prepare_v3() differs from\n  ** sqlite3_prepare_v2() only in having the extra prepFlags parameter,\n  ** which is a bit array consisting of zero or more of the\n  ** SQLITE_PREPARE_* flags.\n  **\n  ** Proof by comparison to the implementation of sqlite3_prepare_v2()\n  ** directly above. */\n  rc = sqlite3LockAndPrepare(db,zSql,nBytes,\n                 SQLITE_PREPARE_SAVESQL|(prepFlags&SQLITE_PREPARE_MASK),\n                 0,ppStmt,pzTail);\n  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );\n  return rc;\n}\n\n\n#ifndef SQLITE_OMIT_UTF16\n/*\n** Compile the UTF-16 encoded SQL statement zSql into a statement handle.\n*/\nstatic int sqlite3Prepare16(\n  sqlite3 *db,              /* Database handle. */ \n  const void *zSql,         /* UTF-16 encoded SQL statement. */\n  int nBytes,               /* Length of zSql in bytes. */\n  u32 prepFlags,            /* Zero or more SQLITE_PREPARE_* flags */\n  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n  const void **pzTail       /* OUT: End of parsed string */\n){\n  /* This function currently works by first transforming the UTF-16\n  ** encoded string to UTF-8, then invoking sqlite3_prepare(). The\n  ** tricky bit is figuring out the pointer to return in *pzTail.\n  */\n  char *zSql8;\n  const char *zTail8 = 0;\n  int rc = SQLITE_OK;\n\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( ppStmt==0 ) return SQLITE_MISUSE_BKPT;\n#endif\n  *ppStmt = 0;\n  if( !sqlite3SafetyCheckOk(db)||zSql==0 ){\n    return SQLITE_MISUSE_BKPT;\n  }\n\n  /* Make sure nBytes is non-negative and correct.  It should be the\n  ** number of bytes until the end of the input buffer or until the first\n  ** U+0000 character.  If the input nBytes is odd, convert it into\n  ** an even number.  If the input nBytes is negative, then the input\n  ** must be terminated by at least one U+0000 character */\n  if( nBytes>=0 ){\n    int sz;\n    const char *z = (const char*)zSql;\n    for(sz=0; sz<nBytes && (z[sz]!=0 || z[sz+1]!=0); sz += 2){}\n    nBytes = sz;\n  }else{\n    int sz;\n    const char *z = (const char*)zSql;\n    for(sz=0; z[sz]!=0 || z[sz+1]!=0; sz += 2){}\n    nBytes = sz;\n  }\n\n  sqlite3_mutex_enter(db->mutex);\n  zSql8 = sqlite3Utf16to8(db, zSql, nBytes, SQLITE_UTF16NATIVE);\n  if( zSql8 ){\n    rc = sqlite3LockAndPrepare(db, zSql8, -1, prepFlags, 0, ppStmt, &zTail8);\n  }\n\n  if( zTail8 && pzTail ){\n    /* If sqlite3_prepare returns a tail pointer, we calculate the\n    ** equivalent pointer into the UTF-16 string by counting the unicode\n    ** characters between zSql8 and zTail8, and then returning a pointer\n    ** the same number of characters into the UTF-16 string.\n    */\n    int chars_parsed = sqlite3Utf8CharLen(zSql8, (int)(zTail8-zSql8));\n    *pzTail = (u8 *)zSql + sqlite3Utf16ByteLen(zSql, nBytes, chars_parsed);\n  }\n  sqlite3DbFree(db, zSql8); \n  rc = sqlite3ApiExit(db, rc);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n/*\n** Two versions of the official API.  Legacy and new use.  In the legacy\n** version, the original SQL text is not saved in the prepared statement\n** and so if a schema change occurs, SQLITE_SCHEMA is returned by\n** sqlite3_step().  In the new version, the original SQL text is retained\n** and the statement is automatically recompiled if an schema change\n** occurs.\n*/\nint sqlite3_prepare16(\n  sqlite3 *db,              /* Database handle. */ \n  const void *zSql,         /* UTF-16 encoded SQL statement. */\n  int nBytes,               /* Length of zSql in bytes. */\n  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n  const void **pzTail       /* OUT: End of parsed string */\n){\n  int rc;\n  rc = sqlite3Prepare16(db,zSql,nBytes,0,ppStmt,pzTail);\n  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */\n  return rc;\n}\nint sqlite3_prepare16_v2(\n  sqlite3 *db,              /* Database handle. */ \n  const void *zSql,         /* UTF-16 encoded SQL statement. */\n  int nBytes,               /* Length of zSql in bytes. */\n  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n  const void **pzTail       /* OUT: End of parsed string */\n){\n  int rc;\n  rc = sqlite3Prepare16(db,zSql,nBytes,SQLITE_PREPARE_SAVESQL,ppStmt,pzTail);\n  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */\n  return rc;\n}\nint sqlite3_prepare16_v3(\n  sqlite3 *db,              /* Database handle. */ \n  const void *zSql,         /* UTF-16 encoded SQL statement. */\n  int nBytes,               /* Length of zSql in bytes. */\n  unsigned int prepFlags,   /* Zero or more SQLITE_PREPARE_* flags */\n  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n  const void **pzTail       /* OUT: End of parsed string */\n){\n  int rc;\n  rc = sqlite3Prepare16(db,zSql,nBytes,\n         SQLITE_PREPARE_SAVESQL|(prepFlags&SQLITE_PREPARE_MASK),\n         ppStmt,pzTail);\n  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */\n  return rc;\n}\n\n#endif /* SQLITE_OMIT_UTF16 */\n"}
{"repo": "sqlite", "file": "os_common.h", "lang": "C++", "code": "/*\n** 2004 May 22\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This file contains macros and a little bit of code that is common to\n** all of the platform-specific files (os_*.c) and is #included into those\n** files.\n**\n** This file should be #included by the os_*.c files only.  It is not a\n** general purpose header file.\n*/\n#ifndef _OS_COMMON_H_\n#define _OS_COMMON_H_\n\n/*\n** At least two bugs have slipped in because we changed the MEMORY_DEBUG\n** macro to SQLITE_DEBUG and some older makefiles have not yet made the\n** switch.  The following code should catch this problem at compile-time.\n*/\n#ifdef MEMORY_DEBUG\n# error \"The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead.\"\n#endif\n\n/*\n** Macros for performance tracing.  Normally turned off.  Only works\n** on i486 hardware.\n*/\n#ifdef SQLITE_PERFORMANCE_TRACE\n\nstatic sqlite_uint64 g_start;\nstatic sqlite_uint64 g_elapsed;\n#define TIMER_START       g_start=sqlite3Hwtime()\n#define TIMER_END         g_elapsed=sqlite3Hwtime()-g_start\n#define TIMER_ELAPSED     g_elapsed\n#else\n#define TIMER_START\n#define TIMER_END\n#define TIMER_ELAPSED     ((sqlite_uint64)0)\n#endif\n\n/*\n** If we compile with the SQLITE_TEST macro set, then the following block\n** of code will give us the ability to simulate a disk I/O error.  This\n** is used for testing the I/O recovery logic.\n*/\n#if defined(SQLITE_TEST)\nextern int sqlite3_io_error_hit;\nextern int sqlite3_io_error_hardhit;\nextern int sqlite3_io_error_pending;\nextern int sqlite3_io_error_persist;\nextern int sqlite3_io_error_benign;\nextern int sqlite3_diskfull_pending;\nextern int sqlite3_diskfull;\n#define SimulateIOErrorBenign(X) sqlite3_io_error_benign=(X)\n#define SimulateIOError(CODE)  \\\n  if( (sqlite3_io_error_persist && sqlite3_io_error_hit) \\\n       || sqlite3_io_error_pending-- == 1 )  \\\n              { local_ioerr(); CODE; }\nstatic void local_ioerr(){\n  IOTRACE((\"IOERR\\n\"));\n  sqlite3_io_error_hit++;\n  if( !sqlite3_io_error_benign ) sqlite3_io_error_hardhit++;\n}\n#define SimulateDiskfullError(CODE) \\\n   if( sqlite3_diskfull_pending ){ \\\n     if( sqlite3_diskfull_pending == 1 ){ \\\n       local_ioerr(); \\\n       sqlite3_diskfull = 1; \\\n       sqlite3_io_error_hit = 1; \\\n       CODE; \\\n     }else{ \\\n       sqlite3_diskfull_pending--; \\\n     } \\\n   }\n#else\n#define SimulateIOErrorBenign(X)\n#define SimulateIOError(A)\n#define SimulateDiskfullError(A)\n#endif /* defined(SQLITE_TEST) */\n\n/*\n** When testing, keep a count of the number of open files.\n*/\n#if defined(SQLITE_TEST)\nextern int sqlite3_open_file_count;\n#define OpenCounter(X)  sqlite3_open_file_count+=(X)\n#else\n#define OpenCounter(X)\n#endif /* defined(SQLITE_TEST) */\n\n#endif /* !defined(_OS_COMMON_H_) */\n"}
{"repo": "sqlite", "file": "pcache.c", "lang": "C++", "code": "/*\n** 2008 August 05\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file implements that page cache.\n*/\n#include \"sqliteInt.h\"\n\n/*\n** A complete page cache is an instance of this structure.  Every\n** entry in the cache holds a single page of the database file.  The\n** btree layer only operates on the cached copy of the database pages.\n**\n** A page cache entry is \"clean\" if it exactly matches what is currently\n** on disk.  A page is \"dirty\" if it has been modified and needs to be\n** persisted to disk.\n**\n** pDirty, pDirtyTail, pSynced:\n**   All dirty pages are linked into the doubly linked list using\n**   PgHdr.pDirtyNext and pDirtyPrev. The list is maintained in LRU order\n**   such that p was added to the list more recently than p->pDirtyNext.\n**   PCache.pDirty points to the first (newest) element in the list and\n**   pDirtyTail to the last (oldest).\n**\n**   The PCache.pSynced variable is used to optimize searching for a dirty\n**   page to eject from the cache mid-transaction. It is better to eject\n**   a page that does not require a journal sync than one that does. \n**   Therefore, pSynced is maintained so that it *almost* always points\n**   to either the oldest page in the pDirty/pDirtyTail list that has a\n**   clear PGHDR_NEED_SYNC flag or to a page that is older than this one\n**   (so that the right page to eject can be found by following pDirtyPrev\n**   pointers).\n*/\nstruct PCache {\n  PgHdr *pDirty, *pDirtyTail;         /* List of dirty pages in LRU order */\n  PgHdr *pSynced;                     /* Last synced page in dirty page list */\n  i64 nRefSum;                        /* Sum of ref counts over all pages */\n  int szCache;                        /* Configured cache size */\n  int szSpill;                        /* Size before spilling occurs */\n  int szPage;                         /* Size of every page in this cache */\n  int szExtra;                        /* Size of extra space for each page */\n  u8 bPurgeable;                      /* True if pages are on backing store */\n  u8 eCreate;                         /* eCreate value for for xFetch() */\n  int (*xStress)(void*,PgHdr*);       /* Call to try make a page clean */\n  void *pStress;                      /* Argument to xStress */\n  sqlite3_pcache *pCache;             /* Pluggable cache module */\n};\n\n/********************************** Test and Debug Logic **********************/\n/*\n** Debug tracing macros.  Enable by by changing the \"0\" to \"1\" and\n** recompiling.\n**\n** When sqlite3PcacheTrace is 1, single line trace messages are issued.\n** When sqlite3PcacheTrace is 2, a dump of the pcache showing all cache entries\n** is displayed for many operations, resulting in a lot of output.\n*/\n#if defined(SQLITE_DEBUG) && 0\n  int sqlite3PcacheTrace = 2;       /* 0: off  1: simple  2: cache dumps */\n  int sqlite3PcacheMxDump = 9999;   /* Max cache entries for pcacheDump() */\n# define pcacheTrace(X) if(sqlite3PcacheTrace){sqlite3DebugPrintf X;}\n  static void pcachePageTrace(int i, sqlite3_pcache_page *pLower){\n    PgHdr *pPg;\n    unsigned char *a;\n    int j;\n    if( pLower==0 ){\n      printf(\"%3d: NULL\\n\", i);\n    }else{\n      pPg = (PgHdr*)pLower->pExtra;\n      printf(\"%3d: nRef %2lld flgs %02x data \", i, pPg->nRef, pPg->flags);\n      a = (unsigned char *)pLower->pBuf;\n      for(j=0; j<12; j++) printf(\"%02x\", a[j]);\n      printf(\" ptr %p\\n\", pPg);\n    }\n  }\n  static void pcacheDump(PCache *pCache){\n    int N;\n    int i;\n    sqlite3_pcache_page *pLower;\n  \n    if( sqlite3PcacheTrace<2 ) return;\n    if( pCache->pCache==0 ) return;\n    N = sqlite3PcachePagecount(pCache);\n    if( N>sqlite3PcacheMxDump ) N = sqlite3PcacheMxDump;\n    for(i=1; i<=N; i++){\n       pLower = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache, i, 0);\n       pcachePageTrace(i, pLower);\n       if( pLower && ((PgHdr*)pLower)->pPage==0 ){\n         sqlite3GlobalConfig.pcache2.xUnpin(pCache->pCache, pLower, 0);\n       }\n    }\n  }\n#else\n# define pcacheTrace(X)\n# define pcachePageTrace(PGNO, X)\n# define pcacheDump(X)\n#endif\n\n/*\n** Return 1 if pPg is on the dirty list for pCache.  Return 0 if not.\n** This routine runs inside of assert() statements only.\n*/\n#if defined(SQLITE_ENABLE_EXPENSIVE_ASSERT)\nstatic int pageOnDirtyList(PCache *pCache, PgHdr *pPg){\n  PgHdr *p;\n  for(p=pCache->pDirty; p; p=p->pDirtyNext){\n    if( p==pPg ) return 1;\n  }\n  return 0;\n}\nstatic int pageNotOnDirtyList(PCache *pCache, PgHdr *pPg){\n  PgHdr *p;\n  for(p=pCache->pDirty; p; p=p->pDirtyNext){\n    if( p==pPg ) return 0;\n  }\n  return 1;\n}\n#else\n# define pageOnDirtyList(A,B)    1\n# define pageNotOnDirtyList(A,B) 1\n#endif\n\n/*\n** Check invariants on a PgHdr entry.  Return true if everything is OK.\n** Return false if any invariant is violated.\n**\n** This routine is for use inside of assert() statements only.  For\n** example:\n**\n**          assert( sqlite3PcachePageSanity(pPg) );\n*/\n#ifdef SQLITE_DEBUG\nint sqlite3PcachePageSanity(PgHdr *pPg){\n  PCache *pCache;\n  assert( pPg!=0 );\n  assert( pPg->pgno>0 || pPg->pPager==0 );    /* Page number is 1 or more */\n  pCache = pPg->pCache;\n  assert( pCache!=0 );      /* Every page has an associated PCache */\n  if( pPg->flags & PGHDR_CLEAN ){\n    assert( (pPg->flags & PGHDR_DIRTY)==0 );/* Cannot be both CLEAN and DIRTY */\n    assert( pageNotOnDirtyList(pCache, pPg) );/* CLEAN pages not on dirtylist */\n  }else{\n    assert( (pPg->flags & PGHDR_DIRTY)!=0 );/* If not CLEAN must be DIRTY */\n    assert( pPg->pDirtyNext==0 || pPg->pDirtyNext->pDirtyPrev==pPg );\n    assert( pPg->pDirtyPrev==0 || pPg->pDirtyPrev->pDirtyNext==pPg );\n    assert( pPg->pDirtyPrev!=0 || pCache->pDirty==pPg );\n    assert( pageOnDirtyList(pCache, pPg) );\n  }\n  /* WRITEABLE pages must also be DIRTY */\n  if( pPg->flags & PGHDR_WRITEABLE ){\n    assert( pPg->flags & PGHDR_DIRTY );     /* WRITEABLE implies DIRTY */\n  }\n  /* NEED_SYNC can be set independently of WRITEABLE.  This can happen,\n  ** for example, when using the sqlite3PagerDontWrite() optimization:\n  **    (1)  Page X is journalled, and gets WRITEABLE and NEED_SEEK.\n  **    (2)  Page X moved to freelist, WRITEABLE is cleared\n  **    (3)  Page X reused, WRITEABLE is set again\n  ** If NEED_SYNC had been cleared in step 2, then it would not be reset\n  ** in step 3, and page might be written into the database without first\n  ** syncing the rollback journal, which might cause corruption on a power\n  ** loss.\n  **\n  ** Another example is when the database page size is smaller than the\n  ** disk sector size.  When any page of a sector is journalled, all pages\n  ** in that sector are marked NEED_SYNC even if they are still CLEAN, just\n  ** in case they are later modified, since all pages in the same sector\n  ** must be journalled and synced before any of those pages can be safely\n  ** written.\n  */\n  return 1;\n}\n#endif /* SQLITE_DEBUG */\n\n\n/********************************** Linked List Management ********************/\n\n/* Allowed values for second argument to pcacheManageDirtyList() */\n#define PCACHE_DIRTYLIST_REMOVE   1    /* Remove pPage from dirty list */\n#define PCACHE_DIRTYLIST_ADD      2    /* Add pPage to the dirty list */\n#define PCACHE_DIRTYLIST_FRONT    3    /* Move pPage to the front of the list */\n\n/*\n** Manage pPage's participation on the dirty list.  Bits of the addRemove\n** argument determines what operation to do.  The 0x01 bit means first\n** remove pPage from the dirty list.  The 0x02 means add pPage back to\n** the dirty list.  Doing both moves pPage to the front of the dirty list.\n*/\nstatic void pcacheManageDirtyList(PgHdr *pPage, u8 addRemove){\n  PCache *p = pPage->pCache;\n\n  pcacheTrace((\"%p.DIRTYLIST.%s %d\\n\", p,\n                addRemove==1 ? \"REMOVE\" : addRemove==2 ? \"ADD\" : \"FRONT\",\n                pPage->pgno));\n  if( addRemove & PCACHE_DIRTYLIST_REMOVE ){\n    assert( pPage->pDirtyNext || pPage==p->pDirtyTail );\n    assert( pPage->pDirtyPrev || pPage==p->pDirty );\n  \n    /* Update the PCache1.pSynced variable if necessary. */\n    if( p->pSynced==pPage ){\n      p->pSynced = pPage->pDirtyPrev;\n    }\n  \n    if( pPage->pDirtyNext ){\n      pPage->pDirtyNext->pDirtyPrev = pPage->pDirtyPrev;\n    }else{\n      assert( pPage==p->pDirtyTail );\n      p->pDirtyTail = pPage->pDirtyPrev;\n    }\n    if( pPage->pDirtyPrev ){\n      pPage->pDirtyPrev->pDirtyNext = pPage->pDirtyNext;\n    }else{\n      /* If there are now no dirty pages in the cache, set eCreate to 2. \n      ** This is an optimization that allows sqlite3PcacheFetch() to skip\n      ** searching for a dirty page to eject from the cache when it might\n      ** otherwise have to.  */\n      assert( pPage==p->pDirty );\n      p->pDirty = pPage->pDirtyNext;\n      assert( p->bPurgeable || p->eCreate==2 );\n      if( p->pDirty==0 ){         /*OPTIMIZATION-IF-TRUE*/\n        assert( p->bPurgeable==0 || p->eCreate==1 );\n        p->eCreate = 2;\n      }\n    }\n  }\n  if( addRemove & PCACHE_DIRTYLIST_ADD ){\n    pPage->pDirtyPrev = 0;\n    pPage->pDirtyNext = p->pDirty;\n    if( pPage->pDirtyNext ){\n      assert( pPage->pDirtyNext->pDirtyPrev==0 );\n      pPage->pDirtyNext->pDirtyPrev = pPage;\n    }else{\n      p->pDirtyTail = pPage;\n      if( p->bPurgeable ){\n        assert( p->eCreate==2 );\n        p->eCreate = 1;\n      }\n    }\n    p->pDirty = pPage;\n\n    /* If pSynced is NULL and this page has a clear NEED_SYNC flag, set\n    ** pSynced to point to it. Checking the NEED_SYNC flag is an \n    ** optimization, as if pSynced points to a page with the NEED_SYNC\n    ** flag set sqlite3PcacheFetchStress() searches through all newer \n    ** entries of the dirty-list for a page with NEED_SYNC clear anyway.  */\n    if( !p->pSynced \n     && 0==(pPage->flags&PGHDR_NEED_SYNC)   /*OPTIMIZATION-IF-FALSE*/\n    ){\n      p->pSynced = pPage;\n    }\n  }\n  pcacheDump(p);\n}\n\n/*\n** Wrapper around the pluggable caches xUnpin method. If the cache is\n** being used for an in-memory database, this function is a no-op.\n*/\nstatic void pcacheUnpin(PgHdr *p){\n  if( p->pCache->bPurgeable ){\n    pcacheTrace((\"%p.UNPIN %d\\n\", p->pCache, p->pgno));\n    sqlite3GlobalConfig.pcache2.xUnpin(p->pCache->pCache, p->pPage, 0);\n    pcacheDump(p->pCache);\n  }\n}\n\n/*\n** Compute the number of pages of cache requested.   p->szCache is the\n** cache size requested by the \"PRAGMA cache_size\" statement.\n*/\nstatic int numberOfCachePages(PCache *p){\n  if( p->szCache>=0 ){\n    /* IMPLEMENTATION-OF: R-42059-47211 If the argument N is positive then the\n    ** suggested cache size is set to N. */\n    return p->szCache;\n  }else{\n    i64 n;\n    /* IMPLEMENTATION-OF: R-59858-46238 If the argument N is negative, then the\n    ** number of cache pages is adjusted to be a number of pages that would\n    ** use approximately abs(N*1024) bytes of memory based on the current\n    ** page size. */\n    n = ((-1024*(i64)p->szCache)/(p->szPage+p->szExtra));\n    if( n>1000000000 ) n = 1000000000;\n    return (int)n;\n  }\n}\n\n/*************************************************** General Interfaces ******\n**\n** Initialize and shutdown the page cache subsystem. Neither of these \n** functions are threadsafe.\n*/\nint sqlite3PcacheInitialize(void){\n  if( sqlite3GlobalConfig.pcache2.xInit==0 ){\n    /* IMPLEMENTATION-OF: R-26801-64137 If the xInit() method is NULL, then the\n    ** built-in default page cache is used instead of the application defined\n    ** page cache. */\n    sqlite3PCacheSetDefault();\n    assert( sqlite3GlobalConfig.pcache2.xInit!=0 );\n  }\n  return sqlite3GlobalConfig.pcache2.xInit(sqlite3GlobalConfig.pcache2.pArg);\n}\nvoid sqlite3PcacheShutdown(void){\n  if( sqlite3GlobalConfig.pcache2.xShutdown ){\n    /* IMPLEMENTATION-OF: R-26000-56589 The xShutdown() method may be NULL. */\n    sqlite3GlobalConfig.pcache2.xShutdown(sqlite3GlobalConfig.pcache2.pArg);\n  }\n}\n\n/*\n** Return the size in bytes of a PCache object.\n*/\nint sqlite3PcacheSize(void){ return sizeof(PCache); }\n\n/*\n** Create a new PCache object. Storage space to hold the object\n** has already been allocated and is passed in as the p pointer. \n** The caller discovers how much space needs to be allocated by \n** calling sqlite3PcacheSize().\n**\n** szExtra is some extra space allocated for each page.  The first\n** 8 bytes of the extra space will be zeroed as the page is allocated,\n** but remaining content will be uninitialized.  Though it is opaque\n** to this module, the extra space really ends up being the MemPage\n** structure in the pager.\n*/\nint sqlite3PcacheOpen(\n  int szPage,                  /* Size of every page */\n  int szExtra,                 /* Extra space associated with each page */\n  int bPurgeable,              /* True if pages are on backing store */\n  int (*xStress)(void*,PgHdr*),/* Call to try to make pages clean */\n  void *pStress,               /* Argument to xStress */\n  PCache *p                    /* Preallocated space for the PCache */\n){\n  memset(p, 0, sizeof(PCache));\n  p->szPage = 1;\n  p->szExtra = szExtra;\n  assert( szExtra>=8 );  /* First 8 bytes will be zeroed */\n  p->bPurgeable = bPurgeable;\n  p->eCreate = 2;\n  p->xStress = xStress;\n  p->pStress = pStress;\n  p->szCache = 100;\n  p->szSpill = 1;\n  pcacheTrace((\"%p.OPEN szPage %d bPurgeable %d\\n\",p,szPage,bPurgeable));\n  return sqlite3PcacheSetPageSize(p, szPage);\n}\n\n/*\n** Change the page size for PCache object. The caller must ensure that there\n** are no outstanding page references when this function is called.\n*/\nint sqlite3PcacheSetPageSize(PCache *pCache, int szPage){\n  assert( pCache->nRefSum==0 && pCache->pDirty==0 );\n  if( pCache->szPage ){\n    sqlite3_pcache *pNew;\n    pNew = sqlite3GlobalConfig.pcache2.xCreate(\n                szPage, pCache->szExtra + ROUND8(sizeof(PgHdr)),\n                pCache->bPurgeable\n    );\n    if( pNew==0 ) return SQLITE_NOMEM_BKPT;\n    sqlite3GlobalConfig.pcache2.xCachesize(pNew, numberOfCachePages(pCache));\n    if( pCache->pCache ){\n      sqlite3GlobalConfig.pcache2.xDestroy(pCache->pCache);\n    }\n    pCache->pCache = pNew;\n    pCache->szPage = szPage;\n    pcacheTrace((\"%p.PAGESIZE %d\\n\",pCache,szPage));\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Try to obtain a page from the cache.\n**\n** This routine returns a pointer to an sqlite3_pcache_page object if\n** such an object is already in cache, or if a new one is created.\n** This routine returns a NULL pointer if the object was not in cache\n** and could not be created.\n**\n** The createFlags should be 0 to check for existing pages and should\n** be 3 (not 1, but 3) to try to create a new page.\n**\n** If the createFlag is 0, then NULL is always returned if the page\n** is not already in the cache.  If createFlag is 1, then a new page\n** is created only if that can be done without spilling dirty pages\n** and without exceeding the cache size limit.\n**\n** The caller needs to invoke sqlite3PcacheFetchFinish() to properly\n** initialize the sqlite3_pcache_page object and convert it into a\n** PgHdr object.  The sqlite3PcacheFetch() and sqlite3PcacheFetchFinish()\n** routines are split this way for performance reasons. When separated\n** they can both (usually) operate without having to push values to\n** the stack on entry and pop them back off on exit, which saves a\n** lot of pushing and popping.\n*/\nsqlite3_pcache_page *sqlite3PcacheFetch(\n  PCache *pCache,       /* Obtain the page from this cache */\n  Pgno pgno,            /* Page number to obtain */\n  int createFlag        /* If true, create page if it does not exist already */\n){\n  int eCreate;\n  sqlite3_pcache_page *pRes;\n\n  assert( pCache!=0 );\n  assert( pCache->pCache!=0 );\n  assert( createFlag==3 || createFlag==0 );\n  assert( pCache->eCreate==((pCache->bPurgeable && pCache->pDirty) ? 1 : 2) );\n\n  /* eCreate defines what to do if the page does not exist.\n  **    0     Do not allocate a new page.  (createFlag==0)\n  **    1     Allocate a new page if doing so is inexpensive.\n  **          (createFlag==1 AND bPurgeable AND pDirty)\n  **    2     Allocate a new page even it doing so is difficult.\n  **          (createFlag==1 AND !(bPurgeable AND pDirty)\n  */\n  eCreate = createFlag & pCache->eCreate;\n  assert( eCreate==0 || eCreate==1 || eCreate==2 );\n  assert( createFlag==0 || pCache->eCreate==eCreate );\n  assert( createFlag==0 || eCreate==1+(!pCache->bPurgeable||!pCache->pDirty) );\n  pRes = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache, pgno, eCreate);\n  pcacheTrace((\"%p.FETCH %d%s (result: %p) \",pCache,pgno,\n               createFlag?\" create\":\"\",pRes));\n  pcachePageTrace(pgno, pRes);\n  return pRes;\n}\n\n/*\n** If the sqlite3PcacheFetch() routine is unable to allocate a new\n** page because no clean pages are available for reuse and the cache\n** size limit has been reached, then this routine can be invoked to \n** try harder to allocate a page.  This routine might invoke the stress\n** callback to spill dirty pages to the journal.  It will then try to\n** allocate the new page and will only fail to allocate a new page on\n** an OOM error.\n**\n** This routine should be invoked only after sqlite3PcacheFetch() fails.\n*/\nint sqlite3PcacheFetchStress(\n  PCache *pCache,                 /* Obtain the page from this cache */\n  Pgno pgno,                      /* Page number to obtain */\n  sqlite3_pcache_page **ppPage    /* Write result here */\n){\n  PgHdr *pPg;\n  if( pCache->eCreate==2 ) return 0;\n\n  if( sqlite3PcachePagecount(pCache)>pCache->szSpill ){\n    /* Find a dirty page to write-out and recycle. First try to find a \n    ** page that does not require a journal-sync (one with PGHDR_NEED_SYNC\n    ** cleared), but if that is not possible settle for any other \n    ** unreferenced dirty page.\n    **\n    ** If the LRU page in the dirty list that has a clear PGHDR_NEED_SYNC\n    ** flag is currently referenced, then the following may leave pSynced\n    ** set incorrectly (pointing to other than the LRU page with NEED_SYNC\n    ** cleared). This is Ok, as pSynced is just an optimization.  */\n    for(pPg=pCache->pSynced; \n        pPg && (pPg->nRef || (pPg->flags&PGHDR_NEED_SYNC)); \n        pPg=pPg->pDirtyPrev\n    );\n    pCache->pSynced = pPg;\n    if( !pPg ){\n      for(pPg=pCache->pDirtyTail; pPg && pPg->nRef; pPg=pPg->pDirtyPrev);\n    }\n    if( pPg ){\n      int rc;\n#ifdef SQLITE_LOG_CACHE_SPILL\n      sqlite3_log(SQLITE_FULL, \n                  \"spill page %d making room for %d - cache used: %d/%d\",\n                  pPg->pgno, pgno,\n                  sqlite3GlobalConfig.pcache2.xPagecount(pCache->pCache),\n                numberOfCachePages(pCache));\n#endif\n      pcacheTrace((\"%p.SPILL %d\\n\",pCache,pPg->pgno));\n      rc = pCache->xStress(pCache->pStress, pPg);\n      pcacheDump(pCache);\n      if( rc!=SQLITE_OK && rc!=SQLITE_BUSY ){\n        return rc;\n      }\n    }\n  }\n  *ppPage = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache, pgno, 2);\n  return *ppPage==0 ? SQLITE_NOMEM_BKPT : SQLITE_OK;\n}\n\n/*\n** This is a helper routine for sqlite3PcacheFetchFinish()\n**\n** In the uncommon case where the page being fetched has not been\n** initialized, this routine is invoked to do the initialization.\n** This routine is broken out into a separate function since it\n** requires extra stack manipulation that can be avoided in the common\n** case.\n*/\nstatic SQLITE_NOINLINE PgHdr *pcacheFetchFinishWithInit(\n  PCache *pCache,             /* Obtain the page from this cache */\n  Pgno pgno,                  /* Page number obtained */\n  sqlite3_pcache_page *pPage  /* Page obtained by prior PcacheFetch() call */\n){\n  PgHdr *pPgHdr;\n  assert( pPage!=0 );\n  pPgHdr = (PgHdr*)pPage->pExtra;\n  assert( pPgHdr->pPage==0 );\n  memset(&pPgHdr->pDirty, 0, sizeof(PgHdr) - offsetof(PgHdr,pDirty));\n  pPgHdr->pPage = pPage;\n  pPgHdr->pData = pPage->pBuf;\n  pPgHdr->pExtra = (void *)&pPgHdr[1];\n  memset(pPgHdr->pExtra, 0, 8);\n  assert( EIGHT_BYTE_ALIGNMENT( pPgHdr->pExtra ) );\n  pPgHdr->pCache = pCache;\n  pPgHdr->pgno = pgno;\n  pPgHdr->flags = PGHDR_CLEAN;\n  return sqlite3PcacheFetchFinish(pCache,pgno,pPage);\n}\n\n/*\n** This routine converts the sqlite3_pcache_page object returned by\n** sqlite3PcacheFetch() into an initialized PgHdr object.  This routine\n** must be called after sqlite3PcacheFetch() in order to get a usable\n** result.\n*/\nPgHdr *sqlite3PcacheFetchFinish(\n  PCache *pCache,             /* Obtain the page from this cache */\n  Pgno pgno,                  /* Page number obtained */\n  sqlite3_pcache_page *pPage  /* Page obtained by prior PcacheFetch() call */\n){\n  PgHdr *pPgHdr;\n\n  assert( pPage!=0 );\n  pPgHdr = (PgHdr *)pPage->pExtra;\n\n  if( !pPgHdr->pPage ){\n    return pcacheFetchFinishWithInit(pCache, pgno, pPage);\n  }\n  pCache->nRefSum++;\n  pPgHdr->nRef++;\n  assert( sqlite3PcachePageSanity(pPgHdr) );\n  return pPgHdr;\n}\n\n/*\n** Decrement the reference count on a page. If the page is clean and the\n** reference count drops to 0, then it is made eligible for recycling.\n*/\nvoid SQLITE_NOINLINE sqlite3PcacheRelease(PgHdr *p){\n  assert( p->nRef>0 );\n  p->pCache->nRefSum--;\n  if( (--p->nRef)==0 ){\n    if( p->flags&PGHDR_CLEAN ){\n      pcacheUnpin(p);\n    }else{\n      pcacheManageDirtyList(p, PCACHE_DIRTYLIST_FRONT);\n      assert( sqlite3PcachePageSanity(p) );\n    }\n  }\n}\n\n/*\n** Increase the reference count of a supplied page by 1.\n*/\nvoid sqlite3PcacheRef(PgHdr *p){\n  assert(p->nRef>0);\n  assert( sqlite3PcachePageSanity(p) );\n  p->nRef++;\n  p->pCache->nRefSum++;\n}\n\n/*\n** Drop a page from the cache. There must be exactly one reference to the\n** page. This function deletes that reference, so after it returns the\n** page pointed to by p is invalid.\n*/\nvoid sqlite3PcacheDrop(PgHdr *p){\n  assert( p->nRef==1 );\n  assert( sqlite3PcachePageSanity(p) );\n  if( p->flags&PGHDR_DIRTY ){\n    pcacheManageDirtyList(p, PCACHE_DIRTYLIST_REMOVE);\n  }\n  p->pCache->nRefSum--;\n  sqlite3GlobalConfig.pcache2.xUnpin(p->pCache->pCache, p->pPage, 1);\n}\n\n/*\n** Make sure the page is marked as dirty. If it isn't dirty already,\n** make it so.\n*/\nvoid sqlite3PcacheMakeDirty(PgHdr *p){\n  assert( p->nRef>0 );\n  assert( sqlite3PcachePageSanity(p) );\n  if( p->flags & (PGHDR_CLEAN|PGHDR_DONT_WRITE) ){    /*OPTIMIZATION-IF-FALSE*/\n    p->flags &= ~PGHDR_DONT_WRITE;\n    if( p->flags & PGHDR_CLEAN ){\n      p->flags ^= (PGHDR_DIRTY|PGHDR_CLEAN);\n      pcacheTrace((\"%p.DIRTY %d\\n\",p->pCache,p->pgno));\n      assert( (p->flags & (PGHDR_DIRTY|PGHDR_CLEAN))==PGHDR_DIRTY );\n      pcacheManageDirtyList(p, PCACHE_DIRTYLIST_ADD);\n      assert( sqlite3PcachePageSanity(p) );\n    }\n    assert( sqlite3PcachePageSanity(p) );\n  }\n}\n\n/*\n** Make sure the page is marked as clean. If it isn't clean already,\n** make it so.\n*/\nvoid sqlite3PcacheMakeClean(PgHdr *p){\n  assert( sqlite3PcachePageSanity(p) );\n  assert( (p->flags & PGHDR_DIRTY)!=0 );\n  assert( (p->flags & PGHDR_CLEAN)==0 );\n  pcacheManageDirtyList(p, PCACHE_DIRTYLIST_REMOVE);\n  p->flags &= ~(PGHDR_DIRTY|PGHDR_NEED_SYNC|PGHDR_WRITEABLE);\n  p->flags |= PGHDR_CLEAN;\n  pcacheTrace((\"%p.CLEAN %d\\n\",p->pCache,p->pgno));\n  assert( sqlite3PcachePageSanity(p) );\n  if( p->nRef==0 ){\n    pcacheUnpin(p);\n  }\n}\n\n/*\n** Make every page in the cache clean.\n*/\nvoid sqlite3PcacheCleanAll(PCache *pCache){\n  PgHdr *p;\n  pcacheTrace((\"%p.CLEAN-ALL\\n\",pCache));\n  while( (p = pCache->pDirty)!=0 ){\n    sqlite3PcacheMakeClean(p);\n  }\n}\n\n/*\n** Clear the PGHDR_NEED_SYNC and PGHDR_WRITEABLE flag from all dirty pages.\n*/\nvoid sqlite3PcacheClearWritable(PCache *pCache){\n  PgHdr *p;\n  pcacheTrace((\"%p.CLEAR-WRITEABLE\\n\",pCache));\n  for(p=pCache->pDirty; p; p=p->pDirtyNext){\n    p->flags &= ~(PGHDR_NEED_SYNC|PGHDR_WRITEABLE);\n  }\n  pCache->pSynced = pCache->pDirtyTail;\n}\n\n/*\n** Clear the PGHDR_NEED_SYNC flag from all dirty pages.\n*/\nvoid sqlite3PcacheClearSyncFlags(PCache *pCache){\n  PgHdr *p;\n  for(p=pCache->pDirty; p; p=p->pDirtyNext){\n    p->flags &= ~PGHDR_NEED_SYNC;\n  }\n  pCache->pSynced = pCache->pDirtyTail;\n}\n\n/*\n** Change the page number of page p to newPgno. \n*/\nvoid sqlite3PcacheMove(PgHdr *p, Pgno newPgno){\n  PCache *pCache = p->pCache;\n  sqlite3_pcache_page *pOther;\n  assert( p->nRef>0 );\n  assert( newPgno>0 );\n  assert( sqlite3PcachePageSanity(p) );\n  pcacheTrace((\"%p.MOVE %d -> %d\\n\",pCache,p->pgno,newPgno));\n  pOther = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache, newPgno, 0);\n  if( pOther ){\n    PgHdr *pXPage = (PgHdr*)pOther->pExtra;\n    assert( pXPage->nRef==0 );\n    pXPage->nRef++;\n    pCache->nRefSum++;\n    sqlite3PcacheDrop(pXPage);\n  }\n  sqlite3GlobalConfig.pcache2.xRekey(pCache->pCache, p->pPage, p->pgno,newPgno);\n  p->pgno = newPgno;\n  if( (p->flags&PGHDR_DIRTY) && (p->flags&PGHDR_NEED_SYNC) ){\n    pcacheManageDirtyList(p, PCACHE_DIRTYLIST_FRONT);\n    assert( sqlite3PcachePageSanity(p) );\n  }\n}\n\n/*\n** Drop every cache entry whose page number is greater than \"pgno\". The\n** caller must ensure that there are no outstanding references to any pages\n** other than page 1 with a page number greater than pgno.\n**\n** If there is a reference to page 1 and the pgno parameter passed to this\n** function is 0, then the data area associated with page 1 is zeroed, but\n** the page object is not dropped.\n*/\nvoid sqlite3PcacheTruncate(PCache *pCache, Pgno pgno){\n  if( pCache->pCache ){\n    PgHdr *p;\n    PgHdr *pNext;\n    pcacheTrace((\"%p.TRUNCATE %d\\n\",pCache,pgno));\n    for(p=pCache->pDirty; p; p=pNext){\n      pNext = p->pDirtyNext;\n      /* This routine never gets call with a positive pgno except right\n      ** after sqlite3PcacheCleanAll().  So if there are dirty pages,\n      ** it must be that pgno==0.\n      */\n      assert( p->pgno>0 );\n      if( p->pgno>pgno ){\n        assert( p->flags&PGHDR_DIRTY );\n        sqlite3PcacheMakeClean(p);\n      }\n    }\n    if( pgno==0 && pCache->nRefSum ){\n      sqlite3_pcache_page *pPage1;\n      pPage1 = sqlite3GlobalConfig.pcache2.xFetch(pCache->pCache,1,0);\n      if( ALWAYS(pPage1) ){  /* Page 1 is always available in cache, because\n                             ** pCache->nRefSum>0 */\n        memset(pPage1->pBuf, 0, pCache->szPage);\n        pgno = 1;\n      }\n    }\n    sqlite3GlobalConfig.pcache2.xTruncate(pCache->pCache, pgno+1);\n  }\n}\n\n/*\n** Close a cache.\n*/\nvoid sqlite3PcacheClose(PCache *pCache){\n  assert( pCache->pCache!=0 );\n  pcacheTrace((\"%p.CLOSE\\n\",pCache));\n  sqlite3GlobalConfig.pcache2.xDestroy(pCache->pCache);\n}\n\n/* \n** Discard the contents of the cache.\n*/\nvoid sqlite3PcacheClear(PCache *pCache){\n  sqlite3PcacheTruncate(pCache, 0);\n}\n\n/*\n** Merge two lists of pages connected by pDirty and in pgno order.\n** Do not bother fixing the pDirtyPrev pointers.\n*/\nstatic PgHdr *pcacheMergeDirtyList(PgHdr *pA, PgHdr *pB){\n  PgHdr result, *pTail;\n  pTail = &result;\n  assert( pA!=0 && pB!=0 );\n  for(;;){\n    if( pA->pgno<pB->pgno ){\n      pTail->pDirty = pA;\n      pTail = pA;\n      pA = pA->pDirty;\n      if( pA==0 ){\n        pTail->pDirty = pB;\n        break;\n      }\n    }else{\n      pTail->pDirty = pB;\n      pTail = pB;\n      pB = pB->pDirty;\n      if( pB==0 ){\n        pTail->pDirty = pA;\n        break;\n      }\n    }\n  }\n  return result.pDirty;\n}\n\n/*\n** Sort the list of pages in ascending order by pgno.  Pages are\n** connected by pDirty pointers.  The pDirtyPrev pointers are\n** corrupted by this sort.\n**\n** Since there cannot be more than 2^31 distinct pages in a database,\n** there cannot be more than 31 buckets required by the merge sorter.\n** One extra bucket is added to catch overflow in case something\n** ever changes to make the previous sentence incorrect.\n*/\n#define N_SORT_BUCKET  32\nstatic PgHdr *pcacheSortDirtyList(PgHdr *pIn){\n  PgHdr *a[N_SORT_BUCKET], *p;\n  int i;\n  memset(a, 0, sizeof(a));\n  while( pIn ){\n    p = pIn;\n    pIn = p->pDirty;\n    p->pDirty = 0;\n    for(i=0; ALWAYS(i<N_SORT_BUCKET-1); i++){\n      if( a[i]==0 ){\n        a[i] = p;\n        break;\n      }else{\n        p = pcacheMergeDirtyList(a[i], p);\n        a[i] = 0;\n      }\n    }\n    if( NEVER(i==N_SORT_BUCKET-1) ){\n      /* To get here, there need to be 2^(N_SORT_BUCKET) elements in\n      ** the input list.  But that is impossible.\n      */\n      a[i] = pcacheMergeDirtyList(a[i], p);\n    }\n  }\n  p = a[0];\n  for(i=1; i<N_SORT_BUCKET; i++){\n    if( a[i]==0 ) continue;\n    p = p ? pcacheMergeDirtyList(p, a[i]) : a[i];\n  }\n  return p;\n}\n\n/*\n** Return a list of all dirty pages in the cache, sorted by page number.\n*/\nPgHdr *sqlite3PcacheDirtyList(PCache *pCache){\n  PgHdr *p;\n  for(p=pCache->pDirty; p; p=p->pDirtyNext){\n    p->pDirty = p->pDirtyNext;\n  }\n  return pcacheSortDirtyList(pCache->pDirty);\n}\n\n/* \n** Return the total number of references to all pages held by the cache.\n**\n** This is not the total number of pages referenced, but the sum of the\n** reference count for all pages.\n*/\ni64 sqlite3PcacheRefCount(PCache *pCache){\n  return pCache->nRefSum;\n}\n\n/*\n** Return the number of references to the page supplied as an argument.\n*/\ni64 sqlite3PcachePageRefcount(PgHdr *p){\n  return p->nRef;\n}\n\n/* \n** Return the total number of pages in the cache.\n*/\nint sqlite3PcachePagecount(PCache *pCache){\n  assert( pCache->pCache!=0 );\n  return sqlite3GlobalConfig.pcache2.xPagecount(pCache->pCache);\n}\n\n#ifdef SQLITE_TEST\n/*\n** Get the suggested cache-size value.\n*/\nint sqlite3PcacheGetCachesize(PCache *pCache){\n  return numberOfCachePages(pCache);\n}\n#endif\n\n/*\n** Set the suggested cache-size value.\n*/\nvoid sqlite3PcacheSetCachesize(PCache *pCache, int mxPage){\n  assert( pCache->pCache!=0 );\n  pCache->szCache = mxPage;\n  sqlite3GlobalConfig.pcache2.xCachesize(pCache->pCache,\n                                         numberOfCachePages(pCache));\n}\n\n/*\n** Set the suggested cache-spill value.  Make no changes if if the\n** argument is zero.  Return the effective cache-spill size, which will\n** be the larger of the szSpill and szCache.\n*/\nint sqlite3PcacheSetSpillsize(PCache *p, int mxPage){\n  int res;\n  assert( p->pCache!=0 );\n  if( mxPage ){\n    if( mxPage<0 ){\n      mxPage = (int)((-1024*(i64)mxPage)/(p->szPage+p->szExtra));\n    }\n    p->szSpill = mxPage;\n  }\n  res = numberOfCachePages(p);\n  if( res<p->szSpill ) res = p->szSpill; \n  return res;\n}\n\n/*\n** Free up as much memory as possible from the page cache.\n*/\nvoid sqlite3PcacheShrink(PCache *pCache){\n  assert( pCache->pCache!=0 );\n  sqlite3GlobalConfig.pcache2.xShrink(pCache->pCache);\n}\n\n/*\n** Return the size of the header added by this middleware layer\n** in the page-cache hierarchy.\n*/\nint sqlite3HeaderSizePcache(void){ return ROUND8(sizeof(PgHdr)); }\n\n/*\n** Return the number of dirty pages currently in the cache, as a percentage\n** of the configured cache size.\n*/\nint sqlite3PCachePercentDirty(PCache *pCache){\n  PgHdr *pDirty;\n  int nDirty = 0;\n  int nCache = numberOfCachePages(pCache);\n  for(pDirty=pCache->pDirty; pDirty; pDirty=pDirty->pDirtyNext) nDirty++;\n  return nCache ? (int)(((i64)nDirty * 100) / nCache) : 0;\n}\n\n#ifdef SQLITE_DIRECT_OVERFLOW_READ\n/* \n** Return true if there are one or more dirty pages in the cache. Else false.\n*/\nint sqlite3PCacheIsDirty(PCache *pCache){\n  return (pCache->pDirty!=0);\n}\n#endif\n\n#if defined(SQLITE_CHECK_PAGES) || defined(SQLITE_DEBUG)\n/*\n** For all dirty pages currently in the cache, invoke the specified\n** callback. This is only used if the SQLITE_CHECK_PAGES macro is\n** defined.\n*/\nvoid sqlite3PcacheIterateDirty(PCache *pCache, void (*xIter)(PgHdr *)){\n  PgHdr *pDirty;\n  for(pDirty=pCache->pDirty; pDirty; pDirty=pDirty->pDirtyNext){\n    xIter(pDirty);\n  }\n}\n#endif\n"}
{"repo": "sqlite", "file": "test_func.c", "lang": "C++", "code": "/*\n** 2008 March 19\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** Code for testing all sorts of SQLite interfaces.  This code\n** implements new SQL functions used by the test scripts.\n*/\n#include \"sqlite3.h\"\n#include \"tclsqlite.h\"\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"sqliteInt.h\"\n#include \"vdbeInt.h\"\n\n/*\n** Allocate nByte bytes of space using sqlite3_malloc(). If the\n** allocation fails, call sqlite3_result_error_nomem() to notify\n** the database handle that malloc() has failed.\n*/\nstatic void *testContextMalloc(sqlite3_context *context, int nByte){\n  char *z = sqlite3_malloc(nByte);\n  if( !z && nByte>0 ){\n    sqlite3_result_error_nomem(context);\n  }\n  return z;\n}\n\n/*\n** This function generates a string of random characters.  Used for\n** generating test data.\n*/\nstatic void randStr(sqlite3_context *context, int argc, sqlite3_value **argv){\n  static const unsigned char zSrc[] = \n     \"abcdefghijklmnopqrstuvwxyz\"\n     \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n     \"0123456789\"\n     \".-!,:*^+=_|?/<> \";\n  int iMin, iMax, n, r, i;\n  unsigned char zBuf[1000];\n\n  /* It used to be possible to call randstr() with any number of arguments,\n  ** but now it is registered with SQLite as requiring exactly 2.\n  */\n  assert(argc==2);\n\n  iMin = sqlite3_value_int(argv[0]);\n  if( iMin<0 ) iMin = 0;\n  if( iMin>=sizeof(zBuf) ) iMin = sizeof(zBuf)-1;\n  iMax = sqlite3_value_int(argv[1]);\n  if( iMax<iMin ) iMax = iMin;\n  if( iMax>=sizeof(zBuf) ) iMax = sizeof(zBuf)-1;\n  n = iMin;\n  if( iMax>iMin ){\n    sqlite3_randomness(sizeof(r), &r);\n    r &= 0x7fffffff;\n    n += r%(iMax + 1 - iMin);\n  }\n  assert( n<sizeof(zBuf) );\n  sqlite3_randomness(n, zBuf);\n  for(i=0; i<n; i++){\n    zBuf[i] = zSrc[zBuf[i]%(sizeof(zSrc)-1)];\n  }\n  zBuf[n] = 0;\n  sqlite3_result_text(context, (char*)zBuf, n, SQLITE_TRANSIENT);\n}\n\n/*\n** The following two SQL functions are used to test returning a text\n** result with a destructor. Function 'test_destructor' takes one argument\n** and returns the same argument interpreted as TEXT. A destructor is\n** passed with the sqlite3_result_text() call.\n**\n** SQL function 'test_destructor_count' returns the number of outstanding \n** allocations made by 'test_destructor';\n**\n** WARNING: Not threadsafe.\n*/\nstatic int test_destructor_count_var = 0;\nstatic void destructor(void *p){\n  char *zVal = (char *)p;\n  assert(zVal);\n  zVal--;\n  sqlite3_free(zVal);\n  test_destructor_count_var--;\n}\nstatic void test_destructor(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **argv\n){\n  char *zVal;\n  int len;\n  \n  test_destructor_count_var++;\n  assert( nArg==1 );\n  if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;\n  len = sqlite3_value_bytes(argv[0]); \n  zVal = testContextMalloc(pCtx, len+3);\n  if( !zVal ){\n    return;\n  }\n  zVal[len+1] = 0;\n  zVal[len+2] = 0;\n  zVal++;\n  memcpy(zVal, sqlite3_value_text(argv[0]), len);\n  sqlite3_result_text(pCtx, zVal, -1, destructor);\n}\n#ifndef SQLITE_OMIT_UTF16\nstatic void test_destructor16(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **argv\n){\n  char *zVal;\n  int len;\n  \n  test_destructor_count_var++;\n  assert( nArg==1 );\n  if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;\n  len = sqlite3_value_bytes16(argv[0]); \n  zVal = testContextMalloc(pCtx, len+3);\n  if( !zVal ){\n    return;\n  }\n  zVal[len+1] = 0;\n  zVal[len+2] = 0;\n  zVal++;\n  memcpy(zVal, sqlite3_value_text16(argv[0]), len);\n  sqlite3_result_text16(pCtx, zVal, -1, destructor);\n}\n#endif\nstatic void test_destructor_count(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **argv\n){\n  sqlite3_result_int(pCtx, test_destructor_count_var);\n}\n\n/*\n** The following aggregate function, test_agg_errmsg16(), takes zero \n** arguments. It returns the text value returned by the sqlite3_errmsg16()\n** API function.\n*/\n#ifndef SQLITE_UNTESTABLE\nvoid sqlite3BeginBenignMalloc(void);\nvoid sqlite3EndBenignMalloc(void);\n#else\n  #define sqlite3BeginBenignMalloc()\n  #define sqlite3EndBenignMalloc()\n#endif\nstatic void test_agg_errmsg16_step(sqlite3_context *a, int b,sqlite3_value **c){\n}\nstatic void test_agg_errmsg16_final(sqlite3_context *ctx){\n#ifndef SQLITE_OMIT_UTF16\n  const void *z;\n  sqlite3 * db = sqlite3_context_db_handle(ctx);\n  sqlite3_aggregate_context(ctx, 2048);\n  z = sqlite3_errmsg16(db);\n  sqlite3_result_text16(ctx, z, -1, SQLITE_TRANSIENT);\n#endif\n}\n\n/*\n** Routines for testing the sqlite3_get_auxdata() and sqlite3_set_auxdata()\n** interface.\n**\n** The test_auxdata() SQL function attempts to register each of its arguments\n** as auxiliary data.  If there are no prior registrations of aux data for\n** that argument (meaning the argument is not a constant or this is its first\n** call) then the result for that argument is 0.  If there is a prior\n** registration, the result for that argument is 1.  The overall result\n** is the individual argument results separated by spaces.\n*/\nstatic void free_test_auxdata(void *p) {sqlite3_free(p);}\nstatic void test_auxdata(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **argv\n){\n  int i;\n  char *zRet = testContextMalloc(pCtx, nArg*2);\n  if( !zRet ) return;\n  memset(zRet, 0, nArg*2);\n  for(i=0; i<nArg; i++){\n    char const *z = (char*)sqlite3_value_text(argv[i]);\n    if( z ){\n      int n;\n      char *zAux = sqlite3_get_auxdata(pCtx, i);\n      if( zAux ){\n        zRet[i*2] = '1';\n        assert( strcmp(zAux,z)==0 );\n      }else {\n        zRet[i*2] = '0';\n      }\n      n = (int)strlen(z) + 1;\n      zAux = testContextMalloc(pCtx, n);\n      if( zAux ){\n        memcpy(zAux, z, n);\n        sqlite3_set_auxdata(pCtx, i, zAux, free_test_auxdata);\n      }\n      zRet[i*2+1] = ' ';\n    }\n  }\n  sqlite3_result_text(pCtx, zRet, 2*nArg-1, free_test_auxdata);\n}\n\n/*\n** A function to test error reporting from user functions. This function\n** returns a copy of its first argument as the error message.  If the\n** second argument exists, it becomes the error code.\n*/\nstatic void test_error(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **argv\n){\n  sqlite3_result_error(pCtx, (char*)sqlite3_value_text(argv[0]), -1);\n  if( nArg==2 ){\n    sqlite3_result_error_code(pCtx, sqlite3_value_int(argv[1]));\n  }\n}\n\n/*\n** Implementation of the counter(X) function.  If X is an integer\n** constant, then the first invocation will return X.  The second X+1.\n** and so forth.  Can be used (for example) to provide a sequence number\n** in a result set.\n*/\nstatic void counterFunc(\n  sqlite3_context *pCtx,   /* Function context */\n  int nArg,                /* Number of function arguments */\n  sqlite3_value **argv     /* Values for all function arguments */\n){\n  int *pCounter = (int*)sqlite3_get_auxdata(pCtx, 0);\n  if( pCounter==0 ){\n    pCounter = sqlite3_malloc( sizeof(*pCounter) );\n    if( pCounter==0 ){\n      sqlite3_result_error_nomem(pCtx);\n      return;\n    }\n    *pCounter = sqlite3_value_int(argv[0]);\n    sqlite3_set_auxdata(pCtx, 0, pCounter, sqlite3_free);\n  }else{\n    ++*pCounter;\n  }\n  sqlite3_result_int(pCtx, *pCounter);\n}\n\n\n/*\n** This function takes two arguments.  It performance UTF-8/16 type\n** conversions on the first argument then returns a copy of the second\n** argument.\n**\n** This function is used in cases such as the following:\n**\n**      SELECT test_isolation(x,x) FROM t1;\n**\n** We want to verify that the type conversions that occur on the\n** first argument do not invalidate the second argument.\n*/\nstatic void test_isolation(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **argv\n){\n#ifndef SQLITE_OMIT_UTF16\n  sqlite3_value_text16(argv[0]);\n  sqlite3_value_text(argv[0]);\n  sqlite3_value_text16(argv[0]);\n  sqlite3_value_text(argv[0]);\n#endif\n  sqlite3_result_value(pCtx, argv[1]);\n}\n\n/*\n** Invoke an SQL statement recursively.  The function result is the \n** first column of the first row of the result set.\n*/\nstatic void test_eval(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **argv\n){\n  sqlite3_stmt *pStmt;\n  int rc;\n  sqlite3 *db = sqlite3_context_db_handle(pCtx);\n  const char *zSql;\n\n  zSql = (char*)sqlite3_value_text(argv[0]);\n  rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);\n  if( rc==SQLITE_OK ){\n    rc = sqlite3_step(pStmt);\n    if( rc==SQLITE_ROW ){\n      sqlite3_result_value(pCtx, sqlite3_column_value(pStmt, 0));\n    }\n    rc = sqlite3_finalize(pStmt);\n  }\n  if( rc ){\n    char *zErr;\n    assert( pStmt==0 );\n    zErr = sqlite3_mprintf(\"sqlite3_prepare_v2() error: %s\",sqlite3_errmsg(db));\n    sqlite3_result_text(pCtx, zErr, -1, sqlite3_free);\n    sqlite3_result_error_code(pCtx, rc);\n  }\n}\n\n\n/*\n** convert one character from hex to binary\n*/\nstatic int testHexChar(char c){\n  if( c>='0' && c<='9' ){\n    return c - '0';\n  }else if( c>='a' && c<='f' ){\n    return c - 'a' + 10;\n  }else if( c>='A' && c<='F' ){\n    return c - 'A' + 10;\n  }\n  return 0;\n}\n\n/*\n** Convert hex to binary.\n*/\nstatic void testHexToBin(const char *zIn, char *zOut){\n  while( zIn[0] && zIn[1] ){\n    *(zOut++) = (testHexChar(zIn[0])<<4) + testHexChar(zIn[1]);\n    zIn += 2;\n  }\n}\n\n/*\n**      hex_to_utf16be(HEX)\n**\n** Convert the input string from HEX into binary.  Then return the\n** result using sqlite3_result_text16le().\n*/\n#ifndef SQLITE_OMIT_UTF16\nstatic void testHexToUtf16be(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **argv\n){\n  int n;\n  const char *zIn;\n  char *zOut;\n  assert( nArg==1 );\n  n = sqlite3_value_bytes(argv[0]);\n  zIn = (const char*)sqlite3_value_text(argv[0]);\n  zOut = sqlite3_malloc( n/2 );\n  if( zOut==0 ){\n    sqlite3_result_error_nomem(pCtx);\n  }else{\n    testHexToBin(zIn, zOut);\n    sqlite3_result_text16be(pCtx, zOut, n/2, sqlite3_free);\n  }\n}\n#endif\n\n/*\n**      hex_to_utf8(HEX)\n**\n** Convert the input string from HEX into binary.  Then return the\n** result using sqlite3_result_text16le().\n*/\nstatic void testHexToUtf8(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **argv\n){\n  int n;\n  const char *zIn;\n  char *zOut;\n  assert( nArg==1 );\n  n = sqlite3_value_bytes(argv[0]);\n  zIn = (const char*)sqlite3_value_text(argv[0]);\n  zOut = sqlite3_malloc( n/2 );\n  if( zOut==0 ){\n    sqlite3_result_error_nomem(pCtx);\n  }else{\n    testHexToBin(zIn, zOut);\n    sqlite3_result_text(pCtx, zOut, n/2, sqlite3_free);\n  }\n}\n\n/*\n**      hex_to_utf16le(HEX)\n**\n** Convert the input string from HEX into binary.  Then return the\n** result using sqlite3_result_text16le().\n*/\n#ifndef SQLITE_OMIT_UTF16\nstatic void testHexToUtf16le(\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **argv\n){\n  int n;\n  const char *zIn;\n  char *zOut;\n  assert( nArg==1 );\n  n = sqlite3_value_bytes(argv[0]);\n  zIn = (const char*)sqlite3_value_text(argv[0]);\n  zOut = sqlite3_malloc( n/2 );\n  if( zOut==0 ){\n    sqlite3_result_error_nomem(pCtx);\n  }else{\n    testHexToBin(zIn, zOut);\n    sqlite3_result_text16le(pCtx, zOut, n/2, sqlite3_free);\n  }\n}\n#endif\n\n/*\n** SQL function:   real2hex(X)\n**\n** If argument X is a real number, then convert it into a string which is\n** the big-endian hexadecimal representation of the ieee754 encoding of\n** that number.  If X is not a real number, return NULL.\n*/\nstatic void real2hex(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  union {\n    sqlite3_uint64 i;\n    double r;\n    unsigned char x[8];\n  } v;\n  char zOut[20];\n  int i;\n  int bigEndian;\n  v.i = 1;\n  bigEndian = v.x[0]==0;\n  v.r = sqlite3_value_double(argv[0]);\n  for(i=0; i<8; i++){\n    if( bigEndian ){\n      zOut[i*2]   = \"0123456789abcdef\"[v.x[i]>>4];\n      zOut[i*2+1] = \"0123456789abcdef\"[v.x[i]&0xf];\n    }else{\n      zOut[14-i*2]   = \"0123456789abcdef\"[v.x[i]>>4];\n      zOut[14-i*2+1] = \"0123456789abcdef\"[v.x[i]&0xf];\n    }\n  }\n  zOut[16] = 0;\n  sqlite3_result_text(context, zOut, -1, SQLITE_TRANSIENT);\n}\n\n/*\n**     test_extract(record, field)\n**\n** This function implements an SQL user-function that accepts a blob\n** containing a formatted database record as the first argument. The\n** second argument is the index of the field within that record to\n** extract and return.\n*/\nstatic void test_extract(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  u8 *pRec;\n  u8 *pEndHdr;                    /* Points to one byte past record header */\n  u8 *pHdr;                       /* Current point in record header */\n  u8 *pBody;                      /* Current point in record data */\n  u64 nHdr;                       /* Bytes in record header */\n  int iIdx;                       /* Required field */\n  int iCurrent = 0;               /* Current field */\n\n  assert( argc==2 );\n  pRec = (u8*)sqlite3_value_blob(argv[0]);\n  iIdx = sqlite3_value_int(argv[1]);\n\n  pHdr = pRec + sqlite3GetVarint(pRec, &nHdr);\n  pBody = pEndHdr = &pRec[nHdr];\n\n  for(iCurrent=0; pHdr<pEndHdr && iCurrent<=iIdx; iCurrent++){\n    u64 iSerialType;\n    Mem mem;\n\n    memset(&mem, 0, sizeof(mem));\n    mem.db = db;\n    mem.enc = ENC(db);\n    pHdr += sqlite3GetVarint(pHdr, &iSerialType);\n    sqlite3VdbeSerialGet(pBody, (u32)iSerialType, &mem);\n    pBody += sqlite3VdbeSerialTypeLen((u32)iSerialType);\n\n    if( iCurrent==iIdx ){\n      sqlite3_result_value(context, &mem);\n    }\n\n    if( mem.szMalloc ) sqlite3DbFree(db, mem.zMalloc);\n  }\n}\n\n/*\n**      test_decode(record)\n**\n** This function implements an SQL user-function that accepts a blob\n** containing a formatted database record as its only argument. It returns\n** a tcl list (type SQLITE_TEXT) containing each of the values stored\n** in the record.\n*/\nstatic void test_decode(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  u8 *pRec;\n  u8 *pEndHdr;                    /* Points to one byte past record header */\n  u8 *pHdr;                       /* Current point in record header */\n  u8 *pBody;                      /* Current point in record data */\n  u64 nHdr;                       /* Bytes in record header */\n  Tcl_Obj *pRet;                  /* Return value */\n\n  pRet = Tcl_NewObj();\n  Tcl_IncrRefCount(pRet);\n\n  assert( argc==1 );\n  pRec = (u8*)sqlite3_value_blob(argv[0]);\n\n  pHdr = pRec + sqlite3GetVarint(pRec, &nHdr);\n  pBody = pEndHdr = &pRec[nHdr];\n  while( pHdr<pEndHdr ){\n    Tcl_Obj *pVal = 0;\n    u64 iSerialType;\n    Mem mem;\n\n    memset(&mem, 0, sizeof(mem));\n    mem.db = db;\n    mem.enc = ENC(db);\n    pHdr += sqlite3GetVarint(pHdr, &iSerialType);\n    sqlite3VdbeSerialGet(pBody, (u32)iSerialType, &mem);\n    pBody += sqlite3VdbeSerialTypeLen((u32)iSerialType);\n\n    switch( sqlite3_value_type(&mem) ){\n      case SQLITE_TEXT:\n        pVal = Tcl_NewStringObj((const char*)sqlite3_value_text(&mem), -1);\n        break;\n\n      case SQLITE_BLOB: {\n        char hexdigit[] = {\n          '0', '1', '2', '3', '4', '5', '6', '7',\n          '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'\n        };\n        int n = sqlite3_value_bytes(&mem);\n        u8 *z = (u8*)sqlite3_value_blob(&mem);\n        int i;\n        pVal = Tcl_NewStringObj(\"x'\", -1);\n        for(i=0; i<n; i++){\n          char hex[3];\n          hex[0] = hexdigit[((z[i] >> 4) & 0x0F)];\n          hex[1] = hexdigit[(z[i] & 0x0F)];\n          hex[2] = '\\0';\n          Tcl_AppendStringsToObj(pVal, hex, 0);\n        }\n        Tcl_AppendStringsToObj(pVal, \"'\", 0);\n        break;\n      }\n\n      case SQLITE_FLOAT:\n        pVal = Tcl_NewDoubleObj(sqlite3_value_double(&mem));\n        break;\n\n      case SQLITE_INTEGER:\n        pVal = Tcl_NewWideIntObj(sqlite3_value_int64(&mem));\n        break;\n\n      case SQLITE_NULL:\n        pVal = Tcl_NewStringObj(\"NULL\", -1);\n        break;\n\n      default:\n        assert( 0 );\n    }\n\n    Tcl_ListObjAppendElement(0, pRet, pVal);\n\n    if( mem.szMalloc ){\n      sqlite3DbFree(db, mem.zMalloc);\n    }\n  }\n\n  sqlite3_result_text(context, Tcl_GetString(pRet), -1, SQLITE_TRANSIENT);\n  Tcl_DecrRefCount(pRet);\n}\n\n/*\n**       test_zeroblob(N)\n**\n** The implementation of scalar SQL function \"test_zeroblob()\". This is\n** similar to the built-in zeroblob() function, except that it does not\n** check that the integer parameter is within range before passing it\n** to sqlite3_result_zeroblob().\n*/\nstatic void test_zeroblob(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  int nZero = sqlite3_value_int(argv[0]);\n  sqlite3_result_zeroblob(context, nZero);\n}\n\n/*         test_getsubtype(V)\n**\n** Return the subtype for value V.\n*/\nstatic void test_getsubtype(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  sqlite3_result_int(context, (int)sqlite3_value_subtype(argv[0]));\n}\n\n/*         test_frombind(A,B,C,...)\n**\n** Return an integer bitmask that has a bit set for every argument\n** (up to the first 63 arguments) that originates from a bind a parameter.\n*/\nstatic void test_frombind(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  sqlite3_uint64 m = 0;\n  int i;\n  for(i=0; i<argc && i<63; i++){\n    if( sqlite3_value_frombind(argv[i]) ) m |= ((sqlite3_uint64)1)<<i;\n  }\n  sqlite3_result_int64(context, (sqlite3_int64)m);\n}\n\n/*         test_setsubtype(V, T)\n**\n** Return the value V with its subtype changed to T\n*/\nstatic void test_setsubtype(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  sqlite3_result_value(context, argv[0]);\n  sqlite3_result_subtype(context, (unsigned int)sqlite3_value_int(argv[1]));\n}\n\nstatic int registerTestFunctions(\n  sqlite3 *db,\n  char **pzErrMsg,\n  const sqlite3_api_routines *pThunk\n){\n  static const struct {\n     char *zName;\n     signed char nArg;\n     unsigned int eTextRep; /* 1: UTF-16.  0: UTF-8 */\n     void (*xFunc)(sqlite3_context*,int,sqlite3_value **);\n  } aFuncs[] = {\n    { \"randstr\",               2, SQLITE_UTF8, randStr    },\n    { \"test_destructor\",       1, SQLITE_UTF8, test_destructor},\n#ifndef SQLITE_OMIT_UTF16\n    { \"test_destructor16\",     1, SQLITE_UTF8, test_destructor16},\n    { \"hex_to_utf16be\",        1, SQLITE_UTF8, testHexToUtf16be},\n    { \"hex_to_utf16le\",        1, SQLITE_UTF8, testHexToUtf16le},\n#endif\n    { \"hex_to_utf8\",           1, SQLITE_UTF8, testHexToUtf8},\n    { \"test_destructor_count\", 0, SQLITE_UTF8, test_destructor_count},\n    { \"test_auxdata\",         -1, SQLITE_UTF8, test_auxdata},\n    { \"test_error\",            1, SQLITE_UTF8, test_error},\n    { \"test_error\",            2, SQLITE_UTF8, test_error},\n    { \"test_eval\",             1, SQLITE_UTF8, test_eval},\n    { \"test_isolation\",        2, SQLITE_UTF8, test_isolation},\n    { \"test_counter\",          1, SQLITE_UTF8, counterFunc},\n    { \"real2hex\",              1, SQLITE_UTF8, real2hex},\n    { \"test_decode\",           1, SQLITE_UTF8, test_decode},\n    { \"test_extract\",          2, SQLITE_UTF8, test_extract},\n    { \"test_zeroblob\",  1, SQLITE_UTF8|SQLITE_DETERMINISTIC, test_zeroblob},\n    { \"test_getsubtype\",       1, SQLITE_UTF8, test_getsubtype},\n    { \"test_setsubtype\",       2, SQLITE_UTF8|SQLITE_RESULT_SUBTYPE,\n                                               test_setsubtype},\n    { \"test_frombind\",        -1, SQLITE_UTF8, test_frombind},\n  };\n  int i;\n\n  for(i=0; i<sizeof(aFuncs)/sizeof(aFuncs[0]); i++){\n    sqlite3_create_function(db, aFuncs[i].zName, aFuncs[i].nArg,\n        aFuncs[i].eTextRep, 0, aFuncs[i].xFunc, 0, 0);\n  }\n\n  sqlite3_create_function(db, \"test_agg_errmsg16\", 0, SQLITE_ANY, 0, 0, \n      test_agg_errmsg16_step, test_agg_errmsg16_final);\n      \n  return SQLITE_OK;\n}\n\n/*\n** TCLCMD:  autoinstall_test_functions\n**\n** Invoke this TCL command to use sqlite3_auto_extension() to cause\n** the standard set of test functions to be loaded into each new\n** database connection.\n*/\nstatic int SQLITE_TCLAPI autoinstall_test_funcs(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  extern int Md5_Register(sqlite3 *, char **, const sqlite3_api_routines *);\n  int rc = sqlite3_auto_extension((void(*)(void))registerTestFunctions);\n  if( rc==SQLITE_OK ){\n    rc = sqlite3_auto_extension((void(*)(void))Md5_Register);\n  }\n  Tcl_SetObjResult(interp, Tcl_NewIntObj(rc));\n  return TCL_OK;\n}\n\n/*\n** A bogus step function and finalizer function.\n*/\nstatic void tStep(sqlite3_context *a, int b, sqlite3_value **c){}\nstatic void tFinal(sqlite3_context *a){}\n\n\n/*\n** tclcmd:  abuse_create_function\n**\n** Make various calls to sqlite3_create_function that do not have valid\n** parameters.  Verify that the error condition is detected and reported.\n*/\nstatic int SQLITE_TCLAPI abuse_create_function(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  extern int getDbPointer(Tcl_Interp*, const char*, sqlite3**);\n  sqlite3 *db;\n  int rc;\n  int mxArg;\n\n  if( getDbPointer(interp, Tcl_GetString(objv[1]), &db) ) return TCL_ERROR;\n\n  rc = sqlite3_create_function(db, \"tx\", 1, SQLITE_UTF8, 0, tStep,tStep,tFinal);\n  if( rc!=SQLITE_MISUSE ) goto abuse_err;\n\n  rc = sqlite3_create_function(db, \"tx\", 1, SQLITE_UTF8, 0, tStep, tStep, 0);\n  if( rc!=SQLITE_MISUSE ) goto abuse_err;\n\n  rc = sqlite3_create_function(db, \"tx\", 1, SQLITE_UTF8, 0, tStep, 0, tFinal);\n  if( rc!=SQLITE_MISUSE) goto abuse_err;\n\n  rc = sqlite3_create_function(db, \"tx\", 1, SQLITE_UTF8, 0, 0, 0, tFinal);\n  if( rc!=SQLITE_MISUSE ) goto abuse_err;\n\n  rc = sqlite3_create_function(db, \"tx\", 1, SQLITE_UTF8, 0, 0, tStep, 0);\n  if( rc!=SQLITE_MISUSE ) goto abuse_err;\n\n  rc = sqlite3_create_function(db, \"tx\", -2, SQLITE_UTF8, 0, tStep, 0, 0);\n  if( rc!=SQLITE_MISUSE ) goto abuse_err;\n\n  rc = sqlite3_create_function(db, \"tx\", 32768, SQLITE_UTF8, 0, tStep, 0, 0);\n  if( rc!=SQLITE_MISUSE ) goto abuse_err;\n\n  rc = sqlite3_create_function(db, \"funcxx\"\n       \"_123456789_123456789_123456789_123456789_123456789\"\n       \"_123456789_123456789_123456789_123456789_123456789\"\n       \"_123456789_123456789_123456789_123456789_123456789\"\n       \"_123456789_123456789_123456789_123456789_123456789\"\n       \"_123456789_123456789_123456789_123456789_123456789\",\n       1, SQLITE_UTF8, 0, tStep, 0, 0);\n  if( rc!=SQLITE_MISUSE ) goto abuse_err;\n\n  /* This last function registration should actually work.  Generate\n  ** a no-op function (that always returns NULL) and which has the\n  ** maximum-length function name and the maximum number of parameters.\n  */\n  sqlite3_limit(db, SQLITE_LIMIT_FUNCTION_ARG, 1000000);\n  mxArg = sqlite3_limit(db, SQLITE_LIMIT_FUNCTION_ARG, -1);\n  rc = sqlite3_create_function(db, \"nullx\"\n       \"_123456789_123456789_123456789_123456789_123456789\"\n       \"_123456789_123456789_123456789_123456789_123456789\"\n       \"_123456789_123456789_123456789_123456789_123456789\"\n       \"_123456789_123456789_123456789_123456789_123456789\"\n       \"_123456789_123456789_123456789_123456789_123456789\",\n       mxArg, SQLITE_UTF8, 0, tStep, 0, 0);\n  if( rc!=SQLITE_OK ) goto abuse_err;\n                                \n  return TCL_OK;\n\nabuse_err:\n  Tcl_AppendResult(interp, \"sqlite3_create_function abused test failed\", \n                   (char*)0);\n  return TCL_ERROR;\n}\n\n\n/*\n** SQLite user defined function to use with matchinfo() to calculate the\n** relevancy of an FTS match. The value returned is the relevancy score\n** (a real value greater than or equal to zero). A larger value indicates \n** a more relevant document.\n**\n** The overall relevancy returned is the sum of the relevancies of each \n** column value in the FTS table. The relevancy of a column value is the\n** sum of the following for each reportable phrase in the FTS query:\n**\n**   (<hit count> / <global hit count>) * <column weight>\n**\n** where <hit count> is the number of instances of the phrase in the\n** column value of the current row and <global hit count> is the number\n** of instances of the phrase in the same column of all rows in the FTS\n** table. The <column weight> is a weighting factor assigned to each\n** column by the caller (see below).\n**\n** The first argument to this function must be the return value of the FTS \n** matchinfo() function. Following this must be one argument for each column \n** of the FTS table containing a numeric weight factor for the corresponding \n** column. Example:\n**\n**     CREATE VIRTUAL TABLE documents USING fts3(title, content)\n**\n** The following query returns the docids of documents that match the full-text\n** query <query> sorted from most to least relevant. When calculating\n** relevance, query term instances in the 'title' column are given twice the\n** weighting of those in the 'content' column.\n**\n**     SELECT docid FROM documents \n**     WHERE documents MATCH <query> \n**     ORDER BY rank(matchinfo(documents), 1.0, 0.5) DESC\n*/\nstatic void rankfunc(sqlite3_context *pCtx, int nVal, sqlite3_value **apVal){\n  int *aMatchinfo;                /* Return value of matchinfo() */\n  int nMatchinfo;                 /* Number of elements in aMatchinfo[] */\n  int nCol = 0;                   /* Number of columns in the table */\n  int nPhrase = 0;                /* Number of phrases in the query */\n  int iPhrase;                    /* Current phrase */\n  double score = 0.0;             /* Value to return */\n\n  assert( sizeof(int)==4 );\n\n  /* Check that the number of arguments passed to this function is correct.\n  ** If not, jump to wrong_number_args. Set aMatchinfo to point to the array\n  ** of unsigned integer values returned by FTS function matchinfo. Set\n  ** nPhrase to contain the number of reportable phrases in the users full-text\n  ** query, and nCol to the number of columns in the table. Then check that the\n  ** size of the matchinfo blob is as expected. Return an error if it is not.\n  */\n  if( nVal<1 ) goto wrong_number_args;\n  aMatchinfo = (int*)sqlite3_value_blob(apVal[0]);\n  nMatchinfo = sqlite3_value_bytes(apVal[0]) / sizeof(int);\n  if( nMatchinfo>=2 ){\n    nPhrase = aMatchinfo[0];\n    nCol = aMatchinfo[1];\n  }\n  if( nMatchinfo!=(2+3*nCol*nPhrase) ){\n    sqlite3_result_error(pCtx,\n        \"invalid matchinfo blob passed to function rank()\", -1);\n    return;\n  }\n  if( nVal!=(1+nCol) ) goto wrong_number_args;\n\n  /* Iterate through each phrase in the users query. */\n  for(iPhrase=0; iPhrase<nPhrase; iPhrase++){\n    int iCol;                     /* Current column */\n\n    /* Now iterate through each column in the users query. For each column,\n    ** increment the relevancy score by:\n    **\n    **   (<hit count> / <global hit count>) * <column weight>\n    **\n    ** aPhraseinfo[] points to the start of the data for phrase iPhrase. So\n    ** the hit count and global hit counts for each column are found in \n    ** aPhraseinfo[iCol*3] and aPhraseinfo[iCol*3+1], respectively.\n    */\n    int *aPhraseinfo = &aMatchinfo[2 + iPhrase*nCol*3];\n    for(iCol=0; iCol<nCol; iCol++){\n      int nHitCount = aPhraseinfo[3*iCol];\n      int nGlobalHitCount = aPhraseinfo[3*iCol+1];\n      double weight = sqlite3_value_double(apVal[iCol+1]);\n      if( nHitCount>0 ){\n        score += ((double)nHitCount / (double)nGlobalHitCount) * weight;\n      }\n    }\n  }\n\n  sqlite3_result_double(pCtx, score);\n  return;\n\n  /* Jump here if the wrong number of arguments are passed to this function */\nwrong_number_args:\n  sqlite3_result_error(pCtx, \"wrong number of arguments to function rank()\", -1);\n}\n\nstatic int SQLITE_TCLAPI install_fts3_rank_function(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  extern int getDbPointer(Tcl_Interp*, const char*, sqlite3**);\n  sqlite3 *db;\n\n  if( objc!=2 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"DB\");\n    return TCL_ERROR;\n  }\n\n  if( getDbPointer(interp, Tcl_GetString(objv[1]), &db) ) return TCL_ERROR;\n  sqlite3_create_function(db, \"rank\", -1, SQLITE_UTF8, 0, rankfunc, 0, 0);\n  return TCL_OK;\n}\n\n\n/*\n** Register commands with the TCL interpreter.\n*/\nint Sqlitetest_func_Init(Tcl_Interp *interp){\n  static struct {\n     char *zName;\n     Tcl_ObjCmdProc *xProc;\n  } aObjCmd[] = {\n     { \"autoinstall_test_functions\",    autoinstall_test_funcs },\n     { \"abuse_create_function\",         abuse_create_function  },\n     { \"install_fts3_rank_function\",    install_fts3_rank_function  },\n  };\n  int i;\n  extern int Md5_Register(sqlite3 *, char **, const sqlite3_api_routines *);\n\n  for(i=0; i<sizeof(aObjCmd)/sizeof(aObjCmd[0]); i++){\n    Tcl_CreateObjCommand(interp, aObjCmd[i].zName, aObjCmd[i].xProc, 0, 0);\n  }\n  sqlite3_initialize();\n  sqlite3_auto_extension((void(*)(void))registerTestFunctions);\n  sqlite3_auto_extension((void(*)(void))Md5_Register);\n  return TCL_OK;\n}\n"}
{"repo": "sqlite", "file": "vxworks.h", "lang": "C++", "code": "/*\n** 2015-03-02\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This file contains code that is specific to Wind River's VxWorks\n*/\n#if defined(__RTP__) || defined(_WRS_KERNEL)\n/* This is VxWorks.  Set up things specially for that OS\n*/\n#include <vxWorks.h>\n#include <pthread.h>  /* amalgamator: dontcache */\n#define OS_VXWORKS 1\n#define SQLITE_OS_OTHER 0\n#define SQLITE_HOMEGROWN_RECURSIVE_MUTEX 1\n#define SQLITE_OMIT_LOAD_EXTENSION 1\n#define SQLITE_ENABLE_LOCKING_STYLE 0\n#define HAVE_UTIME 1\n#else\n/* This is not VxWorks. */\n#ifndef OS_VXWORKS\n#  define OS_VXWORKS 0\n#endif\n#define HAVE_FCHOWN 1\n#define HAVE_READLINK 1\n#define HAVE_LSTAT 1\n#endif /* defined(_WRS_KERNEL) */\n"}
{"repo": "sqlite", "file": "whereInt.h", "lang": "C++", "code": "/*\n** 2013-11-12\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains structure and macro definitions for the query\n** planner logic in \"where.c\".  These definitions are broken out into\n** a separate source file for easier editing.\n*/\n#ifndef SQLITE_WHEREINT_H\n#define SQLITE_WHEREINT_H\n\n\n/* Forward references\n*/\ntypedef struct WhereClause WhereClause;\ntypedef struct WhereMaskSet WhereMaskSet;\ntypedef struct WhereOrInfo WhereOrInfo;\ntypedef struct WhereAndInfo WhereAndInfo;\ntypedef struct WhereLevel WhereLevel;\ntypedef struct WhereLoop WhereLoop;\ntypedef struct WherePath WherePath;\ntypedef struct WhereTerm WhereTerm;\ntypedef struct WhereLoopBuilder WhereLoopBuilder;\ntypedef struct WhereScan WhereScan;\ntypedef struct WhereOrCost WhereOrCost;\ntypedef struct WhereOrSet WhereOrSet;\ntypedef struct WhereMemBlock WhereMemBlock;\ntypedef struct WhereRightJoin WhereRightJoin;\n\n/*\n** This object is a header on a block of allocated memory that will be\n** automatically freed when its WInfo object is destructed.\n*/\nstruct WhereMemBlock {\n  WhereMemBlock *pNext;      /* Next block in the chain */\n  u64 sz;                    /* Bytes of space */\n};\n\n/*\n** Extra information attached to a WhereLevel that is a RIGHT JOIN.\n*/\nstruct WhereRightJoin {\n  int iMatch;          /* Cursor used to determine prior matched rows */\n  int regBloom;        /* Bloom filter for iRJMatch */\n  int regReturn;       /* Return register for the interior subroutine */\n  int addrSubrtn;      /* Starting address for the interior subroutine */\n  int endSubrtn;       /* The last opcode in the interior subroutine */\n};\n\n/*\n** This object contains information needed to implement a single nested\n** loop in WHERE clause.\n**\n** Contrast this object with WhereLoop.  This object describes the\n** implementation of the loop.  WhereLoop describes the algorithm.\n** This object contains a pointer to the WhereLoop algorithm as one of\n** its elements.\n**\n** The WhereInfo object contains a single instance of this object for\n** each term in the FROM clause (which is to say, for each of the\n** nested loops as implemented).  The order of WhereLevel objects determines\n** the loop nested order, with WhereInfo.a[0] being the outer loop and\n** WhereInfo.a[WhereInfo.nLevel-1] being the inner loop.\n*/\nstruct WhereLevel {\n  int iLeftJoin;        /* Memory cell used to implement LEFT OUTER JOIN */\n  int iTabCur;          /* The VDBE cursor used to access the table */\n  int iIdxCur;          /* The VDBE cursor used to access pIdx */\n  int addrBrk;          /* Jump here to break out of the loop */\n  int addrHalt;         /* Abort the query due to empty table or similar */\n  int addrNxt;          /* Jump here to start the next IN combination */\n  int addrSkip;         /* Jump here for next iteration of skip-scan */\n  int addrCont;         /* Jump here to continue with the next loop cycle */\n  int addrFirst;        /* First instruction of interior of the loop */\n  int addrBody;         /* Beginning of the body of this loop */\n  int regBignull;       /* big-null flag reg. True if a NULL-scan is needed */\n  int addrBignull;      /* Jump here for next part of big-null scan */\n#ifndef SQLITE_LIKE_DOESNT_MATCH_BLOBS\n  u32 iLikeRepCntr;     /* LIKE range processing counter register (times 2) */\n  int addrLikeRep;      /* LIKE range processing address */\n#endif\n  int regFilter;        /* Bloom filter */\n  WhereRightJoin *pRJ;  /* Extra information for RIGHT JOIN */\n  u8 iFrom;             /* Which entry in the FROM clause */\n  u8 op, p3, p5;        /* Opcode, P3 & P5 of the opcode that ends the loop */\n  int p1, p2;           /* Operands of the opcode used to end the loop */\n  union {               /* Information that depends on pWLoop->wsFlags */\n    struct {\n      int nIn;              /* Number of entries in aInLoop[] */\n      struct InLoop {\n        int iCur;              /* The VDBE cursor used by this IN operator */\n        int addrInTop;         /* Top of the IN loop */\n        int iBase;             /* Base register of multi-key index record */\n        int nPrefix;           /* Number of prior entries in the key */\n        u8 eEndLoopOp;         /* IN Loop terminator. OP_Next or OP_Prev */\n      } *aInLoop;           /* Information about each nested IN operator */\n    } in;                 /* Used when pWLoop->wsFlags&WHERE_IN_ABLE */\n    Index *pCoveringIdx;  /* Possible covering index for WHERE_MULTI_OR */\n  } u;\n  struct WhereLoop *pWLoop;  /* The selected WhereLoop object */\n  Bitmask notReady;          /* FROM entries not usable at this level */\n#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n  int addrVisit;        /* Address at which row is visited */\n#endif\n};\n\n/*\n** Each instance of this object represents an algorithm for evaluating one\n** term of a join.  Every term of the FROM clause will have at least\n** one corresponding WhereLoop object (unless INDEXED BY constraints\n** prevent a query solution - which is an error) and many terms of the\n** FROM clause will have multiple WhereLoop objects, each describing a\n** potential way of implementing that FROM-clause term, together with\n** dependencies and cost estimates for using the chosen algorithm.\n**\n** Query planning consists of building up a collection of these WhereLoop\n** objects, then computing a particular sequence of WhereLoop objects, with\n** one WhereLoop object per FROM clause term, that satisfy all dependencies\n** and that minimize the overall cost.\n*/\nstruct WhereLoop {\n  Bitmask prereq;       /* Bitmask of other loops that must run first */\n  Bitmask maskSelf;     /* Bitmask identifying table iTab */\n#ifdef SQLITE_DEBUG\n  char cId;             /* Symbolic ID of this loop for debugging use */\n#endif\n  u8 iTab;              /* Position in FROM clause of table for this loop */\n  u8 iSortIdx;          /* Sorting index number.  0==None */\n  LogEst rSetup;        /* One-time setup cost (ex: create transient index) */\n  LogEst rRun;          /* Cost of running each loop */\n  LogEst nOut;          /* Estimated number of output rows */\n  union {\n    struct {               /* Information for internal btree tables */\n      u16 nEq;               /* Number of equality constraints */\n      u16 nBtm;              /* Size of BTM vector */\n      u16 nTop;              /* Size of TOP vector */\n      u16 nDistinctCol;      /* Index columns used to sort for DISTINCT */\n      Index *pIndex;         /* Index used, or NULL */\n      ExprList *pOrderBy;    /* ORDER BY clause if this is really a subquery */\n    } btree;\n    struct {               /* Information for virtual tables */\n      int idxNum;            /* Index number */\n      u32 needFree : 1;      /* True if sqlite3_free(idxStr) is needed */\n      u32 bOmitOffset : 1;   /* True to let virtual table handle offset */\n      u32 bIdxNumHex : 1;    /* Show idxNum as hex in EXPLAIN QUERY PLAN */\n      i8 isOrdered;          /* True if satisfies ORDER BY */\n      u16 omitMask;          /* Terms that may be omitted */\n      char *idxStr;          /* Index identifier string */\n      u32 mHandleIn;         /* Terms to handle as IN(...) instead of == */\n    } vtab;\n  } u;\n  u32 wsFlags;          /* WHERE_* flags describing the plan */\n  u16 nLTerm;           /* Number of entries in aLTerm[] */\n  u16 nSkip;            /* Number of NULL aLTerm[] entries */\n  /**** whereLoopXfer() copies fields above ***********************/\n# define WHERE_LOOP_XFER_SZ offsetof(WhereLoop,nLSlot)\n  u16 nLSlot;           /* Number of slots allocated for aLTerm[] */\n#ifdef WHERETRACE_ENABLED\n  LogEst rStarDelta;    /* Cost delta due to star-schema heuristic.  Not\n                        ** initialized unless pWInfo->bStarUsed */\n#endif\n  WhereTerm **aLTerm;   /* WhereTerms used */\n  WhereLoop *pNextLoop; /* Next WhereLoop object in the WhereClause */\n  WhereTerm *aLTermSpace[3];  /* Initial aLTerm[] space */\n};\n\n/* This object holds the prerequisites and the cost of running a\n** subquery on one operand of an OR operator in the WHERE clause.\n** See WhereOrSet for additional information\n*/\nstruct WhereOrCost {\n  Bitmask prereq;     /* Prerequisites */\n  LogEst rRun;        /* Cost of running this subquery */\n  LogEst nOut;        /* Number of outputs for this subquery */\n};\n\n/* The WhereOrSet object holds a set of possible WhereOrCosts that\n** correspond to the subquery(s) of OR-clause processing.  Only the\n** best N_OR_COST elements are retained.\n*/\n#define N_OR_COST 3\nstruct WhereOrSet {\n  u16 n;                      /* Number of valid a[] entries */\n  WhereOrCost a[N_OR_COST];   /* Set of best costs */\n};\n\n/*\n** Each instance of this object holds a sequence of WhereLoop objects\n** that implement some or all of a query plan.\n**\n** Think of each WhereLoop object as a node in a graph with arcs\n** showing dependencies and costs for travelling between nodes.  (That is\n** not a completely accurate description because WhereLoop costs are a\n** vector, not a scalar, and because dependencies are many-to-one, not\n** one-to-one as are graph nodes.  But it is a useful visualization aid.)\n** Then a WherePath object is a path through the graph that visits some\n** or all of the WhereLoop objects once.\n**\n** The \"solver\" works by creating the N best WherePath objects of length\n** 1.  Then using those as a basis to compute the N best WherePath objects\n** of length 2.  And so forth until the length of WherePaths equals the\n** number of nodes in the FROM clause.  The best (lowest cost) WherePath\n** at the end is the chosen query plan.\n*/\nstruct WherePath {\n  Bitmask maskLoop;     /* Bitmask of all WhereLoop objects in this path */\n  Bitmask revLoop;      /* aLoop[]s that should be reversed for ORDER BY */\n  LogEst nRow;          /* Estimated number of rows generated by this path */\n  LogEst rCost;         /* Total cost of this path */\n  LogEst rUnsort;       /* Total cost of this path ignoring sorting costs */\n  i8 isOrdered;         /* No. of ORDER BY terms satisfied. -1 for unknown */\n  WhereLoop **aLoop;    /* Array of WhereLoop objects implementing this path */\n};\n\n/*\n** The query generator uses an array of instances of this structure to\n** help it analyze the subexpressions of the WHERE clause.  Each WHERE\n** clause subexpression is separated from the others by AND operators,\n** usually, or sometimes subexpressions separated by OR.\n**\n** All WhereTerms are collected into a single WhereClause structure. \n** The following identity holds:\n**\n**        WhereTerm.pWC->a[WhereTerm.idx] == WhereTerm\n**\n** When a term is of the form:\n**\n**              X <op> <expr>\n**\n** where X is a column name and <op> is one of certain operators,\n** then WhereTerm.leftCursor and WhereTerm.u.leftColumn record the\n** cursor number and column number for X.  WhereTerm.eOperator records\n** the <op> using a bitmask encoding defined by WO_xxx below.  The\n** use of a bitmask encoding for the operator allows us to search\n** quickly for terms that match any of several different operators.\n**\n** A WhereTerm might also be two or more subterms connected by OR:\n**\n**         (t1.X <op> <expr>) OR (t1.Y <op> <expr>) OR ....\n**\n** In this second case, wtFlag has the TERM_ORINFO bit set and eOperator==WO_OR\n** and the WhereTerm.u.pOrInfo field points to auxiliary information that\n** is collected about the OR clause.\n**\n** If a term in the WHERE clause does not match either of the two previous\n** categories, then eOperator==0.  The WhereTerm.pExpr field is still set\n** to the original subexpression content and wtFlags is set up appropriately\n** but no other fields in the WhereTerm object are meaningful.\n**\n** When eOperator!=0, prereqRight and prereqAll record sets of cursor numbers,\n** but they do so indirectly.  A single WhereMaskSet structure translates\n** cursor number into bits and the translated bit is stored in the prereq\n** fields.  The translation is used in order to maximize the number of\n** bits that will fit in a Bitmask.  The VDBE cursor numbers might be\n** spread out over the non-negative integers.  For example, the cursor\n** numbers might be 3, 8, 9, 10, 20, 23, 41, and 45.  The WhereMaskSet\n** translates these sparse cursor numbers into consecutive integers\n** beginning with 0 in order to make the best possible use of the available\n** bits in the Bitmask.  So, in the example above, the cursor numbers\n** would be mapped into integers 0 through 7.\n**\n** The number of terms in a join is limited by the number of bits\n** in prereqRight and prereqAll.  The default is 64 bits, hence SQLite\n** is only able to process joins with 64 or fewer tables.\n*/\nstruct WhereTerm {\n  Expr *pExpr;            /* Pointer to the subexpression that is this term */\n  WhereClause *pWC;       /* The clause this term is part of */\n  LogEst truthProb;       /* Probability of truth for this expression */\n  u16 wtFlags;            /* TERM_xxx bit flags.  See below */\n  u16 eOperator;          /* A WO_xx value describing <op> */\n  u8 nChild;              /* Number of children that must disable us */\n  u8 eMatchOp;            /* Op for vtab MATCH/LIKE/GLOB/REGEXP terms */\n  int iParent;            /* Disable pWC->a[iParent] when this term disabled */\n  int leftCursor;         /* Cursor number of X in \"X <op> <expr>\" */\n#ifdef SQLITE_DEBUG\n  int iTerm;              /* Which WhereTerm is this, for debug purposes */\n#endif\n  union {\n    struct {\n      int leftColumn;         /* Column number of X in \"X <op> <expr>\" */\n      int iField;             /* Field in (?,?,?) IN (SELECT...) vector */\n    } x;                    /* Opcode other than OP_OR or OP_AND */\n    WhereOrInfo *pOrInfo;   /* Extra information if (eOperator & WO_OR)!=0 */\n    WhereAndInfo *pAndInfo; /* Extra information if (eOperator& WO_AND)!=0 */\n  } u;\n  Bitmask prereqRight;    /* Bitmask of tables used by pExpr->pRight */\n  Bitmask prereqAll;      /* Bitmask of tables referenced by pExpr */\n};\n\n/*\n** Allowed values of WhereTerm.wtFlags\n*/\n#define TERM_DYNAMIC    0x0001 /* Need to call sqlite3ExprDelete(db, pExpr) */\n#define TERM_VIRTUAL    0x0002 /* Added by the optimizer.  Do not code */\n#define TERM_CODED      0x0004 /* This term is already coded */\n#define TERM_COPIED     0x0008 /* Has a child */\n#define TERM_ORINFO     0x0010 /* Need to free the WhereTerm.u.pOrInfo object */\n#define TERM_ANDINFO    0x0020 /* Need to free the WhereTerm.u.pAndInfo obj */\n#define TERM_OK         0x0040 /* Used during OR-clause processing */\n#define TERM_VNULL      0x0080 /* Manufactured x>NULL or x<=NULL term */\n#define TERM_LIKEOPT    0x0100 /* Virtual terms from the LIKE optimization */\n#define TERM_LIKECOND   0x0200 /* Conditionally this LIKE operator term */\n#define TERM_LIKE       0x0400 /* The original LIKE operator */\n#define TERM_IS         0x0800 /* Term.pExpr is an IS operator */\n#define TERM_VARSELECT  0x1000 /* Term.pExpr contains a correlated sub-query */\n#define TERM_HEURTRUTH  0x2000 /* Heuristic truthProb used */\n#ifdef SQLITE_ENABLE_STAT4\n#  define TERM_HIGHTRUTH  0x4000 /* Term excludes few rows */\n#else\n#  define TERM_HIGHTRUTH  0      /* Only used with STAT4 */\n#endif\n#define TERM_SLICE      0x8000 /* One slice of a row-value/vector comparison */\n\n/*\n** An instance of the WhereScan object is used as an iterator for locating\n** terms in the WHERE clause that are useful to the query planner.\n*/\nstruct WhereScan {\n  WhereClause *pOrigWC;      /* Original, innermost WhereClause */\n  WhereClause *pWC;          /* WhereClause currently being scanned */\n  const char *zCollName;     /* Required collating sequence, if not NULL */\n  Expr *pIdxExpr;            /* Search for this index expression */\n  int k;                     /* Resume scanning at this->pWC->a[this->k] */\n  u32 opMask;                /* Acceptable operators */\n  char idxaff;               /* Must match this affinity, if zCollName!=NULL */\n  unsigned char iEquiv;      /* Current slot in aiCur[] and aiColumn[] */\n  unsigned char nEquiv;      /* Number of entries in aiCur[] and aiColumn[] */\n  int aiCur[11];             /* Cursors in the equivalence class */\n  i16 aiColumn[11];          /* Corresponding column number in the eq-class */\n};\n\n/*\n** An instance of the following structure holds all information about a\n** WHERE clause.  Mostly this is a container for one or more WhereTerms.\n**\n** Explanation of pOuter:  For a WHERE clause of the form\n**\n**           a AND ((b AND c) OR (d AND e)) AND f\n**\n** There are separate WhereClause objects for the whole clause and for\n** the subclauses \"(b AND c)\" and \"(d AND e)\".  The pOuter field of the\n** subclauses points to the WhereClause object for the whole clause.\n*/\nstruct WhereClause {\n  WhereInfo *pWInfo;       /* WHERE clause processing context */\n  WhereClause *pOuter;     /* Outer conjunction */\n  u8 op;                   /* Split operator.  TK_AND or TK_OR */\n  u8 hasOr;                /* True if any a[].eOperator is WO_OR */\n  int nTerm;               /* Number of terms */\n  int nSlot;               /* Number of entries in a[] */\n  int nBase;               /* Number of terms through the last non-Virtual */\n  WhereTerm *a;            /* Each a[] describes a term of the WHERE clause */\n#if defined(SQLITE_SMALL_STACK)\n  WhereTerm aStatic[1];    /* Initial static space for a[] */\n#else\n  WhereTerm aStatic[8];    /* Initial static space for a[] */\n#endif\n};\n\n/*\n** A WhereTerm with eOperator==WO_OR has its u.pOrInfo pointer set to\n** a dynamically allocated instance of the following structure.\n*/\nstruct WhereOrInfo {\n  WhereClause wc;          /* Decomposition into subterms */\n  Bitmask indexable;       /* Bitmask of all indexable tables in the clause */\n};\n\n/*\n** A WhereTerm with eOperator==WO_AND has its u.pAndInfo pointer set to\n** a dynamically allocated instance of the following structure.\n*/\nstruct WhereAndInfo {\n  WhereClause wc;          /* The subexpression broken out */\n};\n\n/*\n** An instance of the following structure keeps track of a mapping\n** between VDBE cursor numbers and bits of the bitmasks in WhereTerm.\n**\n** The VDBE cursor numbers are small integers contained in\n** SrcItem.iCursor and Expr.iTable fields.  For any given WHERE\n** clause, the cursor numbers might not begin with 0 and they might\n** contain gaps in the numbering sequence.  But we want to make maximum\n** use of the bits in our bitmasks.  This structure provides a mapping\n** from the sparse cursor numbers into consecutive integers beginning\n** with 0.\n**\n** If WhereMaskSet.ix[A]==B it means that The A-th bit of a Bitmask\n** corresponds VDBE cursor number B.  The A-th bit of a bitmask is 1<<A.\n**\n** For example, if the WHERE clause expression used these VDBE\n** cursors:  4, 5, 8, 29, 57, 73.  Then the  WhereMaskSet structure\n** would map those cursor numbers into bits 0 through 5.\n**\n** Note that the mapping is not necessarily ordered.  In the example\n** above, the mapping might go like this:  4->3, 5->1, 8->2, 29->0,\n** 57->5, 73->4.  Or one of 719 other combinations might be used. It\n** does not really matter.  What is important is that sparse cursor\n** numbers all get mapped into bit numbers that begin with 0 and contain\n** no gaps.\n*/\nstruct WhereMaskSet {\n  int bVarSelect;               /* Used by sqlite3WhereExprUsage() */\n  int n;                        /* Number of assigned cursor values */\n  int ix[BMS];                  /* Cursor assigned to each bit */\n};\n\n/*\n** This object is a convenience wrapper holding all information needed\n** to construct WhereLoop objects for a particular query.\n*/\nstruct WhereLoopBuilder {\n  WhereInfo *pWInfo;        /* Information about this WHERE */\n  WhereClause *pWC;         /* WHERE clause terms */\n  WhereLoop *pNew;          /* Template WhereLoop */\n  WhereOrSet *pOrSet;       /* Record best loops here, if not NULL */\n#ifdef SQLITE_ENABLE_STAT4\n  UnpackedRecord *pRec;     /* Probe for stat4 (if required) */\n  int nRecValid;            /* Number of valid fields currently in pRec */\n#endif\n  unsigned char bldFlags1;  /* First set of SQLITE_BLDF_* flags */\n  unsigned char bldFlags2;  /* Second set of SQLITE_BLDF_* flags */\n  unsigned int iPlanLimit;  /* Search limiter */\n};\n\n/* Allowed values for WhereLoopBuider.bldFlags */\n#define SQLITE_BLDF1_INDEXED  0x0001   /* An index is used */\n#define SQLITE_BLDF1_UNIQUE   0x0002   /* All keys of a UNIQUE index used */\n\n#define SQLITE_BLDF2_2NDPASS  0x0004   /* Second builder pass needed */\n\n/* The WhereLoopBuilder.iPlanLimit is used to limit the number of\n** index+constraint combinations the query planner will consider for a\n** particular query.  If this parameter is unlimited, then certain\n** pathological queries can spend excess time in the sqlite3WhereBegin()\n** routine.  The limit is high enough that is should not impact real-world\n** queries.\n**\n** SQLITE_QUERY_PLANNER_LIMIT is the baseline limit.  The limit is\n** increased by SQLITE_QUERY_PLANNER_LIMIT_INCR before each term of the FROM\n** clause is processed, so that every table in a join is guaranteed to be\n** able to propose a some index+constraint combinations even if the initial\n** baseline limit was exhausted by prior tables of the join.\n*/\n#ifndef SQLITE_QUERY_PLANNER_LIMIT\n# define SQLITE_QUERY_PLANNER_LIMIT 20000\n#endif\n#ifndef SQLITE_QUERY_PLANNER_LIMIT_INCR\n# define SQLITE_QUERY_PLANNER_LIMIT_INCR 1000\n#endif\n\n/*\n** The WHERE clause processing routine has two halves.  The\n** first part does the start of the WHERE loop and the second\n** half does the tail of the WHERE loop.  An instance of\n** this structure is returned by the first half and passed\n** into the second half to give some continuity.\n**\n** An instance of this object holds the complete state of the query\n** planner.\n*/\nstruct WhereInfo {\n  Parse *pParse;            /* Parsing and code generating context */\n  SrcList *pTabList;        /* List of tables in the join */\n  ExprList *pOrderBy;       /* The ORDER BY clause or NULL */\n  ExprList *pResultSet;     /* Result set of the query */\n#if WHERETRACE_ENABLED\n  Expr *pWhere;             /* The complete WHERE clause */\n#endif\n  Select *pSelect;          /* The entire SELECT statement containing WHERE */\n  int aiCurOnePass[2];      /* OP_OpenWrite cursors for the ONEPASS opt */\n  int iContinue;            /* Jump here to continue with next record */\n  int iBreak;               /* Jump here to break out of the loop */\n  int savedNQueryLoop;      /* pParse->nQueryLoop outside the WHERE loop */\n  u16 wctrlFlags;           /* Flags originally passed to sqlite3WhereBegin() */\n  LogEst iLimit;            /* LIMIT if wctrlFlags has WHERE_USE_LIMIT */\n  u8 nLevel;                /* Number of nested loop */\n  i8 nOBSat;                /* Number of ORDER BY terms satisfied by indices */\n  u8 eOnePass;              /* ONEPASS_OFF, or _SINGLE, or _MULTI */\n  u8 eDistinct;             /* One of the WHERE_DISTINCT_* values */\n  unsigned bDeferredSeek :1;   /* Uses OP_DeferredSeek */\n  unsigned untestedTerms :1;   /* Not all WHERE terms resolved by outer loop */\n  unsigned bOrderedInnerLoop:1;/* True if only the inner-most loop is ordered */\n  unsigned sorted        :1;   /* True if really sorted (not just grouped) */\n  unsigned bStarDone     :1;   /* True if check for star-query is complete */\n  unsigned bStarUsed     :1;   /* True if star-query heuristic is used */\n  LogEst nRowOut;           /* Estimated number of output rows */\n#ifdef WHERETRACE_ENABLED\n  LogEst rTotalCost;        /* Total cost of the solution */\n#endif\n  int iTop;                 /* The very beginning of the WHERE loop */\n  int iEndWhere;            /* End of the WHERE clause itself */\n  WhereLoop *pLoops;        /* List of all WhereLoop objects */\n  WhereMemBlock *pMemToFree;/* Memory to free when this object destroyed */\n  Bitmask revMask;          /* Mask of ORDER BY terms that need reversing */\n  WhereClause sWC;          /* Decomposition of the WHERE clause */\n  WhereMaskSet sMaskSet;    /* Map cursor numbers to bitmasks */\n  WhereLevel a[FLEXARRAY];  /* Information about each nest loop in WHERE */\n};\n\n/*\n** The size (in bytes) of a WhereInfo object that holds N WhereLevels.\n*/\n#define SZ_WHEREINFO(N) ROUND8(offsetof(WhereInfo,a)+(N)*sizeof(WhereLevel))\n\n/*\n** Private interfaces - callable only by other where.c routines.\n**\n** where.c:\n*/\nBitmask sqlite3WhereGetMask(WhereMaskSet*,int);\n#ifdef WHERETRACE_ENABLED\nvoid sqlite3WhereClausePrint(WhereClause *pWC);\nvoid sqlite3WhereTermPrint(WhereTerm *pTerm, int iTerm);\nvoid sqlite3WhereLoopPrint(const WhereLoop *p, const WhereClause *pWC);\n#endif\nWhereTerm *sqlite3WhereFindTerm(\n  WhereClause *pWC,     /* The WHERE clause to be searched */\n  int iCur,             /* Cursor number of LHS */\n  int iColumn,          /* Column number of LHS */\n  Bitmask notReady,     /* RHS must not overlap with this mask */\n  u32 op,               /* Mask of WO_xx values describing operator */\n  Index *pIdx           /* Must be compatible with this index, if not NULL */\n);\nvoid *sqlite3WhereMalloc(WhereInfo *pWInfo, u64 nByte);\nvoid *sqlite3WhereRealloc(WhereInfo *pWInfo, void *pOld, u64 nByte);\n\n/* wherecode.c: */\n#ifndef SQLITE_OMIT_EXPLAIN\nint sqlite3WhereExplainOneScan(\n  Parse *pParse,                  /* Parse context */\n  SrcList *pTabList,              /* Table list this loop refers to */\n  WhereLevel *pLevel,             /* Scan to write OP_Explain opcode for */\n  u16 wctrlFlags                  /* Flags passed to sqlite3WhereBegin() */\n);\nint sqlite3WhereExplainBloomFilter(\n  const Parse *pParse,            /* Parse context */\n  const WhereInfo *pWInfo,        /* WHERE clause */\n  const WhereLevel *pLevel        /* Bloom filter on this level */\n);\nvoid sqlite3WhereAddExplainText(\n  Parse *pParse,                  /* Parse context */\n  int addr, \n  SrcList *pTabList,              /* Table list this loop refers to */\n  WhereLevel *pLevel,             /* Scan to write OP_Explain opcode for */\n  u16 wctrlFlags                  /* Flags passed to sqlite3WhereBegin() */\n);\n#else\n# define sqlite3WhereExplainOneScan(u,v,w,x) 0\n# define sqlite3WhereExplainBloomFilter(u,v,w) 0\n# define  sqlite3WhereAddExplainText(u,v,w,x,y)\n#endif /* SQLITE_OMIT_EXPLAIN */\n#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\nvoid sqlite3WhereAddScanStatus(\n  Vdbe *v,                        /* Vdbe to add scanstatus entry to */\n  SrcList *pSrclist,              /* FROM clause pLvl reads data from */\n  WhereLevel *pLvl,               /* Level to add scanstatus() entry for */\n  int addrExplain                 /* Address of OP_Explain (or 0) */\n);\n#else\n# define sqlite3WhereAddScanStatus(a, b, c, d) ((void)d)\n#endif\nBitmask sqlite3WhereCodeOneLoopStart(\n  Parse *pParse,       /* Parsing context */\n  Vdbe *v,             /* Prepared statement under construction */\n  WhereInfo *pWInfo,   /* Complete information about the WHERE clause */\n  int iLevel,          /* Which level of pWInfo->a[] should be coded */\n  WhereLevel *pLevel,  /* The current level pointer */\n  Bitmask notReady     /* Which tables are currently available */\n);\nSQLITE_NOINLINE void sqlite3WhereRightJoinLoop(\n  WhereInfo *pWInfo,\n  int iLevel,\n  WhereLevel *pLevel\n);\n\n/* whereexpr.c: */\nvoid sqlite3WhereClauseInit(WhereClause*,WhereInfo*);\nvoid sqlite3WhereClauseClear(WhereClause*);\nvoid sqlite3WhereSplit(WhereClause*,Expr*,u8);\nvoid sqlite3WhereAddLimit(WhereClause*, Select*);\nBitmask sqlite3WhereExprUsage(WhereMaskSet*, Expr*);\nBitmask sqlite3WhereExprUsageNN(WhereMaskSet*, Expr*);\nBitmask sqlite3WhereExprListUsage(WhereMaskSet*, ExprList*);\nvoid sqlite3WhereExprAnalyze(SrcList*, WhereClause*);\nvoid sqlite3WhereTabFuncArgs(Parse*, SrcItem*, WhereClause*);\n\n\n\n\n\n/*\n** Bitmasks for the operators on WhereTerm objects.  These are all\n** operators that are of interest to the query planner.  An\n** OR-ed combination of these values can be used when searching for\n** particular WhereTerms within a WhereClause.\n**\n** Value constraints:\n**     WO_EQ    == SQLITE_INDEX_CONSTRAINT_EQ\n**     WO_LT    == SQLITE_INDEX_CONSTRAINT_LT\n**     WO_LE    == SQLITE_INDEX_CONSTRAINT_LE\n**     WO_GT    == SQLITE_INDEX_CONSTRAINT_GT\n**     WO_GE    == SQLITE_INDEX_CONSTRAINT_GE\n*/\n#define WO_IN     0x0001\n#define WO_EQ     0x0002\n#define WO_LT     (WO_EQ<<(TK_LT-TK_EQ))\n#define WO_LE     (WO_EQ<<(TK_LE-TK_EQ))\n#define WO_GT     (WO_EQ<<(TK_GT-TK_EQ))\n#define WO_GE     (WO_EQ<<(TK_GE-TK_EQ))\n#define WO_AUX    0x0040       /* Op useful to virtual tables only */\n#define WO_IS     0x0080\n#define WO_ISNULL 0x0100\n#define WO_OR     0x0200       /* Two or more OR-connected terms */\n#define WO_AND    0x0400       /* Two or more AND-connected terms */\n#define WO_EQUIV  0x0800       /* Of the form A==B, both columns */\n#define WO_NOOP   0x1000       /* This term does not restrict search space */\n#define WO_ROWVAL 0x2000       /* A row-value term */\n\n#define WO_ALL    0x3fff       /* Mask of all possible WO_* values */\n#define WO_SINGLE 0x01ff       /* Mask of all non-compound WO_* values */\n\n/*\n** These are definitions of bits in the WhereLoop.wsFlags field.\n** The particular combination of bits in each WhereLoop help to\n** determine the algorithm that WhereLoop represents.\n*/\n#define WHERE_COLUMN_EQ    0x00000001  /* x=EXPR */\n#define WHERE_COLUMN_RANGE 0x00000002  /* x<EXPR and/or x>EXPR */\n#define WHERE_COLUMN_IN    0x00000004  /* x IN (...) */\n#define WHERE_COLUMN_NULL  0x00000008  /* x IS NULL */\n#define WHERE_CONSTRAINT   0x0000000f  /* Any of the WHERE_COLUMN_xxx values */\n#define WHERE_TOP_LIMIT    0x00000010  /* x<EXPR or x<=EXPR constraint */\n#define WHERE_BTM_LIMIT    0x00000020  /* x>EXPR or x>=EXPR constraint */\n#define WHERE_BOTH_LIMIT   0x00000030  /* Both x>EXPR and x<EXPR */\n#define WHERE_IDX_ONLY     0x00000040  /* Use index only - omit table */\n#define WHERE_IPK          0x00000100  /* x is the INTEGER PRIMARY KEY */\n#define WHERE_INDEXED      0x00000200  /* WhereLoop.u.btree.pIndex is valid */\n#define WHERE_VIRTUALTABLE 0x00000400  /* WhereLoop.u.vtab is valid */\n#define WHERE_IN_ABLE      0x00000800  /* Able to support an IN operator */\n#define WHERE_ONEROW       0x00001000  /* Selects no more than one row */\n#define WHERE_MULTI_OR     0x00002000  /* OR using multiple indices */\n#define WHERE_AUTO_INDEX   0x00004000  /* Uses an ephemeral index */\n#define WHERE_SKIPSCAN     0x00008000  /* Uses the skip-scan algorithm */\n#define WHERE_UNQ_WANTED   0x00010000  /* WHERE_ONEROW would have been helpful*/\n#define WHERE_PARTIALIDX   0x00020000  /* The automatic index is partial */\n#define WHERE_IN_EARLYOUT  0x00040000  /* Perhaps quit IN loops early */\n#define WHERE_BIGNULL_SORT 0x00080000  /* Column nEq of index is BIGNULL */\n#define WHERE_IN_SEEKSCAN  0x00100000  /* Seek-scan optimization for IN */\n#define WHERE_TRANSCONS    0x00200000  /* Uses a transitive constraint */\n#define WHERE_BLOOMFILTER  0x00400000  /* Consider using a Bloom-filter */\n#define WHERE_SELFCULL     0x00800000  /* nOut reduced by extra WHERE terms */\n#define WHERE_OMIT_OFFSET  0x01000000  /* Set offset counter to zero */\n#define WHERE_COROUTINE    0x02000000  /* Implemented by co-routine.\n                                       ** NB: False-negatives are possible */\n#define WHERE_EXPRIDX      0x04000000  /* Uses an index-on-expressions */\n\n#endif /* !defined(SQLITE_WHEREINT_H) */\n"}
{"repo": "sqlite", "file": "vdbeapi.c", "lang": "C++", "code": "/*\n** 2004 May 26\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains code use to implement APIs that are part of the\n** VDBE.\n*/\n#include \"sqliteInt.h\"\n#include \"vdbeInt.h\"\n#include \"opcodes.h\"\n\n#ifndef SQLITE_OMIT_DEPRECATED\n/*\n** Return TRUE (non-zero) of the statement supplied as an argument needs\n** to be recompiled.  A statement needs to be recompiled whenever the\n** execution environment changes in a way that would alter the program\n** that sqlite3_prepare() generates.  For example, if new functions or\n** collating sequences are registered or if an authorizer function is\n** added or changed.\n*/\nint sqlite3_expired(sqlite3_stmt *pStmt){\n  Vdbe *p = (Vdbe*)pStmt;\n  return p==0 || p->expired;\n}\n#endif\n\n/*\n** Check on a Vdbe to make sure it has not been finalized.  Log\n** an error and return true if it has been finalized (or is otherwise\n** invalid).  Return false if it is ok.\n*/\nstatic int vdbeSafety(Vdbe *p){\n  if( p->db==0 ){\n    sqlite3_log(SQLITE_MISUSE, \"API called with finalized prepared statement\");\n    return 1;\n  }else{\n    return 0;\n  }\n}\nstatic int vdbeSafetyNotNull(Vdbe *p){\n  if( p==0 ){\n    sqlite3_log(SQLITE_MISUSE, \"API called with NULL prepared statement\");\n    return 1;\n  }else{\n    return vdbeSafety(p);\n  }\n}\n\n#ifndef SQLITE_OMIT_TRACE\n/*\n** Invoke the profile callback.  This routine is only called if we already\n** know that the profile callback is defined and needs to be invoked.\n*/\nstatic SQLITE_NOINLINE void invokeProfileCallback(sqlite3 *db, Vdbe *p){\n  sqlite3_int64 iNow;\n  sqlite3_int64 iElapse;\n  assert( p->startTime>0 );\n  assert( db->init.busy==0 );\n  assert( p->zSql!=0 );\n  sqlite3OsCurrentTimeInt64(db->pVfs, &iNow);\n  iElapse = (iNow - p->startTime)*1000000;\n#ifndef SQLITE_OMIT_DEPRECATED\n  if( db->xProfile ){\n    db->xProfile(db->pProfileArg, p->zSql, iElapse);\n  }\n#endif\n  if( db->mTrace & SQLITE_TRACE_PROFILE ){\n    db->trace.xV2(SQLITE_TRACE_PROFILE, db->pTraceArg, p, (void*)&iElapse);\n  }\n  p->startTime = 0;\n}\n/*\n** The checkProfileCallback(DB,P) macro checks to see if a profile callback\n** is needed, and it invokes the callback if it is needed.\n*/\n# define checkProfileCallback(DB,P) \\\n   if( ((P)->startTime)>0 ){ invokeProfileCallback(DB,P); }\n#else\n# define checkProfileCallback(DB,P)  /*no-op*/\n#endif\n\n/*\n** The following routine destroys a virtual machine that is created by\n** the sqlite3_compile() routine. The integer returned is an SQLITE_\n** success/failure code that describes the result of executing the virtual\n** machine.\n**\n** This routine sets the error code and string returned by\n** sqlite3_errcode(), sqlite3_errmsg() and sqlite3_errmsg16().\n*/\nint sqlite3_finalize(sqlite3_stmt *pStmt){\n  int rc;\n  if( pStmt==0 ){\n    /* IMPLEMENTATION-OF: R-57228-12904 Invoking sqlite3_finalize() on a NULL\n    ** pointer is a harmless no-op. */\n    rc = SQLITE_OK;\n  }else{\n    Vdbe *v = (Vdbe*)pStmt;\n    sqlite3 *db = v->db;\n    if( vdbeSafety(v) ) return SQLITE_MISUSE_BKPT;\n    sqlite3_mutex_enter(db->mutex);\n    checkProfileCallback(db, v);\n    assert( v->eVdbeState>=VDBE_READY_STATE );\n    rc = sqlite3VdbeReset(v);\n    sqlite3VdbeDelete(v);\n    rc = sqlite3ApiExit(db, rc);\n    sqlite3LeaveMutexAndCloseZombie(db);\n  }\n  return rc;\n}\n\n/*\n** Terminate the current execution of an SQL statement and reset it\n** back to its starting state so that it can be reused. A success code from\n** the prior execution is returned.\n**\n** This routine sets the error code and string returned by\n** sqlite3_errcode(), sqlite3_errmsg() and sqlite3_errmsg16().\n*/\nint sqlite3_reset(sqlite3_stmt *pStmt){\n  int rc;\n  if( pStmt==0 ){\n    rc = SQLITE_OK;\n  }else{\n    Vdbe *v = (Vdbe*)pStmt;\n    sqlite3 *db = v->db;\n    sqlite3_mutex_enter(db->mutex);\n    checkProfileCallback(db, v);\n    rc = sqlite3VdbeReset(v);\n    sqlite3VdbeRewind(v);\n    assert( (rc & (db->errMask))==rc );\n    rc = sqlite3ApiExit(db, rc);\n    sqlite3_mutex_leave(db->mutex);\n  }\n  return rc;\n}\n\n/*\n** Set all the parameters in the compiled SQL statement to NULL.\n*/\nint sqlite3_clear_bindings(sqlite3_stmt *pStmt){\n  int i;\n  int rc = SQLITE_OK;\n  Vdbe *p = (Vdbe*)pStmt;\n#if SQLITE_THREADSAFE\n  sqlite3_mutex *mutex;\n#endif\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( pStmt==0 ){\n    return SQLITE_MISUSE_BKPT;\n  }\n#endif\n#if SQLITE_THREADSAFE\n  mutex = p->db->mutex;\n#endif\n  sqlite3_mutex_enter(mutex);\n  for(i=0; i<p->nVar; i++){\n    sqlite3VdbeMemRelease(&p->aVar[i]);\n    p->aVar[i].flags = MEM_Null;\n  }\n  assert( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 || p->expmask==0 );\n  if( p->expmask ){\n    p->expired = 1;\n  }\n  sqlite3_mutex_leave(mutex);\n  return rc;\n}\n\n\n/**************************** sqlite3_value_  *******************************\n** The following routines extract information from a Mem or sqlite3_value\n** structure.\n*/\nconst void *sqlite3_value_blob(sqlite3_value *pVal){\n  Mem *p = (Mem*)pVal;\n  if( p->flags & (MEM_Blob|MEM_Str) ){\n    if( ExpandBlob(p)!=SQLITE_OK ){\n      assert( p->flags==MEM_Null && p->z==0 );\n      return 0;\n    }\n    p->flags |= MEM_Blob;\n    return p->n ? p->z : 0;\n  }else{\n    return sqlite3_value_text(pVal);\n  }\n}\nint sqlite3_value_bytes(sqlite3_value *pVal){\n  return sqlite3ValueBytes(pVal, SQLITE_UTF8);\n}\nint sqlite3_value_bytes16(sqlite3_value *pVal){\n  return sqlite3ValueBytes(pVal, SQLITE_UTF16NATIVE);\n}\ndouble sqlite3_value_double(sqlite3_value *pVal){\n  return sqlite3VdbeRealValue((Mem*)pVal);\n}\nint sqlite3_value_int(sqlite3_value *pVal){\n  return (int)sqlite3VdbeIntValue((Mem*)pVal);\n}\nsqlite_int64 sqlite3_value_int64(sqlite3_value *pVal){\n  return sqlite3VdbeIntValue((Mem*)pVal);\n}\nunsigned int sqlite3_value_subtype(sqlite3_value *pVal){\n  Mem *pMem = (Mem*)pVal;\n  return ((pMem->flags & MEM_Subtype) ? pMem->eSubtype : 0);\n}\nvoid *sqlite3_value_pointer(sqlite3_value *pVal, const char *zPType){\n  Mem *p = (Mem*)pVal;\n  if( (p->flags&(MEM_TypeMask|MEM_Term|MEM_Subtype)) ==\n                 (MEM_Null|MEM_Term|MEM_Subtype)\n   && zPType!=0\n   && p->eSubtype=='p'\n   && strcmp(p->u.zPType, zPType)==0\n  ){\n    return (void*)p->z;\n  }else{\n    return 0;\n  }\n}\nconst unsigned char *sqlite3_value_text(sqlite3_value *pVal){\n  return (const unsigned char *)sqlite3ValueText(pVal, SQLITE_UTF8);\n}\n#ifndef SQLITE_OMIT_UTF16\nconst void *sqlite3_value_text16(sqlite3_value* pVal){\n  return sqlite3ValueText(pVal, SQLITE_UTF16NATIVE);\n}\nconst void *sqlite3_value_text16be(sqlite3_value *pVal){\n  return sqlite3ValueText(pVal, SQLITE_UTF16BE);\n}\nconst void *sqlite3_value_text16le(sqlite3_value *pVal){\n  return sqlite3ValueText(pVal, SQLITE_UTF16LE);\n}\n#endif /* SQLITE_OMIT_UTF16 */\n/* EVIDENCE-OF: R-12793-43283 Every value in SQLite has one of five\n** fundamental datatypes: 64-bit signed integer 64-bit IEEE floating\n** point number string BLOB NULL\n*/\nint sqlite3_value_type(sqlite3_value* pVal){\n  static const u8 aType[] = {\n     SQLITE_BLOB,     /* 0x00 (not possible) */\n     SQLITE_NULL,     /* 0x01 NULL */\n     SQLITE_TEXT,     /* 0x02 TEXT */\n     SQLITE_NULL,     /* 0x03 (not possible) */\n     SQLITE_INTEGER,  /* 0x04 INTEGER */\n     SQLITE_NULL,     /* 0x05 (not possible) */\n     SQLITE_INTEGER,  /* 0x06 INTEGER + TEXT */\n     SQLITE_NULL,     /* 0x07 (not possible) */\n     SQLITE_FLOAT,    /* 0x08 FLOAT */\n     SQLITE_NULL,     /* 0x09 (not possible) */\n     SQLITE_FLOAT,    /* 0x0a FLOAT + TEXT */\n     SQLITE_NULL,     /* 0x0b (not possible) */\n     SQLITE_INTEGER,  /* 0x0c (not possible) */\n     SQLITE_NULL,     /* 0x0d (not possible) */\n     SQLITE_INTEGER,  /* 0x0e (not possible) */\n     SQLITE_NULL,     /* 0x0f (not possible) */\n     SQLITE_BLOB,     /* 0x10 BLOB */\n     SQLITE_NULL,     /* 0x11 (not possible) */\n     SQLITE_TEXT,     /* 0x12 (not possible) */\n     SQLITE_NULL,     /* 0x13 (not possible) */\n     SQLITE_INTEGER,  /* 0x14 INTEGER + BLOB */\n     SQLITE_NULL,     /* 0x15 (not possible) */\n     SQLITE_INTEGER,  /* 0x16 (not possible) */\n     SQLITE_NULL,     /* 0x17 (not possible) */\n     SQLITE_FLOAT,    /* 0x18 FLOAT + BLOB */\n     SQLITE_NULL,     /* 0x19 (not possible) */\n     SQLITE_FLOAT,    /* 0x1a (not possible) */\n     SQLITE_NULL,     /* 0x1b (not possible) */\n     SQLITE_INTEGER,  /* 0x1c (not possible) */\n     SQLITE_NULL,     /* 0x1d (not possible) */\n     SQLITE_INTEGER,  /* 0x1e (not possible) */\n     SQLITE_NULL,     /* 0x1f (not possible) */\n     SQLITE_FLOAT,    /* 0x20 INTREAL */\n     SQLITE_NULL,     /* 0x21 (not possible) */\n     SQLITE_FLOAT,    /* 0x22 INTREAL + TEXT */\n     SQLITE_NULL,     /* 0x23 (not possible) */\n     SQLITE_FLOAT,    /* 0x24 (not possible) */\n     SQLITE_NULL,     /* 0x25 (not possible) */\n     SQLITE_FLOAT,    /* 0x26 (not possible) */\n     SQLITE_NULL,     /* 0x27 (not possible) */\n     SQLITE_FLOAT,    /* 0x28 (not possible) */\n     SQLITE_NULL,     /* 0x29 (not possible) */\n     SQLITE_FLOAT,    /* 0x2a (not possible) */\n     SQLITE_NULL,     /* 0x2b (not possible) */\n     SQLITE_FLOAT,    /* 0x2c (not possible) */\n     SQLITE_NULL,     /* 0x2d (not possible) */\n     SQLITE_FLOAT,    /* 0x2e (not possible) */\n     SQLITE_NULL,     /* 0x2f (not possible) */\n     SQLITE_BLOB,     /* 0x30 (not possible) */\n     SQLITE_NULL,     /* 0x31 (not possible) */\n     SQLITE_TEXT,     /* 0x32 (not possible) */\n     SQLITE_NULL,     /* 0x33 (not possible) */\n     SQLITE_FLOAT,    /* 0x34 (not possible) */\n     SQLITE_NULL,     /* 0x35 (not possible) */\n     SQLITE_FLOAT,    /* 0x36 (not possible) */\n     SQLITE_NULL,     /* 0x37 (not possible) */\n     SQLITE_FLOAT,    /* 0x38 (not possible) */\n     SQLITE_NULL,     /* 0x39 (not possible) */\n     SQLITE_FLOAT,    /* 0x3a (not possible) */\n     SQLITE_NULL,     /* 0x3b (not possible) */\n     SQLITE_FLOAT,    /* 0x3c (not possible) */\n     SQLITE_NULL,     /* 0x3d (not possible) */\n     SQLITE_FLOAT,    /* 0x3e (not possible) */\n     SQLITE_NULL,     /* 0x3f (not possible) */\n  };\n#ifdef SQLITE_DEBUG\n  {\n    int eType = SQLITE_BLOB;\n    if( pVal->flags & MEM_Null ){\n      eType = SQLITE_NULL;\n    }else if( pVal->flags & (MEM_Real|MEM_IntReal) ){\n      eType = SQLITE_FLOAT;\n    }else if( pVal->flags & MEM_Int ){\n      eType = SQLITE_INTEGER;\n    }else if( pVal->flags & MEM_Str ){\n      eType = SQLITE_TEXT;\n    }\n    assert( eType == aType[pVal->flags&MEM_AffMask] );\n  }\n#endif\n  return aType[pVal->flags&MEM_AffMask];\n}\nint sqlite3_value_encoding(sqlite3_value *pVal){\n  return pVal->enc;\n}\n\n/* Return true if a parameter to xUpdate represents an unchanged column */\nint sqlite3_value_nochange(sqlite3_value *pVal){\n  return (pVal->flags&(MEM_Null|MEM_Zero))==(MEM_Null|MEM_Zero);\n}\n\n/* Return true if a parameter value originated from an sqlite3_bind() */\nint sqlite3_value_frombind(sqlite3_value *pVal){\n  return (pVal->flags&MEM_FromBind)!=0;\n}\n\n/* Make a copy of an sqlite3_value object\n*/\nsqlite3_value *sqlite3_value_dup(const sqlite3_value *pOrig){\n  sqlite3_value *pNew;\n  if( pOrig==0 ) return 0;\n  pNew = sqlite3_malloc( sizeof(*pNew) );\n  if( pNew==0 ) return 0;\n  memset(pNew, 0, sizeof(*pNew));\n  memcpy(pNew, pOrig, MEMCELLSIZE);\n  pNew->flags &= ~MEM_Dyn;\n  pNew->db = 0;\n  if( pNew->flags&(MEM_Str|MEM_Blob) ){\n    pNew->flags &= ~(MEM_Static|MEM_Dyn);\n    pNew->flags |= MEM_Ephem;\n    if( sqlite3VdbeMemMakeWriteable(pNew)!=SQLITE_OK ){\n      sqlite3ValueFree(pNew);\n      pNew = 0;\n    }\n  }else if( pNew->flags & MEM_Null ){\n    /* Do not duplicate pointer values */\n    pNew->flags &= ~(MEM_Term|MEM_Subtype);\n  }\n  return pNew;\n}\n\n/* Destroy an sqlite3_value object previously obtained from\n** sqlite3_value_dup().\n*/\nvoid sqlite3_value_free(sqlite3_value *pOld){\n  sqlite3ValueFree(pOld);\n}\n \n\n/**************************** sqlite3_result_  *******************************\n** The following routines are used by user-defined functions to specify\n** the function result.\n**\n** The setStrOrError() function calls sqlite3VdbeMemSetStr() to store the\n** result as a string or blob.  Appropriate errors are set if the string/blob\n** is too big or if an OOM occurs.\n**\n** The invokeValueDestructor(P,X) routine invokes destructor function X()\n** on value P if P is not going to be used and need to be destroyed.\n*/\nstatic void setResultStrOrError(\n  sqlite3_context *pCtx,  /* Function context */\n  const char *z,          /* String pointer */\n  int n,                  /* Bytes in string, or negative */\n  u8 enc,                 /* Encoding of z.  0 for BLOBs */\n  void (*xDel)(void*)     /* Destructor function */\n){\n  Mem *pOut = pCtx->pOut;\n  int rc;\n  if( enc==SQLITE_UTF8 ){\n    rc = sqlite3VdbeMemSetText(pOut, z, n, xDel);\n  }else if( enc==SQLITE_UTF8_ZT ){\n    /* It is usually considered improper to assert() on an input. However,\n    ** the following assert() is checking for inputs that are documented\n    ** to result in undefined behavior. */\n    assert( z==0\n         || n<0 \n         || n>pOut->db->aLimit[SQLITE_LIMIT_LENGTH]\n         || z[n]==0\n    );\n    rc = sqlite3VdbeMemSetText(pOut, z, n, xDel);\n    pOut->flags |= MEM_Term;\n  }else{\n    rc = sqlite3VdbeMemSetStr(pOut, z, n, enc, xDel);\n  }\n  if( rc ){\n    if( rc==SQLITE_TOOBIG ){\n      sqlite3_result_error_toobig(pCtx);\n    }else{\n      /* The only errors possible from sqlite3VdbeMemSetStr are\n      ** SQLITE_TOOBIG and SQLITE_NOMEM */\n      assert( rc==SQLITE_NOMEM );\n      sqlite3_result_error_nomem(pCtx);\n    }\n    return;\n  }\n  sqlite3VdbeChangeEncoding(pOut, pCtx->enc);\n  if( sqlite3VdbeMemTooBig(pOut) ){\n    sqlite3_result_error_toobig(pCtx);\n  }\n}\nstatic int invokeValueDestructor(\n  const void *p,             /* Value to destroy */\n  void (*xDel)(void*),       /* The destructor */\n  sqlite3_context *pCtx      /* Set a SQLITE_TOOBIG error if not NULL */\n){\n  assert( xDel!=SQLITE_DYNAMIC );\n  if( xDel==0 ){\n    /* noop */\n  }else if( xDel==SQLITE_TRANSIENT ){\n    /* noop */\n  }else{\n    xDel((void*)p);\n  }\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( pCtx!=0 ){\n    sqlite3_result_error_toobig(pCtx);\n  }\n#else\n  assert( pCtx!=0 );\n  sqlite3_result_error_toobig(pCtx);\n#endif\n  return SQLITE_TOOBIG;\n}\nvoid sqlite3_result_blob(\n  sqlite3_context *pCtx,\n  const void *z,\n  int n,\n  void (*xDel)(void *)\n){\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( pCtx==0 || n<0 ){\n    invokeValueDestructor(z, xDel, pCtx);\n    return;\n  }\n#endif\n  assert( n>=0 );\n  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n  setResultStrOrError(pCtx, z, n, 0, xDel);\n}\nvoid sqlite3_result_blob64(\n  sqlite3_context *pCtx,\n  const void *z,\n  sqlite3_uint64 n,\n  void (*xDel)(void *)\n){\n  assert( xDel!=SQLITE_DYNAMIC );\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( pCtx==0 ){\n    invokeValueDestructor(z, xDel, 0);\n    return;\n  }\n#endif\n  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n  if( n>0x7fffffff ){\n    (void)invokeValueDestructor(z, xDel, pCtx);\n  }else{\n    setResultStrOrError(pCtx, z, (int)n, 0, xDel);\n  }\n}\nvoid sqlite3_result_double(sqlite3_context *pCtx, double rVal){\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( pCtx==0 ) return;\n#endif\n  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n  sqlite3VdbeMemSetDouble(pCtx->pOut, rVal);\n}\nvoid sqlite3_result_error(sqlite3_context *pCtx, const char *z, int n){\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( pCtx==0 ) return;\n#endif\n  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n  pCtx->isError = SQLITE_ERROR;\n  sqlite3VdbeMemSetStr(pCtx->pOut, z, n, SQLITE_UTF8, SQLITE_TRANSIENT);\n}\n#ifndef SQLITE_OMIT_UTF16\nvoid sqlite3_result_error16(sqlite3_context *pCtx, const void *z, int n){\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( pCtx==0 ) return;\n#endif\n  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n  pCtx->isError = SQLITE_ERROR;\n  sqlite3VdbeMemSetStr(pCtx->pOut, z, n, SQLITE_UTF16NATIVE, SQLITE_TRANSIENT);\n}\n#endif\nvoid sqlite3_result_int(sqlite3_context *pCtx, int iVal){\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( pCtx==0 ) return;\n#endif\n  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n  sqlite3VdbeMemSetInt64(pCtx->pOut, (i64)iVal);\n}\nvoid sqlite3_result_int64(sqlite3_context *pCtx, i64 iVal){\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( pCtx==0 ) return;\n#endif\n  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n  sqlite3VdbeMemSetInt64(pCtx->pOut, iVal);\n}\nvoid sqlite3_result_null(sqlite3_context *pCtx){\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( pCtx==0 ) return;\n#endif\n  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n  sqlite3VdbeMemSetNull(pCtx->pOut);\n}\nvoid sqlite3_result_pointer(\n  sqlite3_context *pCtx,\n  void *pPtr,\n  const char *zPType,\n  void (*xDestructor)(void*)\n){\n  Mem *pOut;\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( pCtx==0 ){\n    invokeValueDestructor(pPtr, xDestructor, 0);\n    return;\n  }\n#endif\n  pOut = pCtx->pOut;\n  assert( sqlite3_mutex_held(pOut->db->mutex) );\n  sqlite3VdbeMemRelease(pOut);\n  pOut->flags = MEM_Null;\n  sqlite3VdbeMemSetPointer(pOut, pPtr, zPType, xDestructor);\n}\nvoid sqlite3_result_subtype(sqlite3_context *pCtx, unsigned int eSubtype){\n  Mem *pOut;\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( pCtx==0 ) return;\n#endif\n#if defined(SQLITE_STRICT_SUBTYPE) && SQLITE_STRICT_SUBTYPE+0!=0\n  if( pCtx->pFunc!=0\n   && (pCtx->pFunc->funcFlags & SQLITE_RESULT_SUBTYPE)==0\n  ){\n    char zErr[200];\n    sqlite3_snprintf(sizeof(zErr), zErr,\n                     \"misuse of sqlite3_result_subtype() by %s()\", \n                     pCtx->pFunc->zName);\n    sqlite3_result_error(pCtx, zErr, -1);\n    return;\n  }\n#endif /* SQLITE_STRICT_SUBTYPE */\n  pOut = pCtx->pOut;\n  assert( sqlite3_mutex_held(pOut->db->mutex) );\n  pOut->eSubtype = eSubtype & 0xff;\n  pOut->flags |= MEM_Subtype;\n}\nvoid sqlite3_result_text(\n  sqlite3_context *pCtx,\n  const char *z,\n  int n,\n  void (*xDel)(void *)\n){\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( pCtx==0 ){\n    invokeValueDestructor(z, xDel, 0);\n    return;\n  }\n#endif\n  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n  setResultStrOrError(pCtx, z, n, SQLITE_UTF8, xDel);\n}\nvoid sqlite3_result_text64(\n  sqlite3_context *pCtx,\n  const char *z,\n  sqlite3_uint64 n,\n  void (*xDel)(void *),\n  unsigned char enc\n){\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( pCtx==0 ){\n    invokeValueDestructor(z, xDel, 0);\n    return;\n  }\n#endif\n  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n  assert( xDel!=SQLITE_DYNAMIC );\n  if( enc!=SQLITE_UTF8 && enc!=SQLITE_UTF8_ZT ){\n    if( enc==SQLITE_UTF16 ) enc = SQLITE_UTF16NATIVE;\n    n &= ~(u64)1;\n  }\n  if( n>0x7fffffff ){\n    (void)invokeValueDestructor(z, xDel, pCtx);\n  }else{\n    setResultStrOrError(pCtx, z, (int)n, enc, xDel);\n    sqlite3VdbeMemZeroTerminateIfAble(pCtx->pOut);\n  }\n}\n#ifndef SQLITE_OMIT_UTF16\nvoid sqlite3_result_text16(\n  sqlite3_context *pCtx,\n  const void *z,\n  int n,\n  void (*xDel)(void *)\n){\n  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n  setResultStrOrError(pCtx, z, n & ~(u64)1, SQLITE_UTF16NATIVE, xDel);\n}\nvoid sqlite3_result_text16be(\n  sqlite3_context *pCtx,\n  const void *z,\n  int n,\n  void (*xDel)(void *)\n){\n  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n  setResultStrOrError(pCtx, z, n & ~(u64)1, SQLITE_UTF16BE, xDel);\n}\nvoid sqlite3_result_text16le(\n  sqlite3_context *pCtx,\n  const void *z,\n  int n,\n  void (*xDel)(void *)\n){\n  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n  setResultStrOrError(pCtx, z, n & ~(u64)1, SQLITE_UTF16LE, xDel);\n}\n#endif /* SQLITE_OMIT_UTF16 */\nvoid sqlite3_result_value(sqlite3_context *pCtx, sqlite3_value *pValue){\n  Mem *pOut;\n\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( pCtx==0 ) return;\n  if( pValue==0 ){\n    sqlite3_result_null(pCtx);\n    return;\n  }\n#endif\n  pOut = pCtx->pOut;\n  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n  sqlite3VdbeMemCopy(pOut, pValue);\n  sqlite3VdbeChangeEncoding(pOut, pCtx->enc);\n  if( sqlite3VdbeMemTooBig(pOut) ){\n    sqlite3_result_error_toobig(pCtx);\n  }\n}\nvoid sqlite3_result_zeroblob(sqlite3_context *pCtx, int n){\n  sqlite3_result_zeroblob64(pCtx, n>0 ? n : 0);\n}\nint sqlite3_result_zeroblob64(sqlite3_context *pCtx, u64 n){\n  Mem *pOut;\n\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( pCtx==0 ) return SQLITE_MISUSE_BKPT;\n#endif\n  pOut = pCtx->pOut;\n  assert( sqlite3_mutex_held(pOut->db->mutex) );\n  if( n>(u64)pOut->db->aLimit[SQLITE_LIMIT_LENGTH] ){\n    sqlite3_result_error_toobig(pCtx);\n    return SQLITE_TOOBIG;\n  }\n#ifndef SQLITE_OMIT_INCRBLOB\n  sqlite3VdbeMemSetZeroBlob(pCtx->pOut, (int)n);\n  return SQLITE_OK;\n#else\n  return sqlite3VdbeMemSetZeroBlob(pCtx->pOut, (int)n);\n#endif\n}\nvoid sqlite3_result_error_code(sqlite3_context *pCtx, int errCode){\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( pCtx==0 ) return;\n#endif\n  pCtx->isError = errCode ? errCode : -1;\n#ifdef SQLITE_DEBUG\n  if( pCtx->pVdbe ) pCtx->pVdbe->rcApp = errCode;\n#endif\n  if( pCtx->pOut->flags & MEM_Null ){\n    setResultStrOrError(pCtx, sqlite3ErrStr(errCode), -1, SQLITE_UTF8,\n                        SQLITE_STATIC);\n  }\n}\n\n/* Force an SQLITE_TOOBIG error. */\nvoid sqlite3_result_error_toobig(sqlite3_context *pCtx){\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( pCtx==0 ) return;\n#endif\n  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n  pCtx->isError = SQLITE_TOOBIG;\n  sqlite3VdbeMemSetStr(pCtx->pOut, \"string or blob too big\", -1,\n                       SQLITE_UTF8, SQLITE_STATIC);\n}\n\n/* An SQLITE_NOMEM error. */\nvoid sqlite3_result_error_nomem(sqlite3_context *pCtx){\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( pCtx==0 ) return;\n#endif\n  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n  sqlite3VdbeMemSetNull(pCtx->pOut);\n  pCtx->isError = SQLITE_NOMEM_BKPT;\n  sqlite3OomFault(pCtx->pOut->db);\n}\n\n#ifndef SQLITE_UNTESTABLE\n/* Force the INT64 value currently stored as the result to be\n** a MEM_IntReal value.  See the SQLITE_TESTCTRL_RESULT_INTREAL\n** test-control.\n*/\nvoid sqlite3ResultIntReal(sqlite3_context *pCtx){\n  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n  if( pCtx->pOut->flags & MEM_Int ){\n    pCtx->pOut->flags &= ~MEM_Int;\n    pCtx->pOut->flags |= MEM_IntReal;\n  }\n}\n#endif\n\n\n/*\n** This function is called after a transaction has been committed. It\n** invokes callbacks registered with sqlite3_wal_hook() as required.\n*/\nstatic int doWalCallbacks(sqlite3 *db){\n  int rc = SQLITE_OK;\n#ifndef SQLITE_OMIT_WAL\n  int i;\n  for(i=0; i<db->nDb; i++){\n    Btree *pBt = db->aDb[i].pBt;\n    if( pBt ){\n      int nEntry;\n      sqlite3BtreeEnter(pBt);\n      nEntry = sqlite3PagerWalCallback(sqlite3BtreePager(pBt));\n      sqlite3BtreeLeave(pBt);\n      if( nEntry>0 && db->xWalCallback && rc==SQLITE_OK ){\n        rc = db->xWalCallback(db->pWalArg, db, db->aDb[i].zDbSName, nEntry);\n      }\n    }\n  }\n#else\n  UNUSED_PARAMETER(db);\n#endif\n  return rc;\n}\n\n\n/*\n** Execute the statement pStmt, either until a row of data is ready, the\n** statement is completely executed or an error occurs.\n**\n** This routine implements the bulk of the logic behind the sqlite_step()\n** API.  The only thing omitted is the automatic recompile if a\n** schema change has occurred.  That detail is handled by the\n** outer sqlite3_step() wrapper procedure.\n*/\nstatic int sqlite3Step(Vdbe *p){\n  sqlite3 *db;\n  int rc;\n\n  assert(p);\n  db = p->db;\n  if( p->eVdbeState!=VDBE_RUN_STATE ){\n    restart_step:\n    if( p->eVdbeState==VDBE_READY_STATE ){\n      if( p->expired ){\n        p->rc = SQLITE_SCHEMA;\n        rc = SQLITE_ERROR;\n        if( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 ){\n          /* If this statement was prepared using saved SQL and an\n          ** error has occurred, then return the error code in p->rc to the\n          ** caller. Set the error code in the database handle to the same\n          ** value.\n          */\n          rc = sqlite3VdbeTransferError(p);\n        }\n        goto end_of_step;\n      }\n\n      /* If there are no other statements currently running, then\n      ** reset the interrupt flag.  This prevents a call to sqlite3_interrupt\n      ** from interrupting a statement that has not yet started.\n      */\n      if( db->nVdbeActive==0 ){\n        AtomicStore(&db->u1.isInterrupted, 0);\n      }\n\n      assert( db->nVdbeWrite>0 || db->autoCommit==0\n          || ((db->nDeferredCons + db->nDeferredImmCons)==0)\n      );\n\n#ifndef SQLITE_OMIT_TRACE\n      if( (db->mTrace & (SQLITE_TRACE_PROFILE|SQLITE_TRACE_XPROFILE))!=0\n          && !db->init.busy && p->zSql ){\n        sqlite3OsCurrentTimeInt64(db->pVfs, &p->startTime);\n      }else{\n        assert( p->startTime==0 );\n      }\n#endif\n\n      db->nVdbeActive++;\n      if( p->readOnly==0 ) db->nVdbeWrite++;\n      if( p->bIsReader ) db->nVdbeRead++;\n      p->pc = 0;\n      p->eVdbeState = VDBE_RUN_STATE;\n    }else\n\n    if( ALWAYS(p->eVdbeState==VDBE_HALT_STATE) ){\n      /* We used to require that sqlite3_reset() be called before retrying\n      ** sqlite3_step() after any error or after SQLITE_DONE.  But beginning\n      ** with version 3.7.0, we changed this so that sqlite3_reset() would\n      ** be called automatically instead of throwing the SQLITE_MISUSE error.\n      ** This \"automatic-reset\" change is not technically an incompatibility,\n      ** since any application that receives an SQLITE_MISUSE is broken by\n      ** definition.\n      **\n      ** Nevertheless, some published applications that were originally written\n      ** for version 3.6.23 or earlier do in fact depend on SQLITE_MISUSE\n      ** returns, and those were broken by the automatic-reset change.  As a\n      ** a work-around, the SQLITE_OMIT_AUTORESET compile-time restores the\n      ** legacy behavior of returning SQLITE_MISUSE for cases where the\n      ** previous sqlite3_step() returned something other than a SQLITE_LOCKED\n      ** or SQLITE_BUSY error.\n      */\n#ifdef SQLITE_OMIT_AUTORESET\n      if( (rc = p->rc&0xff)==SQLITE_BUSY || rc==SQLITE_LOCKED ){\n        sqlite3_reset((sqlite3_stmt*)p);\n      }else{\n        return SQLITE_MISUSE_BKPT;\n      }\n#else\n      sqlite3_reset((sqlite3_stmt*)p);\n#endif\n      assert( p->eVdbeState==VDBE_READY_STATE );\n      goto restart_step;\n    }\n  }\n\n#ifdef SQLITE_DEBUG\n  p->rcApp = SQLITE_OK;\n#endif\n#ifndef SQLITE_OMIT_EXPLAIN\n  if( p->explain ){\n    rc = sqlite3VdbeList(p);\n  }else\n#endif /* SQLITE_OMIT_EXPLAIN */\n  {\n    db->nVdbeExec++;\n    rc = sqlite3VdbeExec(p);\n    db->nVdbeExec--;\n  }\n\n  if( rc==SQLITE_ROW ){\n    assert( p->rc==SQLITE_OK );\n    assert( db->mallocFailed==0 );\n    db->errCode = SQLITE_ROW;\n    return SQLITE_ROW;\n  }else{\n#ifndef SQLITE_OMIT_TRACE\n    /* If the statement completed successfully, invoke the profile callback */\n    checkProfileCallback(db, p);\n#endif\n    p->pResultRow = 0;\n    if( rc==SQLITE_DONE && db->autoCommit ){\n      assert( p->rc==SQLITE_OK );\n      p->rc = doWalCallbacks(db);\n      if( p->rc!=SQLITE_OK ){\n        rc = SQLITE_ERROR;\n      }\n    }else if( rc!=SQLITE_DONE && (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 ){\n      /* If this statement was prepared using saved SQL and an\n      ** error has occurred, then return the error code in p->rc to the\n      ** caller. Set the error code in the database handle to the same value.\n      */\n      rc = sqlite3VdbeTransferError(p);\n    }\n  }\n\n  db->errCode = rc;\n  if( SQLITE_NOMEM==sqlite3ApiExit(p->db, p->rc) ){\n    p->rc = SQLITE_NOMEM_BKPT;\n    if( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 ) rc = p->rc;\n  }\nend_of_step:\n  /* There are only a limited number of result codes allowed from the\n  ** statements prepared using the legacy sqlite3_prepare() interface */\n  assert( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0\n       || rc==SQLITE_ROW  || rc==SQLITE_DONE   || rc==SQLITE_ERROR\n       || (rc&0xff)==SQLITE_BUSY || rc==SQLITE_MISUSE\n  );\n  return (rc&db->errMask);\n}\n\n/*\n** This is the top-level implementation of sqlite3_step().  Call\n** sqlite3Step() to do most of the work.  If a schema error occurs,\n** call sqlite3Reprepare() and try again.\n*/\nint sqlite3_step(sqlite3_stmt *pStmt){\n  int rc = SQLITE_OK;      /* Result from sqlite3Step() */\n  Vdbe *v = (Vdbe*)pStmt;  /* the prepared statement */\n  int cnt = 0;             /* Counter to prevent infinite loop of reprepares */\n  sqlite3 *db;             /* The database connection */\n\n  if( vdbeSafetyNotNull(v) ){\n    return SQLITE_MISUSE_BKPT;\n  }\n  db = v->db;\n  sqlite3_mutex_enter(db->mutex);\n  while( (rc = sqlite3Step(v))==SQLITE_SCHEMA\n         && cnt++ < SQLITE_MAX_SCHEMA_RETRY ){\n    int savedPc = v->pc;\n    rc = sqlite3Reprepare(v);\n    if( rc!=SQLITE_OK ){\n      /* This case occurs after failing to recompile an sql statement.\n      ** The error message from the SQL compiler has already been loaded\n      ** into the database handle. This block copies the error message\n      ** from the database handle into the statement and sets the statement\n      ** program counter to 0 to ensure that when the statement is\n      ** finalized or reset the parser error message is available via\n      ** sqlite3_errmsg() and sqlite3_errcode().\n      */\n      const char *zErr = (const char *)sqlite3_value_text(db->pErr);\n      sqlite3DbFree(db, v->zErrMsg);\n      if( !db->mallocFailed ){\n        v->zErrMsg = sqlite3DbStrDup(db, zErr);\n        v->rc = rc = sqlite3ApiExit(db, rc);\n      } else {\n        v->zErrMsg = 0;\n        v->rc = rc = SQLITE_NOMEM_BKPT;\n      }\n      break;\n    }\n    sqlite3_reset(pStmt);\n    if( savedPc>=0 ){\n      /* Setting minWriteFileFormat to 254 is a signal to the OP_Init and\n      ** OP_Trace opcodes to *not* perform SQLITE_TRACE_STMT because it has\n      ** already been done once on a prior invocation that failed due to\n      ** SQLITE_SCHEMA.   tag-20220401a  */\n      v->minWriteFileFormat = 254;\n    }\n    assert( v->expired==0 );\n  }\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n\n/*\n** Extract the user data from a sqlite3_context structure and return a\n** pointer to it.\n*/\nvoid *sqlite3_user_data(sqlite3_context *p){\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( p==0 ) return 0;\n#endif\n  assert( p && p->pFunc );\n  return p->pFunc->pUserData;\n}\n\n/*\n** Extract the user data from a sqlite3_context structure and return a\n** pointer to it.\n**\n** IMPLEMENTATION-OF: R-46798-50301 The sqlite3_context_db_handle() interface\n** returns a copy of the pointer to the database connection (the 1st\n** parameter) of the sqlite3_create_function() and\n** sqlite3_create_function16() routines that originally registered the\n** application defined function.\n*/\nsqlite3 *sqlite3_context_db_handle(sqlite3_context *p){\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( p==0 ) return 0;\n#else\n  assert( p && p->pOut );\n#endif\n  return p->pOut->db;\n}\n\n/*\n** If this routine is invoked from within an xColumn method of a virtual\n** table, then it returns true if and only if the the call is during an\n** UPDATE operation and the value of the column will not be modified\n** by the UPDATE.\n**\n** If this routine is called from any context other than within the\n** xColumn method of a virtual table, then the return value is meaningless\n** and arbitrary.\n**\n** Virtual table implements might use this routine to optimize their\n** performance by substituting a NULL result, or some other light-weight\n** value, as a signal to the xUpdate routine that the column is unchanged.\n*/\nint sqlite3_vtab_nochange(sqlite3_context *p){\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( p==0 ) return 0;\n#else\n  assert( p );\n#endif\n  return sqlite3_value_nochange(p->pOut);\n}\n\n/*\n** The destructor function for a ValueList object.  This needs to be\n** a separate function, unknowable to the application, to ensure that\n** calls to sqlite3_vtab_in_first()/sqlite3_vtab_in_next() that are not\n** preceded by activation of IN processing via sqlite3_vtab_int() do not\n** try to access a fake ValueList object inserted by a hostile extension.\n*/\nvoid sqlite3VdbeValueListFree(void *pToDelete){\n  sqlite3_free(pToDelete);\n}\n\n/*\n** Implementation of sqlite3_vtab_in_first() (if bNext==0) and\n** sqlite3_vtab_in_next() (if bNext!=0).\n*/\nstatic int valueFromValueList(\n  sqlite3_value *pVal,        /* Pointer to the ValueList object */\n  sqlite3_value **ppOut,      /* Store the next value from the list here */\n  int bNext                   /* 1 for _next(). 0 for _first() */\n){\n  int rc;\n  ValueList *pRhs;\n\n  *ppOut = 0;\n  if( pVal==0 ) return SQLITE_MISUSE_BKPT;\n  if( (pVal->flags & MEM_Dyn)==0 || pVal->xDel!=sqlite3VdbeValueListFree ){\n    return SQLITE_ERROR;\n  }else{\n    assert( (pVal->flags&(MEM_TypeMask|MEM_Term|MEM_Subtype)) ==\n                 (MEM_Null|MEM_Term|MEM_Subtype) );\n    assert( pVal->eSubtype=='p' );\n    assert( pVal->u.zPType!=0 && strcmp(pVal->u.zPType,\"ValueList\")==0 );\n    pRhs = (ValueList*)pVal->z;\n  }\n  if( bNext ){\n    rc = sqlite3BtreeNext(pRhs->pCsr, 0);\n  }else{\n    int dummy = 0;\n    rc = sqlite3BtreeFirst(pRhs->pCsr, &dummy);\n    assert( rc==SQLITE_OK || sqlite3BtreeEof(pRhs->pCsr) );\n    if( sqlite3BtreeEof(pRhs->pCsr) ) rc = SQLITE_DONE;\n  }\n  if( rc==SQLITE_OK ){\n    u32 sz;       /* Size of current row in bytes */\n    Mem sMem;     /* Raw content of current row */\n    memset(&sMem, 0, sizeof(sMem));\n    sz = sqlite3BtreePayloadSize(pRhs->pCsr);\n    rc = sqlite3VdbeMemFromBtreeZeroOffset(pRhs->pCsr,sz,&sMem);\n    if( rc==SQLITE_OK ){\n      u8 *zBuf = (u8*)sMem.z;\n      u32 iSerial;\n      sqlite3_value *pOut = pRhs->pOut;\n      int iOff = 1 + getVarint32(&zBuf[1], iSerial);\n      sqlite3VdbeSerialGet(&zBuf[iOff], iSerial, pOut);\n      pOut->enc = ENC(pOut->db);\n      if( (pOut->flags & MEM_Ephem)!=0 && sqlite3VdbeMemMakeWriteable(pOut) ){\n        rc = SQLITE_NOMEM;\n      }else{\n        *ppOut = pOut;\n      }\n    }\n    sqlite3VdbeMemRelease(&sMem);\n  }\n  return rc;\n}\n\n/*\n** Set the iterator value pVal to point to the first value in the set.\n** Set (*ppOut) to point to this value before returning.\n*/\nint sqlite3_vtab_in_first(sqlite3_value *pVal, sqlite3_value **ppOut){\n  return valueFromValueList(pVal, ppOut, 0);\n}\n\n/*\n** Set the iterator value pVal to point to the next value in the set.\n** Set (*ppOut) to point to this value before returning.\n*/\nint sqlite3_vtab_in_next(sqlite3_value *pVal, sqlite3_value **ppOut){\n  return valueFromValueList(pVal, ppOut, 1);\n}\n\n/*\n** Return the current time for a statement.  If the current time\n** is requested more than once within the same run of a single prepared\n** statement, the exact same time is returned for each invocation regardless\n** of the amount of time that elapses between invocations.  In other words,\n** the time returned is always the time of the first call.\n*/\nsqlite3_int64 sqlite3StmtCurrentTime(sqlite3_context *p){\n  int rc;\n#ifndef SQLITE_ENABLE_STAT4\n  sqlite3_int64 *piTime = &p->pVdbe->iCurrentTime;\n  assert( p->pVdbe!=0 );\n#else\n  sqlite3_int64 iTime = 0;\n  sqlite3_int64 *piTime = p->pVdbe!=0 ? &p->pVdbe->iCurrentTime : &iTime;\n#endif\n  if( *piTime==0 ){\n    rc = sqlite3OsCurrentTimeInt64(p->pOut->db->pVfs, piTime);\n    if( rc ) *piTime = 0;\n  }\n  return *piTime;\n}\n\n/*\n** Create a new aggregate context for p and return a pointer to\n** its pMem->z element.\n*/\nstatic SQLITE_NOINLINE void *createAggContext(sqlite3_context *p, int nByte){\n  Mem *pMem = p->pMem;\n  assert( (pMem->flags & MEM_Agg)==0 );\n  if( nByte<=0 ){\n    sqlite3VdbeMemSetNull(pMem);\n    pMem->z = 0;\n  }else{\n    sqlite3VdbeMemClearAndResize(pMem, nByte);\n    pMem->flags = MEM_Agg;\n    pMem->u.pDef = p->pFunc;\n    if( pMem->z ){\n      memset(pMem->z, 0, nByte);\n    }\n  }\n  return (void*)pMem->z;\n}\n\n/*\n** Allocate or return the aggregate context for a user function.  A new\n** context is allocated on the first call.  Subsequent calls return the\n** same context that was returned on prior calls.\n*/\nvoid *sqlite3_aggregate_context(sqlite3_context *p, int nByte){\n  assert( p && p->pFunc && p->pFunc->xFinalize );\n  assert( sqlite3_mutex_held(p->pOut->db->mutex) );\n  testcase( nByte<0 );\n  if( (p->pMem->flags & MEM_Agg)==0 ){\n    return createAggContext(p, nByte);\n  }else{\n    return (void*)p->pMem->z;\n  }\n}\n\n/*\n** Return the auxiliary data pointer, if any, for the iArg'th argument to\n** the user-function defined by pCtx.\n**\n** The left-most argument is 0.\n**\n** Undocumented behavior:  If iArg is negative then access a cache of\n** auxiliary data pointers that is available to all functions within a\n** single prepared statement.  The iArg values must match.\n*/\nvoid *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg){\n  AuxData *pAuxData;\n\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( pCtx==0 ) return 0;\n#endif\n  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n#if SQLITE_ENABLE_STAT4\n  if( pCtx->pVdbe==0 ) return 0;\n#else\n  assert( pCtx->pVdbe!=0 );\n#endif\n  for(pAuxData=pCtx->pVdbe->pAuxData; pAuxData; pAuxData=pAuxData->pNextAux){\n    if(  pAuxData->iAuxArg==iArg && (pAuxData->iAuxOp==pCtx->iOp || iArg<0) ){\n      return pAuxData->pAux;\n    }\n  }\n  return 0;\n}\n\n/*\n** Set the auxiliary data pointer and delete function, for the iArg'th\n** argument to the user-function defined by pCtx. Any previous value is\n** deleted by calling the delete function specified when it was set.\n**\n** The left-most argument is 0.\n**\n** Undocumented behavior:  If iArg is negative then make the data available\n** to all functions within the current prepared statement using iArg as an\n** access code.\n*/\nvoid sqlite3_set_auxdata(\n  sqlite3_context *pCtx,\n  int iArg,\n  void *pAux,\n  void (*xDelete)(void*)\n){\n  AuxData *pAuxData;\n  Vdbe *pVdbe;\n\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( pCtx==0 ) return;\n#endif\n  pVdbe= pCtx->pVdbe;\n  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n#ifdef SQLITE_ENABLE_STAT4\n  if( pVdbe==0 ) goto failed;\n#else\n  assert( pVdbe!=0 );\n#endif\n\n  for(pAuxData=pVdbe->pAuxData; pAuxData; pAuxData=pAuxData->pNextAux){\n    if( pAuxData->iAuxArg==iArg && (pAuxData->iAuxOp==pCtx->iOp || iArg<0) ){\n      break;\n    }\n  }\n  if( pAuxData==0 ){\n    pAuxData = sqlite3DbMallocZero(pVdbe->db, sizeof(AuxData));\n    if( !pAuxData ) goto failed;\n    pAuxData->iAuxOp = pCtx->iOp;\n    pAuxData->iAuxArg = iArg;\n    pAuxData->pNextAux = pVdbe->pAuxData;\n    pVdbe->pAuxData = pAuxData;\n    if( pCtx->isError==0 ) pCtx->isError = -1;\n  }else if( pAuxData->xDeleteAux ){\n    pAuxData->xDeleteAux(pAuxData->pAux);\n  }\n\n  pAuxData->pAux = pAux;\n  pAuxData->xDeleteAux = xDelete;\n  return;\n\nfailed:\n  if( xDelete ){\n    xDelete(pAux);\n  }\n}\n\n#ifndef SQLITE_OMIT_DEPRECATED\n/*\n** Return the number of times the Step function of an aggregate has been\n** called.\n**\n** This function is deprecated.  Do not use it for new code.  It is\n** provide only to avoid breaking legacy code.  New aggregate function\n** implementations should keep their own counts within their aggregate\n** context.\n*/\nint sqlite3_aggregate_count(sqlite3_context *p){\n  assert( p && p->pMem && p->pFunc && p->pFunc->xFinalize );\n  return p->pMem->n;\n}\n#endif\n\n/*\n** Return the number of columns in the result set for the statement pStmt.\n*/\nint sqlite3_column_count(sqlite3_stmt *pStmt){\n  Vdbe *pVm = (Vdbe *)pStmt;\n  if( pVm==0 ) return 0;\n  return pVm->nResColumn;\n}\n\n/*\n** Return the number of values available from the current row of the\n** currently executing statement pStmt.\n*/\nint sqlite3_data_count(sqlite3_stmt *pStmt){\n  Vdbe *pVm = (Vdbe *)pStmt;\n  if( pVm==0 || pVm->pResultRow==0 ) return 0;\n  return pVm->nResColumn;\n}\n\n/*\n** Return a pointer to static memory containing an SQL NULL value.\n*/\nstatic const Mem *columnNullValue(void){\n  /* Even though the Mem structure contains an element\n  ** of type i64, on certain architectures (x86) with certain compiler\n  ** switches (-Os), gcc may align this Mem object on a 4-byte boundary\n  ** instead of an 8-byte one. This all works fine, except that when\n  ** running with SQLITE_DEBUG defined the SQLite code sometimes assert()s\n  ** that a Mem structure is located on an 8-byte boundary. To prevent\n  ** these assert()s from failing, when building with SQLITE_DEBUG defined\n  ** using gcc, we force nullMem to be 8-byte aligned using the magical\n  ** __attribute__((aligned(8))) macro.  */\n  static const Mem nullMem\n#if defined(SQLITE_DEBUG) && defined(__GNUC__)\n    __attribute__((aligned(8)))\n#endif\n    = {\n        /* .u          = */ {0},\n        /* .z          = */ (char*)0,\n        /* .n          = */ (int)0,\n        /* .flags      = */ (u16)MEM_Null,\n        /* .enc        = */ (u8)0,\n        /* .eSubtype   = */ (u8)0,\n        /* .db         = */ (sqlite3*)0,\n        /* .szMalloc   = */ (int)0,\n        /* .uTemp      = */ (u32)0,\n        /* .zMalloc    = */ (char*)0,\n        /* .xDel       = */ (void(*)(void*))0,\n#ifdef SQLITE_DEBUG\n        /* .pScopyFrom = */ (Mem*)0,\n        /* .mScopyFlags= */ 0,\n        /* .bScopy     = */ 0,\n#endif\n      };\n  return &nullMem;\n}\n\n/*\n** Check to see if column iCol of the given statement is valid.  If\n** it is, return a pointer to the Mem for the value of that column.\n** If iCol is not valid, return a pointer to a Mem which has a value\n** of NULL.\n*/\nstatic Mem *columnMem(sqlite3_stmt *pStmt, int i){\n  Vdbe *pVm;\n  Mem *pOut;\n\n  pVm = (Vdbe *)pStmt;\n  if( pVm==0 ) return (Mem*)columnNullValue();\n  assert( pVm->db );\n  sqlite3_mutex_enter(pVm->db->mutex);\n  if( pVm->pResultRow!=0 && i<pVm->nResColumn && i>=0 ){\n    pOut = &pVm->pResultRow[i];\n  }else{\n    sqlite3Error(pVm->db, SQLITE_RANGE);\n    pOut = (Mem*)columnNullValue();\n  }\n  return pOut;\n}\n\n/*\n** This function is called after invoking an sqlite3_value_XXX function on a\n** column value (i.e. a value returned by evaluating an SQL expression in the\n** select list of a SELECT statement) that may cause a malloc() failure. If\n** malloc() has failed, the threads mallocFailed flag is cleared and the result\n** code of statement pStmt set to SQLITE_NOMEM.\n**\n** Specifically, this is called from within:\n**\n**     sqlite3_column_int()\n**     sqlite3_column_int64()\n**     sqlite3_column_text()\n**     sqlite3_column_text16()\n**     sqlite3_column_double()\n**     sqlite3_column_bytes()\n**     sqlite3_column_bytes16()\n**     sqlite3_column_blob()\n*/\nstatic void columnMallocFailure(sqlite3_stmt *pStmt)\n{\n  /* If malloc() failed during an encoding conversion within an\n  ** sqlite3_column_XXX API, then set the return code of the statement to\n  ** SQLITE_NOMEM. The next call to _step() (if any) will return SQLITE_ERROR\n  ** and _finalize() will return NOMEM.\n  */\n  Vdbe *p = (Vdbe *)pStmt;\n  if( p ){\n    assert( p->db!=0 );\n    assert( sqlite3_mutex_held(p->db->mutex) );\n    p->rc = sqlite3ApiExit(p->db, p->rc);\n    sqlite3_mutex_leave(p->db->mutex);\n  }\n}\n\n/**************************** sqlite3_column_  *******************************\n** The following routines are used to access elements of the current row\n** in the result set.\n*/\nconst void *sqlite3_column_blob(sqlite3_stmt *pStmt, int i){\n  const void *val;\n  val = sqlite3_value_blob( columnMem(pStmt,i) );\n  /* Even though there is no encoding conversion, value_blob() might\n  ** need to call malloc() to expand the result of a zeroblob()\n  ** expression.\n  */\n  columnMallocFailure(pStmt);\n  return val;\n}\nint sqlite3_column_bytes(sqlite3_stmt *pStmt, int i){\n  int val = sqlite3_value_bytes( columnMem(pStmt,i) );\n  columnMallocFailure(pStmt);\n  return val;\n}\nint sqlite3_column_bytes16(sqlite3_stmt *pStmt, int i){\n  int val = sqlite3_value_bytes16( columnMem(pStmt,i) );\n  columnMallocFailure(pStmt);\n  return val;\n}\ndouble sqlite3_column_double(sqlite3_stmt *pStmt, int i){\n  double val = sqlite3_value_double( columnMem(pStmt,i) );\n  columnMallocFailure(pStmt);\n  return val;\n}\nint sqlite3_column_int(sqlite3_stmt *pStmt, int i){\n  int val = sqlite3_value_int( columnMem(pStmt,i) );\n  columnMallocFailure(pStmt);\n  return val;\n}\nsqlite_int64 sqlite3_column_int64(sqlite3_stmt *pStmt, int i){\n  sqlite_int64 val = sqlite3_value_int64( columnMem(pStmt,i) );\n  columnMallocFailure(pStmt);\n  return val;\n}\nconst unsigned char *sqlite3_column_text(sqlite3_stmt *pStmt, int i){\n  const unsigned char *val = sqlite3_value_text( columnMem(pStmt,i) );\n  columnMallocFailure(pStmt);\n  return val;\n}\nsqlite3_value *sqlite3_column_value(sqlite3_stmt *pStmt, int i){\n  Mem *pOut = columnMem(pStmt, i);\n  if( pOut->flags&MEM_Static ){\n    pOut->flags &= ~MEM_Static;\n    pOut->flags |= MEM_Ephem;\n  }\n  columnMallocFailure(pStmt);\n  return (sqlite3_value *)pOut;\n}\n#ifndef SQLITE_OMIT_UTF16\nconst void *sqlite3_column_text16(sqlite3_stmt *pStmt, int i){\n  const void *val = sqlite3_value_text16( columnMem(pStmt,i) );\n  columnMallocFailure(pStmt);\n  return val;\n}\n#endif /* SQLITE_OMIT_UTF16 */\nint sqlite3_column_type(sqlite3_stmt *pStmt, int i){\n  int iType = sqlite3_value_type( columnMem(pStmt,i) );\n  columnMallocFailure(pStmt);\n  return iType;\n}\n\n/*\n** Column names appropriate for EXPLAIN or EXPLAIN QUERY PLAN.\n*/\nstatic const char * const azExplainColNames8[] = {\n   \"addr\", \"opcode\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"comment\",  /* EXPLAIN */\n   \"id\", \"parent\", \"notused\", \"detail\"                         /* EQP */\n};\nstatic const u16 azExplainColNames16data[] = {\n  /*   0 */  'a', 'd', 'd', 'r',                0,\n  /*   5 */  'o', 'p', 'c', 'o', 'd', 'e',      0,\n  /*  12 */  'p', '1',                          0, \n  /*  15 */  'p', '2',                          0,\n  /*  18 */  'p', '3',                          0,\n  /*  21 */  'p', '4',                          0,\n  /*  24 */  'p', '5',                          0,\n  /*  27 */  'c', 'o', 'm', 'm', 'e', 'n', 't', 0,\n  /*  35 */  'i', 'd',                          0,\n  /*  38 */  'p', 'a', 'r', 'e', 'n', 't',      0,\n  /*  45 */  'n', 'o', 't', 'u', 's', 'e', 'd', 0,\n  /*  53 */  'd', 'e', 't', 'a', 'i', 'l',      0\n};\nstatic const u8 iExplainColNames16[] = {\n  0, 5, 12, 15, 18, 21, 24, 27,\n  35, 38, 45, 53\n};\n\n/*\n** Convert the N-th element of pStmt->pColName[] into a string using\n** xFunc() then return that string.  If N is out of range, return 0.\n**\n** There are up to 5 names for each column.  useType determines which\n** name is returned.  Here are the names:\n**\n**    0      The column name as it should be displayed for output\n**    1      The datatype name for the column\n**    2      The name of the database that the column derives from\n**    3      The name of the table that the column derives from\n**    4      The name of the table column that the result column derives from\n**\n** If the result is not a simple column reference (if it is an expression\n** or a constant) then useTypes 2, 3, and 4 return NULL.\n*/\nstatic const void *columnName(\n  sqlite3_stmt *pStmt,     /* The statement */\n  int N,                   /* Which column to get the name for */\n  int useUtf16,            /* True to return the name as UTF16 */\n  int useType              /* What type of name */\n){\n  const void *ret;\n  Vdbe *p;\n  int n;\n  sqlite3 *db;\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( pStmt==0 ){\n    (void)SQLITE_MISUSE_BKPT;\n    return 0;\n  }\n#endif\n  if( N<0 ) return 0;\n  ret = 0;\n  p = (Vdbe *)pStmt;\n  db = p->db;\n  assert( db!=0 );\n  sqlite3_mutex_enter(db->mutex);\n\n  if( p->explain ){\n    if( useType>0 ) goto columnName_end;\n    n = p->explain==1 ? 8 : 4;\n    if( N>=n ) goto columnName_end;\n    if( useUtf16 ){\n      int i = iExplainColNames16[N + 8*p->explain - 8];\n      ret = (void*)&azExplainColNames16data[i];\n    }else{\n      ret = (void*)azExplainColNames8[N + 8*p->explain - 8];\n    }\n    goto columnName_end;\n  }\n  n = p->nResColumn;\n  if( N<n ){\n    u8 prior_mallocFailed = db->mallocFailed;\n    N += useType*n;\n#ifndef SQLITE_OMIT_UTF16\n    if( useUtf16 ){\n      ret = sqlite3_value_text16((sqlite3_value*)&p->aColName[N]);\n    }else\n#endif\n    {\n      ret = sqlite3_value_text((sqlite3_value*)&p->aColName[N]);\n    }\n    /* A malloc may have failed inside of the _text() call. If this\n    ** is the case, clear the mallocFailed flag and return NULL.\n    */\n    assert( db->mallocFailed==0 || db->mallocFailed==1 );\n    if( db->mallocFailed > prior_mallocFailed ){\n      sqlite3OomClear(db);\n      ret = 0;\n    }\n  }\ncolumnName_end:\n  sqlite3_mutex_leave(db->mutex);\n  return ret;\n}\n\n/*\n** Return the name of the Nth column of the result set returned by SQL\n** statement pStmt.\n*/\nconst char *sqlite3_column_name(sqlite3_stmt *pStmt, int N){\n  return columnName(pStmt, N, 0, COLNAME_NAME);\n}\n#ifndef SQLITE_OMIT_UTF16\nconst void *sqlite3_column_name16(sqlite3_stmt *pStmt, int N){\n  return columnName(pStmt, N, 1, COLNAME_NAME);\n}\n#endif\n\n/*\n** Constraint:  If you have ENABLE_COLUMN_METADATA then you must\n** not define OMIT_DECLTYPE.\n*/\n#if defined(SQLITE_OMIT_DECLTYPE) && defined(SQLITE_ENABLE_COLUMN_METADATA)\n# error \"Must not define both SQLITE_OMIT_DECLTYPE \\\n         and SQLITE_ENABLE_COLUMN_METADATA\"\n#endif\n\n#ifndef SQLITE_OMIT_DECLTYPE\n/*\n** Return the column declaration type (if applicable) of the 'i'th column\n** of the result set of SQL statement pStmt.\n*/\nconst char *sqlite3_column_decltype(sqlite3_stmt *pStmt, int N){\n  return columnName(pStmt, N, 0, COLNAME_DECLTYPE);\n}\n#ifndef SQLITE_OMIT_UTF16\nconst void *sqlite3_column_decltype16(sqlite3_stmt *pStmt, int N){\n  return columnName(pStmt, N, 1, COLNAME_DECLTYPE);\n}\n#endif /* SQLITE_OMIT_UTF16 */\n#endif /* SQLITE_OMIT_DECLTYPE */\n\n#ifdef SQLITE_ENABLE_COLUMN_METADATA\n/*\n** Return the name of the database from which a result column derives.\n** NULL is returned if the result column is an expression or constant or\n** anything else which is not an unambiguous reference to a database column.\n*/\nconst char *sqlite3_column_database_name(sqlite3_stmt *pStmt, int N){\n  return columnName(pStmt, N, 0, COLNAME_DATABASE);\n}\n#ifndef SQLITE_OMIT_UTF16\nconst void *sqlite3_column_database_name16(sqlite3_stmt *pStmt, int N){\n  return columnName(pStmt, N, 1, COLNAME_DATABASE);\n}\n#endif /* SQLITE_OMIT_UTF16 */\n\n/*\n** Return the name of the table from which a result column derives.\n** NULL is returned if the result column is an expression or constant or\n** anything else which is not an unambiguous reference to a database column.\n*/\nconst char *sqlite3_column_table_name(sqlite3_stmt *pStmt, int N){\n  return columnName(pStmt, N, 0, COLNAME_TABLE);\n}\n#ifndef SQLITE_OMIT_UTF16\nconst void *sqlite3_column_table_name16(sqlite3_stmt *pStmt, int N){\n  return columnName(pStmt, N, 1, COLNAME_TABLE);\n}\n#endif /* SQLITE_OMIT_UTF16 */\n\n/*\n** Return the name of the table column from which a result column derives.\n** NULL is returned if the result column is an expression or constant or\n** anything else which is not an unambiguous reference to a database column.\n*/\nconst char *sqlite3_column_origin_name(sqlite3_stmt *pStmt, int N){\n  return columnName(pStmt, N, 0, COLNAME_COLUMN);\n}\n#ifndef SQLITE_OMIT_UTF16\nconst void *sqlite3_column_origin_name16(sqlite3_stmt *pStmt, int N){\n  return columnName(pStmt, N, 1, COLNAME_COLUMN);\n}\n#endif /* SQLITE_OMIT_UTF16 */\n#endif /* SQLITE_ENABLE_COLUMN_METADATA */\n\n\n/******************************* sqlite3_bind_  ***************************\n**\n** Routines used to attach values to wildcards in a compiled SQL statement.\n*/\n/*\n** Unbind the value bound to variable i in virtual machine p. This is the\n** the same as binding a NULL value to the column. If the \"i\" parameter is\n** out of range, then SQLITE_RANGE is returned. Otherwise SQLITE_OK.\n**\n** A successful evaluation of this routine acquires the mutex on p.\n** the mutex is released if any kind of error occurs.\n**\n** The error code stored in database p->db is overwritten with the return\n** value in any case.\n**\n** (tag-20240917-01) If  vdbeUnbind(p,(u32)(i-1))  returns SQLITE_OK,\n** that means all of the the following will be true:\n**\n**     p!=0\n**     p->pVar!=0\n**     i>0\n**     i<=p->nVar\n**\n** An assert() is normally added after vdbeUnbind() to help static analyzers\n** realize this.\n*/\nstatic int vdbeUnbind(Vdbe *p, unsigned int i){\n  Mem *pVar;\n  if( vdbeSafetyNotNull(p) ){\n    return SQLITE_MISUSE_BKPT;\n  }\n  sqlite3_mutex_enter(p->db->mutex);\n  if( p->eVdbeState!=VDBE_READY_STATE ){\n    sqlite3Error(p->db, SQLITE_MISUSE_BKPT);\n    sqlite3_mutex_leave(p->db->mutex);\n    sqlite3_log(SQLITE_MISUSE,\n        \"bind on a busy prepared statement: [%s]\", p->zSql);\n    return SQLITE_MISUSE_BKPT;\n  }\n  if( i>=(unsigned int)p->nVar ){\n    sqlite3Error(p->db, SQLITE_RANGE);\n    sqlite3_mutex_leave(p->db->mutex);\n    return SQLITE_RANGE;\n  }\n  pVar = &p->aVar[i];\n  sqlite3VdbeMemRelease(pVar);\n  pVar->flags = MEM_Null;\n  p->db->errCode = SQLITE_OK;\n\n  /* If the bit corresponding to this variable in Vdbe.expmask is set, then\n  ** binding a new value to this variable invalidates the current query plan.\n  **\n  ** IMPLEMENTATION-OF: R-57496-20354 If the specific value bound to a host\n  ** parameter in the WHERE clause might influence the choice of query plan\n  ** for a statement, then the statement will be automatically recompiled,\n  ** as if there had been a schema change, on the first sqlite3_step() call\n  ** following any change to the bindings of that parameter.\n  */\n  assert( (p->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 || p->expmask==0 );\n  if( p->expmask!=0 && (p->expmask & (i>=31 ? 0x80000000 : (u32)1<<i))!=0 ){\n    p->expired = 1;\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Bind a text or BLOB value.\n*/\nstatic int bindText(\n  sqlite3_stmt *pStmt,   /* The statement to bind against */\n  int i,                 /* Index of the parameter to bind */\n  const void *zData,     /* Pointer to the data to be bound */\n  i64 nData,             /* Number of bytes of data to be bound */\n  void (*xDel)(void*),   /* Destructor for the data */\n  u8 encoding            /* Encoding for the data */\n){\n  Vdbe *p = (Vdbe *)pStmt;\n  Mem *pVar;\n  int rc;\n\n  rc = vdbeUnbind(p, (u32)(i-1));\n  if( rc==SQLITE_OK ){\n    assert( p!=0 && p->aVar!=0 && i>0 && i<=p->nVar ); /* tag-20240917-01 */\n    if( zData!=0 ){\n      pVar = &p->aVar[i-1];\n      if( encoding==SQLITE_UTF8 ){\n        rc = sqlite3VdbeMemSetText(pVar, zData, nData, xDel);\n      }else if( encoding==SQLITE_UTF8_ZT ){\n        /* It is usually consider improper to assert() on an input.\n        ** However, the following assert() is checking for inputs\n        ** that are documented to result in undefined behavior. */\n        assert( zData==0\n             || nData<0 \n             || nData>pVar->db->aLimit[SQLITE_LIMIT_LENGTH]\n             || ((u8*)zData)[nData]==0\n        );\n        rc = sqlite3VdbeMemSetText(pVar, zData, nData, xDel);\n        pVar->flags |= MEM_Term;\n      }else{\n        rc = sqlite3VdbeMemSetStr(pVar, zData, nData, encoding, xDel);\n        if( encoding==0 ) pVar->enc = ENC(p->db);\n      }\n      if( rc==SQLITE_OK && encoding!=0 ){\n        rc = sqlite3VdbeChangeEncoding(pVar, ENC(p->db));\n      }\n      if( rc ){\n        sqlite3Error(p->db, rc);\n        rc = sqlite3ApiExit(p->db, rc);\n      }\n    }\n    sqlite3_mutex_leave(p->db->mutex);\n  }else if( xDel!=SQLITE_STATIC && xDel!=SQLITE_TRANSIENT ){\n    xDel((void*)zData);\n  }\n  return rc;\n}\n\n\n/*\n** Bind a blob value to an SQL statement variable.\n*/\nint sqlite3_bind_blob(\n  sqlite3_stmt *pStmt,\n  int i,\n  const void *zData,\n  int nData,\n  void (*xDel)(void*)\n){\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( nData<0 ) return SQLITE_MISUSE_BKPT;\n#endif\n  return bindText(pStmt, i, zData, nData, xDel, 0);\n}\nint sqlite3_bind_blob64(\n  sqlite3_stmt *pStmt,\n  int i,\n  const void *zData,\n  sqlite3_uint64 nData,\n  void (*xDel)(void*)\n){\n  assert( xDel!=SQLITE_DYNAMIC );\n  return bindText(pStmt, i, zData, nData, xDel, 0);\n}\nint sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue){\n  int rc;\n  Vdbe *p = (Vdbe *)pStmt;\n  rc = vdbeUnbind(p, (u32)(i-1));\n  if( rc==SQLITE_OK ){\n    assert( p!=0 && p->aVar!=0 && i>0 && i<=p->nVar ); /* tag-20240917-01 */\n    sqlite3VdbeMemSetDouble(&p->aVar[i-1], rValue);\n    sqlite3_mutex_leave(p->db->mutex);\n  }\n  return rc;\n}\nint sqlite3_bind_int(sqlite3_stmt *p, int i, int iValue){\n  return sqlite3_bind_int64(p, i, (i64)iValue);\n}\nint sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue){\n  int rc;\n  Vdbe *p = (Vdbe *)pStmt;\n  rc = vdbeUnbind(p, (u32)(i-1));\n  if( rc==SQLITE_OK ){\n    assert( p!=0 && p->aVar!=0 && i>0 && i<=p->nVar ); /* tag-20240917-01 */\n    sqlite3VdbeMemSetInt64(&p->aVar[i-1], iValue);\n    sqlite3_mutex_leave(p->db->mutex);\n  }\n  return rc;\n}\nint sqlite3_bind_null(sqlite3_stmt *pStmt, int i){\n  int rc;\n  Vdbe *p = (Vdbe*)pStmt;\n  rc = vdbeUnbind(p, (u32)(i-1));\n  if( rc==SQLITE_OK ){\n    assert( p!=0 && p->aVar!=0 && i>0 && i<=p->nVar ); /* tag-20240917-01 */\n    sqlite3_mutex_leave(p->db->mutex);\n  }\n  return rc;\n}\nint sqlite3_bind_pointer(\n  sqlite3_stmt *pStmt,\n  int i,\n  void *pPtr,\n  const char *zPTtype,\n  void (*xDestructor)(void*)\n){\n  int rc;\n  Vdbe *p = (Vdbe*)pStmt;\n  rc = vdbeUnbind(p, (u32)(i-1));\n  if( rc==SQLITE_OK ){\n    assert( p!=0 && p->aVar!=0 && i>0 && i<=p->nVar ); /* tag-20240917-01 */\n    sqlite3VdbeMemSetPointer(&p->aVar[i-1], pPtr, zPTtype, xDestructor);\n    sqlite3_mutex_leave(p->db->mutex);\n  }else if( xDestructor ){\n    xDestructor(pPtr);\n  }\n  return rc;\n}\nint sqlite3_bind_text(\n  sqlite3_stmt *pStmt,\n  int i,\n  const char *zData,\n  int nData,\n  void (*xDel)(void*)\n){\n  return bindText(pStmt, i, zData, nData, xDel, SQLITE_UTF8);\n}\nint sqlite3_bind_text64(\n  sqlite3_stmt *pStmt,\n  int i,\n  const char *zData,\n  sqlite3_uint64 nData,\n  void (*xDel)(void*),\n  unsigned char enc\n){\n  assert( xDel!=SQLITE_DYNAMIC );\n  if( enc!=SQLITE_UTF8 && enc!=SQLITE_UTF8_ZT ){\n    if( enc==SQLITE_UTF16 ) enc = SQLITE_UTF16NATIVE;\n    nData &= ~(u64)1;\n  }\n  return bindText(pStmt, i, zData, nData, xDel, enc);\n}\n#ifndef SQLITE_OMIT_UTF16\nint sqlite3_bind_text16(\n  sqlite3_stmt *pStmt,\n  int i,\n  const void *zData,\n  int n,\n  void (*xDel)(void*)\n){\n  return bindText(pStmt, i, zData, n & ~(u64)1, xDel, SQLITE_UTF16NATIVE);\n}\n#endif /* SQLITE_OMIT_UTF16 */\nint sqlite3_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_value *pValue){\n  int rc;\n  switch( sqlite3_value_type((sqlite3_value*)pValue) ){\n    case SQLITE_INTEGER: {\n      rc = sqlite3_bind_int64(pStmt, i, pValue->u.i);\n      break;\n    }\n    case SQLITE_FLOAT: {\n      assert( pValue->flags & (MEM_Real|MEM_IntReal) );\n      rc = sqlite3_bind_double(pStmt, i,\n          (pValue->flags & MEM_Real) ? pValue->u.r : (double)pValue->u.i\n      );\n      break;\n    }\n    case SQLITE_BLOB: {\n      if( pValue->flags & MEM_Zero ){\n        rc = sqlite3_bind_zeroblob(pStmt, i, pValue->u.nZero);\n      }else{\n        rc = sqlite3_bind_blob(pStmt, i, pValue->z, pValue->n,SQLITE_TRANSIENT);\n      }\n      break;\n    }\n    case SQLITE_TEXT: {\n      rc = bindText(pStmt,i,  pValue->z, pValue->n, SQLITE_TRANSIENT,\n                              pValue->enc);\n      break;\n    }\n    default: {\n      rc = sqlite3_bind_null(pStmt, i);\n      break;\n    }\n  }\n  return rc;\n}\nint sqlite3_bind_zeroblob(sqlite3_stmt *pStmt, int i, int n){\n  int rc;\n  Vdbe *p = (Vdbe *)pStmt;\n  rc = vdbeUnbind(p, (u32)(i-1));\n  if( rc==SQLITE_OK ){\n    assert( p!=0 && p->aVar!=0 && i>0 && i<=p->nVar ); /* tag-20240917-01 */\n#ifndef SQLITE_OMIT_INCRBLOB\n    sqlite3VdbeMemSetZeroBlob(&p->aVar[i-1], n);\n#else\n    rc = sqlite3VdbeMemSetZeroBlob(&p->aVar[i-1], n);\n#endif\n    sqlite3_mutex_leave(p->db->mutex);\n  }\n  return rc;\n}\nint sqlite3_bind_zeroblob64(sqlite3_stmt *pStmt, int i, sqlite3_uint64 n){\n  int rc;\n  Vdbe *p = (Vdbe *)pStmt;\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( p==0 ) return SQLITE_MISUSE_BKPT;\n#endif\n  sqlite3_mutex_enter(p->db->mutex);\n  if( n>(u64)p->db->aLimit[SQLITE_LIMIT_LENGTH] ){\n    rc = SQLITE_TOOBIG;\n  }else{\n    assert( (n & 0x7FFFFFFF)==n );\n    rc = sqlite3_bind_zeroblob(pStmt, i, n);\n  }\n  rc = sqlite3ApiExit(p->db, rc);\n  sqlite3_mutex_leave(p->db->mutex);\n  return rc;\n}\n\n/*\n** Return the number of wildcards that can be potentially bound to.\n** This routine is added to support DBD::SQLite. \n*/\nint sqlite3_bind_parameter_count(sqlite3_stmt *pStmt){\n  Vdbe *p = (Vdbe*)pStmt;\n  return p ? p->nVar : 0;\n}\n\n/*\n** Return the name of a wildcard parameter.  Return NULL if the index\n** is out of range or if the wildcard is unnamed.\n**\n** The result is always UTF-8.\n*/\nconst char *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt, int i){\n  Vdbe *p = (Vdbe*)pStmt;\n  if( p==0 ) return 0;\n  return sqlite3VListNumToName(p->pVList, i);\n}\n\n/*\n** Given a wildcard parameter name, return the index of the variable\n** with that name.  If there is no variable with the given name,\n** return 0.\n*/\nint sqlite3VdbeParameterIndex(Vdbe *p, const char *zName, int nName){\n  if( p==0 || zName==0 ) return 0;\n  return sqlite3VListNameToNum(p->pVList, zName, nName);\n}\nint sqlite3_bind_parameter_index(sqlite3_stmt *pStmt, const char *zName){\n  return sqlite3VdbeParameterIndex((Vdbe*)pStmt, zName, sqlite3Strlen30(zName));\n}\n\n/*\n** Transfer all bindings from the first statement over to the second.\n*/\nint sqlite3TransferBindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){\n  Vdbe *pFrom = (Vdbe*)pFromStmt;\n  Vdbe *pTo = (Vdbe*)pToStmt;\n  int i;\n  assert( pTo->db==pFrom->db );\n  assert( pTo->nVar==pFrom->nVar );\n  sqlite3_mutex_enter(pTo->db->mutex);\n  for(i=0; i<pFrom->nVar; i++){\n    sqlite3VdbeMemMove(&pTo->aVar[i], &pFrom->aVar[i]);\n  }\n  sqlite3_mutex_leave(pTo->db->mutex);\n  return SQLITE_OK;\n}\n\n#ifndef SQLITE_OMIT_DEPRECATED\n/*\n** Deprecated external interface.  Internal/core SQLite code\n** should call sqlite3TransferBindings.\n**\n** It is misuse to call this routine with statements from different\n** database connections.  But as this is a deprecated interface, we\n** will not bother to check for that condition.\n**\n** If the two statements contain a different number of bindings, then\n** an SQLITE_ERROR is returned.  Nothing else can go wrong, so otherwise\n** SQLITE_OK is returned.\n*/\nint sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){\n  Vdbe *pFrom = (Vdbe*)pFromStmt;\n  Vdbe *pTo = (Vdbe*)pToStmt;\n  if( pFrom->nVar!=pTo->nVar ){\n    return SQLITE_ERROR;\n  }\n  assert( (pTo->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 || pTo->expmask==0 );\n  if( pTo->expmask ){\n    pTo->expired = 1;\n  }\n  assert( (pFrom->prepFlags & SQLITE_PREPARE_SAVESQL)!=0 || pFrom->expmask==0 );\n  if( pFrom->expmask ){\n    pFrom->expired = 1;\n  }\n  return sqlite3TransferBindings(pFromStmt, pToStmt);\n}\n#endif\n\n/*\n** Return the sqlite3* database handle to which the prepared statement given\n** in the argument belongs.  This is the same database handle that was\n** the first argument to the sqlite3_prepare() that was used to create\n** the statement in the first place.\n*/\nsqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt){\n  return pStmt ? ((Vdbe*)pStmt)->db : 0;\n}\n\n/*\n** Return true if the prepared statement is guaranteed to not modify the\n** database.\n*/\nint sqlite3_stmt_readonly(sqlite3_stmt *pStmt){\n  return pStmt ? ((Vdbe*)pStmt)->readOnly : 1;\n}\n\n/*\n** Return 1 if the statement is an EXPLAIN and return 2 if the\n** statement is an EXPLAIN QUERY PLAN\n*/\nint sqlite3_stmt_isexplain(sqlite3_stmt *pStmt){\n  return pStmt ? ((Vdbe*)pStmt)->explain : 0;\n}\n\n/*\n** Set the explain mode for a statement.\n*/\nint sqlite3_stmt_explain(sqlite3_stmt *pStmt, int eMode){\n  Vdbe *v = (Vdbe*)pStmt;\n  int rc;\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( pStmt==0 ) return SQLITE_MISUSE_BKPT;\n#endif\n  sqlite3_mutex_enter(v->db->mutex);\n  if( ((int)v->explain)==eMode ){\n    rc = SQLITE_OK;\n  }else if( eMode<0 || eMode>2 ){\n    rc = SQLITE_ERROR;\n  }else if( (v->prepFlags & SQLITE_PREPARE_SAVESQL)==0 ){\n    rc = SQLITE_ERROR;\n  }else if( v->eVdbeState!=VDBE_READY_STATE ){\n    rc = SQLITE_BUSY;\n  }else if( v->nMem>=10 && (eMode!=2 || v->haveEqpOps) ){\n    /* No reprepare necessary */\n    v->explain = eMode;\n    rc = SQLITE_OK;\n  }else{\n    v->explain = eMode;\n    rc = sqlite3Reprepare(v);\n    v->haveEqpOps = eMode==2;\n  }\n  if( v->explain ){\n    v->nResColumn = 12 - 4*v->explain;\n  }else{\n    v->nResColumn = v->nResAlloc;\n  }\n  sqlite3_mutex_leave(v->db->mutex);\n  return rc;\n}\n\n/*\n** Return true if the prepared statement is in need of being reset.\n*/\nint sqlite3_stmt_busy(sqlite3_stmt *pStmt){\n  Vdbe *v = (Vdbe*)pStmt;\n  return v!=0 && v->eVdbeState==VDBE_RUN_STATE;\n}\n\n/*\n** Return a pointer to the next prepared statement after pStmt associated\n** with database connection pDb.  If pStmt is NULL, return the first\n** prepared statement for the database connection.  Return NULL if there\n** are no more.\n*/\nsqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt){\n  sqlite3_stmt *pNext;\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( !sqlite3SafetyCheckOk(pDb) ){\n    (void)SQLITE_MISUSE_BKPT;\n    return 0;\n  }\n#endif\n  sqlite3_mutex_enter(pDb->mutex);\n  if( pStmt==0 ){\n    pNext = (sqlite3_stmt*)pDb->pVdbe;\n  }else{\n    pNext = (sqlite3_stmt*)((Vdbe*)pStmt)->pVNext;\n  }\n  sqlite3_mutex_leave(pDb->mutex);\n  return pNext;\n}\n\n/*\n** Return the value of a status counter for a prepared statement\n*/\nint sqlite3_stmt_status(sqlite3_stmt *pStmt, int op, int resetFlag){\n  Vdbe *pVdbe = (Vdbe*)pStmt;\n  u32 v;\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( !pStmt\n   || (op!=SQLITE_STMTSTATUS_MEMUSED && (op<0||op>=ArraySize(pVdbe->aCounter)))\n  ){\n    (void)SQLITE_MISUSE_BKPT;\n    return 0;\n  }\n#endif\n  if( op==SQLITE_STMTSTATUS_MEMUSED ){\n    sqlite3 *db = pVdbe->db;\n    sqlite3_mutex_enter(db->mutex);\n    v = 0;\n    db->pnBytesFreed = (int*)&v;\n    assert( db->lookaside.pEnd==db->lookaside.pTrueEnd );\n    db->lookaside.pEnd = db->lookaside.pStart;\n    sqlite3VdbeDelete(pVdbe);\n    db->pnBytesFreed = 0;\n    db->lookaside.pEnd = db->lookaside.pTrueEnd;\n    sqlite3_mutex_leave(db->mutex);\n  }else{\n    v = pVdbe->aCounter[op];\n    if( resetFlag ) pVdbe->aCounter[op] = 0;\n  }\n  return (int)v;\n}\n\n/*\n** Return the SQL associated with a prepared statement\n*/\nconst char *sqlite3_sql(sqlite3_stmt *pStmt){\n  Vdbe *p = (Vdbe *)pStmt;\n  return p ? p->zSql : 0;\n}\n\n/*\n** Return the SQL associated with a prepared statement with\n** bound parameters expanded.  Space to hold the returned string is\n** obtained from sqlite3_malloc().  The caller is responsible for\n** freeing the returned string by passing it to sqlite3_free().\n**\n** The SQLITE_TRACE_SIZE_LIMIT puts an upper bound on the size of\n** expanded bound parameters.\n*/\nchar *sqlite3_expanded_sql(sqlite3_stmt *pStmt){\n#ifdef SQLITE_OMIT_TRACE\n  return 0;\n#else\n  char *z = 0;\n  const char *zSql = sqlite3_sql(pStmt);\n  if( zSql ){\n    Vdbe *p = (Vdbe *)pStmt;\n    sqlite3_mutex_enter(p->db->mutex);\n    z = sqlite3VdbeExpandSql(p, zSql);\n    sqlite3_mutex_leave(p->db->mutex);\n  }\n  return z;\n#endif\n}\n\n#ifdef SQLITE_ENABLE_NORMALIZE\n/*\n** Return the normalized SQL associated with a prepared statement.\n*/\nconst char *sqlite3_normalized_sql(sqlite3_stmt *pStmt){\n  Vdbe *p = (Vdbe *)pStmt;\n  if( p==0 ) return 0;\n  if( p->zNormSql==0 && ALWAYS(p->zSql!=0) ){\n    sqlite3_mutex_enter(p->db->mutex);\n    p->zNormSql = sqlite3Normalize(p, p->zSql);\n    sqlite3_mutex_leave(p->db->mutex);\n  }\n  return p->zNormSql;\n}\n#endif /* SQLITE_ENABLE_NORMALIZE */\n\n#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n/*\n** Allocate and populate an UnpackedRecord structure based on the serialized\n** record in nKey/pKey. Return a pointer to the new UnpackedRecord structure\n** if successful, or a NULL pointer if an OOM error is encountered.\n*/\nstatic UnpackedRecord *vdbeUnpackRecord(\n  KeyInfo *pKeyInfo,\n  int nKey,\n  const void *pKey\n){\n  UnpackedRecord *pRet;           /* Return value */\n\n  pRet = sqlite3VdbeAllocUnpackedRecord(pKeyInfo);\n  if( pRet ){\n    memset(pRet->aMem, 0, sizeof(Mem)*(pKeyInfo->nKeyField+1));\n    sqlite3VdbeRecordUnpack(nKey, pKey, pRet);\n  }\n  return pRet;\n}\n\n/*\n** This function is called from within a pre-update callback to retrieve\n** a field of the row currently being updated or deleted.\n*/\nint sqlite3_preupdate_old(sqlite3 *db, int iIdx, sqlite3_value **ppValue){\n  PreUpdate *p;\n  Mem *pMem;\n  int rc = SQLITE_OK;\n  int iStore = 0;\n\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( db==0 || ppValue==0 ){\n    return SQLITE_MISUSE_BKPT;\n  }\n#endif\n  p = db->pPreUpdate;\n  /* Test that this call is being made from within an SQLITE_DELETE or\n  ** SQLITE_UPDATE pre-update callback, and that iIdx is within range. */\n  if( !p || p->op==SQLITE_INSERT ){\n    rc = SQLITE_MISUSE_BKPT;\n    goto preupdate_old_out;\n  }\n  if( p->pPk ){\n    iStore = sqlite3TableColumnToIndex(p->pPk, iIdx);\n  }else if( iIdx >= p->pTab->nCol ){\n    rc = SQLITE_MISUSE_BKPT;\n    goto preupdate_old_out;\n  }else{\n    iStore = sqlite3TableColumnToStorage(p->pTab, iIdx);\n  }\n  if( iStore>=p->pCsr->nField || iStore<0 ){\n    rc = SQLITE_RANGE;\n    goto preupdate_old_out;\n  }\n\n  if( iIdx==p->pTab->iPKey ){\n    *ppValue = pMem = &p->oldipk;\n    sqlite3VdbeMemSetInt64(pMem, p->iKey1);\n  }else{\n\n    /* If the old.* record has not yet been loaded into memory, do so now. */\n    if( p->pUnpacked==0 ){\n      u32 nRec;\n      u8 *aRec;\n\n      assert( p->pCsr->eCurType==CURTYPE_BTREE );\n      nRec = sqlite3BtreePayloadSize(p->pCsr->uc.pCursor);\n      aRec = sqlite3DbMallocRaw(db, nRec);\n      if( !aRec ) goto preupdate_old_out;\n      rc = sqlite3BtreePayload(p->pCsr->uc.pCursor, 0, nRec, aRec);\n      if( rc==SQLITE_OK ){\n        p->pUnpacked = vdbeUnpackRecord(p->pKeyinfo, nRec, aRec);\n        if( !p->pUnpacked ) rc = SQLITE_NOMEM;\n      }\n      if( rc!=SQLITE_OK ){\n        sqlite3DbFree(db, aRec);\n        goto preupdate_old_out;\n      }\n      p->aRecord = aRec;\n    }\n\n    pMem = *ppValue = &p->pUnpacked->aMem[iStore];\n    if( iStore>=p->pUnpacked->nField ){\n      /* This occurs when the table has been extended using ALTER TABLE\n      ** ADD COLUMN. The value to return is the default value of the column. */\n      Column *pCol = &p->pTab->aCol[iIdx];\n      if( pCol->iDflt>0 ){\n        if( p->apDflt==0 ){\n          int nByte;\n          assert( sizeof(sqlite3_value*)*UMXV(p->pTab->nCol) < 0x7fffffff );\n          nByte = sizeof(sqlite3_value*)*p->pTab->nCol;\n          p->apDflt = (sqlite3_value**)sqlite3DbMallocZero(db, nByte);\n          if( p->apDflt==0 ) goto preupdate_old_out;\n        }\n        if( p->apDflt[iIdx]==0 ){\n          sqlite3_value *pVal = 0;\n          Expr *pDflt;\n          assert( p->pTab!=0 && IsOrdinaryTable(p->pTab) );\n          pDflt = p->pTab->u.tab.pDfltList->a[pCol->iDflt-1].pExpr;\n          rc = sqlite3ValueFromExpr(db, pDflt, ENC(db), pCol->affinity, &pVal);\n          if( rc==SQLITE_OK && pVal==0 ){\n            rc = SQLITE_CORRUPT_BKPT;\n          }\n          p->apDflt[iIdx] = pVal;\n        }\n        *ppValue = p->apDflt[iIdx];\n      }else{\n        *ppValue = (sqlite3_value *)columnNullValue();\n      }\n    }else if( p->pTab->aCol[iIdx].affinity==SQLITE_AFF_REAL ){\n      if( pMem->flags & (MEM_Int|MEM_IntReal) ){\n        testcase( pMem->flags & MEM_Int );\n        testcase( pMem->flags & MEM_IntReal );\n        sqlite3VdbeMemRealify(pMem);\n      }\n    }\n  }\n\n preupdate_old_out:\n  sqlite3Error(db, rc);\n  return sqlite3ApiExit(db, rc);\n}\n#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */\n\n#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n/*\n** This function is called from within a pre-update callback to retrieve\n** the number of columns in the row being updated, deleted or inserted.\n*/\nint sqlite3_preupdate_count(sqlite3 *db){\n  PreUpdate *p;\n#ifdef SQLITE_ENABLE_API_ARMOR\n  p = db!=0 ? db->pPreUpdate : 0;\n#else\n  p = db->pPreUpdate;\n#endif\n  return (p ? p->pKeyinfo->nKeyField : 0);\n}\n#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */\n\n#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n/*\n** This function is designed to be called from within a pre-update callback\n** only. It returns zero if the change that caused the callback was made\n** immediately by a user SQL statement. Or, if the change was made by a\n** trigger program, it returns the number of trigger programs currently\n** on the stack (1 for a top-level trigger, 2 for a trigger fired by a\n** top-level trigger etc.).\n**\n** For the purposes of the previous paragraph, a foreign key CASCADE, SET NULL\n** or SET DEFAULT action is considered a trigger.\n*/\nint sqlite3_preupdate_depth(sqlite3 *db){\n  PreUpdate *p;\n#ifdef SQLITE_ENABLE_API_ARMOR\n  p = db!=0 ? db->pPreUpdate : 0;\n#else\n  p = db->pPreUpdate;\n#endif\n  return (p ? p->v->nFrame : 0);\n}\n#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */\n\n#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n/*\n** This function is designed to be called from within a pre-update callback\n** only.\n*/\nint sqlite3_preupdate_blobwrite(sqlite3 *db){\n  PreUpdate *p;\n#ifdef SQLITE_ENABLE_API_ARMOR\n  p = db!=0 ? db->pPreUpdate : 0;\n#else\n  p = db->pPreUpdate;\n#endif\n  return (p ? p->iBlobWrite : -1);\n}\n#endif\n\n#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n/*\n** This function is called from within a pre-update callback to retrieve\n** a field of the row currently being updated or inserted.\n*/\nint sqlite3_preupdate_new(sqlite3 *db, int iIdx, sqlite3_value **ppValue){\n  PreUpdate *p;\n  int rc = SQLITE_OK;\n  Mem *pMem;\n  int iStore = 0;\n\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( db==0 || ppValue==0 ){\n    return SQLITE_MISUSE_BKPT;\n  }\n#endif\n  p = db->pPreUpdate;\n  if( !p || p->op==SQLITE_DELETE ){\n    rc = SQLITE_MISUSE_BKPT;\n    goto preupdate_new_out;\n  }\n  if( p->pPk && p->op!=SQLITE_UPDATE ){\n    iStore = sqlite3TableColumnToIndex(p->pPk, iIdx);\n  }else if( iIdx >= p->pTab->nCol ){\n    return SQLITE_MISUSE_BKPT;\n  }else{\n    iStore = sqlite3TableColumnToStorage(p->pTab, iIdx);\n  }\n\n  if( iStore>=p->pCsr->nField || iStore<0 ){\n    rc = SQLITE_RANGE;\n    goto preupdate_new_out;\n  }\n\n  if( p->op==SQLITE_INSERT ){\n    /* For an INSERT, memory cell p->iNewReg contains the serialized record\n    ** that is being inserted. Deserialize it. */\n    UnpackedRecord *pUnpack = p->pNewUnpacked;\n    if( !pUnpack ){\n      Mem *pData = &p->v->aMem[p->iNewReg];\n      rc = ExpandBlob(pData);\n      if( rc!=SQLITE_OK ) goto preupdate_new_out;\n      pUnpack = vdbeUnpackRecord(p->pKeyinfo, pData->n, pData->z);\n      if( !pUnpack ){\n        rc = SQLITE_NOMEM;\n        goto preupdate_new_out;\n      }\n      p->pNewUnpacked = pUnpack;\n    }\n    pMem = &pUnpack->aMem[iStore];\n    if( iIdx==p->pTab->iPKey ){\n      sqlite3VdbeMemSetInt64(pMem, p->iKey2);\n    }else if( iStore>=pUnpack->nField ){\n      pMem = (sqlite3_value *)columnNullValue();\n    }\n  }else{\n    /* For an UPDATE, memory cell (p->iNewReg+1+iStore) contains the required\n    ** value. Make a copy of the cell contents and return a pointer to it.\n    ** It is not safe to return a pointer to the memory cell itself as the\n    ** caller may modify the value text encoding.\n    */\n    assert( p->op==SQLITE_UPDATE );\n    if( !p->aNew ){\n      assert( sizeof(Mem)*UMXV(p->pCsr->nField) < 0x7fffffff );\n      p->aNew = (Mem *)sqlite3DbMallocZero(db, sizeof(Mem)*p->pCsr->nField);\n      if( !p->aNew ){\n        rc = SQLITE_NOMEM;\n        goto preupdate_new_out;\n      }\n    }\n    assert( iStore>=0 && iStore<p->pCsr->nField );\n    pMem = &p->aNew[iStore];\n    if( pMem->flags==0 ){\n      if( iIdx==p->pTab->iPKey ){\n        sqlite3VdbeMemSetInt64(pMem, p->iKey2);\n      }else{\n        rc = sqlite3VdbeMemCopy(pMem, &p->v->aMem[p->iNewReg+1+iStore]);\n        if( rc!=SQLITE_OK ) goto preupdate_new_out;\n      }\n    }\n  }\n  *ppValue = pMem;\n\n preupdate_new_out:\n  sqlite3Error(db, rc);\n  return sqlite3ApiExit(db, rc);\n}\n#endif /* SQLITE_ENABLE_PREUPDATE_HOOK */\n\n#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n/*\n** Return status data for a single loop within query pStmt.\n*/\nint sqlite3_stmt_scanstatus_v2(\n  sqlite3_stmt *pStmt,            /* Prepared statement being queried */\n  int iScan,                      /* Index of loop to report on */\n  int iScanStatusOp,              /* Which metric to return */\n  int flags,\n  void *pOut                      /* OUT: Write the answer here */\n){\n  Vdbe *p = (Vdbe*)pStmt;\n  VdbeOp *aOp;\n  int nOp;\n  ScanStatus *pScan = 0;\n  int idx;\n\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( p==0 || pOut==0\n      || iScanStatusOp<SQLITE_SCANSTAT_NLOOP\n      || iScanStatusOp>SQLITE_SCANSTAT_NCYCLE ){\n    return 1;\n  }\n#endif\n  aOp = p->aOp;\n  nOp = p->nOp;\n  if( p->pFrame ){\n    VdbeFrame *pFrame;\n    for(pFrame=p->pFrame; pFrame->pParent; pFrame=pFrame->pParent);\n    aOp = pFrame->aOp;\n    nOp = pFrame->nOp;\n  }\n\n  if( iScan<0 ){\n    int ii;\n    if( iScanStatusOp==SQLITE_SCANSTAT_NCYCLE ){\n      i64 res = 0;\n      for(ii=0; ii<nOp; ii++){\n        res += aOp[ii].nCycle;\n      }\n      *(i64*)pOut = res;\n      return 0;\n    }\n    return 1;\n  }\n  if( flags & SQLITE_SCANSTAT_COMPLEX ){\n    idx = iScan;\n  }else{\n    /* If the COMPLEX flag is clear, then this function must ignore any\n    ** ScanStatus structures with ScanStatus.addrLoop set to 0. */\n    for(idx=0; idx<p->nScan; idx++){\n      pScan = &p->aScan[idx];\n      if( pScan->zName ){\n        iScan--;\n        if( iScan<0 ) break;\n      }\n    }\n  }\n  if( idx>=p->nScan ) return 1;\n  assert( pScan==0 || pScan==&p->aScan[idx] );\n  pScan = &p->aScan[idx];\n\n  switch( iScanStatusOp ){\n    case SQLITE_SCANSTAT_NLOOP: {\n      if( pScan->addrLoop>0 ){\n        *(sqlite3_int64*)pOut = aOp[pScan->addrLoop].nExec;\n      }else{\n        *(sqlite3_int64*)pOut = -1;\n      }\n      break;\n    }\n    case SQLITE_SCANSTAT_NVISIT: {\n      if( pScan->addrVisit>0 ){\n        *(sqlite3_int64*)pOut = aOp[pScan->addrVisit].nExec;\n      }else{\n        *(sqlite3_int64*)pOut = -1;\n      }\n      break;\n    }\n    case SQLITE_SCANSTAT_EST: {\n      double r = 1.0;\n      LogEst x = pScan->nEst;\n      while( x<100 ){\n        x += 10;\n        r *= 0.5;\n      }\n      *(double*)pOut = r*sqlite3LogEstToInt(x);\n      break;\n    }\n    case SQLITE_SCANSTAT_NAME: {\n      *(const char**)pOut = pScan->zName;\n      break;\n    }\n    case SQLITE_SCANSTAT_EXPLAIN: {\n      if( pScan->addrExplain ){\n        *(const char**)pOut = aOp[ pScan->addrExplain ].p4.z;\n      }else{\n        *(const char**)pOut = 0;\n      }\n      break;\n    }\n    case SQLITE_SCANSTAT_SELECTID: {\n      if( pScan->addrExplain ){\n        *(int*)pOut = aOp[ pScan->addrExplain ].p1;\n      }else{\n        *(int*)pOut = -1;\n      }\n      break;\n    }\n    case SQLITE_SCANSTAT_PARENTID: {\n      if( pScan->addrExplain ){\n        *(int*)pOut = aOp[ pScan->addrExplain ].p2;\n      }else{\n        *(int*)pOut = -1;\n      }\n      break;\n    }\n    case SQLITE_SCANSTAT_NCYCLE: {\n      i64 res = 0;\n      if( pScan->aAddrRange[0]==0 ){\n        res = -1;\n      }else{\n        int ii;\n        for(ii=0; ii<ArraySize(pScan->aAddrRange); ii+=2){\n          int iIns = pScan->aAddrRange[ii];\n          int iEnd = pScan->aAddrRange[ii+1];\n          if( iIns==0 ) break;\n          if( iIns>0 ){\n            while( iIns<=iEnd ){\n              res += aOp[iIns].nCycle;\n              iIns++;\n            }\n          }else{\n            int iOp;\n            for(iOp=0; iOp<nOp; iOp++){\n              Op *pOp = &aOp[iOp];\n              if( pOp->p1!=iEnd ) continue;\n              if( (sqlite3OpcodeProperty[pOp->opcode] & OPFLG_NCYCLE)==0 ){\n                continue;\n              }\n              res += aOp[iOp].nCycle;\n            }\n          }\n        }\n      }\n      *(i64*)pOut = res;\n      break;\n    }\n    default: {\n      return 1;\n    }\n  }\n  return 0;\n}\n\n/*\n** Return status data for a single loop within query pStmt.\n*/\nint sqlite3_stmt_scanstatus(\n  sqlite3_stmt *pStmt,            /* Prepared statement being queried */\n  int iScan,                      /* Index of loop to report on */\n  int iScanStatusOp,              /* Which metric to return */\n  void *pOut                      /* OUT: Write the answer here */\n){\n  return sqlite3_stmt_scanstatus_v2(pStmt, iScan, iScanStatusOp, 0, pOut);\n}\n\n/*\n** Zero all counters associated with the sqlite3_stmt_scanstatus() data.\n*/\nvoid sqlite3_stmt_scanstatus_reset(sqlite3_stmt *pStmt){\n  Vdbe *p = (Vdbe*)pStmt;\n  int ii;\n  for(ii=0; p!=0 && ii<p->nOp; ii++){\n    Op *pOp = &p->aOp[ii];\n    pOp->nExec = 0;\n    pOp->nCycle = 0;\n  }\n}\n#endif /* SQLITE_ENABLE_STMT_SCANSTATUS */\n"}
{"repo": "sqlite", "file": "pcache1.c", "lang": "C++", "code": "/*\n** 2008 November 05\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file implements the default page cache implementation (the\n** sqlite3_pcache interface). It also contains part of the implementation\n** of the SQLITE_CONFIG_PAGECACHE and sqlite3_release_memory() features.\n** If the default page cache implementation is overridden, then neither of\n** these two features are available.\n**\n** A Page cache line looks like this:\n**\n**  -------------------------------------------------------------\n**  |  database page content   |  PgHdr1  |  MemPage  |  PgHdr  |\n**  -------------------------------------------------------------\n**\n** The database page content is up front (so that buffer overreads tend to\n** flow harmlessly into the PgHdr1, MemPage, and PgHdr extensions).   MemPage\n** is the extension added by the btree.c module containing information such\n** as the database page number and how that database page is used.  PgHdr\n** is added by the pcache.c layer and contains information used to keep track\n** of which pages are \"dirty\".  PgHdr1 is an extension added by this\n** module (pcache1.c).  The PgHdr1 header is a subclass of sqlite3_pcache_page.\n** PgHdr1 contains information needed to look up a page by its page number.\n** The superclass sqlite3_pcache_page.pBuf points to the start of the\n** database page content and sqlite3_pcache_page.pExtra points to PgHdr.\n**\n** The size of the extension (MemPage+PgHdr+PgHdr1) can be determined at\n** runtime using sqlite3_config(SQLITE_CONFIG_PCACHE_HDRSZ, &size).  The\n** sizes of the extensions sum to 272 bytes on x64 for 3.8.10, but this\n** size can vary according to architecture, compile-time options, and\n** SQLite library version number.\n**\n** Historical note:  It used to be that if the SQLITE_PCACHE_SEPARATE_HEADER\n** was defined, then the page content would be held in a separate memory\n** allocation from the PgHdr1.  This was intended to avoid clownshoe memory\n** allocations.  However, the btree layer needs a small (16-byte) overrun\n** area after the page content buffer.  The header serves as that overrun\n** area.  Therefore SQLITE_PCACHE_SEPARATE_HEADER was discontinued to avoid\n** any possibility of a memory error.\n**\n** This module tracks pointers to PgHdr1 objects.  Only pcache.c communicates\n** with this module.  Information is passed back and forth as PgHdr1 pointers.\n**\n** The pcache.c and pager.c modules deal pointers to PgHdr objects.\n** The btree.c module deals with pointers to MemPage objects.\n**\n** SOURCE OF PAGE CACHE MEMORY:\n**\n** Memory for a page might come from any of three sources:\n**\n**    (1)  The general-purpose memory allocator - sqlite3Malloc()\n**    (2)  Global page-cache memory provided using sqlite3_config() with\n**         SQLITE_CONFIG_PAGECACHE.\n**    (3)  PCache-local bulk allocation.\n**\n** The third case is a chunk of heap memory (defaulting to 100 pages worth)\n** that is allocated when the page cache is created.  The size of the local\n** bulk allocation can be adjusted using\n**\n**     sqlite3_config(SQLITE_CONFIG_PAGECACHE, (void*)0, 0, N).\n**\n** If N is positive, then N pages worth of memory are allocated using a single\n** sqlite3Malloc() call and that memory is used for the first N pages allocated.\n** Or if N is negative, then -1024*N bytes of memory are allocated and used\n** for as many pages as can be accommodated.\n**\n** Only one of (2) or (3) can be used.  Once the memory available to (2) or\n** (3) is exhausted, subsequent allocations fail over to the general-purpose\n** memory allocator (1).\n**\n** Earlier versions of SQLite used only methods (1) and (2).  But experiments\n** show that method (3) with N==100 provides about a 5% performance boost for\n** common workloads.\n*/\n#include \"sqliteInt.h\"\n\ntypedef struct PCache1 PCache1;\ntypedef struct PgHdr1 PgHdr1;\ntypedef struct PgFreeslot PgFreeslot;\ntypedef struct PGroup PGroup;\n\n/*\n** Each cache entry is represented by an instance of the following\n** structure. A buffer of PgHdr1.pCache->szPage bytes is allocated\n** directly before this structure and is used to cache the page content.\n**\n** When reading a corrupt database file, it is possible that SQLite might\n** read a few bytes (no more than 16 bytes) past the end of the page buffer.\n** It will only read past the end of the page buffer, never write.  This\n** object is positioned immediately after the page buffer to serve as an\n** overrun area, so that overreads are harmless.\n**\n** Variables isBulkLocal and isAnchor were once type \"u8\". That works,\n** but causes a 2-byte gap in the structure for most architectures (since\n** pointers must be either 4 or 8-byte aligned). As this structure is located\n** in memory directly after the associated page data, if the database is\n** corrupt, code at the b-tree layer may overread the page buffer and\n** read part of this structure before the corruption is detected. This\n** can cause a valgrind error if the uninitialized gap is accessed. Using u16\n** ensures there is no such gap, and therefore no bytes of uninitialized\n** memory in the structure.\n**\n** The pLruNext and pLruPrev pointers form a double-linked circular list\n** of all pages that are unpinned.  The PGroup.lru element (which should be\n** the only element on the list with PgHdr1.isAnchor set to 1) forms the\n** beginning and the end of the list.\n*/\nstruct PgHdr1 {\n  sqlite3_pcache_page page; /* Base class. Must be first. pBuf & pExtra */\n  unsigned int iKey;        /* Key value (page number) */\n  u16 isBulkLocal;          /* This page from bulk local storage */\n  u16 isAnchor;             /* This is the PGroup.lru element */\n  PgHdr1 *pNext;            /* Next in hash table chain */\n  PCache1 *pCache;          /* Cache that currently owns this page */\n  PgHdr1 *pLruNext;         /* Next in circular LRU list of unpinned pages */\n  PgHdr1 *pLruPrev;         /* Previous in LRU list of unpinned pages */\n                            /* NB: pLruPrev is only valid if pLruNext!=0 */\n};\n\n/*\n** A page is pinned if it is not on the LRU list.  To be \"pinned\" means\n** that the page is in active use and must not be deallocated.\n*/\n#define PAGE_IS_PINNED(p)    ((p)->pLruNext==0)\n#define PAGE_IS_UNPINNED(p)  ((p)->pLruNext!=0)\n\n/* Each page cache (or PCache) belongs to a PGroup.  A PGroup is a set\n** of one or more PCaches that are able to recycle each other's unpinned\n** pages when they are under memory pressure.  A PGroup is an instance of\n** the following object.\n**\n** This page cache implementation works in one of two modes:\n**\n**   (1)  Every PCache is the sole member of its own PGroup.  There is\n**        one PGroup per PCache.\n**\n**   (2)  There is a single global PGroup that all PCaches are a member\n**        of.\n**\n** Mode 1 uses more memory (since PCache instances are not able to rob\n** unused pages from other PCaches) but it also operates without a mutex,\n** and is therefore often faster.  Mode 2 requires a mutex in order to be\n** threadsafe, but recycles pages more efficiently.\n**\n** For mode (1), PGroup.mutex is NULL.  For mode (2) there is only a single\n** PGroup which is the pcache1.grp global variable and its mutex is\n** SQLITE_MUTEX_STATIC_LRU.\n*/\nstruct PGroup {\n  sqlite3_mutex *mutex;          /* MUTEX_STATIC_LRU or NULL */\n  unsigned int nMaxPage;         /* Sum of nMax for purgeable caches */\n  unsigned int nMinPage;         /* Sum of nMin for purgeable caches */\n  unsigned int mxPinned;         /* nMaxpage + 10 - nMinPage */\n  unsigned int nPurgeable;       /* Number of purgeable pages allocated */\n  PgHdr1 lru;                    /* The beginning and end of the LRU list */\n};\n\n/* Each page cache is an instance of the following object.  Every\n** open database file (including each in-memory database and each\n** temporary or transient database) has a single page cache which\n** is an instance of this object.\n**\n** Pointers to structures of this type are cast and returned as\n** opaque sqlite3_pcache* handles.\n*/\nstruct PCache1 {\n  /* Cache configuration parameters. Page size (szPage) and the purgeable\n  ** flag (bPurgeable) and the pnPurgeable pointer are all set when the\n  ** cache is created and are never changed thereafter. nMax may be\n  ** modified at any time by a call to the pcache1Cachesize() method.\n  ** The PGroup mutex must be held when accessing nMax.\n  */\n  PGroup *pGroup;                     /* PGroup this cache belongs to */\n  unsigned int *pnPurgeable;          /* Pointer to pGroup->nPurgeable */\n  int szPage;                         /* Size of database content section */\n  int szExtra;                        /* sizeof(MemPage)+sizeof(PgHdr) */\n  int szAlloc;                        /* Total size of one pcache line */\n  int bPurgeable;                     /* True if cache is purgeable */\n  unsigned int nMin;                  /* Minimum number of pages reserved */\n  unsigned int nMax;                  /* Configured \"cache_size\" value */\n  unsigned int n90pct;                /* nMax*9/10 */\n  unsigned int iMaxKey;               /* Largest key seen since xTruncate() */\n  unsigned int nPurgeableDummy;       /* pnPurgeable points here when not used*/\n\n  /* Hash table of all pages. The following variables may only be accessed\n  ** when the accessor is holding the PGroup mutex.\n  */\n  unsigned int nRecyclable;           /* Number of pages in the LRU list */\n  unsigned int nPage;                 /* Total number of pages in apHash */\n  unsigned int nHash;                 /* Number of slots in apHash[] */\n  PgHdr1 **apHash;                    /* Hash table for fast lookup by key */\n  PgHdr1 *pFree;                      /* List of unused pcache-local pages */\n  void *pBulk;                        /* Bulk memory used by pcache-local */\n};\n\n/*\n** Free slots in the allocator used to divide up the global page cache\n** buffer provided using the SQLITE_CONFIG_PAGECACHE mechanism.\n*/\nstruct PgFreeslot {\n  PgFreeslot *pNext;  /* Next free slot */\n};\n\n/*\n** Global data used by this cache.\n*/\nstatic SQLITE_WSD struct PCacheGlobal {\n  PGroup grp;                    /* The global PGroup for mode (2) */\n\n  /* Variables related to SQLITE_CONFIG_PAGECACHE settings.  The\n  ** szSlot, nSlot, pStart, pEnd, nReserve, and isInit values are all\n  ** fixed at sqlite3_initialize() time and do not require mutex protection.\n  ** The nFreeSlot and pFree values do require mutex protection.\n  */\n  int isInit;                    /* True if initialized */\n  int separateCache;             /* Use a new PGroup for each PCache */\n  int nInitPage;                 /* Initial bulk allocation size */\n  int szSlot;                    /* Size of each free slot */\n  int nSlot;                     /* The number of pcache slots */\n  int nReserve;                  /* Try to keep nFreeSlot above this */\n  void *pStart, *pEnd;           /* Bounds of global page cache memory */\n  /* Above requires no mutex.  Use mutex below for variable that follow. */\n  sqlite3_mutex *mutex;          /* Mutex for accessing the following: */\n  PgFreeslot *pFree;             /* Free page blocks */\n  int nFreeSlot;                 /* Number of unused pcache slots */\n  int bUnderPressure;            /* True if low on PAGECACHE memory */\n} pcache1_g;\n\n/*\n** All code in this file should access the global structure above via the\n** alias \"pcache1\". This ensures that the WSD emulation is used when\n** compiling for systems that do not support real WSD.\n*/\n#define pcache1 (GLOBAL(struct PCacheGlobal, pcache1_g))\n\n/*\n** Macros to enter and leave the PCache LRU mutex.\n*/\n#if !defined(SQLITE_ENABLE_MEMORY_MANAGEMENT) || SQLITE_THREADSAFE==0\n# define pcache1EnterMutex(X)  assert((X)->mutex==0)\n# define pcache1LeaveMutex(X)  assert((X)->mutex==0)\n# define PCACHE1_MIGHT_USE_GROUP_MUTEX 0\n#else\n# define pcache1EnterMutex(X) sqlite3_mutex_enter((X)->mutex)\n# define pcache1LeaveMutex(X) sqlite3_mutex_leave((X)->mutex)\n# define PCACHE1_MIGHT_USE_GROUP_MUTEX 1\n#endif\n\n/******************************************************************************/\n/******** Page Allocation/SQLITE_CONFIG_PCACHE Related Functions **************/\n\n\n/*\n** This function is called during initialization if a static buffer is\n** supplied to use for the page-cache by passing the SQLITE_CONFIG_PAGECACHE\n** verb to sqlite3_config(). Parameter pBuf points to an allocation large\n** enough to contain 'n' buffers of 'sz' bytes each.\n**\n** This routine is called from sqlite3_initialize() and so it is guaranteed\n** to be serialized already.  There is no need for further mutexing.\n*/\nvoid sqlite3PCacheBufferSetup(void *pBuf, int sz, int n){\n  if( pcache1.isInit ){\n    PgFreeslot *p;\n    if( pBuf==0 ) sz = n = 0;\n    if( n==0 ) sz = 0;\n    sz = ROUNDDOWN8(sz);\n    pcache1.szSlot = sz;\n    pcache1.nSlot = pcache1.nFreeSlot = n;\n    pcache1.nReserve = n>90 ? 10 : (n/10 + 1);\n    pcache1.pStart = pBuf;\n    pcache1.pFree = 0;\n    AtomicStore(&pcache1.bUnderPressure,0);\n    while( n-- ){\n      p = (PgFreeslot*)pBuf;\n      p->pNext = pcache1.pFree;\n      pcache1.pFree = p;\n      pBuf = (void*)&((char*)pBuf)[sz];\n    }\n    pcache1.pEnd = pBuf;\n  }\n}\n\n/*\n** Try to initialize the pCache->pFree and pCache->pBulk fields.  Return\n** true if pCache->pFree ends up containing one or more free pages.\n*/\nstatic int pcache1InitBulk(PCache1 *pCache){\n  i64 szBulk;\n  char *zBulk;\n  if( pcache1.nInitPage==0 ) return 0;\n  /* Do not bother with a bulk allocation if the cache size very small */\n  if( pCache->nMax<3 ) return 0;\n  sqlite3BeginBenignMalloc();\n  if( pcache1.nInitPage>0 ){\n    szBulk = pCache->szAlloc * (i64)pcache1.nInitPage;\n  }else{\n    szBulk = -1024 * (i64)pcache1.nInitPage;\n  }\n  if( szBulk > pCache->szAlloc*(i64)pCache->nMax ){\n    szBulk = pCache->szAlloc*(i64)pCache->nMax;\n  }\n  zBulk = pCache->pBulk = sqlite3Malloc( szBulk );\n  sqlite3EndBenignMalloc();\n  if( zBulk ){\n    int nBulk = sqlite3MallocSize(zBulk)/pCache->szAlloc;\n    do{\n      PgHdr1 *pX = (PgHdr1*)&zBulk[pCache->szPage];\n      pX->page.pBuf = zBulk;\n      pX->page.pExtra = (u8*)pX + ROUND8(sizeof(*pX));\n      assert( EIGHT_BYTE_ALIGNMENT( pX->page.pExtra ) );\n      pX->isBulkLocal = 1;\n      pX->isAnchor = 0;\n      pX->pNext = pCache->pFree;\n      pX->pLruPrev = 0;           /* Initializing this saves a valgrind error */\n      pCache->pFree = pX;\n      zBulk += pCache->szAlloc;\n    }while( --nBulk );\n  }\n  return pCache->pFree!=0;\n}\n\n/*\n** Malloc function used within this file to allocate space from the buffer\n** configured using sqlite3_config(SQLITE_CONFIG_PAGECACHE) option. If no\n** such buffer exists or there is no space left in it, this function falls\n** back to sqlite3Malloc().\n**\n** Multiple threads can run this routine at the same time.  Global variables\n** in pcache1 need to be protected via mutex.\n*/\nstatic void *pcache1Alloc(int nByte){\n  void *p = 0;\n  assert( sqlite3_mutex_notheld(pcache1.grp.mutex) );\n  if( nByte<=pcache1.szSlot ){\n    sqlite3_mutex_enter(pcache1.mutex);\n    p = (PgHdr1 *)pcache1.pFree;\n    if( p ){\n      pcache1.pFree = pcache1.pFree->pNext;\n      pcache1.nFreeSlot--;\n      AtomicStore(&pcache1.bUnderPressure,pcache1.nFreeSlot<pcache1.nReserve);\n      assert( pcache1.nFreeSlot>=0 );\n      sqlite3StatusHighwater(SQLITE_STATUS_PAGECACHE_SIZE, nByte);\n      sqlite3StatusUp(SQLITE_STATUS_PAGECACHE_USED, 1);\n    }\n    sqlite3_mutex_leave(pcache1.mutex);\n  }\n  if( p==0 ){\n    /* Memory is not available in the SQLITE_CONFIG_PAGECACHE pool.  Get\n    ** it from sqlite3Malloc instead.\n    */\n    p = sqlite3Malloc(nByte);\n#ifndef SQLITE_DISABLE_PAGECACHE_OVERFLOW_STATS\n    if( p ){\n      int sz = sqlite3MallocSize(p);\n      sqlite3_mutex_enter(pcache1.mutex);\n      sqlite3StatusHighwater(SQLITE_STATUS_PAGECACHE_SIZE, nByte);\n      sqlite3StatusUp(SQLITE_STATUS_PAGECACHE_OVERFLOW, sz);\n      sqlite3_mutex_leave(pcache1.mutex);\n    }\n#endif\n    sqlite3MemdebugSetType(p, MEMTYPE_PCACHE);\n  }\n  return p;\n}\n\n/*\n** Free an allocated buffer obtained from pcache1Alloc().\n*/\nstatic void pcache1Free(void *p){\n  if( p==0 ) return;\n  if( SQLITE_WITHIN(p, pcache1.pStart, pcache1.pEnd) ){\n    PgFreeslot *pSlot;\n    sqlite3_mutex_enter(pcache1.mutex);\n    sqlite3StatusDown(SQLITE_STATUS_PAGECACHE_USED, 1);\n    pSlot = (PgFreeslot*)p;\n    pSlot->pNext = pcache1.pFree;\n    pcache1.pFree = pSlot;\n    pcache1.nFreeSlot++;\n    AtomicStore(&pcache1.bUnderPressure,pcache1.nFreeSlot<pcache1.nReserve);\n    assert( pcache1.nFreeSlot<=pcache1.nSlot );\n    sqlite3_mutex_leave(pcache1.mutex);\n  }else{\n    assert( sqlite3MemdebugHasType(p, MEMTYPE_PCACHE) );\n    sqlite3MemdebugSetType(p, MEMTYPE_HEAP);\n#ifndef SQLITE_DISABLE_PAGECACHE_OVERFLOW_STATS\n    {\n      int nFreed = 0;\n      nFreed = sqlite3MallocSize(p);\n      sqlite3_mutex_enter(pcache1.mutex);\n      sqlite3StatusDown(SQLITE_STATUS_PAGECACHE_OVERFLOW, nFreed);\n      sqlite3_mutex_leave(pcache1.mutex);\n    }\n#endif\n    sqlite3_free(p);\n  }\n}\n\n#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT\n/*\n** Return the size of a pcache allocation\n*/\nstatic int pcache1MemSize(void *p){\n  if( p>=pcache1.pStart && p<pcache1.pEnd ){\n    return pcache1.szSlot;\n  }else{\n    int iSize;\n    assert( sqlite3MemdebugHasType(p, MEMTYPE_PCACHE) );\n    sqlite3MemdebugSetType(p, MEMTYPE_HEAP);\n    iSize = sqlite3MallocSize(p);\n    sqlite3MemdebugSetType(p, MEMTYPE_PCACHE);\n    return iSize;\n  }\n}\n#endif /* SQLITE_ENABLE_MEMORY_MANAGEMENT */\n\n/*\n** Allocate a new page object initially associated with cache pCache.\n*/\nstatic PgHdr1 *pcache1AllocPage(PCache1 *pCache, int benignMalloc){\n  PgHdr1 *p = 0;\n  void *pPg;\n\n  assert( sqlite3_mutex_held(pCache->pGroup->mutex) );\n  if( pCache->pFree || (pCache->nPage==0 && pcache1InitBulk(pCache)) ){\n    assert( pCache->pFree!=0 );\n    p = pCache->pFree;\n    pCache->pFree = p->pNext;\n    p->pNext = 0;\n  }else{\n#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT\n    /* The group mutex must be released before pcache1Alloc() is called. This\n    ** is because it might call sqlite3_release_memory(), which assumes that\n    ** this mutex is not held. */\n    assert( pcache1.separateCache==0 );\n    assert( pCache->pGroup==&pcache1.grp );\n    pcache1LeaveMutex(pCache->pGroup);\n#endif\n    if( benignMalloc ){ sqlite3BeginBenignMalloc(); }\n    pPg = pcache1Alloc(pCache->szAlloc);\n    if( benignMalloc ){ sqlite3EndBenignMalloc(); }\n#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT\n    pcache1EnterMutex(pCache->pGroup);\n#endif\n    if( pPg==0 ) return 0;\n    p = (PgHdr1 *)&((u8 *)pPg)[pCache->szPage];\n    p->page.pBuf = pPg;\n    p->page.pExtra = (u8*)p + ROUND8(sizeof(*p));\n    assert( EIGHT_BYTE_ALIGNMENT( p->page.pExtra ) );\n    p->isBulkLocal = 0;\n    p->isAnchor = 0;\n    p->pLruPrev = 0;           /* Initializing this saves a valgrind error */\n  }\n  (*pCache->pnPurgeable)++;\n  return p;\n}\n\n/*\n** Free a page object allocated by pcache1AllocPage().\n*/\nstatic void pcache1FreePage(PgHdr1 *p){\n  PCache1 *pCache;\n  assert( p!=0 );\n  pCache = p->pCache;\n  assert( sqlite3_mutex_held(p->pCache->pGroup->mutex) );\n  if( p->isBulkLocal ){\n    p->pNext = pCache->pFree;\n    pCache->pFree = p;\n  }else{\n    pcache1Free(p->page.pBuf);\n  }\n  (*pCache->pnPurgeable)--;\n}\n\n/*\n** Malloc function used by SQLite to obtain space from the buffer configured\n** using sqlite3_config(SQLITE_CONFIG_PAGECACHE) option. If no such buffer\n** exists, this function falls back to sqlite3Malloc().\n*/\nvoid *sqlite3PageMalloc(int sz){\n  assert( sz<=65536+8 ); /* These allocations are never very large */\n  return pcache1Alloc(sz);\n}\n\n/*\n** Free an allocated buffer obtained from sqlite3PageMalloc().\n*/\nvoid sqlite3PageFree(void *p){\n  pcache1Free(p);\n}\n\n\n/*\n** Return true if it desirable to avoid allocating a new page cache\n** entry.\n**\n** If memory was allocated specifically to the page cache using\n** SQLITE_CONFIG_PAGECACHE but that memory has all been used, then\n** it is desirable to avoid allocating a new page cache entry because\n** presumably SQLITE_CONFIG_PAGECACHE was suppose to be sufficient\n** for all page cache needs and we should not need to spill the\n** allocation onto the heap.\n**\n** Or, the heap is used for all page cache memory but the heap is\n** under memory pressure, then again it is desirable to avoid\n** allocating a new page cache entry in order to avoid stressing\n** the heap even further.\n*/\nstatic int pcache1UnderMemoryPressure(PCache1 *pCache){\n  if( pcache1.nSlot && (pCache->szPage+pCache->szExtra)<=pcache1.szSlot ){\n    return AtomicLoad(&pcache1.bUnderPressure);\n  }else{\n    return sqlite3HeapNearlyFull();\n  }\n}\n\n/******************************************************************************/\n/******** General Implementation Functions ************************************/\n\n/*\n** This function is used to resize the hash table used by the cache passed\n** as the first argument.\n**\n** The PCache mutex must be held when this function is called.\n*/\nstatic void pcache1ResizeHash(PCache1 *p){\n  PgHdr1 **apNew;\n  u64 nNew;\n  u32 i;\n\n  assert( sqlite3_mutex_held(p->pGroup->mutex) );\n\n  nNew = 2*(u64)p->nHash;\n  if( nNew<256 ){\n    nNew = 256;\n  }\n\n  pcache1LeaveMutex(p->pGroup);\n  if( p->nHash ){ sqlite3BeginBenignMalloc(); }\n  apNew = (PgHdr1 **)sqlite3MallocZero(sizeof(PgHdr1 *)*nNew);\n  if( p->nHash ){ sqlite3EndBenignMalloc(); }\n  pcache1EnterMutex(p->pGroup);\n  if( apNew ){\n    for(i=0; i<p->nHash; i++){\n      PgHdr1 *pPage;\n      PgHdr1 *pNext = p->apHash[i];\n      while( (pPage = pNext)!=0 ){\n        unsigned int h = pPage->iKey % nNew;\n        pNext = pPage->pNext;\n        pPage->pNext = apNew[h];\n        apNew[h] = pPage;\n      }\n    }\n    sqlite3_free(p->apHash);\n    p->apHash = apNew;\n    p->nHash = nNew;\n  }\n}\n\n/*\n** This function is used internally to remove the page pPage from the\n** PGroup LRU list, if is part of it. If pPage is not part of the PGroup\n** LRU list, then this function is a no-op.\n**\n** The PGroup mutex must be held when this function is called.\n*/\nstatic PgHdr1 *pcache1PinPage(PgHdr1 *pPage){\n  assert( pPage!=0 );\n  assert( PAGE_IS_UNPINNED(pPage) );\n  assert( pPage->pLruNext );\n  assert( pPage->pLruPrev );\n  assert( sqlite3_mutex_held(pPage->pCache->pGroup->mutex) );\n  pPage->pLruPrev->pLruNext = pPage->pLruNext;\n  pPage->pLruNext->pLruPrev = pPage->pLruPrev;\n  pPage->pLruNext = 0;\n  /* pPage->pLruPrev = 0;\n  ** No need to clear pLruPrev as it is never accessed if pLruNext is 0 */\n  assert( pPage->isAnchor==0 );\n  assert( pPage->pCache->pGroup->lru.isAnchor==1 );\n  pPage->pCache->nRecyclable--;\n  return pPage;\n}\n\n\n/*\n** Remove the page supplied as an argument from the hash table\n** (PCache1.apHash structure) that it is currently stored in.\n** Also free the page if freePage is true.\n**\n** The PGroup mutex must be held when this function is called.\n*/\nstatic void pcache1RemoveFromHash(PgHdr1 *pPage, int freeFlag){\n  unsigned int h;\n  PCache1 *pCache = pPage->pCache;\n  PgHdr1 **pp;\n\n  assert( sqlite3_mutex_held(pCache->pGroup->mutex) );\n  h = pPage->iKey % pCache->nHash;\n  for(pp=&pCache->apHash[h]; (*pp)!=pPage; pp=&(*pp)->pNext);\n  *pp = (*pp)->pNext;\n\n  pCache->nPage--;\n  if( freeFlag ) pcache1FreePage(pPage);\n}\n\n/*\n** If there are currently more than nMaxPage pages allocated, try\n** to recycle pages to reduce the number allocated to nMaxPage.\n*/\nstatic void pcache1EnforceMaxPage(PCache1 *pCache){\n  PGroup *pGroup = pCache->pGroup;\n  PgHdr1 *p;\n  assert( sqlite3_mutex_held(pGroup->mutex) );\n  while( pGroup->nPurgeable>pGroup->nMaxPage\n      && (p=pGroup->lru.pLruPrev)->isAnchor==0\n  ){\n    assert( p->pCache->pGroup==pGroup );\n    assert( PAGE_IS_UNPINNED(p) );\n    pcache1PinPage(p);\n    pcache1RemoveFromHash(p, 1);\n  }\n  if( pCache->nPage==0 && pCache->pBulk ){\n    sqlite3_free(pCache->pBulk);\n    pCache->pBulk = pCache->pFree = 0;\n  }\n}\n\n/*\n** Discard all pages from cache pCache with a page number (key value)\n** greater than or equal to iLimit. Any pinned pages that meet this\n** criteria are unpinned before they are discarded.\n**\n** The PCache mutex must be held when this function is called.\n*/\nstatic void pcache1TruncateUnsafe(\n  PCache1 *pCache,             /* The cache to truncate */\n  unsigned int iLimit          /* Drop pages with this pgno or larger */\n){\n  TESTONLY( int nPage = 0; )  /* To assert pCache->nPage is correct */\n  unsigned int h, iStop;\n  assert( sqlite3_mutex_held(pCache->pGroup->mutex) );\n  assert( pCache->iMaxKey >= iLimit );\n  assert( pCache->nHash > 0 );\n  if( pCache->iMaxKey - iLimit < pCache->nHash ){\n    /* If we are just shaving the last few pages off the end of the\n    ** cache, then there is no point in scanning the entire hash table.\n    ** Only scan those hash slots that might contain pages that need to\n    ** be removed. */\n    h = iLimit % pCache->nHash;\n    iStop = pCache->iMaxKey % pCache->nHash;\n    TESTONLY( nPage = -10; )  /* Disable the pCache->nPage validity check */\n  }else{\n    /* This is the general case where many pages are being removed.\n    ** It is necessary to scan the entire hash table */\n    h = pCache->nHash/2;\n    iStop = h - 1;\n  }\n  for(;;){\n    PgHdr1 **pp;\n    PgHdr1 *pPage;\n    assert( h<pCache->nHash );\n    pp = &pCache->apHash[h];\n    while( (pPage = *pp)!=0 ){\n      if( pPage->iKey>=iLimit ){\n        pCache->nPage--;\n        *pp = pPage->pNext;\n        if( PAGE_IS_UNPINNED(pPage) ) pcache1PinPage(pPage);\n        pcache1FreePage(pPage);\n      }else{\n        pp = &pPage->pNext;\n        TESTONLY( if( nPage>=0 ) nPage++; )\n      }\n    }\n    if( h==iStop ) break;\n    h = (h+1) % pCache->nHash;\n  }\n  assert( nPage<0 || pCache->nPage==(unsigned)nPage );\n}\n\n/******************************************************************************/\n/******** sqlite3_pcache Methods **********************************************/\n\n/*\n** Implementation of the sqlite3_pcache.xInit method.\n*/\nstatic int pcache1Init(void *NotUsed){\n  UNUSED_PARAMETER(NotUsed);\n  assert( pcache1.isInit==0 );\n  memset(&pcache1, 0, sizeof(pcache1));\n\n\n  /*\n  ** The pcache1.separateCache variable is true if each PCache has its own\n  ** private PGroup (mode-1).  pcache1.separateCache is false if the single\n  ** PGroup in pcache1.grp is used for all page caches (mode-2).\n  **\n  **   *  Always use a unified cache (mode-2) if ENABLE_MEMORY_MANAGEMENT\n  **\n  **   *  Use a unified cache in single-threaded applications that have\n  **      configured a start-time buffer for use as page-cache memory using\n  **      sqlite3_config(SQLITE_CONFIG_PAGECACHE, pBuf, sz, N) with non-NULL\n  **      pBuf argument.\n  **\n  **   *  Otherwise use separate caches (mode-1)\n  */\n#if defined(SQLITE_ENABLE_MEMORY_MANAGEMENT)\n  pcache1.separateCache = 0;\n#elif SQLITE_THREADSAFE\n  pcache1.separateCache = sqlite3GlobalConfig.pPage==0\n                          || sqlite3GlobalConfig.bCoreMutex>0;\n#else\n  pcache1.separateCache = sqlite3GlobalConfig.pPage==0;\n#endif\n\n#if SQLITE_THREADSAFE\n  if( sqlite3GlobalConfig.bCoreMutex ){\n    pcache1.grp.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_LRU);\n    pcache1.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_PMEM);\n  }\n#endif\n  if( pcache1.separateCache\n   && sqlite3GlobalConfig.nPage!=0\n   && sqlite3GlobalConfig.pPage==0\n  ){\n    pcache1.nInitPage = sqlite3GlobalConfig.nPage;\n  }else{\n    pcache1.nInitPage = 0;\n  }\n  pcache1.grp.mxPinned = 10;\n  pcache1.isInit = 1;\n  return SQLITE_OK;\n}\n\n/*\n** Implementation of the sqlite3_pcache.xShutdown method.\n** Note that the static mutex allocated in xInit does\n** not need to be freed.\n*/\nstatic void pcache1Shutdown(void *NotUsed){\n  UNUSED_PARAMETER(NotUsed);\n  assert( pcache1.isInit!=0 );\n  memset(&pcache1, 0, sizeof(pcache1));\n}\n\n/* forward declaration */\nstatic void pcache1Destroy(sqlite3_pcache *p);\n\n/*\n** Implementation of the sqlite3_pcache.xCreate method.\n**\n** Allocate a new cache.\n*/\nstatic sqlite3_pcache *pcache1Create(int szPage, int szExtra, int bPurgeable){\n  PCache1 *pCache;      /* The newly created page cache */\n  PGroup *pGroup;       /* The group the new page cache will belong to */\n  i64 sz;               /* Bytes of memory required to allocate the new cache */\n\n  assert( (szPage & (szPage-1))==0 && szPage>=512 && szPage<=65536 );\n  assert( szExtra < 300 );\n\n  sz = sizeof(PCache1) + sizeof(PGroup)*pcache1.separateCache;\n  pCache = (PCache1 *)sqlite3MallocZero(sz);\n  if( pCache ){\n    if( pcache1.separateCache ){\n      pGroup = (PGroup*)&pCache[1];\n      pGroup->mxPinned = 10;\n    }else{\n      pGroup = &pcache1.grp;\n    }\n    pcache1EnterMutex(pGroup);\n    if( pGroup->lru.isAnchor==0 ){\n      pGroup->lru.isAnchor = 1;\n      pGroup->lru.pLruPrev = pGroup->lru.pLruNext = &pGroup->lru;\n    }\n    pCache->pGroup = pGroup;\n    pCache->szPage = szPage;\n    pCache->szExtra = szExtra;\n    pCache->szAlloc = szPage + szExtra + ROUND8(sizeof(PgHdr1));\n    pCache->bPurgeable = (bPurgeable ? 1 : 0);\n    pcache1ResizeHash(pCache);\n    if( bPurgeable ){\n      pCache->nMin = 10;\n      pGroup->nMinPage += pCache->nMin;\n      pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;\n      pCache->pnPurgeable = &pGroup->nPurgeable;\n    }else{\n      pCache->pnPurgeable = &pCache->nPurgeableDummy;\n    }\n    pcache1LeaveMutex(pGroup);\n    if( pCache->nHash==0 ){\n      pcache1Destroy((sqlite3_pcache*)pCache);\n      pCache = 0;\n    }\n  }\n  return (sqlite3_pcache *)pCache;\n}\n\n/*\n** Implementation of the sqlite3_pcache.xCachesize method.\n**\n** Configure the cache_size limit for a cache.\n*/\nstatic void pcache1Cachesize(sqlite3_pcache *p, int nMax){\n  PCache1 *pCache = (PCache1 *)p;\n  u32 n;\n  assert( nMax>=0 );\n  if( pCache->bPurgeable ){\n    PGroup *pGroup = pCache->pGroup;\n    pcache1EnterMutex(pGroup);\n    n = (u32)nMax;\n    if( n > 0x7fff0000 - pGroup->nMaxPage + pCache->nMax ){\n      n = 0x7fff0000 - pGroup->nMaxPage + pCache->nMax;\n    }\n    pGroup->nMaxPage += (n - pCache->nMax);\n    pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;\n    pCache->nMax = n;\n    pCache->n90pct = pCache->nMax*9/10;\n    pcache1EnforceMaxPage(pCache);\n    pcache1LeaveMutex(pGroup);\n  }\n}\n\n/*\n** Implementation of the sqlite3_pcache.xShrink method.\n**\n** Free up as much memory as possible.\n*/\nstatic void pcache1Shrink(sqlite3_pcache *p){\n  PCache1 *pCache = (PCache1*)p;\n  if( pCache->bPurgeable ){\n    PGroup *pGroup = pCache->pGroup;\n    unsigned int savedMaxPage;\n    pcache1EnterMutex(pGroup);\n    savedMaxPage = pGroup->nMaxPage;\n    pGroup->nMaxPage = 0;\n    pcache1EnforceMaxPage(pCache);\n    pGroup->nMaxPage = savedMaxPage;\n    pcache1LeaveMutex(pGroup);\n  }\n}\n\n/*\n** Implementation of the sqlite3_pcache.xPagecount method.\n*/\nstatic int pcache1Pagecount(sqlite3_pcache *p){\n  int n;\n  PCache1 *pCache = (PCache1*)p;\n  pcache1EnterMutex(pCache->pGroup);\n  n = pCache->nPage;\n  pcache1LeaveMutex(pCache->pGroup);\n  return n;\n}\n\n\n/*\n** Implement steps 3, 4, and 5 of the pcache1Fetch() algorithm described\n** in the header of the pcache1Fetch() procedure.\n**\n** This steps are broken out into a separate procedure because they are\n** usually not needed, and by avoiding the stack initialization required\n** for these steps, the main pcache1Fetch() procedure can run faster.\n*/\nstatic SQLITE_NOINLINE PgHdr1 *pcache1FetchStage2(\n  PCache1 *pCache,\n  unsigned int iKey,\n  int createFlag\n){\n  unsigned int nPinned;\n  PGroup *pGroup = pCache->pGroup;\n  PgHdr1 *pPage = 0;\n\n  /* Step 3: Abort if createFlag is 1 but the cache is nearly full */\n  assert( pCache->nPage >= pCache->nRecyclable );\n  nPinned = pCache->nPage - pCache->nRecyclable;\n  assert( pGroup->mxPinned == pGroup->nMaxPage + 10 - pGroup->nMinPage );\n  assert( pCache->n90pct == pCache->nMax*9/10 );\n  if( createFlag==1 && (\n        nPinned>=pGroup->mxPinned\n     || nPinned>=pCache->n90pct\n     || (pcache1UnderMemoryPressure(pCache) && pCache->nRecyclable<nPinned)\n  )){\n    return 0;\n  }\n\n  if( pCache->nPage>=pCache->nHash ) pcache1ResizeHash(pCache);\n  assert( pCache->nHash>0 && pCache->apHash );\n\n  /* Step 4. Try to recycle a page. */\n  if( pCache->bPurgeable\n   && !pGroup->lru.pLruPrev->isAnchor\n   && ((pCache->nPage+1>=pCache->nMax) || pcache1UnderMemoryPressure(pCache))\n  ){\n    PCache1 *pOther;\n    pPage = pGroup->lru.pLruPrev;\n    assert( PAGE_IS_UNPINNED(pPage) );\n    pcache1RemoveFromHash(pPage, 0);\n    pcache1PinPage(pPage);\n    pOther = pPage->pCache;\n    if( pOther->szAlloc != pCache->szAlloc ){\n      pcache1FreePage(pPage);\n      pPage = 0;\n    }else{\n      pGroup->nPurgeable -= (pOther->bPurgeable - pCache->bPurgeable);\n    }\n  }\n\n  /* Step 5. If a usable page buffer has still not been found,\n  ** attempt to allocate a new one.\n  */\n  if( !pPage ){\n    pPage = pcache1AllocPage(pCache, createFlag==1);\n  }\n\n  if( pPage ){\n    unsigned int h = iKey % pCache->nHash;\n    pCache->nPage++;\n    pPage->iKey = iKey;\n    pPage->pNext = pCache->apHash[h];\n    pPage->pCache = pCache;\n    pPage->pLruNext = 0;\n    /* pPage->pLruPrev = 0;\n    ** No need to clear pLruPrev since it is not accessed when pLruNext==0 */\n    *(void **)pPage->page.pExtra = 0;\n    pCache->apHash[h] = pPage;\n    if( iKey>pCache->iMaxKey ){\n      pCache->iMaxKey = iKey;\n    }\n  }\n  return pPage;\n}\n\n/*\n** Implementation of the sqlite3_pcache.xFetch method.\n**\n** Fetch a page by key value.\n**\n** Whether or not a new page may be allocated by this function depends on\n** the value of the createFlag argument.  0 means do not allocate a new\n** page.  1 means allocate a new page if space is easily available.  2\n** means to try really hard to allocate a new page.\n**\n** For a non-purgeable cache (a cache used as the storage for an in-memory\n** database) there is really no difference between createFlag 1 and 2.  So\n** the calling function (pcache.c) will never have a createFlag of 1 on\n** a non-purgeable cache.\n**\n** There are three different approaches to obtaining space for a page,\n** depending on the value of parameter createFlag (which may be 0, 1 or 2).\n**\n**   1. Regardless of the value of createFlag, the cache is searched for a\n**      copy of the requested page. If one is found, it is returned.\n**\n**   2. If createFlag==0 and the page is not already in the cache, NULL is\n**      returned.\n**\n**   3. If createFlag is 1, and the page is not already in the cache, then\n**      return NULL (do not allocate a new page) if any of the following\n**      conditions are true:\n**\n**       (a) the number of pages pinned by the cache is greater than\n**           PCache1.nMax, or\n**\n**       (b) the number of pages pinned by the cache is greater than\n**           the sum of nMax for all purgeable caches, less the sum of\n**           nMin for all other purgeable caches, or\n**\n**   4. If none of the first three conditions apply and the cache is marked\n**      as purgeable, and if one of the following is true:\n**\n**       (a) The number of pages allocated for the cache is already\n**           PCache1.nMax, or\n**\n**       (b) The number of pages allocated for all purgeable caches is\n**           already equal to or greater than the sum of nMax for all\n**           purgeable caches,\n**\n**       (c) The system is under memory pressure and wants to avoid\n**           unnecessary pages cache entry allocations\n**\n**      then attempt to recycle a page from the LRU list. If it is the right\n**      size, return the recycled buffer. Otherwise, free the buffer and\n**      proceed to step 5.\n**\n**   5. Otherwise, allocate and return a new page buffer.\n**\n** There are two versions of this routine.  pcache1FetchWithMutex() is\n** the general case.  pcache1FetchNoMutex() is a faster implementation for\n** the common case where pGroup->mutex is NULL.  The pcache1Fetch() wrapper\n** invokes the appropriate routine.\n*/\nstatic PgHdr1 *pcache1FetchNoMutex(\n  sqlite3_pcache *p,\n  unsigned int iKey,\n  int createFlag\n){\n  PCache1 *pCache = (PCache1 *)p;\n  PgHdr1 *pPage = 0;\n\n  /* Step 1: Search the hash table for an existing entry. */\n  pPage = pCache->apHash[iKey % pCache->nHash];\n  while( pPage && pPage->iKey!=iKey ){ pPage = pPage->pNext; }\n\n  /* Step 2: If the page was found in the hash table, then return it.\n  ** If the page was not in the hash table and createFlag is 0, abort.\n  ** Otherwise (page not in hash and createFlag!=0) continue with\n  ** subsequent steps to try to create the page. */\n  if( pPage ){\n    if( PAGE_IS_UNPINNED(pPage) ){\n      return pcache1PinPage(pPage);\n    }else{\n      return pPage;\n    }\n  }else if( createFlag ){\n    /* Steps 3, 4, and 5 implemented by this subroutine */\n    return pcache1FetchStage2(pCache, iKey, createFlag);\n  }else{\n    return 0;\n  }\n}\n#if PCACHE1_MIGHT_USE_GROUP_MUTEX\nstatic PgHdr1 *pcache1FetchWithMutex(\n  sqlite3_pcache *p,\n  unsigned int iKey,\n  int createFlag\n){\n  PCache1 *pCache = (PCache1 *)p;\n  PgHdr1 *pPage;\n\n  pcache1EnterMutex(pCache->pGroup);\n  pPage = pcache1FetchNoMutex(p, iKey, createFlag);\n  assert( pPage==0 || pCache->iMaxKey>=iKey );\n  pcache1LeaveMutex(pCache->pGroup);\n  return pPage;\n}\n#endif\nstatic sqlite3_pcache_page *pcache1Fetch(\n  sqlite3_pcache *p,\n  unsigned int iKey,\n  int createFlag\n){\n#if PCACHE1_MIGHT_USE_GROUP_MUTEX || defined(SQLITE_DEBUG)\n  PCache1 *pCache = (PCache1 *)p;\n#endif\n\n  assert( offsetof(PgHdr1,page)==0 );\n  assert( pCache->bPurgeable || createFlag!=1 );\n  assert( pCache->bPurgeable || pCache->nMin==0 );\n  assert( pCache->bPurgeable==0 || pCache->nMin==10 );\n  assert( pCache->nMin==0 || pCache->bPurgeable );\n  assert( pCache->nHash>0 );\n#if PCACHE1_MIGHT_USE_GROUP_MUTEX\n  if( pCache->pGroup->mutex ){\n    return (sqlite3_pcache_page*)pcache1FetchWithMutex(p, iKey, createFlag);\n  }else\n#endif\n  {\n    return (sqlite3_pcache_page*)pcache1FetchNoMutex(p, iKey, createFlag);\n  }\n}\n\n\n/*\n** Implementation of the sqlite3_pcache.xUnpin method.\n**\n** Mark a page as unpinned (eligible for asynchronous recycling).\n*/\nstatic void pcache1Unpin(\n  sqlite3_pcache *p,\n  sqlite3_pcache_page *pPg,\n  int reuseUnlikely\n){\n  PCache1 *pCache = (PCache1 *)p;\n  PgHdr1 *pPage = (PgHdr1 *)pPg;\n  PGroup *pGroup = pCache->pGroup;\n\n  assert( pPage->pCache==pCache );\n  pcache1EnterMutex(pGroup);\n\n  /* It is an error to call this function if the page is already\n  ** part of the PGroup LRU list.\n  */\n  assert( pPage->pLruNext==0 );\n  assert( PAGE_IS_PINNED(pPage) );\n\n  if( reuseUnlikely || pGroup->nPurgeable>pGroup->nMaxPage ){\n    pcache1RemoveFromHash(pPage, 1);\n  }else{\n    /* Add the page to the PGroup LRU list. */\n    PgHdr1 **ppFirst = &pGroup->lru.pLruNext;\n    pPage->pLruPrev = &pGroup->lru;\n    (pPage->pLruNext = *ppFirst)->pLruPrev = pPage;\n    *ppFirst = pPage;\n    pCache->nRecyclable++;\n  }\n\n  pcache1LeaveMutex(pCache->pGroup);\n}\n\n/*\n** Implementation of the sqlite3_pcache.xRekey method.\n*/\nstatic void pcache1Rekey(\n  sqlite3_pcache *p,\n  sqlite3_pcache_page *pPg,\n  unsigned int iOld,\n  unsigned int iNew\n){\n  PCache1 *pCache = (PCache1 *)p;\n  PgHdr1 *pPage = (PgHdr1 *)pPg;\n  PgHdr1 **pp;\n  unsigned int hOld, hNew;\n  assert( pPage->iKey==iOld );\n  assert( pPage->pCache==pCache );\n  assert( iOld!=iNew );               /* The page number really is changing */\n\n  pcache1EnterMutex(pCache->pGroup);\n\n  assert( pcache1FetchNoMutex(p, iOld, 0)==pPage ); /* pPg really is iOld */\n  hOld = iOld%pCache->nHash;\n  pp = &pCache->apHash[hOld];\n  while( (*pp)!=pPage ){\n    pp = &(*pp)->pNext;\n  }\n  *pp = pPage->pNext;\n\n  assert( pcache1FetchNoMutex(p, iNew, 0)==0 ); /* iNew not in cache */\n  hNew = iNew%pCache->nHash;\n  pPage->iKey = iNew;\n  pPage->pNext = pCache->apHash[hNew];\n  pCache->apHash[hNew] = pPage;\n  if( iNew>pCache->iMaxKey ){\n    pCache->iMaxKey = iNew;\n  }\n\n  pcache1LeaveMutex(pCache->pGroup);\n}\n\n/*\n** Implementation of the sqlite3_pcache.xTruncate method.\n**\n** Discard all unpinned pages in the cache with a page number equal to\n** or greater than parameter iLimit. Any pinned pages with a page number\n** equal to or greater than iLimit are implicitly unpinned.\n*/\nstatic void pcache1Truncate(sqlite3_pcache *p, unsigned int iLimit){\n  PCache1 *pCache = (PCache1 *)p;\n  pcache1EnterMutex(pCache->pGroup);\n  if( iLimit<=pCache->iMaxKey ){\n    pcache1TruncateUnsafe(pCache, iLimit);\n    pCache->iMaxKey = iLimit-1;\n  }\n  pcache1LeaveMutex(pCache->pGroup);\n}\n\n/*\n** Implementation of the sqlite3_pcache.xDestroy method.\n**\n** Destroy a cache allocated using pcache1Create().\n*/\nstatic void pcache1Destroy(sqlite3_pcache *p){\n  PCache1 *pCache = (PCache1 *)p;\n  PGroup *pGroup = pCache->pGroup;\n  assert( pCache->bPurgeable || (pCache->nMax==0 && pCache->nMin==0) );\n  pcache1EnterMutex(pGroup);\n  if( pCache->nPage ) pcache1TruncateUnsafe(pCache, 0);\n  assert( pGroup->nMaxPage >= pCache->nMax );\n  pGroup->nMaxPage -= pCache->nMax;\n  assert( pGroup->nMinPage >= pCache->nMin );\n  pGroup->nMinPage -= pCache->nMin;\n  pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;\n  pcache1EnforceMaxPage(pCache);\n  pcache1LeaveMutex(pGroup);\n  sqlite3_free(pCache->pBulk);\n  sqlite3_free(pCache->apHash);\n  sqlite3_free(pCache);\n}\n\n/*\n** This function is called during initialization (sqlite3_initialize()) to\n** install the default pluggable cache module, assuming the user has not\n** already provided an alternative.\n*/\nvoid sqlite3PCacheSetDefault(void){\n  static const sqlite3_pcache_methods2 defaultMethods = {\n    1,                       /* iVersion */\n    0,                       /* pArg */\n    pcache1Init,             /* xInit */\n    pcache1Shutdown,         /* xShutdown */\n    pcache1Create,           /* xCreate */\n    pcache1Cachesize,        /* xCachesize */\n    pcache1Pagecount,        /* xPagecount */\n    pcache1Fetch,            /* xFetch */\n    pcache1Unpin,            /* xUnpin */\n    pcache1Rekey,            /* xRekey */\n    pcache1Truncate,         /* xTruncate */\n    pcache1Destroy,          /* xDestroy */\n    pcache1Shrink            /* xShrink */\n  };\n  sqlite3_config(SQLITE_CONFIG_PCACHE2, &defaultMethods);\n}\n\n/*\n** Return the size of the header on each page of this PCACHE implementation.\n*/\nint sqlite3HeaderSizePcache1(void){ return ROUND8(sizeof(PgHdr1)); }\n\n/*\n** Return the global mutex used by this PCACHE implementation.  The\n** sqlite3_status() routine needs access to this mutex.\n*/\nsqlite3_mutex *sqlite3Pcache1Mutex(void){\n  return pcache1.mutex;\n}\n\n#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT\n/*\n** This function is called to free superfluous dynamically allocated memory\n** held by the pager system. Memory in use by any SQLite pager allocated\n** by the current thread may be sqlite3_free()ed.\n**\n** nReq is the number of bytes of memory required. Once this much has\n** been released, the function returns. The return value is the total number\n** of bytes of memory released.\n*/\nint sqlite3PcacheReleaseMemory(int nReq){\n  int nFree = 0;\n  assert( sqlite3_mutex_notheld(pcache1.grp.mutex) );\n  assert( sqlite3_mutex_notheld(pcache1.mutex) );\n  if( sqlite3GlobalConfig.pPage==0 ){\n    PgHdr1 *p;\n    pcache1EnterMutex(&pcache1.grp);\n    while( (nReq<0 || nFree<nReq)\n       &&  (p=pcache1.grp.lru.pLruPrev)!=0\n       &&  p->isAnchor==0\n    ){\n      nFree += pcache1MemSize(p->page.pBuf);\n      assert( PAGE_IS_UNPINNED(p) );\n      pcache1PinPage(p);\n      pcache1RemoveFromHash(p, 1);\n    }\n    pcache1LeaveMutex(&pcache1.grp);\n  }\n  return nFree;\n}\n#endif /* SQLITE_ENABLE_MEMORY_MANAGEMENT */\n\n#ifdef SQLITE_TEST\n/*\n** This function is used by test procedures to inspect the internal state\n** of the global cache.\n*/\nvoid sqlite3PcacheStats(\n  int *pnCurrent,      /* OUT: Total number of pages cached */\n  int *pnMax,          /* OUT: Global maximum cache size */\n  int *pnMin,          /* OUT: Sum of PCache1.nMin for purgeable caches */\n  int *pnRecyclable    /* OUT: Total number of pages available for recycling */\n){\n  PgHdr1 *p;\n  int nRecyclable = 0;\n  for(p=pcache1.grp.lru.pLruNext; p && !p->isAnchor; p=p->pLruNext){\n    assert( PAGE_IS_UNPINNED(p) );\n    nRecyclable++;\n  }\n  *pnCurrent = pcache1.grp.nPurgeable;\n  *pnMax = (int)pcache1.grp.nMaxPage;\n  *pnMin = (int)pcache1.grp.nMinPage;\n  *pnRecyclable = nRecyclable;\n}\n#endif\n"}
{"repo": "sqlite", "file": "test_backup.c", "lang": "C++", "code": "/*\n** 2009 January 28\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains test logic for the sqlite3_backup() interface.\n**\n*/\n\n#include \"tclsqlite.h\"\n#include \"sqlite3.h\"\n#include <assert.h>\n\n/* These functions are implemented in main.c. */\nextern const char *sqlite3ErrName(int);\n\n/* These functions are implemented in test1.c. */\nextern int getDbPointer(Tcl_Interp *, const char *, sqlite3 **);\n\nstatic int SQLITE_TCLAPI backupTestCmd(\n  ClientData clientData, \n  Tcl_Interp *interp, \n  int objc,\n  Tcl_Obj *const*objv\n){\n  enum BackupSubCommandEnum {\n    BACKUP_STEP, BACKUP_FINISH, BACKUP_REMAINING, BACKUP_PAGECOUNT\n  };\n  struct BackupSubCommand {\n    const char *zCmd;\n    enum BackupSubCommandEnum eCmd;\n    int nArg;\n    const char *zArg;\n  } aSub[] = {\n    {\"step\",      BACKUP_STEP      , 1, \"npage\" },\n    {\"finish\",    BACKUP_FINISH    , 0, \"\"      },\n    {\"remaining\", BACKUP_REMAINING , 0, \"\"      },\n    {\"pagecount\", BACKUP_PAGECOUNT , 0, \"\"      },\n    {0, 0, 0, 0}\n  };\n\n  sqlite3_backup *p = (sqlite3_backup *)clientData;\n  int iCmd;\n  int rc;\n\n  rc = Tcl_GetIndexFromObjStruct(\n      interp, objv[1], aSub, sizeof(aSub[0]), \"option\", 0, &iCmd\n  );\n  if( rc!=TCL_OK ){\n    return rc;\n  }\n  if( objc!=(2 + aSub[iCmd].nArg) ){\n    Tcl_WrongNumArgs(interp, 2, objv, aSub[iCmd].zArg);\n    return TCL_ERROR;\n  }\n\n  switch( aSub[iCmd].eCmd ){\n\n    case BACKUP_FINISH: {\n      const char *zCmdName;\n      Tcl_CmdInfo cmdInfo;\n      zCmdName = Tcl_GetString(objv[0]);\n      Tcl_GetCommandInfo(interp, zCmdName, &cmdInfo);\n      cmdInfo.deleteProc = 0;\n      Tcl_SetCommandInfo(interp, zCmdName, &cmdInfo);\n      Tcl_DeleteCommand(interp, zCmdName);\n\n      rc = sqlite3_backup_finish(p);\n      Tcl_SetResult(interp, (char *)sqlite3ErrName(rc), TCL_STATIC);\n      break;\n    }\n\n    case BACKUP_STEP: {\n      int nPage;\n      if( TCL_OK!=Tcl_GetIntFromObj(interp, objv[2], &nPage) ){\n        return TCL_ERROR;\n      }\n      rc = sqlite3_backup_step(p, nPage);\n      Tcl_SetResult(interp, (char *)sqlite3ErrName(rc), TCL_STATIC);\n      break;\n    }\n\n    case BACKUP_REMAINING:\n      Tcl_SetObjResult(interp, Tcl_NewIntObj(sqlite3_backup_remaining(p)));\n      break;\n\n    case BACKUP_PAGECOUNT:\n      Tcl_SetObjResult(interp, Tcl_NewIntObj(sqlite3_backup_pagecount(p)));\n      break;\n  }\n\n  return TCL_OK;\n}\n\nstatic void SQLITE_TCLAPI backupTestFinish(ClientData clientData){\n  sqlite3_backup *pBackup = (sqlite3_backup *)clientData;\n  sqlite3_backup_finish(pBackup);\n}\n\n/*\n**     sqlite3_backup CMDNAME DESTHANDLE DESTNAME SRCHANDLE SRCNAME\n**\n*/\nstatic int SQLITE_TCLAPI backupTestInit(\n  ClientData clientData, \n  Tcl_Interp *interp, \n  int objc,\n  Tcl_Obj *const*objv\n){\n  sqlite3_backup *pBackup;\n  sqlite3 *pDestDb;\n  sqlite3 *pSrcDb;\n  const char *zDestName;\n  const char *zSrcName;\n  const char *zCmd;\n\n  if( objc!=6 ){\n    Tcl_WrongNumArgs(\n      interp, 1, objv, \"CMDNAME DESTHANDLE DESTNAME SRCHANDLE SRCNAME\"\n    );\n    return TCL_ERROR;\n  }\n\n  zCmd = Tcl_GetString(objv[1]);\n  getDbPointer(interp, Tcl_GetString(objv[2]), &pDestDb);\n  zDestName = Tcl_GetString(objv[3]);\n  getDbPointer(interp, Tcl_GetString(objv[4]), &pSrcDb);\n  zSrcName = Tcl_GetString(objv[5]);\n\n  pBackup = sqlite3_backup_init(pDestDb, zDestName, pSrcDb, zSrcName);\n  if( !pBackup ){\n    Tcl_AppendResult(interp, \"sqlite3_backup_init() failed\", NULL);\n    return TCL_ERROR;\n  }\n\n  Tcl_CreateObjCommand(interp, zCmd, backupTestCmd, pBackup, backupTestFinish);\n  Tcl_SetObjResult(interp, objv[1]);\n  return TCL_OK;\n}\n\nint Sqlitetestbackup_Init(Tcl_Interp *interp){\n  Tcl_CreateObjCommand(interp, \"sqlite3_backup\", backupTestInit, 0, 0);\n  return TCL_OK;\n}\n"}
{"repo": "sqlite", "file": "update.c", "lang": "C++", "code": "/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains C code routines that are called by the parser\n** to handle UPDATE statements.\n*/\n#include \"sqliteInt.h\"\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n/* Forward declaration */\nstatic void updateVirtualTable(\n  Parse *pParse,       /* The parsing context */\n  SrcList *pSrc,       /* The virtual table to be modified */\n  Table *pTab,         /* The virtual table */\n  ExprList *pChanges,  /* The columns to change in the UPDATE statement */\n  Expr *pRowidExpr,    /* Expression used to recompute the rowid */\n  int *aXRef,          /* Mapping from columns of pTab to entries in pChanges */\n  Expr *pWhere,        /* WHERE clause of the UPDATE statement */\n  int onError          /* ON CONFLICT strategy */\n);\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n\n/*\n** The most recently coded instruction was an OP_Column to retrieve the\n** i-th column of table pTab. This routine sets the P4 parameter of the\n** OP_Column to the default value, if any.\n**\n** The default value of a column is specified by a DEFAULT clause in the\n** column definition. This was either supplied by the user when the table\n** was created, or added later to the table definition by an ALTER TABLE\n** command. If the latter, then the row-records in the table btree on disk\n** may not contain a value for the column and the default value, taken\n** from the P4 parameter of the OP_Column instruction, is returned instead.\n** If the former, then all row-records are guaranteed to include a value\n** for the column and the P4 value is not required.\n**\n** Column definitions created by an ALTER TABLE command may only have\n** literal default values specified: a number, null or a string. (If a more\n** complicated default expression value was provided, it is evaluated\n** when the ALTER TABLE is executed and one of the literal values written\n** into the sqlite_schema table.)\n**\n** Therefore, the P4 parameter is only required if the default value for\n** the column is a literal number, string or null. The sqlite3ValueFromExpr()\n** function is capable of transforming these types of expressions into\n** sqlite3_value objects.\n**\n** If column as REAL affinity and the table is an ordinary b-tree table\n** (not a virtual table) then the value might have been stored as an\n** integer.  In that case, add an OP_RealAffinity opcode to make sure\n** it has been converted into REAL.\n*/\nvoid sqlite3ColumnDefault(Vdbe *v, Table *pTab, int i, int iReg){\n  Column *pCol;\n  assert( pTab!=0 );\n  assert( pTab->nCol>i );\n  pCol = &pTab->aCol[i];\n  if( pCol->iDflt ){\n    sqlite3_value *pValue = 0;\n    u8 enc = ENC(sqlite3VdbeDb(v));\n    assert( !IsView(pTab) );\n    VdbeComment((v, \"%s.%s\", pTab->zName, pCol->zCnName));\n    assert( i<pTab->nCol );\n    sqlite3ValueFromExpr(sqlite3VdbeDb(v),\n                         sqlite3ColumnExpr(pTab,pCol), enc,\n                         pCol->affinity, &pValue);\n    if( pValue ){\n      sqlite3VdbeAppendP4(v, pValue, P4_MEM);\n    }\n  }\n#ifndef SQLITE_OMIT_FLOATING_POINT\n  if( pCol->affinity==SQLITE_AFF_REAL && !IsVirtual(pTab) ){\n    sqlite3VdbeAddOp1(v, OP_RealAffinity, iReg);\n  }\n#endif\n}\n\n/*\n** Check to see if column iCol of index pIdx references any of the\n** columns defined by aXRef and chngRowid.  Return true if it does\n** and false if not.  This is an optimization.  False-positives are a\n** performance degradation, but false-negatives can result in a corrupt\n** index and incorrect answers.\n**\n** aXRef[j] will be non-negative if column j of the original table is\n** being updated.  chngRowid will be true if the rowid of the table is\n** being updated.\n*/\nstatic int indexColumnIsBeingUpdated(\n  Index *pIdx,      /* The index to check */\n  int iCol,         /* Which column of the index to check */\n  int *aXRef,       /* aXRef[j]>=0 if column j is being updated */\n  int chngRowid     /* true if the rowid is being updated */\n){\n  i16 iIdxCol = pIdx->aiColumn[iCol];\n  assert( iIdxCol!=XN_ROWID ); /* Cannot index rowid */\n  if( iIdxCol>=0 ){\n    return aXRef[iIdxCol]>=0;\n  }\n  assert( iIdxCol==XN_EXPR );\n  assert( pIdx->aColExpr!=0 );\n  assert( pIdx->aColExpr->a[iCol].pExpr!=0 );\n  return sqlite3ExprReferencesUpdatedColumn(pIdx->aColExpr->a[iCol].pExpr,\n                                            aXRef,chngRowid);\n}\n\n/*\n** Check to see if index pIdx is a partial index whose conditional\n** expression might change values due to an UPDATE.  Return true if\n** the index is subject to change and false if the index is guaranteed\n** to be unchanged.  This is an optimization.  False-positives are a\n** performance degradation, but false-negatives can result in a corrupt\n** index and incorrect answers.\n**\n** aXRef[j] will be non-negative if column j of the original table is\n** being updated.  chngRowid will be true if the rowid of the table is\n** being updated.\n*/\nstatic int indexWhereClauseMightChange(\n  Index *pIdx,      /* The index to check */\n  int *aXRef,       /* aXRef[j]>=0 if column j is being updated */\n  int chngRowid     /* true if the rowid is being updated */\n){\n  if( pIdx->pPartIdxWhere==0 ) return 0;\n  return sqlite3ExprReferencesUpdatedColumn(pIdx->pPartIdxWhere,\n                                            aXRef, chngRowid);\n}\n\n/*\n** Allocate and return a pointer to an expression of type TK_ROW with\n** Expr.iColumn set to value (iCol+1). The resolver will modify the\n** expression to be a TK_COLUMN reading column iCol of the first\n** table in the source-list (pSrc->a[0]).\n*/\nstatic Expr *exprRowColumn(Parse *pParse, int iCol){\n  Expr *pRet = sqlite3PExpr(pParse, TK_ROW, 0, 0);\n  if( pRet ) pRet->iColumn = iCol+1;\n  return pRet;\n}\n\n/*\n** Assuming both the pLimit and pOrderBy parameters are NULL, this function\n** generates VM code to run the query:\n**\n**   SELECT <other-columns>, pChanges FROM pTabList WHERE pWhere\n**\n** and write the results to the ephemeral table already opened as cursor\n** iEph. None of pChanges, pTabList or pWhere are modified or consumed by\n** this function, they must be deleted by the caller.\n**\n** Or, if pLimit and pOrderBy are not NULL, and pTab is not a view:\n**\n**   SELECT <other-columns>, pChanges FROM pTabList\n**   WHERE pWhere\n**   GROUP BY <other-columns>\n**   ORDER BY pOrderBy LIMIT pLimit\n**\n** If pTab is a view, the GROUP BY clause is omitted.\n**\n** Exactly how results are written to table iEph, and exactly what\n** the <other-columns> in the query above are is determined by the type\n** of table pTabList->a[0].pTab.\n**\n** If the table is a WITHOUT ROWID table, then argument pPk must be its\n** PRIMARY KEY. In this case <other-columns> are the primary key columns\n** of the table, in order. The results of the query are written to ephemeral\n** table iEph as index keys, using OP_IdxInsert.\n**\n** If the table is actually a view, then <other-columns> are all columns of\n** the view. The results are written to the ephemeral table iEph as records\n** with automatically assigned integer keys.\n**\n** If the table is a virtual or ordinary intkey table, then <other-columns>\n** is its rowid. For a virtual table, the results are written to iEph as\n** records with automatically assigned integer keys For intkey tables, the\n** rowid value in <other-columns> is used as the integer key, and the\n** remaining fields make up the table record.\n*/\nstatic void updateFromSelect(\n  Parse *pParse,                  /* Parse context */\n  int iEph,                       /* Cursor for open eph. table */\n  Index *pPk,                     /* PK if table 0 is WITHOUT ROWID */\n  ExprList *pChanges,             /* List of expressions to return */\n  SrcList *pTabList,              /* List of tables to select from */\n  Expr *pWhere,                   /* WHERE clause for query */\n  ExprList *pOrderBy,             /* ORDER BY clause */\n  Expr *pLimit                    /* LIMIT clause */\n){\n  int i;\n  SelectDest dest;\n  Select *pSelect = 0;\n  ExprList *pList = 0;\n  ExprList *pGrp = 0;\n  Expr *pLimit2 = 0;\n  ExprList *pOrderBy2 = 0;\n  sqlite3 *db = pParse->db;\n  Table *pTab = pTabList->a[0].pSTab;\n  SrcList *pSrc;\n  Expr *pWhere2;\n  int eDest;\n\n#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT\n  if( pOrderBy && pLimit==0 ) {\n    sqlite3ErrorMsg(pParse, \"ORDER BY without LIMIT on UPDATE\");\n    return;\n  }\n  pOrderBy2 = sqlite3ExprListDup(db, pOrderBy, 0);\n  pLimit2 = sqlite3ExprDup(db, pLimit, 0);\n#else\n  UNUSED_PARAMETER(pOrderBy);\n  UNUSED_PARAMETER(pLimit);\n#endif\n\n  pSrc = sqlite3SrcListDup(db, pTabList, 0);\n  pWhere2 = sqlite3ExprDup(db, pWhere, 0);\n\n  assert( pTabList->nSrc>1 );\n  if( pSrc ){\n    assert( pSrc->a[0].fg.notCte );\n    pSrc->a[0].iCursor = -1;\n    pSrc->a[0].pSTab->nTabRef--;\n    pSrc->a[0].pSTab = 0;\n  }\n  if( pPk ){\n    for(i=0; i<pPk->nKeyCol; i++){\n      Expr *pNew = exprRowColumn(pParse, pPk->aiColumn[i]);\n#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT\n      if( pLimit ){\n        pGrp = sqlite3ExprListAppend(pParse, pGrp, sqlite3ExprDup(db, pNew, 0));\n      }\n#endif\n      pList = sqlite3ExprListAppend(pParse, pList, pNew);\n    }\n    eDest = IsVirtual(pTab) ? SRT_Table : SRT_Upfrom;\n  }else if( IsView(pTab) ){\n    for(i=0; i<pTab->nCol; i++){\n      pList = sqlite3ExprListAppend(pParse, pList, exprRowColumn(pParse, i));\n    }\n    eDest = SRT_Table;\n  }else{\n    eDest = IsVirtual(pTab) ? SRT_Table : SRT_Upfrom;\n    pList = sqlite3ExprListAppend(pParse, 0, sqlite3PExpr(pParse,TK_ROW,0,0));\n#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT\n    if( pLimit ){\n      pGrp = sqlite3ExprListAppend(pParse, 0, sqlite3PExpr(pParse,TK_ROW,0,0));\n    }\n#endif\n  }\n  assert( pChanges!=0 || pParse->db->mallocFailed );\n  if( pChanges ){\n    for(i=0; i<pChanges->nExpr; i++){\n      pList = sqlite3ExprListAppend(pParse, pList,\n          sqlite3ExprDup(db, pChanges->a[i].pExpr, 0)\n      );\n    }\n  }\n  pSelect = sqlite3SelectNew(pParse, pList,\n      pSrc, pWhere2, pGrp, 0, pOrderBy2,\n      SF_UFSrcCheck|SF_IncludeHidden|SF_UpdateFrom, pLimit2\n  );\n  if( pSelect ) pSelect->selFlags |= SF_OrderByReqd;\n  sqlite3SelectDestInit(&dest, eDest, iEph);\n  dest.iSDParm2 = (pPk ? pPk->nKeyCol : -1);\n  sqlite3Select(pParse, pSelect, &dest);\n  sqlite3SelectDelete(db, pSelect);\n}\n\n/*\n** Process an UPDATE statement.\n**\n**   UPDATE OR IGNORE tbl SET a=b, c=d FROM tbl2... WHERE e<5 AND f NOT NULL;\n**          \\_______/ \\_/     \\______/      \\_____/       \\________________/\n**           onError   |      pChanges         |                pWhere\n**                     \\_______________________/\n**                               pTabList\n*/\nvoid sqlite3Update(\n  Parse *pParse,         /* The parser context */\n  SrcList *pTabList,     /* The table in which we should change things */\n  ExprList *pChanges,    /* Things to be changed */\n  Expr *pWhere,          /* The WHERE clause.  May be null */\n  int onError,           /* How to handle constraint errors */\n  ExprList *pOrderBy,    /* ORDER BY clause. May be null */\n  Expr *pLimit,          /* LIMIT clause. May be null */\n  Upsert *pUpsert        /* ON CONFLICT clause, or null */\n){\n  int i, j, k;           /* Loop counters */\n  Table *pTab;           /* The table to be updated */\n  int addrTop = 0;       /* VDBE instruction address of the start of the loop */\n  WhereInfo *pWInfo = 0; /* Information about the WHERE clause */\n  Vdbe *v;               /* The virtual database engine */\n  Index *pIdx;           /* For looping over indices */\n  Index *pPk;            /* The PRIMARY KEY index for WITHOUT ROWID tables */\n  int nIdx;              /* Number of indices that need updating */\n  int nAllIdx;           /* Total number of indexes */\n  int iBaseCur;          /* Base cursor number */\n  int iDataCur;          /* Cursor for the canonical data btree */\n  int iIdxCur;           /* Cursor for the first index */\n  sqlite3 *db;           /* The database structure */\n  int *aRegIdx = 0;      /* Registers for to each index and the main table */\n  int *aXRef = 0;        /* aXRef[i] is the index in pChanges->a[] of the\n                         ** an expression for the i-th column of the table.\n                         ** aXRef[i]==-1 if the i-th column is not changed. */\n  u8 *aToOpen;           /* 1 for tables and indices to be opened */\n  u8 chngPk;             /* PRIMARY KEY changed in a WITHOUT ROWID table */\n  u8 chngRowid;          /* Rowid changed in a normal table */\n  u8 chngKey;            /* Either chngPk or chngRowid */\n  Expr *pRowidExpr = 0;  /* Expression defining the new record number */\n  int iRowidExpr = -1;   /* Index of \"rowid=\" (or IPK) assignment in pChanges */\n  AuthContext sContext;  /* The authorization context */\n  NameContext sNC;       /* The name-context to resolve expressions in */\n  int iDb;               /* Database containing the table being updated */\n  int eOnePass;          /* ONEPASS_XXX value from where.c */\n  int hasFK;             /* True if foreign key processing is required */\n  int labelBreak;        /* Jump here to break out of UPDATE loop */\n  int labelContinue;     /* Jump here to continue next step of UPDATE loop */\n  int flags;             /* Flags for sqlite3WhereBegin() */\n\n#ifndef SQLITE_OMIT_TRIGGER\n  int isView;            /* True when updating a view (INSTEAD OF trigger) */\n  Trigger *pTrigger;     /* List of triggers on pTab, if required */\n  int tmask;             /* Mask of TRIGGER_BEFORE|TRIGGER_AFTER */\n#endif\n  int newmask;           /* Mask of NEW.* columns accessed by BEFORE triggers */\n  int iEph = 0;          /* Ephemeral table holding all primary key values */\n  int nKey = 0;          /* Number of elements in regKey for WITHOUT ROWID */\n  int aiCurOnePass[2];   /* The write cursors opened by WHERE_ONEPASS */\n  int addrOpen = 0;      /* Address of OP_OpenEphemeral */\n  int iPk = 0;           /* First of nPk cells holding PRIMARY KEY value */\n  i16 nPk = 0;           /* Number of components of the PRIMARY KEY */\n  int bReplace = 0;      /* True if REPLACE conflict resolution might happen */\n  int bFinishSeek = 1;   /* The OP_FinishSeek opcode is needed */\n  int nChangeFrom = 0;   /* If there is a FROM, pChanges->nExpr, else 0 */\n\n  /* Register Allocations */\n  int regRowCount = 0;   /* A count of rows changed */\n  int regOldRowid = 0;   /* The old rowid */\n  int regNewRowid = 0;   /* The new rowid */\n  int regNew = 0;        /* Content of the NEW.* table in triggers */\n  int regOld = 0;        /* Content of OLD.* table in triggers */\n  int regRowSet = 0;     /* Rowset of rows to be updated */\n  int regKey = 0;        /* composite PRIMARY KEY value */\n\n  memset(&sContext, 0, sizeof(sContext));\n  db = pParse->db;\n  assert( db->pParse==pParse );\n  if( pParse->nErr ){\n    goto update_cleanup;\n  }\n  assert( db->mallocFailed==0 );\n\n  /* Locate the table which we want to update.\n  */\n  pTab = sqlite3SrcListLookup(pParse, pTabList);\n  if( pTab==0 ) goto update_cleanup;\n  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n\n  /* Figure out if we have any triggers and if the table being\n  ** updated is a view.\n  */\n#ifndef SQLITE_OMIT_TRIGGER\n  pTrigger = sqlite3TriggersExist(pParse, pTab, TK_UPDATE, pChanges, &tmask);\n  isView = IsView(pTab);\n  assert( pTrigger || tmask==0 );\n#else\n# define pTrigger 0\n# define isView 0\n# define tmask 0\n#endif\n#ifdef SQLITE_OMIT_VIEW\n# undef isView\n# define isView 0\n#endif\n\n#if TREETRACE_ENABLED\n  if( sqlite3TreeTrace & 0x10000 ){\n    sqlite3TreeViewLine(0, \"In sqlite3Update() at %s:%d\", __FILE__, __LINE__);\n    sqlite3TreeViewUpdate(pParse->pWith, pTabList, pChanges, pWhere,\n                          onError, pOrderBy, pLimit, pUpsert, pTrigger);\n  }\n#endif\n\n  /* If there was a FROM clause, set nChangeFrom to the number of expressions\n  ** in the change-list. Otherwise, set it to 0. There cannot be a FROM\n  ** clause if this function is being called to generate code for part of\n  ** an UPSERT statement.  */\n  nChangeFrom = (pTabList->nSrc>1) ? pChanges->nExpr : 0;\n  assert( nChangeFrom==0 || pUpsert==0 );\n\n#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT\n  if( !isView && nChangeFrom==0 ){\n    pWhere = sqlite3LimitWhere(\n        pParse, pTabList, pWhere, pOrderBy, pLimit, \"UPDATE\"\n    );\n    pOrderBy = 0;\n    pLimit = 0;\n  }\n#endif\n\n  if( sqlite3ViewGetColumnNames(pParse, pTab) ){\n    goto update_cleanup;\n  }\n  if( sqlite3IsReadOnly(pParse, pTab, pTrigger) ){\n    goto update_cleanup;\n  }\n\n  /* Allocate a cursors for the main database table and for all indices.\n  ** The index cursors might not be used, but if they are used they\n  ** need to occur right after the database cursor.  So go ahead and\n  ** allocate enough space, just in case.\n  */\n  iBaseCur = iDataCur = pParse->nTab++;\n  iIdxCur = iDataCur+1;\n  pPk = HasRowid(pTab) ? 0 : sqlite3PrimaryKeyIndex(pTab);\n  testcase( pPk!=0 && pPk!=pTab->pIndex );\n  for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){\n    if( pPk==pIdx ){\n      iDataCur = pParse->nTab;\n    }\n    pParse->nTab++;\n  }\n  if( pUpsert ){\n    /* On an UPSERT, reuse the same cursors already opened by INSERT */\n    iDataCur = pUpsert->iDataCur;\n    iIdxCur = pUpsert->iIdxCur;\n    pParse->nTab = iBaseCur;\n  }\n  pTabList->a[0].iCursor = iDataCur;\n\n  /* Allocate space for aXRef[], aRegIdx[], and aToOpen[].\n  ** Initialize aXRef[] and aToOpen[] to their default values.\n  */\n  aXRef = sqlite3DbMallocRawNN(db, sizeof(int) * (pTab->nCol+nIdx+1) + nIdx+2 );\n  if( aXRef==0 ) goto update_cleanup;\n  aRegIdx = aXRef+pTab->nCol;\n  aToOpen = (u8*)(aRegIdx+nIdx+1);\n  memset(aToOpen, 1, nIdx+1);\n  aToOpen[nIdx+1] = 0;\n  for(i=0; i<pTab->nCol; i++) aXRef[i] = -1;\n\n  /* Initialize the name-context */\n  memset(&sNC, 0, sizeof(sNC));\n  sNC.pParse = pParse;\n  sNC.pSrcList = pTabList;\n  sNC.uNC.pUpsert = pUpsert;\n  sNC.ncFlags = NC_UUpsert;\n\n  /* Begin generating code. */\n  v = sqlite3GetVdbe(pParse);\n  if( v==0 ) goto update_cleanup;\n\n  /* Resolve the column names in all the expressions of the\n  ** of the UPDATE statement.  Also find the column index\n  ** for each column to be updated in the pChanges array.  For each\n  ** column to be updated, make sure we have authorization to change\n  ** that column.\n  */\n  chngRowid = chngPk = 0;\n  for(i=0; i<pChanges->nExpr; i++){\n    /* If this is an UPDATE with a FROM clause, do not resolve expressions\n    ** here. The call to sqlite3Select() below will do that. */\n    if( nChangeFrom==0 && sqlite3ResolveExprNames(&sNC, pChanges->a[i].pExpr) ){\n      goto update_cleanup;\n    }\n    j = sqlite3ColumnIndex(pTab, pChanges->a[i].zEName);\n    if( j>=0 ){\n      if( j==pTab->iPKey ){\n        chngRowid = 1;\n        pRowidExpr = pChanges->a[i].pExpr;\n        iRowidExpr = i;\n      }else if( pPk && (pTab->aCol[j].colFlags & COLFLAG_PRIMKEY)!=0 ){\n        chngPk = 1;\n      }\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n      else if( pTab->aCol[j].colFlags & COLFLAG_GENERATED ){\n        testcase( pTab->aCol[j].colFlags & COLFLAG_VIRTUAL );\n        testcase( pTab->aCol[j].colFlags & COLFLAG_STORED );\n        sqlite3ErrorMsg(pParse,\n           \"cannot UPDATE generated column \\\"%s\\\"\",\n           pTab->aCol[j].zCnName);\n        goto update_cleanup;\n      }\n#endif\n      aXRef[j] = i;\n    }else{\n      if( pPk==0 && sqlite3IsRowid(pChanges->a[i].zEName) ){\n        j = -1;\n        chngRowid = 1;\n        pRowidExpr = pChanges->a[i].pExpr;\n        iRowidExpr = i;\n      }else{\n        sqlite3ErrorMsg(pParse, \"no such column: %s\", pChanges->a[i].zEName);\n        pParse->checkSchema = 1;\n        goto update_cleanup;\n      }\n    }\n#ifndef SQLITE_OMIT_AUTHORIZATION\n    {\n      int rc;\n      rc = sqlite3AuthCheck(pParse, SQLITE_UPDATE, pTab->zName,\n                            j<0 ? \"ROWID\" : pTab->aCol[j].zCnName,\n                            db->aDb[iDb].zDbSName);\n      if( rc==SQLITE_DENY ){\n        goto update_cleanup;\n      }else if( rc==SQLITE_IGNORE ){\n        aXRef[j] = -1;\n      }\n    }\n#endif\n  }\n  assert( (chngRowid & chngPk)==0 );\n  assert( chngRowid==0 || chngRowid==1 );\n  assert( chngPk==0 || chngPk==1 );\n  chngKey = chngRowid + chngPk;\n\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n  /* Mark generated columns as changing if their generator expressions\n  ** reference any changing column.  The actual aXRef[] value for\n  ** generated expressions is not used, other than to check to see that it\n  ** is non-negative, so the value of aXRef[] for generated columns can be\n  ** set to any non-negative number.  We use 99999 so that the value is\n  ** obvious when looking at aXRef[] in a symbolic debugger.\n  */\n  if( pTab->tabFlags & TF_HasGenerated ){\n    int bProgress;\n    testcase( pTab->tabFlags & TF_HasVirtual );\n    testcase( pTab->tabFlags & TF_HasStored );\n    do{\n      bProgress = 0;\n      for(i=0; i<pTab->nCol; i++){\n        if( aXRef[i]>=0 ) continue;\n        if( (pTab->aCol[i].colFlags & COLFLAG_GENERATED)==0 ) continue;\n        if( sqlite3ExprReferencesUpdatedColumn(\n                sqlite3ColumnExpr(pTab, &pTab->aCol[i]),\n                 aXRef, chngRowid)\n        ){\n          aXRef[i] = 99999;\n          bProgress = 1;\n        }\n      }\n    }while( bProgress );\n  }\n#endif\n\n  /* The SET expressions are not actually used inside the WHERE loop.\n  ** So reset the colUsed mask. Unless this is a virtual table. In that\n  ** case, set all bits of the colUsed mask (to ensure that the virtual\n  ** table implementation makes all columns available).\n  */\n  pTabList->a[0].colUsed = IsVirtual(pTab) ? ALLBITS : 0;\n\n  hasFK = sqlite3FkRequired(pParse, pTab, aXRef, chngKey);\n\n  /* There is one entry in the aRegIdx[] array for each index on the table\n  ** being updated.  Fill in aRegIdx[] with a register number that will hold\n  ** the key for accessing each index.\n  */\n  if( onError==OE_Replace ) bReplace = 1;\n  for(nAllIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nAllIdx++){\n    int reg;\n    if( chngKey || hasFK>1 || pIdx==pPk\n     || indexWhereClauseMightChange(pIdx,aXRef,chngRowid)\n    ){\n      reg = ++pParse->nMem;\n      pParse->nMem += pIdx->nColumn;\n    }else{\n      reg = 0;\n      for(i=0; i<pIdx->nKeyCol; i++){\n        if( indexColumnIsBeingUpdated(pIdx, i, aXRef, chngRowid) ){\n          reg = ++pParse->nMem;\n          pParse->nMem += pIdx->nColumn;\n          if( onError==OE_Default && pIdx->onError==OE_Replace ){\n            bReplace = 1;\n          }\n          break;\n        }\n      }\n    }\n    if( reg==0 ) aToOpen[nAllIdx+1] = 0;\n    aRegIdx[nAllIdx] = reg;\n  }\n  aRegIdx[nAllIdx] = ++pParse->nMem;  /* Register storing the table record */\n  if( bReplace ){\n    /* If REPLACE conflict resolution might be invoked, open cursors on all\n    ** indexes in case they are needed to delete records.  */\n    memset(aToOpen, 1, nIdx+1);\n  }\n\n  if( pParse->nested==0 ) sqlite3VdbeCountChanges(v);\n  sqlite3BeginWriteOperation(pParse, pTrigger || hasFK, iDb);\n\n  /* Allocate required registers. */\n  if( !IsVirtual(pTab) ){\n    /* For now, regRowSet and aRegIdx[nAllIdx] share the same register.\n    ** If regRowSet turns out to be needed, then aRegIdx[nAllIdx] will be\n    ** reallocated.  aRegIdx[nAllIdx] is the register in which the main\n    ** table record is written.  regRowSet holds the RowSet for the\n    ** two-pass update algorithm. */\n    assert( aRegIdx[nAllIdx]==pParse->nMem );\n    regRowSet = aRegIdx[nAllIdx];\n    regOldRowid = regNewRowid = ++pParse->nMem;\n    if( chngPk || pTrigger || hasFK ){\n      regOld = pParse->nMem + 1;\n      pParse->nMem += pTab->nCol;\n    }\n    if( chngKey || pTrigger || hasFK ){\n      regNewRowid = ++pParse->nMem;\n    }\n    regNew = pParse->nMem + 1;\n    pParse->nMem += pTab->nCol;\n  }\n\n  /* Start the view context. */\n  if( isView ){\n    sqlite3AuthContextPush(pParse, &sContext, pTab->zName);\n  }\n\n  /* If we are trying to update a view, realize that view into\n  ** an ephemeral table.\n  */\n#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)\n  if( nChangeFrom==0 && isView ){\n    sqlite3MaterializeView(pParse, pTab,\n        pWhere, pOrderBy, pLimit, iDataCur\n    );\n    pOrderBy = 0;\n    pLimit = 0;\n  }\n#endif\n\n  /* Resolve the column names in all the expressions in the\n  ** WHERE clause.\n  */\n  if( nChangeFrom==0 && sqlite3ResolveExprNames(&sNC, pWhere) ){\n    goto update_cleanup;\n  }\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  /* Virtual tables must be handled separately */\n  if( IsVirtual(pTab) ){\n    updateVirtualTable(pParse, pTabList, pTab, pChanges, pRowidExpr, aXRef,\n                       pWhere, onError);\n    goto update_cleanup;\n  }\n#endif\n\n  /* Jump to labelBreak to abandon further processing of this UPDATE */\n  labelContinue = labelBreak = sqlite3VdbeMakeLabel(pParse);\n\n  /* Not an UPSERT.  Normal processing.  Begin by\n  ** initialize the count of updated rows */\n  if( (db->flags&SQLITE_CountRows)!=0\n   && !pParse->pTriggerTab\n   && !pParse->nested\n   && !pParse->bReturning\n   && pUpsert==0\n  ){\n    regRowCount = ++pParse->nMem;\n    sqlite3VdbeAddOp2(v, OP_Integer, 0, regRowCount);\n  }\n\n  if( nChangeFrom==0 && HasRowid(pTab) ){\n    sqlite3VdbeAddOp3(v, OP_Null, 0, regRowSet, regOldRowid);\n    iEph = pParse->nTab++;\n    addrOpen = sqlite3VdbeAddOp3(v, OP_OpenEphemeral, iEph, 0, regRowSet);\n  }else{\n    assert( pPk!=0 || HasRowid(pTab) );\n    nPk = pPk ? pPk->nKeyCol : 0;\n    iPk = pParse->nMem+1;\n    pParse->nMem += nPk;\n    pParse->nMem += nChangeFrom;\n    regKey = ++pParse->nMem;\n    if( pUpsert==0 ){\n      int nEphCol = nPk + nChangeFrom + (isView ? pTab->nCol : 0);\n      iEph = pParse->nTab++;\n      if( pPk ) sqlite3VdbeAddOp3(v, OP_Null, 0, iPk, iPk+nPk-1);\n      addrOpen = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iEph, nEphCol);\n      if( pPk ){\n        KeyInfo *pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pPk);\n        if( pKeyInfo ){\n          pKeyInfo->nAllField = nEphCol;\n          sqlite3VdbeAppendP4(v, pKeyInfo, P4_KEYINFO);\n        }\n      }\n      if( nChangeFrom ){\n        updateFromSelect(\n            pParse, iEph, pPk, pChanges, pTabList, pWhere, pOrderBy, pLimit\n        );\n#ifndef SQLITE_OMIT_SUBQUERY\n        if( isView ) iDataCur = iEph;\n#endif\n      }\n    }\n  }\n\n  if( nChangeFrom ){\n    sqlite3MultiWrite(pParse);\n    eOnePass = ONEPASS_OFF;\n    nKey = nPk;\n    regKey = iPk;\n  }else{\n    if( pUpsert ){\n      /* If this is an UPSERT, then all cursors have already been opened by\n      ** the outer INSERT and the data cursor should be pointing at the row\n      ** that is to be updated.  So bypass the code that searches for the\n      ** row(s) to be updated.\n      */\n      pWInfo = 0;\n      eOnePass = ONEPASS_SINGLE;\n      sqlite3ExprIfFalse(pParse, pWhere, labelBreak, SQLITE_JUMPIFNULL);\n      bFinishSeek = 0;\n    }else{\n      /* Begin the database scan.\n      **\n      ** Do not consider a single-pass strategy for a multi-row update if\n      ** there is anything that might disrupt the cursor being used to do\n      ** the UPDATE:\n      **   (1) This is a nested UPDATE\n      **   (2) There are triggers\n      **   (3) There are FOREIGN KEY constraints\n      **   (4) There are REPLACE conflict handlers\n      **   (5) There are subqueries in the WHERE clause\n      */\n      flags = WHERE_ONEPASS_DESIRED;\n      if( !pParse->nested\n       && !pTrigger\n       && !hasFK\n       && !chngKey\n       && !bReplace\n       && (pWhere==0 || !ExprHasProperty(pWhere, EP_Subquery))\n      ){\n        flags |= WHERE_ONEPASS_MULTIROW;\n      }\n      pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere,0,0,0,flags,iIdxCur);\n      if( pWInfo==0 ) goto update_cleanup;\n\n      /* A one-pass strategy that might update more than one row may not\n      ** be used if any column of the index used for the scan is being\n      ** updated. Otherwise, if there is an index on \"b\", statements like\n      ** the following could create an infinite loop:\n      **\n      **   UPDATE t1 SET b=b+1 WHERE b>?\n      **\n      ** Fall back to ONEPASS_OFF if where.c has selected a ONEPASS_MULTI\n      ** strategy that uses an index for which one or more columns are being\n      ** updated.  */\n      eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);\n      bFinishSeek = sqlite3WhereUsesDeferredSeek(pWInfo);\n      if( eOnePass!=ONEPASS_SINGLE ){\n        sqlite3MultiWrite(pParse);\n        if( eOnePass==ONEPASS_MULTI ){\n          int iCur = aiCurOnePass[1];\n          if( iCur>=0 && iCur!=iDataCur && aToOpen[iCur-iBaseCur] ){\n            eOnePass = ONEPASS_OFF;\n          }\n          assert( iCur!=iDataCur || !HasRowid(pTab) );\n        }\n      }\n    }\n\n    if( HasRowid(pTab) ){\n      /* Read the rowid of the current row of the WHERE scan. In ONEPASS_OFF\n      ** mode, write the rowid into the FIFO. In either of the one-pass modes,\n      ** leave it in register regOldRowid.  */\n      sqlite3VdbeAddOp2(v, OP_Rowid, iDataCur, regOldRowid);\n      if( eOnePass==ONEPASS_OFF ){\n        aRegIdx[nAllIdx] = ++pParse->nMem;\n        sqlite3VdbeAddOp3(v, OP_Insert, iEph, regRowSet, regOldRowid);\n      }else{\n        if( ALWAYS(addrOpen) ) sqlite3VdbeChangeToNoop(v, addrOpen);\n      }\n    }else{\n      /* Read the PK of the current row into an array of registers. In\n      ** ONEPASS_OFF mode, serialize the array into a record and store it in\n      ** the ephemeral table. Or, in ONEPASS_SINGLE or MULTI mode, change\n      ** the OP_OpenEphemeral instruction to a Noop (the ephemeral table\n      ** is not required) and leave the PK fields in the array of registers.  */\n      for(i=0; i<nPk; i++){\n        assert( pPk->aiColumn[i]>=0 );\n        sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur,\n                                        pPk->aiColumn[i], iPk+i);\n      }\n      if( eOnePass ){\n        if( addrOpen ) sqlite3VdbeChangeToNoop(v, addrOpen);\n        nKey = nPk;\n        regKey = iPk;\n      }else{\n        sqlite3VdbeAddOp4(v, OP_MakeRecord, iPk, nPk, regKey,\n                          sqlite3IndexAffinityStr(db, pPk), nPk);\n        sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iEph, regKey, iPk, nPk);\n      }\n    }\n  }\n\n  if( pUpsert==0 ){\n    if( nChangeFrom==0 && eOnePass!=ONEPASS_MULTI ){\n      sqlite3WhereEnd(pWInfo);\n    }\n\n    if( !isView ){\n      int addrOnce = 0;\n      int iNotUsed1 = 0;\n      int iNotUsed2 = 0;\n\n      /* Open every index that needs updating. */\n      if( eOnePass!=ONEPASS_OFF ){\n        if( aiCurOnePass[0]>=0 ) aToOpen[aiCurOnePass[0]-iBaseCur] = 0;\n        if( aiCurOnePass[1]>=0 ) aToOpen[aiCurOnePass[1]-iBaseCur] = 0;\n      }\n\n      if( eOnePass==ONEPASS_MULTI && (nIdx-(aiCurOnePass[1]>=0))>0 ){\n        addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);\n      }\n      sqlite3OpenTableAndIndices(pParse, pTab, OP_OpenWrite, 0, iBaseCur,\n                                 aToOpen, &iNotUsed1, &iNotUsed2);\n      if( addrOnce ){\n        sqlite3VdbeJumpHereOrPopInst(v, addrOnce);\n      }\n    }\n\n    /* Top of the update loop */\n    if( eOnePass!=ONEPASS_OFF ){\n      if( aiCurOnePass[0]!=iDataCur\n       && aiCurOnePass[1]!=iDataCur\n#ifdef SQLITE_ALLOW_ROWID_IN_VIEW\n       && !isView\n#endif\n      ){\n        assert( pPk );\n        sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, labelBreak, regKey,nKey);\n        VdbeCoverage(v);\n      }\n      if( eOnePass!=ONEPASS_SINGLE ){\n        labelContinue = sqlite3VdbeMakeLabel(pParse);\n      }\n      sqlite3VdbeAddOp2(v, OP_IsNull, pPk ? regKey : regOldRowid, labelBreak);\n      VdbeCoverageIf(v, pPk==0);\n      VdbeCoverageIf(v, pPk!=0);\n    }else if( pPk || nChangeFrom ){\n      labelContinue = sqlite3VdbeMakeLabel(pParse);\n      sqlite3VdbeAddOp2(v, OP_Rewind, iEph, labelBreak); VdbeCoverage(v);\n      addrTop = sqlite3VdbeCurrentAddr(v);\n      if( nChangeFrom ){\n        if( !isView ){\n          if( pPk ){\n            for(i=0; i<nPk; i++){\n              sqlite3VdbeAddOp3(v, OP_Column, iEph, i, iPk+i);\n            }\n            sqlite3VdbeAddOp4Int(\n                v, OP_NotFound, iDataCur, labelContinue, iPk, nPk\n            ); VdbeCoverage(v);\n          }else{\n            sqlite3VdbeAddOp2(v, OP_Rowid, iEph, regOldRowid);\n            sqlite3VdbeAddOp3(\n                v, OP_NotExists, iDataCur, labelContinue, regOldRowid\n            ); VdbeCoverage(v);\n          }\n        }\n      }else{\n        sqlite3VdbeAddOp2(v, OP_RowData, iEph, regKey);\n        sqlite3VdbeAddOp4Int(v, OP_NotFound, iDataCur, labelContinue, regKey,0);\n        VdbeCoverage(v);\n      }\n    }else{\n      sqlite3VdbeAddOp2(v, OP_Rewind, iEph, labelBreak); VdbeCoverage(v);\n      labelContinue = sqlite3VdbeMakeLabel(pParse);\n      addrTop = sqlite3VdbeAddOp2(v, OP_Rowid, iEph, regOldRowid);\n      VdbeCoverage(v);\n      sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, labelContinue, regOldRowid);\n      VdbeCoverage(v);\n    }\n  }\n\n  /* If the rowid value will change, set register regNewRowid to\n  ** contain the new value. If the rowid is not being modified,\n  ** then regNewRowid is the same register as regOldRowid, which is\n  ** already populated.  */\n  assert( chngKey || pTrigger || hasFK || regOldRowid==regNewRowid );\n  if( chngRowid ){\n    assert( iRowidExpr>=0 );\n    if( nChangeFrom==0 ){\n      sqlite3ExprCode(pParse, pRowidExpr, regNewRowid);\n    }else{\n      sqlite3VdbeAddOp3(v, OP_Column, iEph, iRowidExpr, regNewRowid);\n    }\n    sqlite3VdbeAddOp1(v, OP_MustBeInt, regNewRowid); VdbeCoverage(v);\n  }\n\n  /* Compute the old pre-UPDATE content of the row being changed, if that\n  ** information is needed */\n  if( chngPk || hasFK || pTrigger ){\n    u32 oldmask = (hasFK ? sqlite3FkOldmask(pParse, pTab) : 0);\n    oldmask |= sqlite3TriggerColmask(pParse,\n        pTrigger, pChanges, 0, TRIGGER_BEFORE|TRIGGER_AFTER, pTab, onError\n    );\n    for(i=0; i<pTab->nCol; i++){\n      u32 colFlags = pTab->aCol[i].colFlags;\n      k = sqlite3TableColumnToStorage(pTab, i) + regOld;\n      if( oldmask==0xffffffff\n       || (i<32 && (oldmask & MASKBIT32(i))!=0)\n       || (colFlags & COLFLAG_PRIMKEY)!=0\n      ){\n        testcase(  oldmask!=0xffffffff && i==31 );\n        sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);\n      }else{\n        sqlite3VdbeAddOp2(v, OP_Null, 0, k);\n      }\n    }\n    if( chngRowid==0 && pPk==0 ){\n#ifdef SQLITE_ALLOW_ROWID_IN_VIEW\n      if( isView ) sqlite3VdbeAddOp2(v, OP_Null, 0, regOldRowid);\n#endif\n      sqlite3VdbeAddOp2(v, OP_Copy, regOldRowid, regNewRowid);\n    }\n  }\n\n  /* Populate the array of registers beginning at regNew with the new\n  ** row data. This array is used to check constants, create the new\n  ** table and index records, and as the values for any new.* references\n  ** made by triggers.\n  **\n  ** If there are one or more BEFORE triggers, then do not populate the\n  ** registers associated with columns that are (a) not modified by\n  ** this UPDATE statement and (b) not accessed by new.* references. The\n  ** values for registers not modified by the UPDATE must be reloaded from\n  ** the database after the BEFORE triggers are fired anyway (as the trigger\n  ** may have modified them). So not loading those that are not going to\n  ** be used eliminates some redundant opcodes.\n  */\n  newmask = sqlite3TriggerColmask(\n      pParse, pTrigger, pChanges, 1, TRIGGER_BEFORE, pTab, onError\n  );\n  for(i=0, k=regNew; i<pTab->nCol; i++, k++){\n    if( i==pTab->iPKey ){\n      sqlite3VdbeAddOp2(v, OP_Null, 0, k);\n    }else if( (pTab->aCol[i].colFlags & COLFLAG_GENERATED)!=0 ){\n      if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ) k--;\n    }else{\n      j = aXRef[i];\n      if( j>=0 ){\n        if( nChangeFrom ){\n          int nOff = (isView ? pTab->nCol : nPk);\n          assert( eOnePass==ONEPASS_OFF );\n          sqlite3VdbeAddOp3(v, OP_Column, iEph, nOff+j, k);\n        }else{\n          sqlite3ExprCode(pParse, pChanges->a[j].pExpr, k);\n        }\n      }else if( 0==(tmask&TRIGGER_BEFORE) || i>31 || (newmask & MASKBIT32(i)) ){\n        /* This branch loads the value of a column that will not be changed\n        ** into a register. This is done if there are no BEFORE triggers, or\n        ** if there are one or more BEFORE triggers that use this value via\n        ** a new.* reference in a trigger program.\n        */\n        testcase( i==31 );\n        testcase( i==32 );\n        sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);\n        bFinishSeek = 0;\n      }else{\n        sqlite3VdbeAddOp2(v, OP_Null, 0, k);\n      }\n    }\n  }\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n  if( pTab->tabFlags & TF_HasGenerated ){\n    testcase( pTab->tabFlags & TF_HasVirtual );\n    testcase( pTab->tabFlags & TF_HasStored );\n    sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);\n  }\n#endif\n\n  /* Fire any BEFORE UPDATE triggers. This happens before constraints are\n  ** verified. One could argue that this is wrong.\n  */\n  if( tmask&TRIGGER_BEFORE ){\n    sqlite3TableAffinity(v, pTab, regNew);\n    sqlite3CodeRowTrigger(pParse, pTrigger, TK_UPDATE, pChanges,\n        TRIGGER_BEFORE, pTab, regOldRowid, onError, labelContinue);\n\n    if( !isView ){\n      /* The row-trigger may have deleted the row being updated. In this\n      ** case, jump to the next row. No updates or AFTER triggers are\n      ** required. This behavior - what happens when the row being updated\n      ** is deleted or renamed by a BEFORE trigger - is left undefined in the\n      ** documentation.\n      */\n      if( pPk ){\n        sqlite3VdbeAddOp4Int(v, OP_NotFound,iDataCur,labelContinue,regKey,nKey);\n        VdbeCoverage(v);\n      }else{\n        sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, labelContinue,regOldRowid);\n        VdbeCoverage(v);\n      }\n\n      /* After-BEFORE-trigger-reload-loop:\n      ** If it did not delete it, the BEFORE trigger may still have modified\n      ** some of the columns of the row being updated. Load the values for\n      ** all columns not modified by the update statement into their registers\n      ** in case this has happened. Only unmodified columns are reloaded.\n      ** The values computed for modified columns use the values before the\n      ** BEFORE trigger runs.  See test case trigger1-18.0 (added 2018-04-26)\n      ** for an example.\n      */\n      for(i=0, k=regNew; i<pTab->nCol; i++, k++){\n        if( pTab->aCol[i].colFlags & COLFLAG_GENERATED ){\n          if( pTab->aCol[i].colFlags & COLFLAG_VIRTUAL ) k--;\n        }else if( aXRef[i]<0 && i!=pTab->iPKey ){\n          sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, k);\n        }\n      }\n#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n      if( pTab->tabFlags & TF_HasGenerated ){\n        testcase( pTab->tabFlags & TF_HasVirtual );\n        testcase( pTab->tabFlags & TF_HasStored );\n        sqlite3ComputeGeneratedColumns(pParse, regNew, pTab);\n      }\n#endif\n    }\n  }\n\n  if( !isView ){\n    /* Do constraint checks. */\n    assert( regOldRowid>0 );\n    sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, iDataCur, iIdxCur,\n        regNewRowid, regOldRowid, chngKey, onError, labelContinue, &bReplace,\n        aXRef, 0);\n\n    /* If REPLACE conflict handling may have been used, or if the PK of the\n    ** row is changing, then the GenerateConstraintChecks() above may have\n    ** moved cursor iDataCur. Reseek it. */\n    if( bReplace || chngKey ){\n      if( pPk ){\n        sqlite3VdbeAddOp4Int(v, OP_NotFound,iDataCur,labelContinue,regKey,nKey);\n      }else{\n        sqlite3VdbeAddOp3(v, OP_NotExists, iDataCur, labelContinue,regOldRowid);\n      }\n      VdbeCoverage(v);\n    }\n\n    /* Do FK constraint checks. */\n    if( hasFK ){\n      sqlite3FkCheck(pParse, pTab, regOldRowid, 0, aXRef, chngKey);\n    }\n\n    /* Delete the index entries associated with the current record.  */\n    sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, aRegIdx, -1);\n\n    /* We must run the OP_FinishSeek opcode to resolve a prior\n    ** OP_DeferredSeek if there is any possibility that there have been\n    ** no OP_Column opcodes since the OP_DeferredSeek was issued.  But\n    ** we want to avoid the OP_FinishSeek if possible, as running it\n    ** costs CPU cycles. */\n    if( bFinishSeek ){\n      sqlite3VdbeAddOp1(v, OP_FinishSeek, iDataCur);\n    }\n\n    /* If changing the rowid value, or if there are foreign key constraints\n    ** to process, delete the old record. Otherwise, add a noop OP_Delete\n    ** to invoke the pre-update hook.\n    **\n    ** That (regNew==regnewRowid+1) is true is also important for the\n    ** pre-update hook. If the caller invokes preupdate_new(), the returned\n    ** value is copied from memory cell (regNewRowid+1+iCol), where iCol\n    ** is the column index supplied by the user.\n    */\n    assert( regNew==regNewRowid+1 );\n#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\n    sqlite3VdbeAddOp3(v, OP_Delete, iDataCur,\n        OPFLAG_ISUPDATE | ((hasFK>1 || chngKey) ? 0 : OPFLAG_ISNOOP),\n        regNewRowid\n    );\n    if( eOnePass==ONEPASS_MULTI ){\n      assert( hasFK==0 && chngKey==0 );\n      sqlite3VdbeChangeP5(v, OPFLAG_SAVEPOSITION);\n    }\n    if( !pParse->nested ){\n      sqlite3VdbeAppendP4(v, pTab, P4_TABLE);\n    }\n#else\n    if( hasFK>1 || chngKey ){\n      sqlite3VdbeAddOp2(v, OP_Delete, iDataCur, 0);\n    }\n#endif\n\n    if( hasFK ){\n      sqlite3FkCheck(pParse, pTab, 0, regNewRowid, aXRef, chngKey);\n    }\n\n    /* Insert the new index entries and the new record. */\n    sqlite3CompleteInsertion(\n        pParse, pTab, iDataCur, iIdxCur, regNewRowid, aRegIdx,\n        OPFLAG_ISUPDATE | (eOnePass==ONEPASS_MULTI ? OPFLAG_SAVEPOSITION : 0),\n        0, 0\n    );\n\n    /* Do any ON CASCADE, SET NULL or SET DEFAULT operations required to\n    ** handle rows (possibly in other tables) that refer via a foreign key\n    ** to the row just updated. */\n    if( hasFK ){\n      sqlite3FkActions(pParse, pTab, pChanges, regOldRowid, aXRef, chngKey);\n    }\n  }\n\n  /* Increment the row counter\n  */\n  if( regRowCount ){\n    sqlite3VdbeAddOp2(v, OP_AddImm, regRowCount, 1);\n  }\n\n  if( pTrigger ){\n    sqlite3CodeRowTrigger(pParse, pTrigger, TK_UPDATE, pChanges,\n        TRIGGER_AFTER, pTab, regOldRowid, onError, labelContinue);\n  }\n\n  /* Repeat the above with the next record to be updated, until\n  ** all record selected by the WHERE clause have been updated.\n  */\n  if( eOnePass==ONEPASS_SINGLE ){\n    /* Nothing to do at end-of-loop for a single-pass */\n  }else if( eOnePass==ONEPASS_MULTI ){\n    sqlite3VdbeResolveLabel(v, labelContinue);\n    sqlite3WhereEnd(pWInfo);\n  }else{\n    sqlite3VdbeResolveLabel(v, labelContinue);\n    sqlite3VdbeAddOp2(v, OP_Next, iEph, addrTop); VdbeCoverage(v);\n  }\n  sqlite3VdbeResolveLabel(v, labelBreak);\n\n  /* Update the sqlite_sequence table by storing the content of the\n  ** maximum rowid counter values recorded while inserting into\n  ** autoincrement tables.\n  */\n  if( pParse->nested==0 && pParse->pTriggerTab==0 && pUpsert==0 ){\n    sqlite3AutoincrementEnd(pParse);\n  }\n\n  /*\n  ** Return the number of rows that were changed, if we are tracking\n  ** that information.\n  */\n  if( regRowCount ){\n    sqlite3CodeChangeCount(v, regRowCount, \"rows updated\");\n  }\n\nupdate_cleanup:\n  sqlite3AuthContextPop(&sContext);\n  sqlite3DbFree(db, aXRef); /* Also frees aRegIdx[] and aToOpen[] */\n  sqlite3SrcListDelete(db, pTabList);\n  sqlite3ExprListDelete(db, pChanges);\n  sqlite3ExprDelete(db, pWhere);\n#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT)\n  sqlite3ExprListDelete(db, pOrderBy);\n  sqlite3ExprDelete(db, pLimit);\n#endif\n  return;\n}\n/* Make sure \"isView\" and other macros defined above are undefined. Otherwise\n** they may interfere with compilation of other functions in this file\n** (or in another file, if this file becomes part of the amalgamation).  */\n#ifdef isView\n #undef isView\n#endif\n#ifdef pTrigger\n #undef pTrigger\n#endif\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n/*\n** Generate code for an UPDATE of a virtual table.\n**\n** There are two possible strategies - the default and the special\n** \"onepass\" strategy. Onepass is only used if the virtual table\n** implementation indicates that pWhere may match at most one row.\n**\n** The default strategy is to create an ephemeral table that contains\n** for each row to be changed:\n**\n**   (A)  The original rowid of that row.\n**   (B)  The revised rowid for the row.\n**   (C)  The content of every column in the row.\n**\n** Then loop through the contents of this ephemeral table executing a\n** VUpdate for each row. When finished, drop the ephemeral table.\n**\n** The \"onepass\" strategy does not use an ephemeral table. Instead, it\n** stores the same values (A, B and C above) in a register array and\n** makes a single invocation of VUpdate.\n*/\nstatic void updateVirtualTable(\n  Parse *pParse,       /* The parsing context */\n  SrcList *pSrc,       /* The virtual table to be modified */\n  Table *pTab,         /* The virtual table */\n  ExprList *pChanges,  /* The columns to change in the UPDATE statement */\n  Expr *pRowid,        /* Expression used to recompute the rowid */\n  int *aXRef,          /* Mapping from columns of pTab to entries in pChanges */\n  Expr *pWhere,        /* WHERE clause of the UPDATE statement */\n  int onError          /* ON CONFLICT strategy */\n){\n  Vdbe *v = pParse->pVdbe;  /* Virtual machine under construction */\n  int ephemTab;             /* Table holding the result of the SELECT */\n  int i;                    /* Loop counter */\n  sqlite3 *db = pParse->db; /* Database connection */\n  const char *pVTab = (const char*)sqlite3GetVTable(db, pTab);\n  WhereInfo *pWInfo = 0;\n  int nArg = 2 + pTab->nCol;      /* Number of arguments to VUpdate */\n  int regArg;                     /* First register in VUpdate arg array */\n  int regRec;                     /* Register in which to assemble record */\n  int regRowid;                   /* Register for ephemeral table rowid */\n  int iCsr = pSrc->a[0].iCursor;  /* Cursor used for virtual table scan */\n  int aDummy[2];                  /* Unused arg for sqlite3WhereOkOnePass() */\n  int eOnePass;                   /* True to use onepass strategy */\n  int addr;                       /* Address of OP_OpenEphemeral */\n\n  /* Allocate nArg registers in which to gather the arguments for VUpdate. Then\n  ** create and open the ephemeral table in which the records created from\n  ** these arguments will be temporarily stored. */\n  assert( v );\n  ephemTab = pParse->nTab++;\n  addr= sqlite3VdbeAddOp2(v, OP_OpenEphemeral, ephemTab, nArg);\n  regArg = pParse->nMem + 1;\n  pParse->nMem += nArg;\n  if( pSrc->nSrc>1 ){\n    Index *pPk = 0;\n    Expr *pRow;\n    ExprList *pList;\n    if( HasRowid(pTab) ){\n      if( pRowid ){\n        pRow = sqlite3ExprDup(db, pRowid, 0);\n      }else{\n        pRow = sqlite3PExpr(pParse, TK_ROW, 0, 0);\n      }\n    }else{\n      i16 iPk;      /* PRIMARY KEY column */\n      pPk = sqlite3PrimaryKeyIndex(pTab);\n      assert( pPk!=0 );\n      assert( pPk->nKeyCol==1 );\n      iPk = pPk->aiColumn[0];\n      if( aXRef[iPk]>=0 ){\n        pRow = sqlite3ExprDup(db, pChanges->a[aXRef[iPk]].pExpr, 0);\n      }else{\n        pRow = exprRowColumn(pParse, iPk);\n      }\n    }\n    pList = sqlite3ExprListAppend(pParse, 0, pRow);\n\n    for(i=0; i<pTab->nCol; i++){\n      if( aXRef[i]>=0 ){\n        pList = sqlite3ExprListAppend(pParse, pList,\n          sqlite3ExprDup(db, pChanges->a[aXRef[i]].pExpr, 0)\n        );\n      }else{\n        Expr *pRowExpr = exprRowColumn(pParse, i);\n        if( pRowExpr ) pRowExpr->op2 = OPFLAG_NOCHNG;\n        pList = sqlite3ExprListAppend(pParse, pList, pRowExpr);\n      }\n    }\n\n    updateFromSelect(pParse, ephemTab, pPk, pList, pSrc, pWhere, 0, 0);\n    sqlite3ExprListDelete(db, pList);\n    eOnePass = ONEPASS_OFF;\n  }else{\n    regRec = ++pParse->nMem;\n    regRowid = ++pParse->nMem;\n\n    /* Start scanning the virtual table */\n    pWInfo = sqlite3WhereBegin(\n        pParse, pSrc, pWhere, 0, 0, 0, WHERE_ONEPASS_DESIRED, 0\n    );\n    if( pWInfo==0 ) return;\n\n    /* Populate the argument registers. */\n    for(i=0; i<pTab->nCol; i++){\n      assert( (pTab->aCol[i].colFlags & COLFLAG_GENERATED)==0 );\n      if( aXRef[i]>=0 ){\n        sqlite3ExprCode(pParse, pChanges->a[aXRef[i]].pExpr, regArg+2+i);\n      }else{\n        sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, i, regArg+2+i);\n        sqlite3VdbeChangeP5(v, OPFLAG_NOCHNG);/* For sqlite3_vtab_nochange() */\n      }\n    }\n    if( HasRowid(pTab) ){\n      sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg);\n      if( pRowid ){\n        sqlite3ExprCode(pParse, pRowid, regArg+1);\n      }else{\n        sqlite3VdbeAddOp2(v, OP_Rowid, iCsr, regArg+1);\n      }\n    }else{\n      Index *pPk;   /* PRIMARY KEY index */\n      i16 iPk;      /* PRIMARY KEY column */\n      pPk = sqlite3PrimaryKeyIndex(pTab);\n      assert( pPk!=0 );\n      assert( pPk->nKeyCol==1 );\n      iPk = pPk->aiColumn[0];\n      sqlite3VdbeAddOp3(v, OP_VColumn, iCsr, iPk, regArg);\n      sqlite3VdbeAddOp2(v, OP_SCopy, regArg+2+iPk, regArg+1);\n    }\n\n    eOnePass = sqlite3WhereOkOnePass(pWInfo, aDummy);\n\n    /* There is no ONEPASS_MULTI on virtual tables */\n    assert( eOnePass==ONEPASS_OFF || eOnePass==ONEPASS_SINGLE );\n\n    if( eOnePass ){\n      /* If using the onepass strategy, no-op out the OP_OpenEphemeral coded\n      ** above. */\n      sqlite3VdbeChangeToNoop(v, addr);\n      sqlite3VdbeAddOp1(v, OP_Close, iCsr);\n    }else{\n      /* Create a record from the argument register contents and insert it into\n      ** the ephemeral table. */\n      sqlite3MultiWrite(pParse);\n      sqlite3VdbeAddOp3(v, OP_MakeRecord, regArg, nArg, regRec);\n#if defined(SQLITE_DEBUG) && !defined(SQLITE_ENABLE_NULL_TRIM)\n      /* Signal an assert() within OP_MakeRecord that it is allowed to\n      ** accept no-change records with serial_type 10 */\n      sqlite3VdbeChangeP5(v, OPFLAG_NOCHNG_MAGIC);\n#endif\n      sqlite3VdbeAddOp2(v, OP_NewRowid, ephemTab, regRowid);\n      sqlite3VdbeAddOp3(v, OP_Insert, ephemTab, regRec, regRowid);\n    }\n  }\n\n\n  if( eOnePass==ONEPASS_OFF ){\n    /* End the virtual table scan */\n    if( pSrc->nSrc==1 ){\n      sqlite3WhereEnd(pWInfo);\n    }\n\n    /* Begin scanning through the ephemeral table. */\n    addr = sqlite3VdbeAddOp1(v, OP_Rewind, ephemTab); VdbeCoverage(v);\n\n    /* Extract arguments from the current row of the ephemeral table and\n    ** invoke the VUpdate method.  */\n    for(i=0; i<nArg; i++){\n      sqlite3VdbeAddOp3(v, OP_Column, ephemTab, i, regArg+i);\n    }\n  }\n  sqlite3VtabMakeWritable(pParse, pTab);\n  sqlite3VdbeAddOp4(v, OP_VUpdate, 0, nArg, regArg, pVTab, P4_VTAB);\n  sqlite3VdbeChangeP5(v, onError==OE_Default ? OE_Abort : onError);\n  sqlite3MayAbort(pParse);\n\n  /* End of the ephemeral table scan. Or, if using the onepass strategy,\n  ** jump to here if the scan visited zero rows. */\n  if( eOnePass==ONEPASS_OFF ){\n    sqlite3VdbeAddOp2(v, OP_Next, ephemTab, addr+1); VdbeCoverage(v);\n    sqlite3VdbeJumpHere(v, addr);\n    sqlite3VdbeAddOp2(v, OP_Close, ephemTab, 0);\n  }else{\n    sqlite3WhereEnd(pWInfo);\n  }\n}\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n"}
{"repo": "sqlite", "file": "vdbeInt.h", "lang": "C++", "code": "/*\n** 2003 September 6\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This is the header file for information that is private to the\n** VDBE.  This information used to all be at the top of the single\n** source code file \"vdbe.c\".  When that file became too big (over\n** 6000 lines long) it was split up into several smaller files and\n** this header information was factored out.\n*/\n#ifndef SQLITE_VDBEINT_H\n#define SQLITE_VDBEINT_H\n\n/*\n** The maximum number of times that a statement will try to reparse\n** itself before giving up and returning SQLITE_SCHEMA.\n*/\n#ifndef SQLITE_MAX_SCHEMA_RETRY\n# define SQLITE_MAX_SCHEMA_RETRY 50\n#endif\n\n/*\n** VDBE_DISPLAY_P4 is true or false depending on whether or not the\n** \"explain\" P4 display logic is enabled.\n*/\n#if !defined(SQLITE_OMIT_EXPLAIN) || !defined(NDEBUG) \\\n     || defined(VDBE_PROFILE) || defined(SQLITE_DEBUG) \\\n     || defined(SQLITE_ENABLE_BYTECODE_VTAB)\n# define VDBE_DISPLAY_P4 1\n#else\n# define VDBE_DISPLAY_P4 0\n#endif\n\n/*\n** SQL is translated into a sequence of instructions to be\n** executed by a virtual machine.  Each instruction is an instance\n** of the following structure.\n*/\ntypedef struct VdbeOp Op;\n\n/*\n** Boolean values\n*/\ntypedef unsigned Bool;\n\n/* Opaque type used by code in vdbesort.c */\ntypedef struct VdbeSorter VdbeSorter;\n\n/* Elements of the linked list at Vdbe.pAuxData */\ntypedef struct AuxData AuxData;\n\n/* A cache of large TEXT or BLOB values in a VdbeCursor */\ntypedef struct VdbeTxtBlbCache VdbeTxtBlbCache;\n\n/* Types of VDBE cursors */\n#define CURTYPE_BTREE       0\n#define CURTYPE_SORTER      1\n#define CURTYPE_VTAB        2\n#define CURTYPE_PSEUDO      3\n\n/*\n** A VdbeCursor is an superclass (a wrapper) for various cursor objects:\n**\n**      * A b-tree cursor\n**          -  In the main database or in an ephemeral database\n**          -  On either an index or a table\n**      * A sorter\n**      * A virtual table\n**      * A one-row \"pseudotable\" stored in a single register\n*/\ntypedef struct VdbeCursor VdbeCursor;\nstruct VdbeCursor {\n  u8 eCurType;            /* One of the CURTYPE_* values above */\n  i8 iDb;                 /* Index of cursor database in db->aDb[] */\n  u8 nullRow;             /* True if pointing to a row with no data */\n  u8 deferredMoveto;      /* A call to sqlite3BtreeMoveto() is needed */\n  u8 isTable;             /* True for rowid tables.  False for indexes */\n#ifdef SQLITE_DEBUG\n  u8 seekOp;              /* Most recent seek operation on this cursor */\n  u8 wrFlag;              /* The wrFlag argument to sqlite3BtreeCursor() */\n#endif\n  Bool isEphemeral:1;     /* True for an ephemeral table */\n  Bool useRandomRowid:1;  /* Generate new record numbers semi-randomly */\n  Bool isOrdered:1;       /* True if the table is not BTREE_UNORDERED */\n  Bool noReuse:1;         /* OpenEphemeral may not reuse this cursor */\n  Bool colCache:1;        /* pCache pointer is initialized and non-NULL */\n  u16 seekHit;            /* See the OP_SeekHit and OP_IfNoHope opcodes */\n  union {                 /* pBtx for isEphermeral.  pAltMap otherwise */\n    Btree *pBtx;            /* Separate file holding temporary table */\n    u32 *aAltMap;           /* Mapping from table to index column numbers */\n  } ub;\n  i64 seqCount;           /* Sequence counter */\n\n  /* Cached OP_Column parse information is only valid if cacheStatus matches\n  ** Vdbe.cacheCtr.  Vdbe.cacheCtr will never take on the value of\n  ** CACHE_STALE (0) and so setting cacheStatus=CACHE_STALE guarantees that\n  ** the cache is out of date. */\n  u32 cacheStatus;        /* Cache is valid if this matches Vdbe.cacheCtr */\n  int seekResult;         /* Result of previous sqlite3BtreeMoveto() or 0\n                          ** if there have been no prior seeks on the cursor. */\n  /* seekResult does not distinguish between \"no seeks have ever occurred\n  ** on this cursor\" and \"the most recent seek was an exact match\".\n  ** For CURTYPE_PSEUDO, seekResult is the register holding the record */\n\n  /* When a new VdbeCursor is allocated, only the fields above are zeroed.\n  ** The fields that follow are uninitialized, and must be individually\n  ** initialized prior to first use. */\n  VdbeCursor *pAltCursor; /* Associated index cursor from which to read */\n  union {\n    BtCursor *pCursor;          /* CURTYPE_BTREE or _PSEUDO.  Btree cursor */\n    sqlite3_vtab_cursor *pVCur; /* CURTYPE_VTAB.              Vtab cursor */\n    VdbeSorter *pSorter;        /* CURTYPE_SORTER.            Sorter object */\n  } uc;\n  KeyInfo *pKeyInfo;      /* Info about index keys needed by index cursors */\n  u32 iHdrOffset;         /* Offset to next unparsed byte of the header */\n  Pgno pgnoRoot;          /* Root page of the open btree cursor */\n  i16 nField;             /* Number of fields in the header */\n  u16 nHdrParsed;         /* Number of header fields parsed so far */\n  i64 movetoTarget;       /* Argument to the deferred sqlite3BtreeMoveto() */\n  u32 *aOffset;           /* Pointer to aType[nField] */\n  const u8 *aRow;         /* Data for the current row, if all on one page */\n  u32 payloadSize;        /* Total number of bytes in the record */\n  u32 szRow;              /* Byte available in aRow */\n#ifdef SQLITE_ENABLE_COLUMN_USED_MASK\n  u64 maskUsed;           /* Mask of columns used by this cursor */\n#endif\n  VdbeTxtBlbCache *pCache; /* Cache of large TEXT or BLOB values */\n\n  /* Space is allocated for aType to hold at least 2*nField+1 entries:\n  ** nField slots for aType[] and nField+1 array slots for aOffset[] */\n  u32 aType[FLEXARRAY];    /* Type values record decode.  MUST BE LAST */\n};\n\n/*\n** The size (in bytes) of a VdbeCursor object that has an nField value of N\n** or less.  The value of SZ_VDBECURSOR(n) is guaranteed to be a multiple\n** of 8.\n*/\n#define SZ_VDBECURSOR(N) \\\n    (ROUND8(offsetof(VdbeCursor,aType)) + ((N)+1)*sizeof(u64))\n\n/* Return true if P is a null-only cursor\n*/\n#define IsNullCursor(P) \\\n  ((P)->eCurType==CURTYPE_PSEUDO && (P)->nullRow && (P)->seekResult==0)\n\n/*\n** A value for VdbeCursor.cacheStatus that means the cache is always invalid.\n*/\n#define CACHE_STALE 0\n\n/*\n** Large TEXT or BLOB values can be slow to load, so we want to avoid\n** loading them more than once.  For that reason, large TEXT and BLOB values\n** can be stored in a cache defined by this object, and attached to the\n** VdbeCursor using the pCache field.\n*/\nstruct VdbeTxtBlbCache {\n  char *pCValue;        /* A RCStr buffer to hold the value */\n  i64 iOffset;          /* File offset of the row being cached */\n  int iCol;             /* Column for which the cache is valid */\n  u32 cacheStatus;      /* Vdbe.cacheCtr value */\n  u32 colCacheCtr;      /* Column cache counter */\n};\n\n/*\n** When a sub-program is executed (OP_Program), a structure of this type\n** is allocated to store the current value of the program counter, as\n** well as the current memory cell array and various other frame specific\n** values stored in the Vdbe struct. When the sub-program is finished,\n** these values are copied back to the Vdbe from the VdbeFrame structure,\n** restoring the state of the VM to as it was before the sub-program\n** began executing.\n**\n** The memory for a VdbeFrame object is allocated and managed by a memory\n** cell in the parent (calling) frame. When the memory cell is deleted or\n** overwritten, the VdbeFrame object is not freed immediately. Instead, it\n** is linked into the Vdbe.pDelFrame list. The contents of the Vdbe.pDelFrame\n** list is deleted when the VM is reset in VdbeHalt(). The reason for doing\n** this instead of deleting the VdbeFrame immediately is to avoid recursive\n** calls to sqlite3VdbeMemRelease() when the memory cells belonging to the\n** child frame are released.\n**\n** The currently executing frame is stored in Vdbe.pFrame. Vdbe.pFrame is\n** set to NULL if the currently executing frame is the main program.\n*/\ntypedef struct VdbeFrame VdbeFrame;\nstruct VdbeFrame {\n  Vdbe *v;                /* VM this frame belongs to */\n  VdbeFrame *pParent;     /* Parent of this frame, or NULL if parent is main */\n  Op *aOp;                /* Program instructions for parent frame */\n  Mem *aMem;              /* Array of memory cells for parent frame */\n  VdbeCursor **apCsr;     /* Array of Vdbe cursors for parent frame */\n  u8 *aOnce;              /* Bitmask used by OP_Once */\n  void *token;            /* Copy of SubProgram.token */\n  i64 lastRowid;          /* Last insert rowid (sqlite3.lastRowid) */\n  AuxData *pAuxData;      /* Linked list of auxdata allocations */\n#if SQLITE_DEBUG\n  u32 iFrameMagic;        /* magic number for sanity checking */\n#endif\n  int nCursor;            /* Number of entries in apCsr */\n  int pc;                 /* Program Counter in parent (calling) frame */\n  int nOp;                /* Size of aOp array */\n  int nMem;               /* Number of entries in aMem */\n  int nChildMem;          /* Number of memory cells for child frame */\n  int nChildCsr;          /* Number of cursors for child frame */\n  i64 nChange;            /* Statement changes (Vdbe.nChange)     */\n  i64 nDbChange;          /* Value of db->nChange */\n};\n\n/* Magic number for sanity checking on VdbeFrame objects */\n#define SQLITE_FRAME_MAGIC 0x879fb71e\n\n/*\n** Return a pointer to the array of registers allocated for use\n** by a VdbeFrame.\n*/\n#define VdbeFrameMem(p) ((Mem *)&((u8 *)p)[ROUND8(sizeof(VdbeFrame))])\n\n/*\n** Internally, the vdbe manipulates nearly all SQL values as Mem\n** structures. Each Mem struct may cache multiple representations (string,\n** integer etc.) of the same value.\n*/\nstruct sqlite3_value {\n  union MemValue {\n    double r;           /* Real value used when MEM_Real is set in flags */\n    i64 i;              /* Integer value used when MEM_Int is set in flags */\n    int nZero;          /* Extra zero bytes when MEM_Zero and MEM_Blob set */\n    const char *zPType; /* Pointer type when MEM_Term|MEM_Subtype|MEM_Null */\n    FuncDef *pDef;      /* Used only when flags==MEM_Agg */\n  } u;\n  char *z;            /* String or BLOB value */\n  int n;              /* Number of characters in string value, excluding '\\0' */\n  u16 flags;          /* Some combination of MEM_Null, MEM_Str, MEM_Dyn, etc. */\n  u8  enc;            /* SQLITE_UTF8, SQLITE_UTF16BE, SQLITE_UTF16LE */\n  u8  eSubtype;       /* Subtype for this value */\n  /* ShallowCopy only needs to copy the information above */\n  sqlite3 *db;        /* The associated database connection */\n  int szMalloc;       /* Size of the zMalloc allocation */\n  u32 uTemp;          /* Transient storage for serial_type in OP_MakeRecord */\n  char *zMalloc;      /* Space to hold MEM_Str or MEM_Blob if szMalloc>0 */\n  void (*xDel)(void*);/* Destructor for Mem.z - only valid if MEM_Dyn */\n#ifdef SQLITE_DEBUG\n  Mem *pScopyFrom;    /* This Mem is a shallow copy of pScopyFrom */\n  u16 mScopyFlags;    /* flags value immediately after the shallow copy */\n  u8  bScopy;         /* The pScopyFrom of some other Mem *might* point here */\n#endif\n};\n\n/*\n** Size of struct Mem not including the Mem.zMalloc member or anything that\n** follows.\n*/\n#define MEMCELLSIZE offsetof(Mem,db)\n\n/* One or more of the following flags are set to indicate the\n** representations of the value stored in the Mem struct.\n**\n**  *  MEM_Null                An SQL NULL value\n**\n**  *  MEM_Null|MEM_Zero       An SQL NULL with the virtual table\n**                             UPDATE no-change flag set\n**\n**  *  MEM_Null|MEM_Term|      An SQL NULL, but also contains a\n**        MEM_Subtype          pointer accessible using\n**                             sqlite3_value_pointer().\n**\n**  *  MEM_Null|MEM_Cleared    Special SQL NULL that compares non-equal\n**                             to other NULLs even using the IS operator.\n**\n**  *  MEM_Str                 A string, stored in Mem.z with\n**                             length Mem.n.  Zero-terminated if\n**                             MEM_Term is set.  This flag is\n**                             incompatible with MEM_Blob and\n**                             MEM_Null, but can appear with MEM_Int,\n**                             MEM_Real, and MEM_IntReal.\n**\n**  *  MEM_Blob                A blob, stored in Mem.z length Mem.n.\n**                             Incompatible with MEM_Str, MEM_Null,\n**                             MEM_Int, MEM_Real, and MEM_IntReal.\n**\n**  *  MEM_Blob|MEM_Zero       A blob in Mem.z of length Mem.n plus\n**                             Mem.u.nZero extra 0x00 bytes at the end.\n**\n**  *  MEM_Int                 Integer stored in Mem.u.i.\n**\n**  *  MEM_Real                Real stored in Mem.u.r.\n**\n**  *  MEM_IntReal             Real stored as an integer in Mem.u.i.\n**\n** If the MEM_Null flag is set, then the value is an SQL NULL value.\n** For a pointer type created using sqlite3_bind_pointer() or\n** sqlite3_result_pointer() the MEM_Term and MEM_Subtype flags are also set.\n**\n** If the MEM_Str flag is set then Mem.z points at a string representation.\n** Usually this is encoded in the same unicode encoding as the main\n** database (see below for exceptions). If the MEM_Term flag is also\n** set, then the string is nul terminated. The MEM_Int and MEM_Real\n** flags may coexist with the MEM_Str flag.\n*/\n#define MEM_Undefined 0x0000   /* Value is undefined */\n#define MEM_Null      0x0001   /* Value is NULL (or a pointer) */\n#define MEM_Str       0x0002   /* Value is a string */\n#define MEM_Int       0x0004   /* Value is an integer */\n#define MEM_Real      0x0008   /* Value is a real number */\n#define MEM_Blob      0x0010   /* Value is a BLOB */\n#define MEM_IntReal   0x0020   /* MEM_Int that stringifies like MEM_Real */\n#define MEM_AffMask   0x003f   /* Mask of affinity bits */\n\n/* Extra bits that modify the meanings of the core datatypes above\n*/\n#define MEM_FromBind  0x0040   /* Value originates from sqlite3_bind() */\n /*                   0x0080   // Available */\n#define MEM_Cleared   0x0100   /* NULL set by OP_Null, not from data */\n#define MEM_Term      0x0200   /* String in Mem.z is zero terminated */\n#define MEM_Zero      0x0400   /* Mem.i contains count of 0s appended to blob */\n#define MEM_Subtype   0x0800   /* Mem.eSubtype is valid */\n#define MEM_TypeMask  0x0dbf   /* Mask of type bits */\n\n/* Bits that determine the storage for Mem.z for a string or blob or\n** aggregate accumulator.\n*/\n#define MEM_Dyn       0x1000   /* Need to call Mem.xDel() on Mem.z */\n#define MEM_Static    0x2000   /* Mem.z points to a static string */\n#define MEM_Ephem     0x4000   /* Mem.z points to an ephemeral string */\n#define MEM_Agg       0x8000   /* Mem.z points to an agg function context */\n\n/* Return TRUE if Mem X contains dynamically allocated content - anything\n** that needs to be deallocated to avoid a leak.\n*/\n#define VdbeMemDynamic(X)  \\\n  (((X)->flags&(MEM_Agg|MEM_Dyn))!=0)\n\n/*\n** Clear any existing type flags from a Mem and replace them with f\n*/\n#define MemSetTypeFlag(p, f) \\\n   ((p)->flags = ((p)->flags&~(MEM_TypeMask|MEM_Zero))|f)\n\n/*\n** True if Mem X is a NULL-nochng type.\n*/\n#define MemNullNochng(X) \\\n  (((X)->flags&MEM_TypeMask)==(MEM_Null|MEM_Zero) \\\n    && (X)->n==0 && (X)->u.nZero==0)\n\n/*\n** Return true if a memory cell has been initialized and is valid.\n** is for use inside assert() statements only.\n**\n** A Memory cell is initialized if at least one of the\n** MEM_Null, MEM_Str, MEM_Int, MEM_Real, MEM_Blob, or MEM_IntReal bits\n** is set.  It is \"undefined\" if all those bits are zero.\n*/\n#ifdef SQLITE_DEBUG\n#define memIsValid(M)  ((M)->flags & MEM_AffMask)!=0\n#endif\n\n/*\n** Each auxiliary data pointer stored by a user defined function\n** implementation calling sqlite3_set_auxdata() is stored in an instance\n** of this structure. All such structures associated with a single VM\n** are stored in a linked list headed at Vdbe.pAuxData. All are destroyed\n** when the VM is halted (if not before).\n*/\nstruct AuxData {\n  int iAuxOp;                     /* Instruction number of OP_Function opcode */\n  int iAuxArg;                    /* Index of function argument. */\n  void *pAux;                     /* Aux data pointer */\n  void (*xDeleteAux)(void*);      /* Destructor for the aux data */\n  AuxData *pNextAux;              /* Next element in list */\n};\n\n/*\n** The \"context\" argument for an installable function.  A pointer to an\n** instance of this structure is the first argument to the routines used\n** implement the SQL functions.\n**\n** There is a typedef for this structure in sqlite.h.  So all routines,\n** even the public interface to SQLite, can use a pointer to this structure.\n** But this file is the only place where the internal details of this\n** structure are known.\n**\n** This structure is defined inside of vdbeInt.h because it uses substructures\n** (Mem) which are only defined there.\n*/\nstruct sqlite3_context {\n  Mem *pOut;              /* The return value is stored here */\n  FuncDef *pFunc;         /* Pointer to function information */\n  Mem *pMem;              /* Memory cell used to store aggregate context */\n  Vdbe *pVdbe;            /* The VM that owns this context */\n  int iOp;                /* Instruction number of OP_Function */\n  int isError;            /* Error code returned by the function. */\n  u8 enc;                 /* Encoding to use for results */\n  u8 skipFlag;            /* Skip accumulator loading if true */\n  u16 argc;               /* Number of arguments */\n  sqlite3_value *argv[FLEXARRAY]; /* Argument set */\n};\n\n/*\n** The size (in bytes) of an sqlite3_context object that holds N\n** argv[] arguments.\n*/\n#define SZ_CONTEXT(N)  \\\n   (offsetof(sqlite3_context,argv)+(N)*sizeof(sqlite3_value*))\n\n\n/* The ScanStatus object holds a single value for the\n** sqlite3_stmt_scanstatus() interface.\n**\n** aAddrRange[]:\n**   This array is used by ScanStatus elements associated with EQP\n**   notes that make an SQLITE_SCANSTAT_NCYCLE value available. It is\n**   an array of up to 3 ranges of VM addresses for which the Vdbe.anCycle[]\n**   values should be summed to calculate the NCYCLE value. Each pair of\n**   integer addresses is a start and end address (both inclusive) for a range\n**   instructions. A start value of 0 indicates an empty range.\n*/\ntypedef struct ScanStatus ScanStatus;\nstruct ScanStatus {\n  int addrExplain;                /* OP_Explain for loop */\n  int aAddrRange[6];\n  int addrLoop;                   /* Address of \"loops\" counter */\n  int addrVisit;                  /* Address of \"rows visited\" counter */\n  int iSelectID;                  /* The \"Select-ID\" for this loop */\n  LogEst nEst;                    /* Estimated output rows per loop */\n  char *zName;                    /* Name of table or index */\n};\n\n/* The DblquoteStr object holds the text of a double-quoted\n** string for a prepared statement.  A linked list of these objects\n** is constructed during statement parsing and is held on Vdbe.pDblStr.\n** When computing a normalized SQL statement for an SQL statement, that\n** list is consulted for each double-quoted identifier to see if the\n** identifier should really be a string literal.\n*/\ntypedef struct DblquoteStr DblquoteStr;\nstruct DblquoteStr {\n  DblquoteStr *pNextStr;   /* Next string literal in the list */\n  char z[8];               /* Dequoted value for the string */\n};\n\n/*\n** An instance of the virtual machine.  This structure contains the complete\n** state of the virtual machine.\n**\n** The \"sqlite3_stmt\" structure pointer that is returned by sqlite3_prepare()\n** is really a pointer to an instance of this structure.\n*/\nstruct Vdbe {\n  sqlite3 *db;            /* The database connection that owns this statement */\n  Vdbe **ppVPrev,*pVNext; /* Linked list of VDBEs with the same Vdbe.db */\n  Parse *pParse;          /* Parsing context used to create this Vdbe */\n  ynVar nVar;             /* Number of entries in aVar[] */\n  int nMem;               /* Number of memory locations currently allocated */\n  int nCursor;            /* Number of slots in apCsr[] */\n  u32 cacheCtr;           /* VdbeCursor row cache generation counter */\n  int pc;                 /* The program counter */\n  int rc;                 /* Value to return */\n  i64 nChange;            /* Number of db changes made since last reset */\n  int iStatement;         /* Statement number (or 0 if has no opened stmt) */\n  i64 iCurrentTime;       /* Value of julianday('now') for this statement */\n  i64 nFkConstraint;      /* Number of imm. FK constraints this VM */\n  i64 nStmtDefCons;       /* Number of def. constraints when stmt started */\n  i64 nStmtDefImmCons;    /* Number of def. imm constraints when stmt started */\n  Mem *aMem;              /* The memory locations */\n  Mem **apArg;            /* Arguments xUpdate and xFilter vtab methods */\n  VdbeCursor **apCsr;     /* One element of this array for each open cursor */\n  Mem *aVar;              /* Values for the OP_Variable opcode. */\n\n  /* When allocating a new Vdbe object, all of the fields below should be\n  ** initialized to zero or NULL */\n\n  Op *aOp;                /* Space to hold the virtual machine's program */\n  int nOp;                /* Number of instructions in the program */\n  int nOpAlloc;           /* Slots allocated for aOp[] */\n  Mem *aColName;          /* Column names to return */\n  Mem *pResultRow;        /* Current output row */\n  char *zErrMsg;          /* Error message written here */\n  VList *pVList;          /* Name of variables */\n#ifndef SQLITE_OMIT_TRACE\n  i64 startTime;          /* Time when query started - used for profiling */\n#endif\n#ifdef SQLITE_DEBUG\n  int rcApp;              /* errcode set by sqlite3_result_error_code() */\n  u32 nWrite;             /* Number of write operations that have occurred */\n  int napArg;             /* Size of the apArg[] array */\n#endif\n  u16 nResColumn;         /* Number of columns in one row of the result set */\n  u16 nResAlloc;          /* Column slots allocated to aColName[] */\n  u8 errorAction;         /* Recovery action to do in case of an error */\n  u8 minWriteFileFormat;  /* Minimum file format for writable database files */\n  u8 prepFlags;           /* SQLITE_PREPARE_* flags */\n  u8 eVdbeState;          /* On of the VDBE_*_STATE values */\n  bft expired:2;          /* 1: recompile VM immediately  2: when convenient */\n  bft explain:2;          /* 0: normal, 1: EXPLAIN, 2: EXPLAIN QUERY PLAN */\n  bft changeCntOn:1;      /* True to update the change-counter */\n  bft usesStmtJournal:1;  /* True if uses a statement journal */\n  bft readOnly:1;         /* True for statements that do not write */\n  bft bIsReader:1;        /* True for statements that read */\n  bft haveEqpOps:1;       /* Bytecode supports EXPLAIN QUERY PLAN */\n  yDbMask btreeMask;      /* Bitmask of db->aDb[] entries referenced */\n  yDbMask lockMask;       /* Subset of btreeMask that requires a lock */\n  u32 aCounter[9];        /* Counters used by sqlite3_stmt_status() */\n  char *zSql;             /* Text of the SQL statement that generated this */\n#ifdef SQLITE_ENABLE_NORMALIZE\n  char *zNormSql;         /* Normalization of the associated SQL statement */\n  DblquoteStr *pDblStr;   /* List of double-quoted string literals */\n#endif\n  void *pFree;            /* Free this when deleting the vdbe */\n  VdbeFrame *pFrame;      /* Parent frame */\n  VdbeFrame *pDelFrame;   /* List of frame objects to free on VM reset */\n  int nFrame;             /* Number of frames in pFrame list */\n  u32 expmask;            /* Binding to these vars invalidates VM */\n  SubProgram *pProgram;   /* Linked list of all sub-programs used by VM */\n  AuxData *pAuxData;      /* Linked list of auxdata allocations */\n#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n  int nScan;              /* Entries in aScan[] */\n  ScanStatus *aScan;      /* Scan definitions for sqlite3_stmt_scanstatus() */\n#endif\n};\n\n/*\n** The following are allowed values for Vdbe.eVdbeState\n*/\n#define VDBE_INIT_STATE     0   /* Prepared statement under construction */\n#define VDBE_READY_STATE    1   /* Ready to run but not yet started */\n#define VDBE_RUN_STATE      2   /* Run in progress */\n#define VDBE_HALT_STATE     3   /* Finished.  Need reset() or finalize() */\n\n/*\n** Structure used to store the context required by the\n** sqlite3_preupdate_*() API functions.\n*/\nstruct PreUpdate {\n  Vdbe *v;\n  VdbeCursor *pCsr;               /* Cursor to read old values from */\n  int op;                         /* One of SQLITE_INSERT, UPDATE, DELETE */\n  u8 *aRecord;                    /* old.* database record */\n  KeyInfo *pKeyinfo;              /* Key information */\n  UnpackedRecord *pUnpacked;      /* Unpacked version of aRecord[] */\n  UnpackedRecord *pNewUnpacked;   /* Unpacked version of new.* record */\n  int iNewReg;                    /* Register for new.* values */\n  int iBlobWrite;                 /* Value returned by preupdate_blobwrite() */\n  i64 iKey1;                      /* First key value passed to hook */\n  i64 iKey2;                      /* Second key value passed to hook */\n  Mem oldipk;                     /* Memory cell holding \"old\" IPK value */\n  Mem *aNew;                      /* Array of new.* values */\n  Table *pTab;                    /* Schema object being updated */\n  Index *pPk;                     /* PK index if pTab is WITHOUT ROWID */\n  sqlite3_value **apDflt;         /* Array of default values, if required */\n  struct {\n    u8 keyinfoSpace[SZ_KEYINFO_0];  /* Space to hold pKeyinfo[0] content */\n  } uKey;\n};\n\n/*\n** An instance of this object is used to pass an vector of values into\n** OP_VFilter, the xFilter method of a virtual table.  The vector is the\n** set of values on the right-hand side of an IN constraint.\n**\n** The value as passed into xFilter is an sqlite3_value with a \"pointer\"\n** type, such as is generated by sqlite3_result_pointer() and read by\n** sqlite3_value_pointer.  Such values have MEM_Term|MEM_Subtype|MEM_Null\n** and a subtype of 'p'.  The sqlite3_vtab_in_first() and _next() interfaces\n** know how to use this object to step through all the values in the\n** right operand of the IN constraint.\n*/\ntypedef struct ValueList ValueList;\nstruct ValueList {\n  BtCursor *pCsr;          /* An ephemeral table holding all values */\n  sqlite3_value *pOut;     /* Register to hold each decoded output value */\n};\n\n/* Size of content associated with serial types that fit into a\n** single-byte varint.\n*/\n#ifndef SQLITE_AMALGAMATION\nextern const u8 sqlite3SmallTypeSizes[];\n#endif\n\n/*\n** Function prototypes\n*/\nvoid sqlite3VdbeError(Vdbe*, const char *, ...);\nvoid sqlite3VdbeFreeCursor(Vdbe *, VdbeCursor*);\nvoid sqlite3VdbeFreeCursorNN(Vdbe*,VdbeCursor*);\nvoid sqliteVdbePopStack(Vdbe*,int);\nint SQLITE_NOINLINE sqlite3VdbeHandleMovedCursor(VdbeCursor *p);\nint SQLITE_NOINLINE sqlite3VdbeFinishMoveto(VdbeCursor*);\nint sqlite3VdbeCursorRestore(VdbeCursor*);\nu32 sqlite3VdbeSerialTypeLen(u32);\nu8 sqlite3VdbeOneByteSerialTypeLen(u8);\n#ifdef SQLITE_MIXED_ENDIAN_64BIT_FLOAT\n  u64 sqlite3FloatSwap(u64 in);\n# define swapMixedEndianFloat(X)  X = sqlite3FloatSwap(X)\n#else\n# define swapMixedEndianFloat(X)\n#endif\nvoid sqlite3VdbeSerialGet(const unsigned char*, u32, Mem*);\nvoid sqlite3VdbeDeleteAuxData(sqlite3*, AuxData**, int, int);\n\nint sqlite2BtreeKeyCompare(BtCursor *, const void *, int, int, int *);\nint sqlite3VdbeIdxKeyCompare(sqlite3*,VdbeCursor*,UnpackedRecord*,int*);\nint sqlite3VdbeIdxRowid(sqlite3*, BtCursor*, i64*);\nint sqlite3VdbeExec(Vdbe*);\n#if !defined(SQLITE_OMIT_EXPLAIN) || defined(SQLITE_ENABLE_BYTECODE_VTAB)\nint sqlite3VdbeNextOpcode(Vdbe*,Mem*,int,int*,int*,Op**);\nchar *sqlite3VdbeDisplayP4(sqlite3*,Op*);\n#endif\n#if defined(SQLITE_ENABLE_EXPLAIN_COMMENTS)\nchar *sqlite3VdbeDisplayComment(sqlite3*,const Op*,const char*);\n#endif\n#if !defined(SQLITE_OMIT_EXPLAIN)\nint sqlite3VdbeList(Vdbe*);\n#endif\nint sqlite3VdbeHalt(Vdbe*);\nint sqlite3VdbeChangeEncoding(Mem *, int);\nint sqlite3VdbeMemTooBig(Mem*);\nint sqlite3VdbeMemCopy(Mem*, const Mem*);\nvoid sqlite3VdbeMemShallowCopy(Mem*, const Mem*, int);\nvoid sqlite3VdbeMemMove(Mem*, Mem*);\nint sqlite3VdbeMemNulTerminate(Mem*);\nint sqlite3VdbeMemSetStr(Mem*, const char*, i64, u8, void(*)(void*));\nint sqlite3VdbeMemSetText(Mem*, const char*, i64, void(*)(void*));\nvoid sqlite3VdbeMemSetInt64(Mem*, i64);\n#ifdef SQLITE_OMIT_FLOATING_POINT\n# define sqlite3VdbeMemSetDouble sqlite3VdbeMemSetInt64\n#else\n  void sqlite3VdbeMemSetDouble(Mem*, double);\n#endif\nvoid sqlite3VdbeMemSetPointer(Mem*, void*, const char*, void(*)(void*));\nvoid sqlite3VdbeMemInit(Mem*,sqlite3*,u16);\nvoid sqlite3VdbeMemSetNull(Mem*);\n#ifndef SQLITE_OMIT_INCRBLOB\nvoid sqlite3VdbeMemSetZeroBlob(Mem*,int);\n#else\nint sqlite3VdbeMemSetZeroBlob(Mem*,int);\n#endif\n#ifdef SQLITE_DEBUG\nint sqlite3VdbeMemIsRowSet(const Mem*);\n#endif\nint sqlite3VdbeMemSetRowSet(Mem*);\nvoid sqlite3VdbeMemZeroTerminateIfAble(Mem*);\nint sqlite3VdbeMemMakeWriteable(Mem*);\nint sqlite3VdbeMemStringify(Mem*, u8, u8);\nint sqlite3IntFloatCompare(i64,double);\ni64 sqlite3VdbeIntValue(const Mem*);\nint sqlite3VdbeMemIntegerify(Mem*);\ndouble sqlite3VdbeRealValue(Mem*);\nint sqlite3VdbeBooleanValue(Mem*, int ifNull);\nvoid sqlite3VdbeIntegerAffinity(Mem*);\nint sqlite3VdbeMemRealify(Mem*);\nint sqlite3VdbeMemNumerify(Mem*);\nint sqlite3VdbeMemCast(Mem*,u8,u8);\nint sqlite3VdbeMemFromBtree(BtCursor*,u32,u32,Mem*);\nint sqlite3VdbeMemFromBtreeZeroOffset(BtCursor*,u32,Mem*);\nvoid sqlite3VdbeMemRelease(Mem *p);\nvoid sqlite3VdbeMemReleaseMalloc(Mem*p);\nint sqlite3VdbeMemFinalize(Mem*, FuncDef*);\n#ifndef SQLITE_OMIT_WINDOWFUNC\nint sqlite3VdbeMemAggValue(Mem*, Mem*, FuncDef*);\n#endif\n#if !defined(SQLITE_OMIT_EXPLAIN) || defined(SQLITE_ENABLE_BYTECODE_VTAB)\nconst char *sqlite3OpcodeName(int);\n#endif\nint sqlite3VdbeMemGrow(Mem *pMem, int n, int preserve);\nint sqlite3VdbeMemClearAndResize(Mem *pMem, int n);\nint sqlite3VdbeCloseStatement(Vdbe *, int);\n#ifdef SQLITE_DEBUG\nint sqlite3VdbeFrameIsValid(VdbeFrame*);\n#endif\nvoid sqlite3VdbeFrameMemDel(void*);      /* Destructor on Mem */\nvoid sqlite3VdbeFrameDelete(VdbeFrame*); /* Actually deletes the Frame */\nint sqlite3VdbeFrameRestore(VdbeFrame *);\n#ifdef SQLITE_ENABLE_PREUPDATE_HOOK\nvoid sqlite3VdbePreUpdateHook(\n    Vdbe*,VdbeCursor*,int,const char*,Table*,i64,int,int);\n#endif\nint sqlite3VdbeTransferError(Vdbe *p);\n\nint sqlite3VdbeSorterInit(sqlite3 *, int, VdbeCursor *);\nvoid sqlite3VdbeSorterReset(sqlite3 *, VdbeSorter *);\nvoid sqlite3VdbeSorterClose(sqlite3 *, VdbeCursor *);\nint sqlite3VdbeSorterRowkey(const VdbeCursor *, Mem *);\nint sqlite3VdbeSorterNext(sqlite3 *, const VdbeCursor *);\nint sqlite3VdbeSorterRewind(const VdbeCursor *, int *);\nint sqlite3VdbeSorterWrite(const VdbeCursor *, Mem *);\nint sqlite3VdbeSorterCompare(const VdbeCursor *, Mem *, int, int *);\n\nvoid sqlite3VdbeValueListFree(void*);\n\n#ifdef SQLITE_DEBUG\n  void sqlite3VdbeIncrWriteCounter(Vdbe*, VdbeCursor*);\n  void sqlite3VdbeAssertAbortable(Vdbe*);\n#else\n# define sqlite3VdbeIncrWriteCounter(V,C)\n# define sqlite3VdbeAssertAbortable(V)\n#endif\n\n#if !defined(SQLITE_OMIT_SHARED_CACHE)\n  void sqlite3VdbeEnter(Vdbe*);\n#else\n# define sqlite3VdbeEnter(X)\n#endif\n\n#if !defined(SQLITE_OMIT_SHARED_CACHE) && SQLITE_THREADSAFE>0\n  void sqlite3VdbeLeave(Vdbe*);\n#else\n# define sqlite3VdbeLeave(X)\n#endif\n\n#ifdef SQLITE_DEBUG\nvoid sqlite3VdbeMemAboutToChange(Vdbe*,Mem*);\nint sqlite3VdbeCheckMemInvariants(Mem*);\n#endif\n\n#ifndef SQLITE_OMIT_FOREIGN_KEY\nint sqlite3VdbeCheckFkImmediate(Vdbe*);\nint sqlite3VdbeCheckFkDeferred(Vdbe*);\n#else\n# define sqlite3VdbeCheckFkImmediate(p) 0\n# define sqlite3VdbeCheckFkDeferred(p) 0\n#endif\n\n#ifdef SQLITE_DEBUG\n  void sqlite3VdbePrintSql(Vdbe*);\n  void sqlite3VdbeMemPrettyPrint(Mem *pMem, StrAccum *pStr);\n#endif\n#ifndef SQLITE_OMIT_UTF16\n  int sqlite3VdbeMemTranslate(Mem*, u8);\n  int sqlite3VdbeMemHandleBom(Mem *pMem);\n#endif\n\n#ifndef SQLITE_OMIT_INCRBLOB\n  int sqlite3VdbeMemExpandBlob(Mem *);\n  #define ExpandBlob(P) (((P)->flags&MEM_Zero)?sqlite3VdbeMemExpandBlob(P):0)\n#else\n  #define sqlite3VdbeMemExpandBlob(x) SQLITE_OK\n  #define ExpandBlob(P) SQLITE_OK\n#endif\n\n#endif /* !defined(SQLITE_VDBEINT_H) */\n"}
{"repo": "sqlite", "file": "vdbesort.c", "lang": "C++", "code": "/*\n** 2011-07-09\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains code for the VdbeSorter object, used in concert with\n** a VdbeCursor to sort large numbers of keys for CREATE INDEX statements\n** or by SELECT statements with ORDER BY clauses that cannot be satisfied\n** using indexes and without LIMIT clauses.\n**\n** The VdbeSorter object implements a multi-threaded external merge sort\n** algorithm that is efficient even if the number of elements being sorted\n** exceeds the available memory.\n**\n** Here is the (internal, non-API) interface between this module and the\n** rest of the SQLite system:\n**\n**    sqlite3VdbeSorterInit()       Create a new VdbeSorter object.\n**\n**    sqlite3VdbeSorterWrite()      Add a single new row to the VdbeSorter\n**                                  object.  The row is a binary blob in the\n**                                  OP_MakeRecord format that contains both\n**                                  the ORDER BY key columns and result columns\n**                                  in the case of a SELECT w/ ORDER BY, or\n**                                  the complete record for an index entry\n**                                  in the case of a CREATE INDEX.\n**\n**    sqlite3VdbeSorterRewind()     Sort all content previously added.\n**                                  Position the read cursor on the\n**                                  first sorted element.\n**\n**    sqlite3VdbeSorterNext()       Advance the read cursor to the next sorted\n**                                  element.\n**\n**    sqlite3VdbeSorterRowkey()     Return the complete binary blob for the\n**                                  row currently under the read cursor.\n**\n**    sqlite3VdbeSorterCompare()    Compare the binary blob for the row\n**                                  currently under the read cursor against\n**                                  another binary blob X and report if\n**                                  X is strictly less than the read cursor.\n**                                  Used to enforce uniqueness in a\n**                                  CREATE UNIQUE INDEX statement.\n**\n**    sqlite3VdbeSorterClose()      Close the VdbeSorter object and reclaim\n**                                  all resources.\n**\n**    sqlite3VdbeSorterReset()      Refurbish the VdbeSorter for reuse.  This\n**                                  is like Close() followed by Init() only\n**                                  much faster.\n**\n** The interfaces above must be called in a particular order.  Write() can\n** only occur in between Init()/Reset() and Rewind().  Next(), Rowkey(), and\n** Compare() can only occur in between Rewind() and Close()/Reset(). i.e.\n**\n**   Init()\n**   for each record: Write()\n**   Rewind()\n**     Rowkey()/Compare()\n**   Next()\n**   Close()\n**\n** Algorithm:\n**\n** Records passed to the sorter via calls to Write() are initially held\n** unsorted in main memory. Assuming the amount of memory used never exceeds\n** a threshold, when Rewind() is called the set of records is sorted using\n** an in-memory merge sort. In this case, no temporary files are required\n** and subsequent calls to Rowkey(), Next() and Compare() read records\n** directly from main memory.\n**\n** If the amount of space used to store records in main memory exceeds the\n** threshold, then the set of records currently in memory are sorted and\n** written to a temporary file in \"Packed Memory Array\" (PMA) format.\n** A PMA created at this point is known as a \"level-0 PMA\". Higher levels\n** of PMAs may be created by merging existing PMAs together - for example\n** merging two or more level-0 PMAs together creates a level-1 PMA.\n**\n** The threshold for the amount of main memory to use before flushing\n** records to a PMA is roughly the same as the limit configured for the\n** page-cache of the main database. Specifically, the threshold is set to\n** the value returned by \"PRAGMA main.page_size\" multiplied by\n** that returned by \"PRAGMA main.cache_size\", in bytes.\n**\n** If the sorter is running in single-threaded mode, then all PMAs generated\n** are appended to a single temporary file. Or, if the sorter is running in\n** multi-threaded mode then up to (N+1) temporary files may be opened, where\n** N is the configured number of worker threads. In this case, instead of\n** sorting the records and writing the PMA to a temporary file itself, the\n** calling thread usually launches a worker thread to do so. Except, if\n** there are already N worker threads running, the main thread does the work\n** itself.\n**\n** The sorter is running in multi-threaded mode if (a) the library was built\n** with pre-processor symbol SQLITE_MAX_WORKER_THREADS set to a value greater\n** than zero, and (b) worker threads have been enabled at runtime by calling\n** \"PRAGMA threads=N\" with some value of N greater than 0.\n**\n** When Rewind() is called, any data remaining in memory is flushed to a\n** final PMA. So at this point the data is stored in some number of sorted\n** PMAs within temporary files on disk.\n**\n** If there are fewer than SORTER_MAX_MERGE_COUNT PMAs in total and the\n** sorter is running in single-threaded mode, then these PMAs are merged\n** incrementally as keys are retrieved from the sorter by the VDBE.  The\n** MergeEngine object, described in further detail below, performs this\n** merge.\n**\n** Or, if running in multi-threaded mode, then a background thread is\n** launched to merge the existing PMAs. Once the background thread has\n** merged T bytes of data into a single sorted PMA, the main thread\n** begins reading keys from that PMA while the background thread proceeds\n** with merging the next T bytes of data. And so on.\n**\n** Parameter T is set to half the value of the memory threshold used\n** by Write() above to determine when to create a new PMA.\n**\n** If there are more than SORTER_MAX_MERGE_COUNT PMAs in total when\n** Rewind() is called, then a hierarchy of incremental-merges is used.\n** First, T bytes of data from the first SORTER_MAX_MERGE_COUNT PMAs on\n** disk are merged together. Then T bytes of data from the second set, and\n** so on, such that no operation ever merges more than SORTER_MAX_MERGE_COUNT\n** PMAs at a time. This done is to improve locality.\n**\n** If running in multi-threaded mode and there are more than\n** SORTER_MAX_MERGE_COUNT PMAs on disk when Rewind() is called, then more\n** than one background thread may be created. Specifically, there may be\n** one background thread for each temporary file on disk, and one background\n** thread to merge the output of each of the others to a single PMA for\n** the main thread to read from.\n*/\n#include \"sqliteInt.h\"\n#include \"vdbeInt.h\"\n\n/*\n** If SQLITE_DEBUG_SORTER_THREADS is defined, this module outputs various\n** messages to stderr that may be helpful in understanding the performance\n** characteristics of the sorter in multi-threaded mode.\n*/\n#if 0\n# define SQLITE_DEBUG_SORTER_THREADS 1\n#endif\n\n/*\n** Hard-coded maximum amount of data to accumulate in memory before flushing\n** to a level 0 PMA. The purpose of this limit is to prevent various integer\n** overflows. 512MiB.\n*/\n#define SQLITE_MAX_PMASZ    (1<<29)\n\n/*\n** Private objects used by the sorter\n*/\ntypedef struct MergeEngine MergeEngine;     /* Merge PMAs together */\ntypedef struct PmaReader PmaReader;         /* Incrementally read one PMA */\ntypedef struct PmaWriter PmaWriter;         /* Incrementally write one PMA */\ntypedef struct SorterRecord SorterRecord;   /* A record being sorted */\ntypedef struct SortSubtask SortSubtask;     /* A sub-task in the sort process */\ntypedef struct SorterFile SorterFile;       /* Temporary file object wrapper */\ntypedef struct SorterList SorterList;       /* In-memory list of records */\ntypedef struct IncrMerger IncrMerger;       /* Read & merge multiple PMAs */\n\n/*\n** A container for a temp file handle and the current amount of data\n** stored in the file.\n*/\nstruct SorterFile {\n  sqlite3_file *pFd;              /* File handle */\n  i64 iEof;                       /* Bytes of data stored in pFd */\n};\n\n/*\n** An in-memory list of objects to be sorted.\n**\n** If aMemory==0 then each object is allocated separately and the objects\n** are connected using SorterRecord.u.pNext.  If aMemory!=0 then all objects\n** are stored in the aMemory[] bulk memory, one right after the other, and\n** are connected using SorterRecord.u.iNext.\n*/\nstruct SorterList {\n  SorterRecord *pList;            /* Linked list of records */\n  u8 *aMemory;                    /* If non-NULL, bulk memory to hold pList */\n  i64 szPMA;                      /* Size of pList as PMA in bytes */\n};\n\n/*\n** The MergeEngine object is used to combine two or more smaller PMAs into\n** one big PMA using a merge operation.  Separate PMAs all need to be\n** combined into one big PMA in order to be able to step through the sorted\n** records in order.\n**\n** The aReadr[] array contains a PmaReader object for each of the PMAs being\n** merged.  An aReadr[] object either points to a valid key or else is at EOF.\n** (\"EOF\" means \"End Of File\".  When aReadr[] is at EOF there is no more data.)\n** For the purposes of the paragraphs below, we assume that the array is\n** actually N elements in size, where N is the smallest power of 2 greater\n** to or equal to the number of PMAs being merged. The extra aReadr[] elements\n** are treated as if they are empty (always at EOF).\n**\n** The aTree[] array is also N elements in size. The value of N is stored in\n** the MergeEngine.nTree variable.\n**\n** The final (N/2) elements of aTree[] contain the results of comparing\n** pairs of PMA keys together. Element i contains the result of\n** comparing aReadr[2*i-N] and aReadr[2*i-N+1]. Whichever key is smaller, the\n** aTree element is set to the index of it.\n**\n** For the purposes of this comparison, EOF is considered greater than any\n** other key value. If the keys are equal (only possible with two EOF\n** values), it doesn't matter which index is stored.\n**\n** The (N/4) elements of aTree[] that precede the final (N/2) described\n** above contains the index of the smallest of each block of 4 PmaReaders\n** And so on. So that aTree[1] contains the index of the PmaReader that\n** currently points to the smallest key value. aTree[0] is unused.\n**\n** Example:\n**\n**     aReadr[0] -> Banana\n**     aReadr[1] -> Feijoa\n**     aReadr[2] -> Elderberry\n**     aReadr[3] -> Currant\n**     aReadr[4] -> Grapefruit\n**     aReadr[5] -> Apple\n**     aReadr[6] -> Durian\n**     aReadr[7] -> EOF\n**\n**     aTree[] = { X, 5   0, 5    0, 3, 5, 6 }\n**\n** The current element is \"Apple\" (the value of the key indicated by\n** PmaReader 5). When the Next() operation is invoked, PmaReader 5 will\n** be advanced to the next key in its segment. Say the next key is\n** \"Eggplant\":\n**\n**     aReadr[5] -> Eggplant\n**\n** The contents of aTree[] are updated first by comparing the new PmaReader\n** 5 key to the current key of PmaReader 4 (still \"Grapefruit\"). The PmaReader\n** 5 value is still smaller, so aTree[6] is set to 5. And so on up the tree.\n** The value of PmaReader 6 - \"Durian\" - is now smaller than that of PmaReader\n** 5, so aTree[3] is set to 6. Key 0 is smaller than key 6 (Banana<Durian),\n** so the value written into element 1 of the array is 0. As follows:\n**\n**     aTree[] = { X, 0   0, 6    0, 3, 5, 6 }\n**\n** In other words, each time we advance to the next sorter element, log2(N)\n** key comparison operations are required, where N is the number of segments\n** being merged (rounded up to the next power of 2).\n*/\nstruct MergeEngine {\n  int nTree;                 /* Used size of aTree/aReadr (power of 2) */\n  SortSubtask *pTask;        /* Used by this thread only */\n  int *aTree;                /* Current state of incremental merge */\n  PmaReader *aReadr;         /* Array of PmaReaders to merge data from */\n};\n\n/*\n** This object represents a single thread of control in a sort operation.\n** Exactly VdbeSorter.nTask instances of this object are allocated\n** as part of each VdbeSorter object. Instances are never allocated any\n** other way. VdbeSorter.nTask is set to the number of worker threads allowed\n** (see SQLITE_CONFIG_WORKER_THREADS) plus one (the main thread).  Thus for\n** single-threaded operation, there is exactly one instance of this object\n** and for multi-threaded operation there are two or more instances.\n**\n** Essentially, this structure contains all those fields of the VdbeSorter\n** structure for which each thread requires a separate instance. For example,\n** each thread requeries its own UnpackedRecord object to unpack records in\n** as part of comparison operations.\n**\n** Before a background thread is launched, variable bDone is set to 0. Then,\n** right before it exits, the thread itself sets bDone to 1. This is used for\n** two purposes:\n**\n**   1. When flushing the contents of memory to a level-0 PMA on disk, to\n**      attempt to select a SortSubtask for which there is not already an\n**      active background thread (since doing so causes the main thread\n**      to block until it finishes).\n**\n**   2. If SQLITE_DEBUG_SORTER_THREADS is defined, to determine if a call\n**      to sqlite3ThreadJoin() is likely to block. Cases that are likely to\n**      block provoke debugging output.\n**\n** In both cases, the effects of the main thread seeing (bDone==0) even\n** after the thread has finished are not dire. So we don't worry about\n** memory barriers and such here.\n*/\ntypedef int (*SorterCompare)(SortSubtask*,int*,const void*,int,const void*,int);\nstruct SortSubtask {\n  SQLiteThread *pThread;          /* Background thread, if any */\n  int bDone;                      /* Set if thread is finished but not joined */\n  int nPMA;                       /* Number of PMAs currently in file */\n  VdbeSorter *pSorter;            /* Sorter that owns this sub-task */\n  UnpackedRecord *pUnpacked;      /* Space to unpack a record */\n  SorterList list;                /* List for thread to write to a PMA */\n  SorterCompare xCompare;         /* Compare function to use */\n  SorterFile file;                /* Temp file for level-0 PMAs */\n  SorterFile file2;               /* Space for other PMAs */\n  u64 nSpill;                     /* Total bytes written by this task */\n};\n\n\n/*\n** Main sorter structure. A single instance of this is allocated for each\n** sorter cursor created by the VDBE.\n**\n** mxKeysize:\n**   As records are added to the sorter by calls to sqlite3VdbeSorterWrite(),\n**   this variable is updated so as to be set to the size on disk of the\n**   largest record in the sorter.\n*/\nstruct VdbeSorter {\n  int mnPmaSize;                  /* Minimum PMA size, in bytes */\n  int mxPmaSize;                  /* Maximum PMA size, in bytes.  0==no limit */\n  int mxKeysize;                  /* Largest serialized key seen so far */\n  int pgsz;                       /* Main database page size */\n  PmaReader *pReader;             /* Readr data from here after Rewind() */\n  MergeEngine *pMerger;           /* Or here, if bUseThreads==0 */\n  sqlite3 *db;                    /* Database connection */\n  KeyInfo *pKeyInfo;              /* How to compare records */\n  UnpackedRecord *pUnpacked;      /* Used by VdbeSorterCompare() */\n  SorterList list;                /* List of in-memory records */\n  int iMemory;                    /* Offset of free space in list.aMemory */\n  int nMemory;                    /* Size of list.aMemory allocation in bytes */\n  u8 bUsePMA;                     /* True if one or more PMAs created */\n  u8 bUseThreads;                 /* True to use background threads */\n  u8 iPrev;                       /* Previous thread used to flush PMA */\n  u8 nTask;                       /* Size of aTask[] array */\n  u8 typeMask;\n  SortSubtask aTask[FLEXARRAY];   /* One or more subtasks */\n};\n\n/* Size (in bytes) of a VdbeSorter object that works with N or fewer subtasks */\n#define SZ_VDBESORTER(N)  (offsetof(VdbeSorter,aTask)+(N)*sizeof(SortSubtask))\n\n#define SORTER_TYPE_INTEGER 0x01\n#define SORTER_TYPE_TEXT    0x02\n\n/*\n** An instance of the following object is used to read records out of a\n** PMA, in sorted order.  The next key to be read is cached in nKey/aKey.\n** aKey might point into aMap or into aBuffer.  If neither of those locations\n** contain a contiguous representation of the key, then aAlloc is allocated\n** and the key is copied into aAlloc and aKey is made to point to aAlloc.\n**\n** pFd==0 at EOF.\n*/\nstruct PmaReader {\n  i64 iReadOff;               /* Current read offset */\n  i64 iEof;                   /* 1 byte past EOF for this PmaReader */\n  int nAlloc;                 /* Bytes of space at aAlloc */\n  int nKey;                   /* Number of bytes in key */\n  sqlite3_file *pFd;          /* File handle we are reading from */\n  u8 *aAlloc;                 /* Space for aKey if aBuffer and pMap wont work */\n  u8 *aKey;                   /* Pointer to current key */\n  u8 *aBuffer;                /* Current read buffer */\n  int nBuffer;                /* Size of read buffer in bytes */\n  u8 *aMap;                   /* Pointer to mapping of entire file */\n  IncrMerger *pIncr;          /* Incremental merger */\n};\n\n/*\n** Normally, a PmaReader object iterates through an existing PMA stored\n** within a temp file. However, if the PmaReader.pIncr variable points to\n** an object of the following type, it may be used to iterate/merge through\n** multiple PMAs simultaneously.\n**\n** There are two types of IncrMerger object - single (bUseThread==0) and\n** multi-threaded (bUseThread==1).\n**\n** A multi-threaded IncrMerger object uses two temporary files - aFile[0]\n** and aFile[1]. Neither file is allowed to grow to more than mxSz bytes in\n** size. When the IncrMerger is initialized, it reads enough data from\n** pMerger to populate aFile[0]. It then sets variables within the\n** corresponding PmaReader object to read from that file and kicks off\n** a background thread to populate aFile[1] with the next mxSz bytes of\n** sorted record data from pMerger.\n**\n** When the PmaReader reaches the end of aFile[0], it blocks until the\n** background thread has finished populating aFile[1]. It then exchanges\n** the contents of the aFile[0] and aFile[1] variables within this structure,\n** sets the PmaReader fields to read from the new aFile[0] and kicks off\n** another background thread to populate the new aFile[1]. And so on, until\n** the contents of pMerger are exhausted.\n**\n** A single-threaded IncrMerger does not open any temporary files of its\n** own. Instead, it has exclusive access to mxSz bytes of space beginning\n** at offset iStartOff of file pTask->file2. And instead of using a\n** background thread to prepare data for the PmaReader, with a single\n** threaded IncrMerger the allocate part of pTask->file2 is \"refilled\" with\n** keys from pMerger by the calling thread whenever the PmaReader runs out\n** of data.\n*/\nstruct IncrMerger {\n  SortSubtask *pTask;             /* Task that owns this merger */\n  MergeEngine *pMerger;           /* Merge engine thread reads data from */\n  i64 iStartOff;                  /* Offset to start writing file at */\n  int mxSz;                       /* Maximum bytes of data to store */\n  int bEof;                       /* Set to true when merge is finished */\n  int bUseThread;                 /* True to use a bg thread for this object */\n  SorterFile aFile[2];            /* aFile[0] for reading, [1] for writing */\n};\n\n/*\n** An instance of this object is used for writing a PMA.\n**\n** The PMA is written one record at a time.  Each record is of an arbitrary\n** size.  But I/O is more efficient if it occurs in page-sized blocks where\n** each block is aligned on a page boundary.  This object caches writes to\n** the PMA so that aligned, page-size blocks are written.\n*/\nstruct PmaWriter {\n  int eFWErr;                     /* Non-zero if in an error state */\n  u8 *aBuffer;                    /* Pointer to write buffer */\n  int nBuffer;                    /* Size of write buffer in bytes */\n  int iBufStart;                  /* First byte of buffer to write */\n  int iBufEnd;                    /* Last byte of buffer to write */\n  i64 iWriteOff;                  /* Offset of start of buffer in file */\n  sqlite3_file *pFd;              /* File handle to write to */\n  u64 nPmaSpill;                  /* Total number of bytes written */\n};\n\n/*\n** This object is the header on a single record while that record is being\n** held in memory and prior to being written out as part of a PMA.\n**\n** How the linked list is connected depends on how memory is being managed\n** by this module. If using a separate allocation for each in-memory record\n** (VdbeSorter.list.aMemory==0), then the list is always connected using the\n** SorterRecord.u.pNext pointers.\n**\n** Or, if using the single large allocation method (VdbeSorter.list.aMemory!=0),\n** then while records are being accumulated the list is linked using the\n** SorterRecord.u.iNext offset. This is because the aMemory[] array may\n** be sqlite3Realloc()ed while records are being accumulated. Once the VM\n** has finished passing records to the sorter, or when the in-memory buffer\n** is full, the list is sorted. As part of the sorting process, it is\n** converted to use the SorterRecord.u.pNext pointers. See function\n** vdbeSorterSort() for details.\n*/\nstruct SorterRecord {\n  int nVal;                       /* Size of the record in bytes */\n  union {\n    SorterRecord *pNext;          /* Pointer to next record in list */\n    int iNext;                    /* Offset within aMemory of next record */\n  } u;\n  /* The data for the record immediately follows this header */\n};\n\n/* Return a pointer to the buffer containing the record data for SorterRecord\n** object p. Should be used as if:\n**\n**   void *SRVAL(SorterRecord *p) { return (void*)&p[1]; }\n*/\n#define SRVAL(p) ((void*)((SorterRecord*)(p) + 1))\n\n\n/* Maximum number of PMAs that a single MergeEngine can merge */\n#define SORTER_MAX_MERGE_COUNT 16\n\nstatic int vdbeIncrSwap(IncrMerger*);\nstatic void vdbeIncrFree(IncrMerger *);\n\n/*\n** Free all memory belonging to the PmaReader object passed as the\n** argument. All structure fields are set to zero before returning.\n*/\nstatic void vdbePmaReaderClear(PmaReader *pReadr){\n  sqlite3_free(pReadr->aAlloc);\n  sqlite3_free(pReadr->aBuffer);\n  if( pReadr->aMap ) sqlite3OsUnfetch(pReadr->pFd, 0, pReadr->aMap);\n  vdbeIncrFree(pReadr->pIncr);\n  memset(pReadr, 0, sizeof(PmaReader));\n}\n\n/*\n** Read the next nByte bytes of data from the PMA p.\n** If successful, set *ppOut to point to a buffer containing the data\n** and return SQLITE_OK. Otherwise, if an error occurs, return an SQLite\n** error code.\n**\n** The buffer returned in *ppOut is only valid until the\n** next call to this function.\n*/\nstatic int vdbePmaReadBlob(\n  PmaReader *p,                   /* PmaReader from which to take the blob */\n  int nByte,                      /* Bytes of data to read */\n  u8 **ppOut                      /* OUT: Pointer to buffer containing data */\n){\n  int iBuf;                       /* Offset within buffer to read from */\n  int nAvail;                     /* Bytes of data available in buffer */\n\n  if( p->aMap ){\n    *ppOut = &p->aMap[p->iReadOff];\n    p->iReadOff += nByte;\n    return SQLITE_OK;\n  }\n\n  assert( p->aBuffer );\n\n  /* If there is no more data to be read from the buffer, read the next\n  ** p->nBuffer bytes of data from the file into it. Or, if there are less\n  ** than p->nBuffer bytes remaining in the PMA, read all remaining data.  */\n  iBuf = p->iReadOff % p->nBuffer;\n  if( iBuf==0 ){\n    int nRead;                    /* Bytes to read from disk */\n    int rc;                       /* sqlite3OsRead() return code */\n\n    /* Determine how many bytes of data to read. */\n    if( (p->iEof - p->iReadOff) > (i64)p->nBuffer ){\n      nRead = p->nBuffer;\n    }else{\n      nRead = (int)(p->iEof - p->iReadOff);\n    }\n    assert( nRead>0 );\n\n    /* Readr data from the file. Return early if an error occurs. */\n    rc = sqlite3OsRead(p->pFd, p->aBuffer, nRead, p->iReadOff);\n    assert( rc!=SQLITE_IOERR_SHORT_READ );\n    if( rc!=SQLITE_OK ) return rc;\n  }\n  nAvail = p->nBuffer - iBuf;\n\n  if( nByte<=nAvail ){\n    /* The requested data is available in the in-memory buffer. In this\n    ** case there is no need to make a copy of the data, just return a\n    ** pointer into the buffer to the caller.  */\n    *ppOut = &p->aBuffer[iBuf];\n    p->iReadOff += nByte;\n  }else{\n    /* The requested data is not all available in the in-memory buffer.\n    ** In this case, allocate space at p->aAlloc[] to copy the requested\n    ** range into. Then return a copy of pointer p->aAlloc to the caller.  */\n    int nRem;                     /* Bytes remaining to copy */\n\n    /* Extend the p->aAlloc[] allocation if required. */\n    if( p->nAlloc<nByte ){\n      u8 *aNew;\n      sqlite3_int64 nNew = MAX(128, 2*(sqlite3_int64)p->nAlloc);\n      while( nByte>nNew ) nNew = nNew*2;\n      aNew = sqlite3Realloc(p->aAlloc, nNew);\n      if( !aNew ) return SQLITE_NOMEM_BKPT;\n      p->nAlloc = nNew;\n      p->aAlloc = aNew;\n    }\n\n    /* Copy as much data as is available in the buffer into the start of\n    ** p->aAlloc[].  */\n    memcpy(p->aAlloc, &p->aBuffer[iBuf], nAvail);\n    p->iReadOff += nAvail;\n    nRem = nByte - nAvail;\n\n    /* The following loop copies up to p->nBuffer bytes per iteration into\n    ** the p->aAlloc[] buffer.  */\n    while( nRem>0 ){\n      int rc;                     /* vdbePmaReadBlob() return code */\n      int nCopy;                  /* Number of bytes to copy */\n      u8 *aNext = 0;              /* Pointer to buffer to copy data from */\n\n      nCopy = nRem;\n      if( nRem>p->nBuffer ) nCopy = p->nBuffer;\n      rc = vdbePmaReadBlob(p, nCopy, &aNext);\n      if( rc!=SQLITE_OK ) return rc;\n      assert( aNext!=p->aAlloc );\n      assert( aNext!=0 );\n      memcpy(&p->aAlloc[nByte - nRem], aNext, nCopy);\n      nRem -= nCopy;\n    }\n\n    *ppOut = p->aAlloc;\n  }\n\n  return SQLITE_OK;\n}\n\n/*\n** Read a varint from the stream of data accessed by p. Set *pnOut to\n** the value read.\n*/\nstatic int vdbePmaReadVarint(PmaReader *p, u64 *pnOut){\n  int iBuf;\n\n  if( p->aMap ){\n    p->iReadOff += sqlite3GetVarint(&p->aMap[p->iReadOff], pnOut);\n  }else{\n    iBuf = p->iReadOff % p->nBuffer;\n    if( iBuf && (p->nBuffer-iBuf)>=9 ){\n      p->iReadOff += sqlite3GetVarint(&p->aBuffer[iBuf], pnOut);\n    }else{\n      u8 aVarint[16], *a;\n      int i = 0, rc;\n      do{\n        rc = vdbePmaReadBlob(p, 1, &a);\n        if( rc ) return rc;\n        aVarint[(i++)&0xf] = a[0];\n      }while( (a[0]&0x80)!=0 );\n      sqlite3GetVarint(aVarint, pnOut);\n    }\n  }\n\n  return SQLITE_OK;\n}\n\n/*\n** Attempt to memory map file pFile. If successful, set *pp to point to the\n** new mapping and return SQLITE_OK. If the mapping is not attempted\n** (because the file is too large or the VFS layer is configured not to use\n** mmap), return SQLITE_OK and set *pp to NULL.\n**\n** Or, if an error occurs, return an SQLite error code. The final value of\n** *pp is undefined in this case.\n*/\nstatic int vdbeSorterMapFile(SortSubtask *pTask, SorterFile *pFile, u8 **pp){\n  int rc = SQLITE_OK;\n  if( pFile->iEof<=(i64)(pTask->pSorter->db->nMaxSorterMmap) ){\n    sqlite3_file *pFd = pFile->pFd;\n    if( pFd->pMethods->iVersion>=3 ){\n      rc = sqlite3OsFetch(pFd, 0, (int)pFile->iEof, (void**)pp);\n      testcase( rc!=SQLITE_OK );\n    }\n  }\n  return rc;\n}\n\n/*\n** Attach PmaReader pReadr to file pFile (if it is not already attached to\n** that file) and seek it to offset iOff within the file.  Return SQLITE_OK\n** if successful, or an SQLite error code if an error occurs.\n*/\nstatic int vdbePmaReaderSeek(\n  SortSubtask *pTask,             /* Task context */\n  PmaReader *pReadr,              /* Reader whose cursor is to be moved */\n  SorterFile *pFile,              /* Sorter file to read from */\n  i64 iOff                        /* Offset in pFile */\n){\n  int rc = SQLITE_OK;\n\n  assert( pReadr->pIncr==0 || pReadr->pIncr->bEof==0 );\n\n  if( sqlite3FaultSim(201) ) return SQLITE_IOERR_READ;\n  if( pReadr->aMap ){\n    sqlite3OsUnfetch(pReadr->pFd, 0, pReadr->aMap);\n    pReadr->aMap = 0;\n  }\n  pReadr->iReadOff = iOff;\n  pReadr->iEof = pFile->iEof;\n  pReadr->pFd = pFile->pFd;\n\n  rc = vdbeSorterMapFile(pTask, pFile, &pReadr->aMap);\n  if( rc==SQLITE_OK && pReadr->aMap==0 ){\n    int pgsz = pTask->pSorter->pgsz;\n    int iBuf = pReadr->iReadOff % pgsz;\n    if( pReadr->aBuffer==0 ){\n      pReadr->aBuffer = (u8*)sqlite3Malloc(pgsz);\n      if( pReadr->aBuffer==0 ) rc = SQLITE_NOMEM_BKPT;\n      pReadr->nBuffer = pgsz;\n    }\n    if( rc==SQLITE_OK && iBuf ){\n      int nRead = pgsz - iBuf;\n      if( (pReadr->iReadOff + nRead) > pReadr->iEof ){\n        nRead = (int)(pReadr->iEof - pReadr->iReadOff);\n      }\n      rc = sqlite3OsRead(\n          pReadr->pFd, &pReadr->aBuffer[iBuf], nRead, pReadr->iReadOff\n      );\n      testcase( rc!=SQLITE_OK );\n    }\n  }\n\n  return rc;\n}\n\n/*\n** Advance PmaReader pReadr to the next key in its PMA. Return SQLITE_OK if\n** no error occurs, or an SQLite error code if one does.\n*/\nstatic int vdbePmaReaderNext(PmaReader *pReadr){\n  int rc = SQLITE_OK;             /* Return Code */\n  u64 nRec = 0;                   /* Size of record in bytes */\n\n\n  if( pReadr->iReadOff>=pReadr->iEof ){\n    IncrMerger *pIncr = pReadr->pIncr;\n    int bEof = 1;\n    if( pIncr ){\n      rc = vdbeIncrSwap(pIncr);\n      if( rc==SQLITE_OK && pIncr->bEof==0 ){\n        rc = vdbePmaReaderSeek(\n            pIncr->pTask, pReadr, &pIncr->aFile[0], pIncr->iStartOff\n        );\n        bEof = 0;\n      }\n    }\n\n    if( bEof ){\n      /* This is an EOF condition */\n      vdbePmaReaderClear(pReadr);\n      testcase( rc!=SQLITE_OK );\n      return rc;\n    }\n  }\n\n  if( rc==SQLITE_OK ){\n    rc = vdbePmaReadVarint(pReadr, &nRec);\n  }\n  if( rc==SQLITE_OK ){\n    pReadr->nKey = (int)nRec;\n    rc = vdbePmaReadBlob(pReadr, (int)nRec, &pReadr->aKey);\n    testcase( rc!=SQLITE_OK );\n  }\n\n  return rc;\n}\n\n/*\n** Initialize PmaReader pReadr to scan through the PMA stored in file pFile\n** starting at offset iStart and ending at offset iEof-1. This function\n** leaves the PmaReader pointing to the first key in the PMA (or EOF if the\n** PMA is empty).\n**\n** If the pnByte parameter is NULL, then it is assumed that the file\n** contains a single PMA, and that that PMA omits the initial length varint.\n*/\nstatic int vdbePmaReaderInit(\n  SortSubtask *pTask,             /* Task context */\n  SorterFile *pFile,              /* Sorter file to read from */\n  i64 iStart,                     /* Start offset in pFile */\n  PmaReader *pReadr,              /* PmaReader to populate */\n  i64 *pnByte                     /* IN/OUT: Increment this value by PMA size */\n){\n  int rc;\n\n  assert( pFile->iEof>iStart );\n  assert( pReadr->aAlloc==0 && pReadr->nAlloc==0 );\n  assert( pReadr->aBuffer==0 );\n  assert( pReadr->aMap==0 );\n\n  rc = vdbePmaReaderSeek(pTask, pReadr, pFile, iStart);\n  if( rc==SQLITE_OK ){\n    u64 nByte = 0;                 /* Size of PMA in bytes */\n    rc = vdbePmaReadVarint(pReadr, &nByte);\n    pReadr->iEof = pReadr->iReadOff + nByte;\n    *pnByte += nByte;\n  }\n\n  if( rc==SQLITE_OK ){\n    rc = vdbePmaReaderNext(pReadr);\n  }\n  return rc;\n}\n\n/*\n** A version of vdbeSorterCompare() that assumes that it has already been\n** determined that the first field of key1 is equal to the first field of\n** key2.\n*/\nstatic int vdbeSorterCompareTail(\n  SortSubtask *pTask,             /* Subtask context (for pKeyInfo) */\n  int *pbKey2Cached,              /* True if pTask->pUnpacked is pKey2 */\n  const void *pKey1, int nKey1,   /* Left side of comparison */\n  const void *pKey2, int nKey2    /* Right side of comparison */\n){\n  UnpackedRecord *r2 = pTask->pUnpacked;\n  if( *pbKey2Cached==0 ){\n    sqlite3VdbeRecordUnpack(nKey2, pKey2, r2);\n    *pbKey2Cached = 1;\n  }\n  return sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, r2, 1);\n}\n\n/*\n** Compare key1 (buffer pKey1, size nKey1 bytes) with key2 (buffer pKey2,\n** size nKey2 bytes). Use (pTask->pKeyInfo) for the collation sequences\n** used by the comparison. Return the result of the comparison.\n**\n** If IN/OUT parameter *pbKey2Cached is true when this function is called,\n** it is assumed that (pTask->pUnpacked) contains the unpacked version\n** of key2. If it is false, (pTask->pUnpacked) is populated with the unpacked\n** version of key2 and *pbKey2Cached set to true before returning.\n**\n** If an OOM error is encountered, (pTask->pUnpacked->error_rc) is set\n** to SQLITE_NOMEM.\n*/\nstatic int vdbeSorterCompare(\n  SortSubtask *pTask,             /* Subtask context (for pKeyInfo) */\n  int *pbKey2Cached,              /* True if pTask->pUnpacked is pKey2 */\n  const void *pKey1, int nKey1,   /* Left side of comparison */\n  const void *pKey2, int nKey2    /* Right side of comparison */\n){\n  UnpackedRecord *r2 = pTask->pUnpacked;\n  if( !*pbKey2Cached ){\n    sqlite3VdbeRecordUnpack(nKey2, pKey2, r2);\n    *pbKey2Cached = 1;\n  }\n  return sqlite3VdbeRecordCompare(nKey1, pKey1, r2);\n}\n\n/*\n** A specially optimized version of vdbeSorterCompare() that assumes that\n** the first field of each key is a TEXT value and that the collation\n** sequence to compare them with is BINARY.\n*/\nstatic int vdbeSorterCompareText(\n  SortSubtask *pTask,             /* Subtask context (for pKeyInfo) */\n  int *pbKey2Cached,              /* True if pTask->pUnpacked is pKey2 */\n  const void *pKey1, int nKey1,   /* Left side of comparison */\n  const void *pKey2, int nKey2    /* Right side of comparison */\n){\n  const u8 * const p1 = (const u8 * const)pKey1;\n  const u8 * const p2 = (const u8 * const)pKey2;\n  const u8 * const v1 = &p1[ p1[0] ];   /* Pointer to value 1 */\n  const u8 * const v2 = &p2[ p2[0] ];   /* Pointer to value 2 */\n\n  int n1;\n  int n2;\n  int res;\n\n  getVarint32NR(&p1[1], n1);\n  getVarint32NR(&p2[1], n2);\n  res = memcmp(v1, v2, (MIN(n1, n2) - 13)/2);\n  if( res==0 ){\n    res = n1 - n2;\n  }\n\n  if( res==0 ){\n    if( pTask->pSorter->pKeyInfo->nKeyField>1 ){\n      res = vdbeSorterCompareTail(\n          pTask, pbKey2Cached, pKey1, nKey1, pKey2, nKey2\n      );\n    }\n  }else{\n    assert( pTask->pSorter->pKeyInfo->aSortFlags!=0 );\n    assert( !(pTask->pSorter->pKeyInfo->aSortFlags[0]&KEYINFO_ORDER_BIGNULL) );\n    if( pTask->pSorter->pKeyInfo->aSortFlags[0] ){\n      res = res * -1;\n    }\n  }\n\n  return res;\n}\n\n/*\n** A specially optimized version of vdbeSorterCompare() that assumes that\n** the first field of each key is an INTEGER value.\n*/\nstatic int vdbeSorterCompareInt(\n  SortSubtask *pTask,             /* Subtask context (for pKeyInfo) */\n  int *pbKey2Cached,              /* True if pTask->pUnpacked is pKey2 */\n  const void *pKey1, int nKey1,   /* Left side of comparison */\n  const void *pKey2, int nKey2    /* Right side of comparison */\n){\n  const u8 * const p1 = (const u8 * const)pKey1;\n  const u8 * const p2 = (const u8 * const)pKey2;\n  const int s1 = p1[1];                 /* Left hand serial type */\n  const int s2 = p2[1];                 /* Right hand serial type */\n  const u8 * const v1 = &p1[ p1[0] ];   /* Pointer to value 1 */\n  const u8 * const v2 = &p2[ p2[0] ];   /* Pointer to value 2 */\n  int res;                              /* Return value */\n\n  assert( (s1>0 && s1<7) || s1==8 || s1==9 );\n  assert( (s2>0 && s2<7) || s2==8 || s2==9 );\n\n  if( s1==s2 ){\n    /* The two values have the same sign. Compare using memcmp(). */\n    static const u8 aLen[] = {0, 1, 2, 3, 4, 6, 8, 0, 0, 0 };\n    const u8 n = aLen[s1];\n    int i;\n    res = 0;\n    for(i=0; i<n; i++){\n      if( (res = v1[i] - v2[i])!=0 ){\n        if( ((v1[0] ^ v2[0]) & 0x80)!=0 ){\n          res = v1[0] & 0x80 ? -1 : +1;\n        }\n        break;\n      }\n    }\n  }else if( s1>7 && s2>7 ){\n    res = s1 - s2;\n  }else{\n    if( s2>7 ){\n      res = +1;\n    }else if( s1>7 ){\n      res = -1;\n    }else{\n      res = s1 - s2;\n    }\n    assert( res!=0 );\n\n    if( res>0 ){\n      if( *v1 & 0x80 ) res = -1;\n    }else{\n      if( *v2 & 0x80 ) res = +1;\n    }\n  }\n\n  assert( pTask->pSorter->pKeyInfo->aSortFlags!=0 );\n  if( res==0 ){\n    if( pTask->pSorter->pKeyInfo->nKeyField>1 ){\n      res = vdbeSorterCompareTail(\n          pTask, pbKey2Cached, pKey1, nKey1, pKey2, nKey2\n      );\n    }\n  }else if( pTask->pSorter->pKeyInfo->aSortFlags[0] ){\n    assert( !(pTask->pSorter->pKeyInfo->aSortFlags[0]&KEYINFO_ORDER_BIGNULL) );\n    res = res * -1;\n  }\n\n  return res;\n}\n\n/*\n** Initialize the temporary index cursor just opened as a sorter cursor.\n**\n** Usually, the sorter module uses the value of (pCsr->pKeyInfo->nKeyField)\n** to determine the number of fields that should be compared from the\n** records being sorted. However, if the value passed as argument nField\n** is non-zero and the sorter is able to guarantee a stable sort, nField\n** is used instead. This is used when sorting records for a CREATE INDEX\n** statement. In this case, keys are always delivered to the sorter in\n** order of the primary key, which happens to be make up the final part\n** of the records being sorted. So if the sort is stable, there is never\n** any reason to compare PK fields and they can be ignored for a small\n** performance boost.\n**\n** The sorter can guarantee a stable sort when running in single-threaded\n** mode, but not in multi-threaded mode.\n**\n** SQLITE_OK is returned if successful, or an SQLite error code otherwise.\n*/\nint sqlite3VdbeSorterInit(\n  sqlite3 *db,                    /* Database connection (for malloc()) */\n  int nField,                     /* Number of key fields in each record */\n  VdbeCursor *pCsr                /* Cursor that holds the new sorter */\n){\n  int pgsz;                       /* Page size of main database */\n  int i;                          /* Used to iterate through aTask[] */\n  VdbeSorter *pSorter;            /* The new sorter */\n  KeyInfo *pKeyInfo;              /* Copy of pCsr->pKeyInfo with db==0 */\n  int szKeyInfo;                  /* Size of pCsr->pKeyInfo in bytes */\n  i64 sz;                         /* Size of pSorter in bytes */\n  int rc = SQLITE_OK;\n#if SQLITE_MAX_WORKER_THREADS==0\n# define nWorker 0\n#else\n  int nWorker;\n#endif\n\n  /* Initialize the upper limit on the number of worker threads */\n#if SQLITE_MAX_WORKER_THREADS>0\n  if( sqlite3TempInMemory(db) || sqlite3GlobalConfig.bCoreMutex==0 ){\n    nWorker = 0;\n  }else{\n    nWorker = db->aLimit[SQLITE_LIMIT_WORKER_THREADS];\n  }\n#endif\n\n  /* Do not allow the total number of threads (main thread + all workers)\n  ** to exceed the maximum merge count */\n#if SQLITE_MAX_WORKER_THREADS>=SORTER_MAX_MERGE_COUNT\n  if( nWorker>=SORTER_MAX_MERGE_COUNT ){\n    nWorker = SORTER_MAX_MERGE_COUNT-1;\n  }\n#endif\n\n  assert( pCsr->pKeyInfo );\n  assert( !pCsr->isEphemeral );\n  assert( pCsr->eCurType==CURTYPE_SORTER );\n  assert( sizeof(KeyInfo) + UMXV(pCsr->pKeyInfo->nKeyField)*sizeof(CollSeq*)\n               < 0x7fffffff );\n  assert( pCsr->pKeyInfo->nKeyField<=pCsr->pKeyInfo->nAllField );\n  szKeyInfo = SZ_KEYINFO(pCsr->pKeyInfo->nAllField);\n  sz = SZ_VDBESORTER(nWorker+1);\n\n  pSorter = (VdbeSorter*)sqlite3DbMallocZero(db, sz + szKeyInfo);\n  pCsr->uc.pSorter = pSorter;\n  if( pSorter==0 ){\n    rc = SQLITE_NOMEM_BKPT;\n  }else{\n    Btree *pBt = db->aDb[0].pBt;\n    pSorter->pKeyInfo = pKeyInfo = (KeyInfo*)((u8*)pSorter + sz);\n    memcpy(pKeyInfo, pCsr->pKeyInfo, szKeyInfo);\n    pKeyInfo->db = 0;\n    if( nField && nWorker==0 ){\n      pKeyInfo->nKeyField = nField;\n      assert( nField<=pCsr->pKeyInfo->nAllField );\n    }\n    /* It is OK that pKeyInfo reuses the aSortFlags field from pCsr->pKeyInfo,\n    ** since the pCsr->pKeyInfo->aSortFlags[] array is invariant and lives\n    ** longer that pSorter. */\n    assert( pKeyInfo->aSortFlags==pCsr->pKeyInfo->aSortFlags );\n    sqlite3BtreeEnter(pBt);\n    pSorter->pgsz = pgsz = sqlite3BtreeGetPageSize(pBt);\n    sqlite3BtreeLeave(pBt);\n    pSorter->nTask = nWorker + 1;\n    pSorter->iPrev = (u8)(nWorker - 1);\n    pSorter->bUseThreads = (pSorter->nTask>1);\n    pSorter->db = db;\n    for(i=0; i<pSorter->nTask; i++){\n      SortSubtask *pTask = &pSorter->aTask[i];\n      pTask->pSorter = pSorter;\n    }\n\n    if( !sqlite3TempInMemory(db) ){\n      i64 mxCache;                /* Cache size in bytes*/\n      u32 szPma = sqlite3GlobalConfig.szPma;\n      pSorter->mnPmaSize = szPma * pgsz;\n\n      mxCache = db->aDb[0].pSchema->cache_size;\n      if( mxCache<0 ){\n        /* A negative cache-size value C indicates that the cache is abs(C)\n        ** KiB in size.  */\n        mxCache = mxCache * -1024;\n      }else{\n        mxCache = mxCache * pgsz;\n      }\n      mxCache = MIN(mxCache, SQLITE_MAX_PMASZ);\n      pSorter->mxPmaSize = MAX(pSorter->mnPmaSize, (int)mxCache);\n\n      /* Avoid large memory allocations if the application has requested\n      ** SQLITE_CONFIG_SMALL_MALLOC. */\n      if( sqlite3GlobalConfig.bSmallMalloc==0 ){\n        assert( pSorter->iMemory==0 );\n        pSorter->nMemory = pgsz;\n        pSorter->list.aMemory = (u8*)sqlite3Malloc(pgsz);\n        if( !pSorter->list.aMemory ) rc = SQLITE_NOMEM_BKPT;\n      }\n    }\n\n    if( pKeyInfo->nAllField<13\n     && (pKeyInfo->aColl[0]==0 || pKeyInfo->aColl[0]==db->pDfltColl)\n     && (pKeyInfo->aSortFlags[0] & KEYINFO_ORDER_BIGNULL)==0\n    ){\n      pSorter->typeMask = SORTER_TYPE_INTEGER | SORTER_TYPE_TEXT;\n    }\n  }\n\n  return rc;\n}\n#undef nWorker   /* Defined at the top of this function */\n\n/*\n** Free the list of sorted records starting at pRecord.\n*/\nstatic void vdbeSorterRecordFree(sqlite3 *db, SorterRecord *pRecord){\n  SorterRecord *p;\n  SorterRecord *pNext;\n  for(p=pRecord; p; p=pNext){\n    pNext = p->u.pNext;\n    sqlite3DbFree(db, p);\n  }\n}\n\n/*\n** Free all resources owned by the object indicated by argument pTask. All\n** fields of *pTask are zeroed before returning.\n*/\nstatic void vdbeSortSubtaskCleanup(sqlite3 *db, SortSubtask *pTask){\n  sqlite3DbFree(db, pTask->pUnpacked);\n#if SQLITE_MAX_WORKER_THREADS>0\n  /* pTask->list.aMemory can only be non-zero if it was handed memory\n  ** from the main thread.  That only occurs SQLITE_MAX_WORKER_THREADS>0 */\n  if( pTask->list.aMemory ){\n    sqlite3_free(pTask->list.aMemory);\n  }else\n#endif\n  {\n    assert( pTask->list.aMemory==0 );\n    vdbeSorterRecordFree(0, pTask->list.pList);\n  }\n  if( pTask->file.pFd ){\n    sqlite3OsCloseFree(pTask->file.pFd);\n  }\n  if( pTask->file2.pFd ){\n    sqlite3OsCloseFree(pTask->file2.pFd);\n  }\n  memset(pTask, 0, sizeof(SortSubtask));\n}\n\n#ifdef SQLITE_DEBUG_SORTER_THREADS\nstatic void vdbeSorterWorkDebug(SortSubtask *pTask, const char *zEvent){\n  i64 t;\n  int iTask = (pTask - pTask->pSorter->aTask);\n  sqlite3OsCurrentTimeInt64(pTask->pSorter->db->pVfs, &t);\n  fprintf(stderr, \"%lld:%d %s\\n\", t, iTask, zEvent);\n}\nstatic void vdbeSorterRewindDebug(const char *zEvent){\n  i64 t = 0;\n  sqlite3_vfs *pVfs = sqlite3_vfs_find(0);\n  if( ALWAYS(pVfs) ) sqlite3OsCurrentTimeInt64(pVfs, &t);\n  fprintf(stderr, \"%lld:X %s\\n\", t, zEvent);\n}\nstatic void vdbeSorterPopulateDebug(\n  SortSubtask *pTask,\n  const char *zEvent\n){\n  i64 t;\n  int iTask = (pTask - pTask->pSorter->aTask);\n  sqlite3OsCurrentTimeInt64(pTask->pSorter->db->pVfs, &t);\n  fprintf(stderr, \"%lld:bg%d %s\\n\", t, iTask, zEvent);\n}\nstatic void vdbeSorterBlockDebug(\n  SortSubtask *pTask,\n  int bBlocked,\n  const char *zEvent\n){\n  if( bBlocked ){\n    i64 t;\n    sqlite3OsCurrentTimeInt64(pTask->pSorter->db->pVfs, &t);\n    fprintf(stderr, \"%lld:main %s\\n\", t, zEvent);\n  }\n}\n#else\n# define vdbeSorterWorkDebug(x,y)\n# define vdbeSorterRewindDebug(y)\n# define vdbeSorterPopulateDebug(x,y)\n# define vdbeSorterBlockDebug(x,y,z)\n#endif\n\n#if SQLITE_MAX_WORKER_THREADS>0\n/*\n** Join thread pTask->thread.\n*/\nstatic int vdbeSorterJoinThread(SortSubtask *pTask){\n  int rc = SQLITE_OK;\n  if( pTask->pThread ){\n#ifdef SQLITE_DEBUG_SORTER_THREADS\n    int bDone = pTask->bDone;\n#endif\n    void *pRet = SQLITE_INT_TO_PTR(SQLITE_ERROR);\n    vdbeSorterBlockDebug(pTask, !bDone, \"enter\");\n    (void)sqlite3ThreadJoin(pTask->pThread, &pRet);\n    vdbeSorterBlockDebug(pTask, !bDone, \"exit\");\n    rc = SQLITE_PTR_TO_INT(pRet);\n    assert( pTask->bDone==1 );\n    pTask->bDone = 0;\n    pTask->pThread = 0;\n  }\n  return rc;\n}\n\n/*\n** Launch a background thread to run xTask(pIn).\n*/\nstatic int vdbeSorterCreateThread(\n  SortSubtask *pTask,             /* Thread will use this task object */\n  void *(*xTask)(void*),          /* Routine to run in a separate thread */\n  void *pIn                       /* Argument passed into xTask() */\n){\n  assert( pTask->pThread==0 && pTask->bDone==0 );\n  return sqlite3ThreadCreate(&pTask->pThread, xTask, pIn);\n}\n\n/*\n** Join all outstanding threads launched by SorterWrite() to create\n** level-0 PMAs.\n*/\nstatic int vdbeSorterJoinAll(VdbeSorter *pSorter, int rcin){\n  int rc = rcin;\n  int i;\n\n  /* This function is always called by the main user thread.\n  **\n  ** If this function is being called after SorterRewind() has been called,\n  ** it is possible that thread pSorter->aTask[pSorter->nTask-1].pThread\n  ** is currently attempt to join one of the other threads. To avoid a race\n  ** condition where this thread also attempts to join the same object, join\n  ** thread pSorter->aTask[pSorter->nTask-1].pThread first. */\n  for(i=pSorter->nTask-1; i>=0; i--){\n    SortSubtask *pTask = &pSorter->aTask[i];\n    int rc2 = vdbeSorterJoinThread(pTask);\n    if( rc==SQLITE_OK ) rc = rc2;\n  }\n  return rc;\n}\n#else\n# define vdbeSorterJoinAll(x,rcin) (rcin)\n# define vdbeSorterJoinThread(pTask) SQLITE_OK\n#endif\n\n/*\n** Allocate a new MergeEngine object capable of handling up to\n** nReader PmaReader inputs.\n**\n** nReader is automatically rounded up to the next power of two.\n** nReader may not exceed SORTER_MAX_MERGE_COUNT even after rounding up.\n*/\nstatic MergeEngine *vdbeMergeEngineNew(int nReader){\n  int N = 2;                      /* Smallest power of two >= nReader */\n  i64 nByte;                      /* Total bytes of space to allocate */\n  MergeEngine *pNew;              /* Pointer to allocated object to return */\n\n  assert( nReader<=SORTER_MAX_MERGE_COUNT );\n\n  while( N<nReader ) N += N;\n  nByte = sizeof(MergeEngine) + N * (sizeof(int) + sizeof(PmaReader));\n\n  pNew = sqlite3FaultSim(100) ? 0 : (MergeEngine*)sqlite3MallocZero(nByte);\n  if( pNew ){\n    pNew->nTree = N;\n    pNew->pTask = 0;\n    pNew->aReadr = (PmaReader*)&pNew[1];\n    pNew->aTree = (int*)&pNew->aReadr[N];\n  }\n  return pNew;\n}\n\n/*\n** Free the MergeEngine object passed as the only argument.\n*/\nstatic void vdbeMergeEngineFree(MergeEngine *pMerger){\n  int i;\n  if( pMerger ){\n    for(i=0; i<pMerger->nTree; i++){\n      vdbePmaReaderClear(&pMerger->aReadr[i]);\n    }\n  }\n  sqlite3_free(pMerger);\n}\n\n/*\n** Free all resources associated with the IncrMerger object indicated by\n** the first argument.\n*/\nstatic void vdbeIncrFree(IncrMerger *pIncr){\n  if( pIncr ){\n#if SQLITE_MAX_WORKER_THREADS>0\n    if( pIncr->bUseThread ){\n      vdbeSorterJoinThread(pIncr->pTask);\n      if( pIncr->aFile[0].pFd ) sqlite3OsCloseFree(pIncr->aFile[0].pFd);\n      if( pIncr->aFile[1].pFd ) sqlite3OsCloseFree(pIncr->aFile[1].pFd);\n    }\n#endif\n    vdbeMergeEngineFree(pIncr->pMerger);\n    sqlite3_free(pIncr);\n  }\n}\n\n/*\n** Reset a sorting cursor back to its original empty state.\n*/\nvoid sqlite3VdbeSorterReset(sqlite3 *db, VdbeSorter *pSorter){\n  int i;\n  (void)vdbeSorterJoinAll(pSorter, SQLITE_OK);\n  assert( pSorter->bUseThreads || pSorter->pReader==0 );\n#if SQLITE_MAX_WORKER_THREADS>0\n  if( pSorter->pReader ){\n    vdbePmaReaderClear(pSorter->pReader);\n    sqlite3DbFree(db, pSorter->pReader);\n    pSorter->pReader = 0;\n  }\n#endif\n  vdbeMergeEngineFree(pSorter->pMerger);\n  pSorter->pMerger = 0;\n  for(i=0; i<pSorter->nTask; i++){\n    SortSubtask *pTask = &pSorter->aTask[i];\n    vdbeSortSubtaskCleanup(db, pTask);\n    pTask->pSorter = pSorter;\n  }\n  if( pSorter->list.aMemory==0 ){\n    vdbeSorterRecordFree(0, pSorter->list.pList);\n  }\n  pSorter->list.pList = 0;\n  pSorter->list.szPMA = 0;\n  pSorter->bUsePMA = 0;\n  pSorter->iMemory = 0;\n  pSorter->mxKeysize = 0;\n  sqlite3DbFree(db, pSorter->pUnpacked);\n  pSorter->pUnpacked = 0;\n}\n\n/*\n** Free any cursor components allocated by sqlite3VdbeSorterXXX routines.\n*/\nvoid sqlite3VdbeSorterClose(sqlite3 *db, VdbeCursor *pCsr){\n  VdbeSorter *pSorter;\n  assert( pCsr->eCurType==CURTYPE_SORTER );\n  pSorter = pCsr->uc.pSorter;\n  if( pSorter ){\n    /* Increment db->nSpill by the total number of bytes of data written\n    ** to temp files by this sort operation.  */\n    int ii;\n    for(ii=0; ii<pSorter->nTask; ii++){\n      db->nSpill += pSorter->aTask[ii].nSpill;\n    }\n    sqlite3VdbeSorterReset(db, pSorter);\n    sqlite3_free(pSorter->list.aMemory);\n    sqlite3DbFree(db, pSorter);\n    pCsr->uc.pSorter = 0;\n  }\n}\n\n#if SQLITE_MAX_MMAP_SIZE>0\n/*\n** The first argument is a file-handle open on a temporary file. The file\n** is guaranteed to be nByte bytes or smaller in size. This function\n** attempts to extend the file to nByte bytes in size and to ensure that\n** the VFS has memory mapped it.\n**\n** Whether or not the file does end up memory mapped of course depends on\n** the specific VFS implementation.\n*/\nstatic void vdbeSorterExtendFile(sqlite3 *db, sqlite3_file *pFd, i64 nByte){\n  if( nByte<=(i64)(db->nMaxSorterMmap) && pFd->pMethods->iVersion>=3 ){\n    void *p = 0;\n    int chunksize = 4*1024;\n    sqlite3OsFileControlHint(pFd, SQLITE_FCNTL_CHUNK_SIZE, &chunksize);\n    sqlite3OsFileControlHint(pFd, SQLITE_FCNTL_SIZE_HINT, &nByte);\n    sqlite3OsFetch(pFd, 0, (int)nByte, &p);\n    if( p ) sqlite3OsUnfetch(pFd, 0, p);\n  }\n}\n#else\n# define vdbeSorterExtendFile(x,y,z)\n#endif\n\n/*\n** Allocate space for a file-handle and open a temporary file. If successful,\n** set *ppFd to point to the malloc'd file-handle and return SQLITE_OK.\n** Otherwise, set *ppFd to 0 and return an SQLite error code.\n*/\nstatic int vdbeSorterOpenTempFile(\n  sqlite3 *db,                    /* Database handle doing sort */\n  i64 nExtend,                    /* Attempt to extend file to this size */\n  sqlite3_file **ppFd\n){\n  int rc;\n  if( sqlite3FaultSim(202) ) return SQLITE_IOERR_ACCESS;\n  rc = sqlite3OsOpenMalloc(db->pVfs, 0, ppFd,\n      SQLITE_OPEN_TEMP_JOURNAL |\n      SQLITE_OPEN_READWRITE    | SQLITE_OPEN_CREATE |\n      SQLITE_OPEN_EXCLUSIVE    | SQLITE_OPEN_DELETEONCLOSE, &rc\n  );\n  if( rc==SQLITE_OK ){\n    i64 max = SQLITE_MAX_MMAP_SIZE;\n    sqlite3OsFileControlHint(*ppFd, SQLITE_FCNTL_MMAP_SIZE, (void*)&max);\n    if( nExtend>0 ){\n      vdbeSorterExtendFile(db, *ppFd, nExtend);\n    }\n  }\n  return rc;\n}\n\n/*\n** If it has not already been allocated, allocate the UnpackedRecord\n** structure at pTask->pUnpacked. Return SQLITE_OK if successful (or\n** if no allocation was required), or SQLITE_NOMEM otherwise.\n*/\nstatic int vdbeSortAllocUnpacked(SortSubtask *pTask){\n  if( pTask->pUnpacked==0 ){\n    pTask->pUnpacked = sqlite3VdbeAllocUnpackedRecord(pTask->pSorter->pKeyInfo);\n    if( pTask->pUnpacked==0 ) return SQLITE_NOMEM_BKPT;\n    pTask->pUnpacked->nField = pTask->pSorter->pKeyInfo->nKeyField;\n    pTask->pUnpacked->errCode = 0;\n  }\n  return SQLITE_OK;\n}\n\n\n/*\n** Merge the two sorted lists p1 and p2 into a single list.\n*/\nstatic SorterRecord *vdbeSorterMerge(\n  SortSubtask *pTask,             /* Calling thread context */\n  SorterRecord *p1,               /* First list to merge */\n  SorterRecord *p2                /* Second list to merge */\n){\n  SorterRecord *pFinal = 0;\n  SorterRecord **pp = &pFinal;\n  int bCached = 0;\n\n  assert( p1!=0 && p2!=0 );\n  for(;;){\n    int res;\n    res = pTask->xCompare(\n        pTask, &bCached, SRVAL(p1), p1->nVal, SRVAL(p2), p2->nVal\n    );\n\n    if( res<=0 ){\n      *pp = p1;\n      pp = &p1->u.pNext;\n      p1 = p1->u.pNext;\n      if( p1==0 ){\n        *pp = p2;\n        break;\n      }\n    }else{\n      *pp = p2;\n      pp = &p2->u.pNext;\n      p2 = p2->u.pNext;\n      bCached = 0;\n      if( p2==0 ){\n        *pp = p1;\n        break;\n      }\n    }\n  }\n  return pFinal;\n}\n\n/*\n** Return the SorterCompare function to compare values collected by the\n** sorter object passed as the only argument.\n*/\nstatic SorterCompare vdbeSorterGetCompare(VdbeSorter *p){\n  if( p->typeMask==SORTER_TYPE_INTEGER ){\n    return vdbeSorterCompareInt;\n  }else if( p->typeMask==SORTER_TYPE_TEXT ){\n    return vdbeSorterCompareText;\n  }\n  return vdbeSorterCompare;\n}\n\n/*\n** Sort the linked list of records headed at pTask->pList. Return\n** SQLITE_OK if successful, or an SQLite error code (i.e. SQLITE_NOMEM) if\n** an error occurs.\n*/\nstatic int vdbeSorterSort(SortSubtask *pTask, SorterList *pList){\n  int i;\n  SorterRecord *p;\n  int rc;\n  SorterRecord *aSlot[64];\n\n  rc = vdbeSortAllocUnpacked(pTask);\n  if( rc!=SQLITE_OK ) return rc;\n\n  p = pList->pList;\n  pTask->xCompare = vdbeSorterGetCompare(pTask->pSorter);\n  memset(aSlot, 0, sizeof(aSlot));\n\n  while( p ){\n    SorterRecord *pNext;\n    if( pList->aMemory ){\n      if( (u8*)p==pList->aMemory ){\n        pNext = 0;\n      }else{\n        assert( p->u.iNext<sqlite3MallocSize(pList->aMemory) );\n        pNext = (SorterRecord*)&pList->aMemory[p->u.iNext];\n      }\n    }else{\n      pNext = p->u.pNext;\n    }\n\n    p->u.pNext = 0;\n    for(i=0; aSlot[i]; i++){\n      p = vdbeSorterMerge(pTask, p, aSlot[i]);\n      /* ,--Each aSlot[] holds twice as much as the previous. So we cannot use\n      ** |  up all 64 aSlots[] with only a 64-bit address space.\n      ** v                                                                */\n      assert( i<ArraySize(aSlot) );\n      aSlot[i] = 0;\n    }\n    aSlot[i] = p;\n    p = pNext;\n  }\n\n  p = 0;\n  for(i=0; i<ArraySize(aSlot); i++){\n    if( aSlot[i]==0 ) continue;\n    p = p ? vdbeSorterMerge(pTask, p, aSlot[i]) : aSlot[i];\n  }\n  pList->pList = p;\n\n  assert( pTask->pUnpacked->errCode==SQLITE_OK\n       || pTask->pUnpacked->errCode==SQLITE_NOMEM\n  );\n  return pTask->pUnpacked->errCode;\n}\n\n/*\n** Initialize a PMA-writer object.\n*/\nstatic void vdbePmaWriterInit(\n  sqlite3_file *pFd,              /* File handle to write to */\n  PmaWriter *p,                   /* Object to populate */\n  int nBuf,                       /* Buffer size */\n  i64 iStart                      /* Offset of pFd to begin writing at */\n){\n  memset(p, 0, sizeof(PmaWriter));\n  p->aBuffer = (u8*)sqlite3Malloc(nBuf);\n  if( !p->aBuffer ){\n    p->eFWErr = SQLITE_NOMEM_BKPT;\n  }else{\n    p->iBufEnd = p->iBufStart = (iStart % nBuf);\n    p->iWriteOff = iStart - p->iBufStart;\n    p->nBuffer = nBuf;\n    p->pFd = pFd;\n  }\n}\n\n/*\n** Write nData bytes of data to the PMA. Return SQLITE_OK\n** if successful, or an SQLite error code if an error occurs.\n*/\nstatic void vdbePmaWriteBlob(PmaWriter *p, u8 *pData, int nData){\n  int nRem = nData;\n  while( nRem>0 && p->eFWErr==0 ){\n    int nCopy = nRem;\n    if( nCopy>(p->nBuffer - p->iBufEnd) ){\n      nCopy = p->nBuffer - p->iBufEnd;\n    }\n\n    memcpy(&p->aBuffer[p->iBufEnd], &pData[nData-nRem], nCopy);\n    p->iBufEnd += nCopy;\n    if( p->iBufEnd==p->nBuffer ){\n      p->eFWErr = sqlite3OsWrite(p->pFd,\n          &p->aBuffer[p->iBufStart], p->iBufEnd - p->iBufStart,\n          p->iWriteOff + p->iBufStart\n      );\n      p->nPmaSpill += (p->iBufEnd - p->iBufStart);\n      p->iBufStart = p->iBufEnd = 0;\n      p->iWriteOff += p->nBuffer;\n    }\n    assert( p->iBufEnd<p->nBuffer );\n\n    nRem -= nCopy;\n  }\n}\n\n/*\n** Flush any buffered data to disk and clean up the PMA-writer object.\n** The results of using the PMA-writer after this call are undefined.\n** Return SQLITE_OK if flushing the buffered data succeeds or is not\n** required. Otherwise, return an SQLite error code.\n**\n** Before returning, set *piEof to the offset immediately following the\n** last byte written to the file. Also, increment (*pnSpill) by the total\n** number of bytes written to the file.\n*/\nstatic int vdbePmaWriterFinish(PmaWriter *p, i64 *piEof, u64 *pnSpill){\n  int rc;\n  if( p->eFWErr==0 && ALWAYS(p->aBuffer) && p->iBufEnd>p->iBufStart ){\n    p->eFWErr = sqlite3OsWrite(p->pFd,\n        &p->aBuffer[p->iBufStart], p->iBufEnd - p->iBufStart,\n        p->iWriteOff + p->iBufStart\n    );\n    p->nPmaSpill += (p->iBufEnd - p->iBufStart);\n  }\n  *piEof = (p->iWriteOff + p->iBufEnd);\n  *pnSpill += p->nPmaSpill;\n  sqlite3_free(p->aBuffer);\n  rc = p->eFWErr;\n  memset(p, 0, sizeof(PmaWriter));\n  return rc;\n}\n\n/*\n** Write value iVal encoded as a varint to the PMA. Return\n** SQLITE_OK if successful, or an SQLite error code if an error occurs.\n*/\nstatic void vdbePmaWriteVarint(PmaWriter *p, u64 iVal){\n  int nByte;\n  u8 aByte[10];\n  nByte = sqlite3PutVarint(aByte, iVal);\n  vdbePmaWriteBlob(p, aByte, nByte);\n}\n\n/*\n** Write the current contents of in-memory linked-list pList to a level-0\n** PMA in the temp file belonging to sub-task pTask. Return SQLITE_OK if\n** successful, or an SQLite error code otherwise.\n**\n** The format of a PMA is:\n**\n**     * A varint. This varint contains the total number of bytes of content\n**       in the PMA (not including the varint itself).\n**\n**     * One or more records packed end-to-end in order of ascending keys.\n**       Each record consists of a varint followed by a blob of data (the\n**       key). The varint is the number of bytes in the blob of data.\n*/\nstatic int vdbeSorterListToPMA(SortSubtask *pTask, SorterList *pList){\n  sqlite3 *db = pTask->pSorter->db;\n  int rc = SQLITE_OK;             /* Return code */\n  PmaWriter writer;               /* Object used to write to the file */\n\n#ifdef SQLITE_DEBUG\n  /* Set iSz to the expected size of file pTask->file after writing the PMA.\n  ** This is used by an assert() statement at the end of this function.  */\n  i64 iSz = pList->szPMA + sqlite3VarintLen(pList->szPMA) + pTask->file.iEof;\n#endif\n\n  vdbeSorterWorkDebug(pTask, \"enter\");\n  memset(&writer, 0, sizeof(PmaWriter));\n  assert( pList->szPMA>0 );\n\n  /* If the first temporary PMA file has not been opened, open it now. */\n  if( pTask->file.pFd==0 ){\n    rc = vdbeSorterOpenTempFile(db, 0, &pTask->file.pFd);\n    assert( rc!=SQLITE_OK || pTask->file.pFd );\n    assert( pTask->file.iEof==0 );\n    assert( pTask->nPMA==0 );\n  }\n\n  /* Try to get the file to memory map */\n  if( rc==SQLITE_OK ){\n    vdbeSorterExtendFile(db, pTask->file.pFd, pTask->file.iEof+pList->szPMA+9);\n  }\n\n  /* Sort the list */\n  if( rc==SQLITE_OK ){\n    rc = vdbeSorterSort(pTask, pList);\n  }\n\n  if( rc==SQLITE_OK ){\n    SorterRecord *p;\n    SorterRecord *pNext = 0;\n\n    vdbePmaWriterInit(pTask->file.pFd, &writer, pTask->pSorter->pgsz,\n                      pTask->file.iEof);\n    pTask->nPMA++;\n    vdbePmaWriteVarint(&writer, pList->szPMA);\n    for(p=pList->pList; p; p=pNext){\n      pNext = p->u.pNext;\n      vdbePmaWriteVarint(&writer, p->nVal);\n      vdbePmaWriteBlob(&writer, SRVAL(p), p->nVal);\n      if( pList->aMemory==0 ) sqlite3_free(p);\n    }\n    pList->pList = p;\n    rc = vdbePmaWriterFinish(&writer, &pTask->file.iEof, &pTask->nSpill);\n  }\n\n  vdbeSorterWorkDebug(pTask, \"exit\");\n  assert( rc!=SQLITE_OK || pList->pList==0 );\n  assert( rc!=SQLITE_OK || pTask->file.iEof==iSz );\n  return rc;\n}\n\n/*\n** Advance the MergeEngine to its next entry.\n** Set *pbEof to true there is no next entry because\n** the MergeEngine has reached the end of all its inputs.\n**\n** Return SQLITE_OK if successful or an error code if an error occurs.\n*/\nstatic int vdbeMergeEngineStep(\n  MergeEngine *pMerger,      /* The merge engine to advance to the next row */\n  int *pbEof                 /* Set TRUE at EOF.  Set false for more content */\n){\n  int rc;\n  int iPrev = pMerger->aTree[1];/* Index of PmaReader to advance */\n  SortSubtask *pTask = pMerger->pTask;\n\n  /* Advance the current PmaReader */\n  rc = vdbePmaReaderNext(&pMerger->aReadr[iPrev]);\n\n  /* Update contents of aTree[] */\n  if( rc==SQLITE_OK ){\n    int i;                      /* Index of aTree[] to recalculate */\n    PmaReader *pReadr1;         /* First PmaReader to compare */\n    PmaReader *pReadr2;         /* Second PmaReader to compare */\n    int bCached = 0;\n\n    /* Find the first two PmaReaders to compare. The one that was just\n    ** advanced (iPrev) and the one next to it in the array.  */\n    pReadr1 = &pMerger->aReadr[(iPrev & 0xFFFE)];\n    pReadr2 = &pMerger->aReadr[(iPrev | 0x0001)];\n\n    for(i=(pMerger->nTree+iPrev)/2; i>0; i=i/2){\n      /* Compare pReadr1 and pReadr2. Store the result in variable iRes. */\n      int iRes;\n      if( pReadr1->pFd==0 ){\n        iRes = +1;\n      }else if( pReadr2->pFd==0 ){\n        iRes = -1;\n      }else{\n        iRes = pTask->xCompare(pTask, &bCached,\n            pReadr1->aKey, pReadr1->nKey, pReadr2->aKey, pReadr2->nKey\n        );\n      }\n\n      /* If pReadr1 contained the smaller value, set aTree[i] to its index.\n      ** Then set pReadr2 to the next PmaReader to compare to pReadr1. In this\n      ** case there is no cache of pReadr2 in pTask->pUnpacked, so set\n      ** pKey2 to point to the record belonging to pReadr2.\n      **\n      ** Alternatively, if pReadr2 contains the smaller of the two values,\n      ** set aTree[i] to its index and update pReadr1. If vdbeSorterCompare()\n      ** was actually called above, then pTask->pUnpacked now contains\n      ** a value equivalent to pReadr2. So set pKey2 to NULL to prevent\n      ** vdbeSorterCompare() from decoding pReadr2 again.\n      **\n      ** If the two values were equal, then the value from the oldest\n      ** PMA should be considered smaller. The VdbeSorter.aReadr[] array\n      ** is sorted from oldest to newest, so pReadr1 contains older values\n      ** than pReadr2 iff (pReadr1<pReadr2).  */\n      if( iRes<0 || (iRes==0 && pReadr1<pReadr2) ){\n        pMerger->aTree[i] = (int)(pReadr1 - pMerger->aReadr);\n        pReadr2 = &pMerger->aReadr[ pMerger->aTree[i ^ 0x0001] ];\n        bCached = 0;\n      }else{\n        if( pReadr1->pFd ) bCached = 0;\n        pMerger->aTree[i] = (int)(pReadr2 - pMerger->aReadr);\n        pReadr1 = &pMerger->aReadr[ pMerger->aTree[i ^ 0x0001] ];\n      }\n    }\n    *pbEof = (pMerger->aReadr[pMerger->aTree[1]].pFd==0);\n  }\n\n  return (rc==SQLITE_OK ? pTask->pUnpacked->errCode : rc);\n}\n\n#if SQLITE_MAX_WORKER_THREADS>0\n/*\n** The main routine for background threads that write level-0 PMAs.\n*/\nstatic void *vdbeSorterFlushThread(void *pCtx){\n  SortSubtask *pTask = (SortSubtask*)pCtx;\n  int rc;                         /* Return code */\n  assert( pTask->bDone==0 );\n  rc = vdbeSorterListToPMA(pTask, &pTask->list);\n  pTask->bDone = 1;\n  return SQLITE_INT_TO_PTR(rc);\n}\n#endif /* SQLITE_MAX_WORKER_THREADS>0 */\n\n/*\n** Flush the current contents of VdbeSorter.list to a new PMA, possibly\n** using a background thread.\n*/\nstatic int vdbeSorterFlushPMA(VdbeSorter *pSorter){\n#if SQLITE_MAX_WORKER_THREADS==0\n  pSorter->bUsePMA = 1;\n  return vdbeSorterListToPMA(&pSorter->aTask[0], &pSorter->list);\n#else\n  int rc = SQLITE_OK;\n  int i;\n  SortSubtask *pTask = 0;    /* Thread context used to create new PMA */\n  int nWorker = (pSorter->nTask-1);\n\n  /* Set the flag to indicate that at least one PMA has been written.\n  ** Or will be, anyhow.  */\n  pSorter->bUsePMA = 1;\n\n  /* Select a sub-task to sort and flush the current list of in-memory\n  ** records to disk. If the sorter is running in multi-threaded mode,\n  ** round-robin between the first (pSorter->nTask-1) tasks. Except, if\n  ** the background thread from a sub-tasks previous turn is still running,\n  ** skip it. If the first (pSorter->nTask-1) sub-tasks are all still busy,\n  ** fall back to using the final sub-task. The first (pSorter->nTask-1)\n  ** sub-tasks are preferred as they use background threads - the final\n  ** sub-task uses the main thread. */\n  for(i=0; i<nWorker; i++){\n    int iTest = (pSorter->iPrev + i + 1) % nWorker;\n    pTask = &pSorter->aTask[iTest];\n    if( pTask->bDone ){\n      rc = vdbeSorterJoinThread(pTask);\n    }\n    if( rc!=SQLITE_OK || pTask->pThread==0 ) break;\n  }\n\n  if( rc==SQLITE_OK ){\n    if( i==nWorker ){\n      /* Use the foreground thread for this operation */\n      rc = vdbeSorterListToPMA(&pSorter->aTask[nWorker], &pSorter->list);\n    }else{\n      /* Launch a background thread for this operation */\n      u8 *aMem;\n      void *pCtx;\n\n      assert( pTask!=0 );\n      assert( pTask->pThread==0 && pTask->bDone==0 );\n      assert( pTask->list.pList==0 );\n      assert( pTask->list.aMemory==0 || pSorter->list.aMemory!=0 );\n\n      aMem = pTask->list.aMemory;\n      pCtx = (void*)pTask;\n      pSorter->iPrev = (u8)(pTask - pSorter->aTask);\n      pTask->list = pSorter->list;\n      pSorter->list.pList = 0;\n      pSorter->list.szPMA = 0;\n      if( aMem ){\n        pSorter->list.aMemory = aMem;\n        pSorter->nMemory = sqlite3MallocSize(aMem);\n      }else if( pSorter->list.aMemory ){\n        pSorter->list.aMemory = sqlite3Malloc(pSorter->nMemory);\n        if( !pSorter->list.aMemory ) return SQLITE_NOMEM_BKPT;\n      }\n\n      rc = vdbeSorterCreateThread(pTask, vdbeSorterFlushThread, pCtx);\n    }\n  }\n\n  return rc;\n#endif /* SQLITE_MAX_WORKER_THREADS!=0 */\n}\n\n/*\n** Add a record to the sorter.\n*/\nint sqlite3VdbeSorterWrite(\n  const VdbeCursor *pCsr,         /* Sorter cursor */\n  Mem *pVal                       /* Memory cell containing record */\n){\n  VdbeSorter *pSorter;\n  int rc = SQLITE_OK;             /* Return Code */\n  SorterRecord *pNew;             /* New list element */\n  int bFlush;                     /* True to flush contents of memory to PMA */\n  i64 nReq;                       /* Bytes of memory required */\n  i64 nPMA;                       /* Bytes of PMA space required */\n  int t;                          /* serial type of first record field */\n\n  assert( pCsr->eCurType==CURTYPE_SORTER );\n  pSorter = pCsr->uc.pSorter;\n  getVarint32NR((const u8*)&pVal->z[1], t);\n  if( t>0 && t<10 && t!=7 ){\n    pSorter->typeMask &= SORTER_TYPE_INTEGER;\n  }else if( t>10 && (t & 0x01) ){\n    pSorter->typeMask &= SORTER_TYPE_TEXT;\n  }else{\n    pSorter->typeMask = 0;\n  }\n\n  assert( pSorter );\n\n  /* Figure out whether or not the current contents of memory should be\n  ** flushed to a PMA before continuing. If so, do so.\n  **\n  ** If using the single large allocation mode (pSorter->aMemory!=0), then\n  ** flush the contents of memory to a new PMA if (a) at least one value is\n  ** already in memory and (b) the new value will not fit in memory.\n  **\n  ** Or, if using separate allocations for each record, flush the contents\n  ** of memory to a PMA if either of the following are true:\n  **\n  **   * The total memory allocated for the in-memory list is greater\n  **     than (page-size * cache-size), or\n  **\n  **   * The total memory allocated for the in-memory list is greater\n  **     than (page-size * 10) and sqlite3HeapNearlyFull() returns true.\n  */\n  nReq = pVal->n + sizeof(SorterRecord);\n  nPMA = pVal->n + sqlite3VarintLen(pVal->n);\n  if( pSorter->mxPmaSize ){\n    if( pSorter->list.aMemory ){\n      bFlush = pSorter->iMemory && (pSorter->iMemory+nReq) > pSorter->mxPmaSize;\n    }else{\n      bFlush = (\n          (pSorter->list.szPMA > pSorter->mxPmaSize)\n       || (pSorter->list.szPMA > pSorter->mnPmaSize && sqlite3HeapNearlyFull())\n      );\n    }\n    if( bFlush ){\n      rc = vdbeSorterFlushPMA(pSorter);\n      pSorter->list.szPMA = 0;\n      pSorter->iMemory = 0;\n      assert( rc!=SQLITE_OK || pSorter->list.pList==0 );\n    }\n  }\n\n  pSorter->list.szPMA += nPMA;\n  if( nPMA>pSorter->mxKeysize ){\n    pSorter->mxKeysize = nPMA;\n  }\n\n  if( pSorter->list.aMemory ){\n    int nMin = pSorter->iMemory + nReq;\n\n    if( nMin>pSorter->nMemory ){\n      u8 *aNew;\n      sqlite3_int64 nNew = 2 * (sqlite3_int64)pSorter->nMemory;\n      int iListOff = -1;\n      if( pSorter->list.pList ){\n        iListOff = (u8*)pSorter->list.pList - pSorter->list.aMemory;\n      }\n      while( nNew < nMin ) nNew = nNew*2;\n      if( nNew > pSorter->mxPmaSize ) nNew = pSorter->mxPmaSize;\n      if( nNew < nMin ) nNew = nMin;\n      aNew = sqlite3Realloc(pSorter->list.aMemory, nNew);\n      if( !aNew ) return SQLITE_NOMEM_BKPT;\n      if( iListOff>=0 ){\n        pSorter->list.pList = (SorterRecord*)&aNew[iListOff];\n      }\n      pSorter->list.aMemory = aNew;\n      pSorter->nMemory = nNew;\n    }\n\n    pNew = (SorterRecord*)&pSorter->list.aMemory[pSorter->iMemory];\n    pSorter->iMemory += ROUND8(nReq);\n    if( pSorter->list.pList ){\n      pNew->u.iNext = (int)((u8*)(pSorter->list.pList) - pSorter->list.aMemory);\n    }\n  }else{\n    pNew = (SorterRecord *)sqlite3Malloc(nReq);\n    if( pNew==0 ){\n      return SQLITE_NOMEM_BKPT;\n    }\n    pNew->u.pNext = pSorter->list.pList;\n  }\n\n  memcpy(SRVAL(pNew), pVal->z, pVal->n);\n  pNew->nVal = pVal->n;\n  pSorter->list.pList = pNew;\n\n  return rc;\n}\n\n/*\n** Read keys from pIncr->pMerger and populate pIncr->aFile[1]. The format\n** of the data stored in aFile[1] is the same as that used by regular PMAs,\n** except that the number-of-bytes varint is omitted from the start.\n*/\nstatic int vdbeIncrPopulate(IncrMerger *pIncr){\n  int rc = SQLITE_OK;\n  int rc2;\n  i64 iStart = pIncr->iStartOff;\n  SorterFile *pOut = &pIncr->aFile[1];\n  SortSubtask *pTask = pIncr->pTask;\n  MergeEngine *pMerger = pIncr->pMerger;\n  PmaWriter writer;\n  assert( pIncr->bEof==0 );\n\n  vdbeSorterPopulateDebug(pTask, \"enter\");\n\n  vdbePmaWriterInit(pOut->pFd, &writer, pTask->pSorter->pgsz, iStart);\n  while( rc==SQLITE_OK ){\n    int dummy;\n    PmaReader *pReader = &pMerger->aReadr[ pMerger->aTree[1] ];\n    int nKey = pReader->nKey;\n    i64 iEof = writer.iWriteOff + writer.iBufEnd;\n\n    /* Check if the output file is full or if the input has been exhausted.\n    ** In either case exit the loop. */\n    if( pReader->pFd==0 ) break;\n    if( (iEof + nKey + sqlite3VarintLen(nKey))>(iStart + pIncr->mxSz) ) break;\n\n    /* Write the next key to the output. */\n    vdbePmaWriteVarint(&writer, nKey);\n    vdbePmaWriteBlob(&writer, pReader->aKey, nKey);\n    assert( pIncr->pMerger->pTask==pTask );\n    rc = vdbeMergeEngineStep(pIncr->pMerger, &dummy);\n  }\n\n  rc2 = vdbePmaWriterFinish(&writer, &pOut->iEof, &pTask->nSpill);\n  if( rc==SQLITE_OK ) rc = rc2;\n  vdbeSorterPopulateDebug(pTask, \"exit\");\n  return rc;\n}\n\n#if SQLITE_MAX_WORKER_THREADS>0\n/*\n** The main routine for background threads that populate aFile[1] of\n** multi-threaded IncrMerger objects.\n*/\nstatic void *vdbeIncrPopulateThread(void *pCtx){\n  IncrMerger *pIncr = (IncrMerger*)pCtx;\n  void *pRet = SQLITE_INT_TO_PTR( vdbeIncrPopulate(pIncr) );\n  pIncr->pTask->bDone = 1;\n  return pRet;\n}\n\n/*\n** Launch a background thread to populate aFile[1] of pIncr.\n*/\nstatic int vdbeIncrBgPopulate(IncrMerger *pIncr){\n  void *p = (void*)pIncr;\n  assert( pIncr->bUseThread );\n  return vdbeSorterCreateThread(pIncr->pTask, vdbeIncrPopulateThread, p);\n}\n#endif\n\n/*\n** This function is called when the PmaReader corresponding to pIncr has\n** finished reading the contents of aFile[0]. Its purpose is to \"refill\"\n** aFile[0] such that the PmaReader should start rereading it from the\n** beginning.\n**\n** For single-threaded objects, this is accomplished by literally reading\n** keys from pIncr->pMerger and repopulating aFile[0].\n**\n** For multi-threaded objects, all that is required is to wait until the\n** background thread is finished (if it is not already) and then swap\n** aFile[0] and aFile[1] in place. If the contents of pMerger have not\n** been exhausted, this function also launches a new background thread\n** to populate the new aFile[1].\n**\n** SQLITE_OK is returned on success, or an SQLite error code otherwise.\n*/\nstatic int vdbeIncrSwap(IncrMerger *pIncr){\n  int rc = SQLITE_OK;\n\n#if SQLITE_MAX_WORKER_THREADS>0\n  if( pIncr->bUseThread ){\n    rc = vdbeSorterJoinThread(pIncr->pTask);\n\n    if( rc==SQLITE_OK ){\n      SorterFile f0 = pIncr->aFile[0];\n      pIncr->aFile[0] = pIncr->aFile[1];\n      pIncr->aFile[1] = f0;\n    }\n\n    if( rc==SQLITE_OK ){\n      if( pIncr->aFile[0].iEof==pIncr->iStartOff ){\n        pIncr->bEof = 1;\n      }else{\n        rc = vdbeIncrBgPopulate(pIncr);\n      }\n    }\n  }else\n#endif\n  {\n    rc = vdbeIncrPopulate(pIncr);\n    pIncr->aFile[0] = pIncr->aFile[1];\n    if( pIncr->aFile[0].iEof==pIncr->iStartOff ){\n      pIncr->bEof = 1;\n    }\n  }\n\n  return rc;\n}\n\n/*\n** Allocate and return a new IncrMerger object to read data from pMerger.\n**\n** If an OOM condition is encountered, return NULL. In this case free the\n** pMerger argument before returning.\n*/\nstatic int vdbeIncrMergerNew(\n  SortSubtask *pTask,     /* The thread that will be using the new IncrMerger */\n  MergeEngine *pMerger,   /* The MergeEngine that the IncrMerger will control */\n  IncrMerger **ppOut      /* Write the new IncrMerger here */\n){\n  int rc = SQLITE_OK;\n  IncrMerger *pIncr = *ppOut = (IncrMerger*)\n       (sqlite3FaultSim(100) ? 0 : sqlite3MallocZero(sizeof(*pIncr)));\n  if( pIncr ){\n    pIncr->pMerger = pMerger;\n    pIncr->pTask = pTask;\n    pIncr->mxSz = MAX(pTask->pSorter->mxKeysize+9,pTask->pSorter->mxPmaSize/2);\n    pTask->file2.iEof += pIncr->mxSz;\n  }else{\n    vdbeMergeEngineFree(pMerger);\n    rc = SQLITE_NOMEM_BKPT;\n  }\n  assert( *ppOut!=0 || rc!=SQLITE_OK );\n  return rc;\n}\n\n#if SQLITE_MAX_WORKER_THREADS>0\n/*\n** Set the \"use-threads\" flag on object pIncr.\n*/\nstatic void vdbeIncrMergerSetThreads(IncrMerger *pIncr){\n  pIncr->bUseThread = 1;\n  pIncr->pTask->file2.iEof -= pIncr->mxSz;\n}\n#endif /* SQLITE_MAX_WORKER_THREADS>0 */\n\n\n\n/*\n** Recompute pMerger->aTree[iOut] by comparing the next keys on the\n** two PmaReaders that feed that entry.  Neither of the PmaReaders\n** are advanced.  This routine merely does the comparison.\n*/\nstatic void vdbeMergeEngineCompare(\n  MergeEngine *pMerger,  /* Merge engine containing PmaReaders to compare */\n  int iOut               /* Store the result in pMerger->aTree[iOut] */\n){\n  int i1;\n  int i2;\n  int iRes;\n  PmaReader *p1;\n  PmaReader *p2;\n\n  assert( iOut<pMerger->nTree && iOut>0 );\n\n  if( iOut>=(pMerger->nTree/2) ){\n    i1 = (iOut - pMerger->nTree/2) * 2;\n    i2 = i1 + 1;\n  }else{\n    i1 = pMerger->aTree[iOut*2];\n    i2 = pMerger->aTree[iOut*2+1];\n  }\n\n  p1 = &pMerger->aReadr[i1];\n  p2 = &pMerger->aReadr[i2];\n\n  if( p1->pFd==0 ){\n    iRes = i2;\n  }else if( p2->pFd==0 ){\n    iRes = i1;\n  }else{\n    SortSubtask *pTask = pMerger->pTask;\n    int bCached = 0;\n    int res;\n    assert( pTask->pUnpacked!=0 );  /* from vdbeSortSubtaskMain() */\n    res = pTask->xCompare(\n        pTask, &bCached, p1->aKey, p1->nKey, p2->aKey, p2->nKey\n    );\n    if( res<=0 ){\n      iRes = i1;\n    }else{\n      iRes = i2;\n    }\n  }\n\n  pMerger->aTree[iOut] = iRes;\n}\n\n/*\n** Allowed values for the eMode parameter to vdbeMergeEngineInit()\n** and vdbePmaReaderIncrMergeInit().\n**\n** Only INCRINIT_NORMAL is valid in single-threaded builds (when\n** SQLITE_MAX_WORKER_THREADS==0).  The other values are only used\n** when there exists one or more separate worker threads.\n*/\n#define INCRINIT_NORMAL 0\n#define INCRINIT_TASK   1\n#define INCRINIT_ROOT   2\n\n/*\n** Forward reference required as the vdbeIncrMergeInit() and\n** vdbePmaReaderIncrInit() routines are called mutually recursively when\n** building a merge tree.\n*/\nstatic int vdbePmaReaderIncrInit(PmaReader *pReadr, int eMode);\n\n/*\n** Initialize the MergeEngine object passed as the second argument. Once this\n** function returns, the first key of merged data may be read from the\n** MergeEngine object in the usual fashion.\n**\n** If argument eMode is INCRINIT_ROOT, then it is assumed that any IncrMerge\n** objects attached to the PmaReader objects that the merger reads from have\n** already been populated, but that they have not yet populated aFile[0] and\n** set the PmaReader objects up to read from it. In this case all that is\n** required is to call vdbePmaReaderNext() on each PmaReader to point it at\n** its first key.\n**\n** Otherwise, if eMode is any value other than INCRINIT_ROOT, then use\n** vdbePmaReaderIncrMergeInit() to initialize each PmaReader that feeds data\n** to pMerger.\n**\n** SQLITE_OK is returned if successful, or an SQLite error code otherwise.\n*/\nstatic int vdbeMergeEngineInit(\n  SortSubtask *pTask,             /* Thread that will run pMerger */\n  MergeEngine *pMerger,           /* MergeEngine to initialize */\n  int eMode                       /* One of the INCRINIT_XXX constants */\n){\n  int rc = SQLITE_OK;             /* Return code */\n  int i;                          /* For looping over PmaReader objects */\n  int nTree;                      /* Number of subtrees to merge */\n\n  /* Failure to allocate the merge would have been detected prior to\n  ** invoking this routine */\n  assert( pMerger!=0 );\n\n  /* eMode is always INCRINIT_NORMAL in single-threaded mode */\n  assert( SQLITE_MAX_WORKER_THREADS>0 || eMode==INCRINIT_NORMAL );\n\n  /* Verify that the MergeEngine is assigned to a single thread */\n  assert( pMerger->pTask==0 );\n  pMerger->pTask = pTask;\n\n  nTree = pMerger->nTree;\n  for(i=0; i<nTree; i++){\n    if( SQLITE_MAX_WORKER_THREADS>0 && eMode==INCRINIT_ROOT ){\n      /* PmaReaders should be normally initialized in order, as if they are\n      ** reading from the same temp file this makes for more linear file IO.\n      ** However, in the INCRINIT_ROOT case, if PmaReader aReadr[nTask-1] is\n      ** in use it will block the vdbePmaReaderNext() call while it uses\n      ** the main thread to fill its buffer. So calling PmaReaderNext()\n      ** on this PmaReader before any of the multi-threaded PmaReaders takes\n      ** better advantage of multi-processor hardware. */\n      rc = vdbePmaReaderNext(&pMerger->aReadr[nTree-i-1]);\n    }else{\n      rc = vdbePmaReaderIncrInit(&pMerger->aReadr[i], INCRINIT_NORMAL);\n    }\n    if( rc!=SQLITE_OK ) return rc;\n  }\n\n  for(i=pMerger->nTree-1; i>0; i--){\n    vdbeMergeEngineCompare(pMerger, i);\n  }\n  return pTask->pUnpacked->errCode;\n}\n\n/*\n** The PmaReader passed as the first argument is guaranteed to be an\n** incremental-reader (pReadr->pIncr!=0). This function serves to open\n** and/or initialize the temp file related fields of the IncrMerge\n** object at (pReadr->pIncr).\n**\n** If argument eMode is set to INCRINIT_NORMAL, then all PmaReaders\n** in the sub-tree headed by pReadr are also initialized. Data is then\n** loaded into the buffers belonging to pReadr and it is set to point to\n** the first key in its range.\n**\n** If argument eMode is set to INCRINIT_TASK, then pReadr is guaranteed\n** to be a multi-threaded PmaReader and this function is being called in a\n** background thread. In this case all PmaReaders in the sub-tree are\n** initialized as for INCRINIT_NORMAL and the aFile[1] buffer belonging to\n** pReadr is populated. However, pReadr itself is not set up to point\n** to its first key. A call to vdbePmaReaderNext() is still required to do\n** that.\n**\n** The reason this function does not call vdbePmaReaderNext() immediately\n** in the INCRINIT_TASK case is that vdbePmaReaderNext() assumes that it has\n** to block on thread (pTask->thread) before accessing aFile[1]. But, since\n** this entire function is being run by thread (pTask->thread), that will\n** lead to the current background thread attempting to join itself.\n**\n** Finally, if argument eMode is set to INCRINIT_ROOT, it may be assumed\n** that pReadr->pIncr is a multi-threaded IncrMerge objects, and that all\n** child-trees have already been initialized using IncrInit(INCRINIT_TASK).\n** In this case vdbePmaReaderNext() is called on all child PmaReaders and\n** the current PmaReader set to point to the first key in its range.\n**\n** SQLITE_OK is returned if successful, or an SQLite error code otherwise.\n*/\nstatic int vdbePmaReaderIncrMergeInit(PmaReader *pReadr, int eMode){\n  int rc = SQLITE_OK;\n  IncrMerger *pIncr = pReadr->pIncr;\n  SortSubtask *pTask = pIncr->pTask;\n  sqlite3 *db = pTask->pSorter->db;\n\n  /* eMode is always INCRINIT_NORMAL in single-threaded mode */\n  assert( SQLITE_MAX_WORKER_THREADS>0 || eMode==INCRINIT_NORMAL );\n\n  rc = vdbeMergeEngineInit(pTask, pIncr->pMerger, eMode);\n\n  /* Set up the required files for pIncr. A multi-threaded IncrMerge object\n  ** requires two temp files to itself, whereas a single-threaded object\n  ** only requires a region of pTask->file2. */\n  if( rc==SQLITE_OK ){\n    int mxSz = pIncr->mxSz;\n#if SQLITE_MAX_WORKER_THREADS>0\n    if( pIncr->bUseThread ){\n      rc = vdbeSorterOpenTempFile(db, mxSz, &pIncr->aFile[0].pFd);\n      if( rc==SQLITE_OK ){\n        rc = vdbeSorterOpenTempFile(db, mxSz, &pIncr->aFile[1].pFd);\n      }\n    }else\n#endif\n    /*if( !pIncr->bUseThread )*/{\n      if( pTask->file2.pFd==0 ){\n        assert( pTask->file2.iEof>0 );\n        rc = vdbeSorterOpenTempFile(db, pTask->file2.iEof, &pTask->file2.pFd);\n        pTask->file2.iEof = 0;\n      }\n      if( rc==SQLITE_OK ){\n        pIncr->aFile[1].pFd = pTask->file2.pFd;\n        pIncr->iStartOff = pTask->file2.iEof;\n        pTask->file2.iEof += mxSz;\n      }\n    }\n  }\n\n#if SQLITE_MAX_WORKER_THREADS>0\n  if( rc==SQLITE_OK && pIncr->bUseThread ){\n    /* Use the current thread to populate aFile[1], even though this\n    ** PmaReader is multi-threaded. If this is an INCRINIT_TASK object,\n    ** then this function is already running in background thread\n    ** pIncr->pTask->thread.\n    **\n    ** If this is the INCRINIT_ROOT object, then it is running in the\n    ** main VDBE thread. But that is Ok, as that thread cannot return\n    ** control to the VDBE or proceed with anything useful until the\n    ** first results are ready from this merger object anyway.\n    */\n    assert( eMode==INCRINIT_ROOT || eMode==INCRINIT_TASK );\n    rc = vdbeIncrPopulate(pIncr);\n  }\n#endif\n\n  if( rc==SQLITE_OK && (SQLITE_MAX_WORKER_THREADS==0 || eMode!=INCRINIT_TASK) ){\n    rc = vdbePmaReaderNext(pReadr);\n  }\n\n  return rc;\n}\n\n#if SQLITE_MAX_WORKER_THREADS>0\n/*\n** The main routine for vdbePmaReaderIncrMergeInit() operations run in\n** background threads.\n*/\nstatic void *vdbePmaReaderBgIncrInit(void *pCtx){\n  PmaReader *pReader = (PmaReader*)pCtx;\n  void *pRet = SQLITE_INT_TO_PTR(\n                  vdbePmaReaderIncrMergeInit(pReader,INCRINIT_TASK)\n               );\n  pReader->pIncr->pTask->bDone = 1;\n  return pRet;\n}\n#endif\n\n/*\n** If the PmaReader passed as the first argument is not an incremental-reader\n** (if pReadr->pIncr==0), then this function is a no-op. Otherwise, it invokes\n** the vdbePmaReaderIncrMergeInit() function with the parameters passed to\n** this routine to initialize the incremental merge.\n**\n** If the IncrMerger object is multi-threaded (IncrMerger.bUseThread==1),\n** then a background thread is launched to call vdbePmaReaderIncrMergeInit().\n** Or, if the IncrMerger is single threaded, the same function is called\n** using the current thread.\n*/\nstatic int vdbePmaReaderIncrInit(PmaReader *pReadr, int eMode){\n  IncrMerger *pIncr = pReadr->pIncr;   /* Incremental merger */\n  int rc = SQLITE_OK;                  /* Return code */\n  if( pIncr ){\n#if SQLITE_MAX_WORKER_THREADS>0\n    assert( pIncr->bUseThread==0 || eMode==INCRINIT_TASK );\n    if( pIncr->bUseThread ){\n      void *pCtx = (void*)pReadr;\n      rc = vdbeSorterCreateThread(pIncr->pTask, vdbePmaReaderBgIncrInit, pCtx);\n    }else\n#endif\n    {\n      rc = vdbePmaReaderIncrMergeInit(pReadr, eMode);\n    }\n  }\n  return rc;\n}\n\n/*\n** Allocate a new MergeEngine object to merge the contents of nPMA level-0\n** PMAs from pTask->file. If no error occurs, set *ppOut to point to\n** the new object and return SQLITE_OK. Or, if an error does occur, set *ppOut\n** to NULL and return an SQLite error code.\n**\n** When this function is called, *piOffset is set to the offset of the\n** first PMA to read from pTask->file. Assuming no error occurs, it is\n** set to the offset immediately following the last byte of the last\n** PMA before returning. If an error does occur, then the final value of\n** *piOffset is undefined.\n*/\nstatic int vdbeMergeEngineLevel0(\n  SortSubtask *pTask,             /* Sorter task to read from */\n  int nPMA,                       /* Number of PMAs to read */\n  i64 *piOffset,                  /* IN/OUT: Readr offset in pTask->file */\n  MergeEngine **ppOut             /* OUT: New merge-engine */\n){\n  MergeEngine *pNew;              /* Merge engine to return */\n  i64 iOff = *piOffset;\n  int i;\n  int rc = SQLITE_OK;\n\n  *ppOut = pNew = vdbeMergeEngineNew(nPMA);\n  if( pNew==0 ) rc = SQLITE_NOMEM_BKPT;\n\n  for(i=0; i<nPMA && rc==SQLITE_OK; i++){\n    i64 nDummy = 0;\n    PmaReader *pReadr = &pNew->aReadr[i];\n    rc = vdbePmaReaderInit(pTask, &pTask->file, iOff, pReadr, &nDummy);\n    iOff = pReadr->iEof;\n  }\n\n  if( rc!=SQLITE_OK ){\n    vdbeMergeEngineFree(pNew);\n    *ppOut = 0;\n  }\n  *piOffset = iOff;\n  return rc;\n}\n\n/*\n** Return the depth of a tree comprising nPMA PMAs, assuming a fanout of\n** SORTER_MAX_MERGE_COUNT. The returned value does not include leaf nodes.\n**\n** i.e.\n**\n**   nPMA<=16    -> TreeDepth() == 0\n**   nPMA<=256   -> TreeDepth() == 1\n**   nPMA<=65536 -> TreeDepth() == 2\n*/\nstatic int vdbeSorterTreeDepth(int nPMA){\n  int nDepth = 0;\n  i64 nDiv = SORTER_MAX_MERGE_COUNT;\n  while( nDiv < (i64)nPMA ){\n    nDiv = nDiv * SORTER_MAX_MERGE_COUNT;\n    nDepth++;\n  }\n  return nDepth;\n}\n\n/*\n** pRoot is the root of an incremental merge-tree with depth nDepth (according\n** to vdbeSorterTreeDepth()). pLeaf is the iSeq'th leaf to be added to the\n** tree, counting from zero. This function adds pLeaf to the tree.\n**\n** If successful, SQLITE_OK is returned. If an error occurs, an SQLite error\n** code is returned and pLeaf is freed.\n*/\nstatic int vdbeSorterAddToTree(\n  SortSubtask *pTask,             /* Task context */\n  int nDepth,                     /* Depth of tree according to TreeDepth() */\n  int iSeq,                       /* Sequence number of leaf within tree */\n  MergeEngine *pRoot,             /* Root of tree */\n  MergeEngine *pLeaf              /* Leaf to add to tree */\n){\n  int rc = SQLITE_OK;\n  int nDiv = 1;\n  int i;\n  MergeEngine *p = pRoot;\n  IncrMerger *pIncr;\n\n  rc = vdbeIncrMergerNew(pTask, pLeaf, &pIncr);\n\n  for(i=1; i<nDepth; i++){\n    nDiv = nDiv * SORTER_MAX_MERGE_COUNT;\n  }\n\n  for(i=1; i<nDepth && rc==SQLITE_OK; i++){\n    int iIter = (iSeq / nDiv) % SORTER_MAX_MERGE_COUNT;\n    PmaReader *pReadr = &p->aReadr[iIter];\n\n    if( pReadr->pIncr==0 ){\n      MergeEngine *pNew = vdbeMergeEngineNew(SORTER_MAX_MERGE_COUNT);\n      if( pNew==0 ){\n        rc = SQLITE_NOMEM_BKPT;\n      }else{\n        rc = vdbeIncrMergerNew(pTask, pNew, &pReadr->pIncr);\n      }\n    }\n    if( rc==SQLITE_OK ){\n      p = pReadr->pIncr->pMerger;\n      nDiv = nDiv / SORTER_MAX_MERGE_COUNT;\n    }\n  }\n\n  if( rc==SQLITE_OK ){\n    p->aReadr[iSeq % SORTER_MAX_MERGE_COUNT].pIncr = pIncr;\n  }else{\n    vdbeIncrFree(pIncr);\n  }\n  return rc;\n}\n\n/*\n** This function is called as part of a SorterRewind() operation on a sorter\n** that has already written two or more level-0 PMAs to one or more temp\n** files. It builds a tree of MergeEngine/IncrMerger/PmaReader objects that\n** can be used to incrementally merge all PMAs on disk.\n**\n** If successful, SQLITE_OK is returned and *ppOut set to point to the\n** MergeEngine object at the root of the tree before returning. Or, if an\n** error occurs, an SQLite error code is returned and the final value\n** of *ppOut is undefined.\n*/\nstatic int vdbeSorterMergeTreeBuild(\n  VdbeSorter *pSorter,       /* The VDBE cursor that implements the sort */\n  MergeEngine **ppOut        /* Write the MergeEngine here */\n){\n  MergeEngine *pMain = 0;\n  int rc = SQLITE_OK;\n  int iTask;\n\n#if SQLITE_MAX_WORKER_THREADS>0\n  /* If the sorter uses more than one task, then create the top-level\n  ** MergeEngine here. This MergeEngine will read data from exactly\n  ** one PmaReader per sub-task.  */\n  assert( pSorter->bUseThreads || pSorter->nTask==1 );\n  if( pSorter->nTask>1 ){\n    pMain = vdbeMergeEngineNew(pSorter->nTask);\n    if( pMain==0 ) rc = SQLITE_NOMEM_BKPT;\n  }\n#endif\n\n  for(iTask=0; rc==SQLITE_OK && iTask<pSorter->nTask; iTask++){\n    SortSubtask *pTask = &pSorter->aTask[iTask];\n    assert( pTask->nPMA>0 || SQLITE_MAX_WORKER_THREADS>0 );\n    if( SQLITE_MAX_WORKER_THREADS==0 || pTask->nPMA ){\n      MergeEngine *pRoot = 0;     /* Root node of tree for this task */\n      int nDepth = vdbeSorterTreeDepth(pTask->nPMA);\n      i64 iReadOff = 0;\n\n      if( pTask->nPMA<=SORTER_MAX_MERGE_COUNT ){\n        rc = vdbeMergeEngineLevel0(pTask, pTask->nPMA, &iReadOff, &pRoot);\n      }else{\n        int i;\n        int iSeq = 0;\n        pRoot = vdbeMergeEngineNew(SORTER_MAX_MERGE_COUNT);\n        if( pRoot==0 ) rc = SQLITE_NOMEM_BKPT;\n        for(i=0; i<pTask->nPMA && rc==SQLITE_OK; i += SORTER_MAX_MERGE_COUNT){\n          MergeEngine *pMerger = 0; /* New level-0 PMA merger */\n          int nReader;              /* Number of level-0 PMAs to merge */\n\n          nReader = MIN(pTask->nPMA - i, SORTER_MAX_MERGE_COUNT);\n          rc = vdbeMergeEngineLevel0(pTask, nReader, &iReadOff, &pMerger);\n          if( rc==SQLITE_OK ){\n            rc = vdbeSorterAddToTree(pTask, nDepth, iSeq++, pRoot, pMerger);\n          }\n        }\n      }\n\n      if( rc==SQLITE_OK ){\n#if SQLITE_MAX_WORKER_THREADS>0\n        if( pMain!=0 ){\n          rc = vdbeIncrMergerNew(pTask, pRoot, &pMain->aReadr[iTask].pIncr);\n        }else\n#endif\n        {\n          assert( pMain==0 );\n          pMain = pRoot;\n        }\n      }else{\n        vdbeMergeEngineFree(pRoot);\n      }\n    }\n  }\n\n  if( rc!=SQLITE_OK ){\n    vdbeMergeEngineFree(pMain);\n    pMain = 0;\n  }\n  *ppOut = pMain;\n  return rc;\n}\n\n/*\n** This function is called as part of an sqlite3VdbeSorterRewind() operation\n** on a sorter that has written two or more PMAs to temporary files. It sets\n** up either VdbeSorter.pMerger (for single threaded sorters) or pReader\n** (for multi-threaded sorters) so that it can be used to iterate through\n** all records stored in the sorter.\n**\n** SQLITE_OK is returned if successful, or an SQLite error code otherwise.\n*/\nstatic int vdbeSorterSetupMerge(VdbeSorter *pSorter){\n  int rc;                         /* Return code */\n  SortSubtask *pTask0 = &pSorter->aTask[0];\n  MergeEngine *pMain = 0;\n#if SQLITE_MAX_WORKER_THREADS\n  sqlite3 *db = pTask0->pSorter->db;\n  int i;\n  SorterCompare xCompare = vdbeSorterGetCompare(pSorter);\n  for(i=0; i<pSorter->nTask; i++){\n    pSorter->aTask[i].xCompare = xCompare;\n  }\n#endif\n\n  rc = vdbeSorterMergeTreeBuild(pSorter, &pMain);\n  if( rc==SQLITE_OK ){\n#if SQLITE_MAX_WORKER_THREADS\n    assert( pSorter->bUseThreads==0 || pSorter->nTask>1 );\n    if( pSorter->bUseThreads ){\n      int iTask;\n      PmaReader *pReadr = 0;\n      SortSubtask *pLast = &pSorter->aTask[pSorter->nTask-1];\n      rc = vdbeSortAllocUnpacked(pLast);\n      if( rc==SQLITE_OK ){\n        pReadr = (PmaReader*)sqlite3DbMallocZero(db, sizeof(PmaReader));\n        pSorter->pReader = pReadr;\n        if( pReadr==0 ) rc = SQLITE_NOMEM_BKPT;\n      }\n      if( rc==SQLITE_OK ){\n        rc = vdbeIncrMergerNew(pLast, pMain, &pReadr->pIncr);\n        if( rc==SQLITE_OK ){\n          vdbeIncrMergerSetThreads(pReadr->pIncr);\n          for(iTask=0; iTask<(pSorter->nTask-1); iTask++){\n            IncrMerger *pIncr;\n            if( (pIncr = pMain->aReadr[iTask].pIncr) ){\n              vdbeIncrMergerSetThreads(pIncr);\n              assert( pIncr->pTask!=pLast );\n            }\n          }\n          for(iTask=0; rc==SQLITE_OK && iTask<pSorter->nTask; iTask++){\n            /* Check that:\n            **  \n            **   a) The incremental merge object is configured to use the\n            **      right task, and\n            **   b) If it is using task (nTask-1), it is configured to run\n            **      in single-threaded mode. This is important, as the\n            **      root merge (INCRINIT_ROOT) will be using the same task\n            **      object.\n            */\n            PmaReader *p = &pMain->aReadr[iTask];\n            assert( p->pIncr==0 || (\n                (p->pIncr->pTask==&pSorter->aTask[iTask])             /* a */\n             && (iTask!=pSorter->nTask-1 || p->pIncr->bUseThread==0)  /* b */\n            ));\n            rc = vdbePmaReaderIncrInit(p, INCRINIT_TASK);\n          }\n        }\n        pMain = 0;\n      }\n      if( rc==SQLITE_OK ){\n        rc = vdbePmaReaderIncrMergeInit(pReadr, INCRINIT_ROOT);\n      }\n    }else\n#endif\n    {\n      rc = vdbeMergeEngineInit(pTask0, pMain, INCRINIT_NORMAL);\n      pSorter->pMerger = pMain;\n      pMain = 0;\n    }\n  }\n\n  if( rc!=SQLITE_OK ){\n    vdbeMergeEngineFree(pMain);\n  }\n  return rc;\n}\n\n\n/*\n** Once the sorter has been populated by calls to sqlite3VdbeSorterWrite,\n** this function is called to prepare for iterating through the records\n** in sorted order.\n*/\nint sqlite3VdbeSorterRewind(const VdbeCursor *pCsr, int *pbEof){\n  VdbeSorter *pSorter;\n  int rc = SQLITE_OK;             /* Return code */\n\n  assert( pCsr->eCurType==CURTYPE_SORTER );\n  pSorter = pCsr->uc.pSorter;\n  assert( pSorter );\n\n  /* If no data has been written to disk, then do not do so now. Instead,\n  ** sort the VdbeSorter.pRecord list. The vdbe layer will read data directly\n  ** from the in-memory list.  */\n  if( pSorter->bUsePMA==0 ){\n    if( pSorter->list.pList ){\n      *pbEof = 0;\n      rc = vdbeSorterSort(&pSorter->aTask[0], &pSorter->list);\n    }else{\n      *pbEof = 1;\n    }\n    return rc;\n  }\n\n  /* Write the current in-memory list to a PMA. When the VdbeSorterWrite()\n  ** function flushes the contents of memory to disk, it immediately always\n  ** creates a new list consisting of a single key immediately afterwards.\n  ** So the list is never empty at this point.  */\n  assert( pSorter->list.pList );\n  rc = vdbeSorterFlushPMA(pSorter);\n\n  /* Join all threads */\n  rc = vdbeSorterJoinAll(pSorter, rc);\n\n  vdbeSorterRewindDebug(\"rewind\");\n\n  /* Assuming no errors have occurred, set up a merger structure to\n  ** incrementally read and merge all remaining PMAs.  */\n  assert( pSorter->pReader==0 );\n  if( rc==SQLITE_OK ){\n    rc = vdbeSorterSetupMerge(pSorter);\n    *pbEof = 0;\n  }\n\n  vdbeSorterRewindDebug(\"rewinddone\");\n  return rc;\n}\n\n/*\n** Advance to the next element in the sorter.  Return value:\n**\n**    SQLITE_OK     success\n**    SQLITE_DONE   end of data\n**    otherwise     some kind of error.\n*/\nint sqlite3VdbeSorterNext(sqlite3 *db, const VdbeCursor *pCsr){\n  VdbeSorter *pSorter;\n  int rc;                         /* Return code */\n\n  assert( pCsr->eCurType==CURTYPE_SORTER );\n  pSorter = pCsr->uc.pSorter;\n  assert( pSorter->bUsePMA || (pSorter->pReader==0 && pSorter->pMerger==0) );\n  if( pSorter->bUsePMA ){\n    assert( pSorter->pReader==0 || pSorter->pMerger==0 );\n    assert( pSorter->bUseThreads==0 || pSorter->pReader );\n    assert( pSorter->bUseThreads==1 || pSorter->pMerger );\n#if SQLITE_MAX_WORKER_THREADS>0\n    if( pSorter->bUseThreads ){\n      rc = vdbePmaReaderNext(pSorter->pReader);\n      if( rc==SQLITE_OK && pSorter->pReader->pFd==0 ) rc = SQLITE_DONE;\n    }else\n#endif\n    /*if( !pSorter->bUseThreads )*/ {\n      int res = 0;\n      assert( pSorter->pMerger!=0 );\n      assert( pSorter->pMerger->pTask==(&pSorter->aTask[0]) );\n      rc = vdbeMergeEngineStep(pSorter->pMerger, &res);\n      if( rc==SQLITE_OK && res ) rc = SQLITE_DONE;\n    }\n  }else{\n    SorterRecord *pFree = pSorter->list.pList;\n    pSorter->list.pList = pFree->u.pNext;\n    pFree->u.pNext = 0;\n    if( pSorter->list.aMemory==0 ) vdbeSorterRecordFree(db, pFree);\n    rc = pSorter->list.pList ? SQLITE_OK : SQLITE_DONE;\n  }\n  return rc;\n}\n\n/*\n** Return a pointer to a buffer owned by the sorter that contains the\n** current key.\n*/\nstatic void *vdbeSorterRowkey(\n  const VdbeSorter *pSorter,      /* Sorter object */\n  int *pnKey                      /* OUT: Size of current key in bytes */\n){\n  void *pKey;\n  if( pSorter->bUsePMA ){\n    PmaReader *pReader;\n#if SQLITE_MAX_WORKER_THREADS>0\n    if( pSorter->bUseThreads ){\n      pReader = pSorter->pReader;\n    }else\n#endif\n    /*if( !pSorter->bUseThreads )*/{\n      pReader = &pSorter->pMerger->aReadr[pSorter->pMerger->aTree[1]];\n    }\n    *pnKey = pReader->nKey;\n    pKey = pReader->aKey;\n  }else{\n    *pnKey = pSorter->list.pList->nVal;\n    pKey = SRVAL(pSorter->list.pList);\n  }\n  return pKey;\n}\n\n/*\n** Copy the current sorter key into the memory cell pOut.\n*/\nint sqlite3VdbeSorterRowkey(const VdbeCursor *pCsr, Mem *pOut){\n  VdbeSorter *pSorter;\n  void *pKey; int nKey;           /* Sorter key to copy into pOut */\n\n  assert( pCsr->eCurType==CURTYPE_SORTER );\n  pSorter = pCsr->uc.pSorter;\n  pKey = vdbeSorterRowkey(pSorter, &nKey);\n  if( sqlite3VdbeMemClearAndResize(pOut, nKey) ){\n    return SQLITE_NOMEM_BKPT;\n  }\n  pOut->n = nKey;\n  MemSetTypeFlag(pOut, MEM_Blob);\n  memcpy(pOut->z, pKey, nKey);\n\n  return SQLITE_OK;\n}\n\n/*\n** Compare the key in memory cell pVal with the key that the sorter cursor\n** passed as the first argument currently points to. For the purposes of\n** the comparison, ignore the rowid field at the end of each record.\n**\n** If the sorter cursor key contains any NULL values, consider it to be\n** less than pVal. Even if pVal also contains NULL values.\n**\n** If an error occurs, return an SQLite error code (i.e. SQLITE_NOMEM).\n** Otherwise, set *pRes to a negative, zero or positive value if the\n** key in pVal is smaller than, equal to or larger than the current sorter\n** key.\n**\n** This routine forms the core of the OP_SorterCompare opcode, which in\n** turn is used to verify uniqueness when constructing a UNIQUE INDEX.\n*/\nint sqlite3VdbeSorterCompare(\n  const VdbeCursor *pCsr,         /* Sorter cursor */\n  Mem *pVal,                      /* Value to compare to current sorter key */\n  int nKeyCol,                    /* Compare this many columns */\n  int *pRes                       /* OUT: Result of comparison */\n){\n  VdbeSorter *pSorter;\n  UnpackedRecord *r2;\n  KeyInfo *pKeyInfo;\n  int i;\n  void *pKey; int nKey;           /* Sorter key to compare pVal with */\n\n  assert( pCsr->eCurType==CURTYPE_SORTER );\n  pSorter = pCsr->uc.pSorter;\n  r2 = pSorter->pUnpacked;\n  pKeyInfo = pCsr->pKeyInfo;\n  if( r2==0 ){\n    r2 = pSorter->pUnpacked = sqlite3VdbeAllocUnpackedRecord(pKeyInfo);\n    if( r2==0 ) return SQLITE_NOMEM_BKPT;\n    r2->nField = nKeyCol;\n  }\n  assert( r2->nField==nKeyCol );\n\n  pKey = vdbeSorterRowkey(pSorter, &nKey);\n  sqlite3VdbeRecordUnpack(nKey, pKey, r2);\n  for(i=0; i<nKeyCol; i++){\n    if( r2->aMem[i].flags & MEM_Null ){\n      *pRes = -1;\n      return SQLITE_OK;\n    }\n  }\n\n  *pRes = sqlite3VdbeRecordCompare(pVal->n, pVal->z, r2);\n  return SQLITE_OK;\n}\n"}
{"repo": "sqlite", "file": "vdbe.h", "lang": "C++", "code": "/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** Header file for the Virtual DataBase Engine (VDBE)\n**\n** This header defines the interface to the virtual database engine\n** or VDBE.  The VDBE implements an abstract machine that runs a\n** simple program to access and modify the underlying database.\n*/\n#ifndef SQLITE_VDBE_H\n#define SQLITE_VDBE_H\n#include <stdio.h>\n\n/*\n** A single VDBE is an opaque structure named \"Vdbe\".  Only routines\n** in the source file sqliteVdbe.c are allowed to see the insides\n** of this structure.\n*/\ntypedef struct Vdbe Vdbe;\n\n/*\n** The names of the following types declared in vdbeInt.h are required\n** for the VdbeOp definition.\n*/\ntypedef struct sqlite3_value Mem;\ntypedef struct SubProgram SubProgram;\ntypedef struct SubrtnSig SubrtnSig;\n\n/*\n** A signature for a reusable subroutine that materializes the RHS of\n** an IN operator.\n*/\nstruct SubrtnSig {\n  int selId;          /* SELECT-id for the SELECT statement on the RHS */\n  u8 bComplete;       /* True if fully coded and available for reusable */\n  char *zAff;         /* Affinity of the overall IN expression */\n  int iTable;         /* Ephemeral table generated by the subroutine */\n  int iAddr;          /* Subroutine entry address */\n  int regReturn;      /* Register used to hold return address */\n};\n\n/*\n** A single instruction of the virtual machine has an opcode\n** and as many as three operands.  The instruction is recorded\n** as an instance of the following structure:\n*/\nstruct VdbeOp {\n  u8 opcode;          /* What operation to perform */\n  signed char p4type; /* One of the P4_xxx constants for p4 */\n  u16 p5;             /* Fifth parameter is an unsigned 16-bit integer */\n  int p1;             /* First operand */\n  int p2;             /* Second parameter (often the jump destination) */\n  int p3;             /* The third parameter */\n  union p4union {     /* fourth parameter */\n    int i;                 /* Integer value if p4type==P4_INT32 */\n    void *p;               /* Generic pointer */\n    char *z;               /* Pointer to data for string (char array) types */\n    i64 *pI64;             /* Used when p4type is P4_INT64 */\n    double *pReal;         /* Used when p4type is P4_REAL */\n    FuncDef *pFunc;        /* Used when p4type is P4_FUNCDEF */\n    sqlite3_context *pCtx; /* Used when p4type is P4_FUNCCTX */\n    CollSeq *pColl;        /* Used when p4type is P4_COLLSEQ */\n    Mem *pMem;             /* Used when p4type is P4_MEM */\n    VTable *pVtab;         /* Used when p4type is P4_VTAB */\n    KeyInfo *pKeyInfo;     /* Used when p4type is P4_KEYINFO */\n    u32 *ai;               /* Used when p4type is P4_INTARRAY */\n    SubProgram *pProgram;  /* Used when p4type is P4_SUBPROGRAM */\n    Table *pTab;           /* Used when p4type is P4_TABLE */\n    SubrtnSig *pSubrtnSig; /* Used when p4type is P4_SUBRTNSIG */\n#ifdef SQLITE_ENABLE_CURSOR_HINTS\n    Expr *pExpr;           /* Used when p4type is P4_EXPR */\n#endif\n  } p4;\n#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS\n  char *zComment;          /* Comment to improve readability */\n#endif\n#ifdef SQLITE_VDBE_COVERAGE\n  u32 iSrcLine;            /* Source-code line that generated this opcode\n                           ** with flags in the upper 8 bits */\n#endif\n#if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || defined(VDBE_PROFILE)\n  u64 nExec;\n  u64 nCycle;\n#endif\n};\ntypedef struct VdbeOp VdbeOp;\n\n\n/*\n** A sub-routine used to implement a trigger program.\n*/\nstruct SubProgram {\n  VdbeOp *aOp;                  /* Array of opcodes for sub-program */\n  int nOp;                      /* Elements in aOp[] */\n  int nMem;                     /* Number of memory cells required */\n  int nCsr;                     /* Number of cursors required */\n  u8 *aOnce;                    /* Array of OP_Once flags */\n  void *token;                  /* id that may be used to recursive triggers */\n  SubProgram *pNext;            /* Next sub-program already visited */\n};\n\n/*\n** A smaller version of VdbeOp used for the VdbeAddOpList() function because\n** it takes up less space.\n*/\nstruct VdbeOpList {\n  u8 opcode;          /* What operation to perform */\n  signed char p1;     /* First operand */\n  signed char p2;     /* Second parameter (often the jump destination) */\n  signed char p3;     /* Third parameter */\n};\ntypedef struct VdbeOpList VdbeOpList;\n\n/*\n** Allowed values of VdbeOp.p4type\n*/\n#define P4_NOTUSED      0   /* The P4 parameter is not used */\n#define P4_TRANSIENT    0   /* P4 is a pointer to a transient string */\n#define P4_STATIC     (-1)  /* Pointer to a static string */\n#define P4_COLLSEQ    (-2)  /* P4 is a pointer to a CollSeq structure */\n#define P4_INT32      (-3)  /* P4 is a 32-bit signed integer */\n#define P4_SUBPROGRAM (-4)  /* P4 is a pointer to a SubProgram structure */\n#define P4_TABLE      (-5)  /* P4 is a pointer to a Table structure */\n/* Above do not own any resources.  Must free those below */\n#define P4_FREE_IF_LE (-6)\n#define P4_DYNAMIC    (-6)  /* Pointer to memory from sqliteMalloc() */\n#define P4_FUNCDEF    (-7)  /* P4 is a pointer to a FuncDef structure */\n#define P4_KEYINFO    (-8)  /* P4 is a pointer to a KeyInfo structure */\n#define P4_EXPR       (-9) /* P4 is a pointer to an Expr tree */\n#define P4_MEM        (-10) /* P4 is a pointer to a Mem*    structure */\n#define P4_VTAB       (-11) /* P4 is a pointer to an sqlite3_vtab structure */\n#define P4_REAL       (-12) /* P4 is a 64-bit floating point value */\n#define P4_INT64      (-13) /* P4 is a 64-bit signed integer */\n#define P4_INTARRAY   (-14) /* P4 is a vector of 32-bit integers */\n#define P4_FUNCCTX    (-15) /* P4 is a pointer to an sqlite3_context object */\n#define P4_TABLEREF   (-16) /* Like P4_TABLE, but reference counted */\n#define P4_SUBRTNSIG  (-17) /* P4 is a SubrtnSig pointer */\n\n/* Error message codes for OP_Halt */\n#define P5_ConstraintNotNull 1\n#define P5_ConstraintUnique  2\n#define P5_ConstraintCheck   3\n#define P5_ConstraintFK      4\n\n/*\n** The Vdbe.aColName array contains 5n Mem structures, where n is the \n** number of columns of data returned by the statement.\n*/\n#define COLNAME_NAME     0\n#define COLNAME_DECLTYPE 1\n#define COLNAME_DATABASE 2\n#define COLNAME_TABLE    3\n#define COLNAME_COLUMN   4\n#ifdef SQLITE_ENABLE_COLUMN_METADATA\n# define COLNAME_N        5      /* Number of COLNAME_xxx symbols */\n#else\n# ifdef SQLITE_OMIT_DECLTYPE\n#   define COLNAME_N      1      /* Store only the name */\n# else\n#   define COLNAME_N      2      /* Store the name and decltype */\n# endif\n#endif\n\n/*\n** The following macro converts a label returned by sqlite3VdbeMakeLabel()\n** into an index into the Parse.aLabel[] array that contains the resolved\n** address of that label.\n*/\n#define ADDR(X)  (~(X))\n\n/*\n** The makefile scans the vdbe.c source file and creates the \"opcodes.h\"\n** header file that defines a number for each opcode used by the VDBE.\n*/\n#include \"opcodes.h\"\n\n/*\n** Additional non-public SQLITE_PREPARE_* flags\n*/\n#define SQLITE_PREPARE_SAVESQL  0x80  /* Preserve SQL text */\n#define SQLITE_PREPARE_MASK     0x3f  /* Mask of public flags */\n\n/*\n** Prototypes for the VDBE interface.  See comments on the implementation\n** for a description of what each of these routines does.\n*/\nVdbe *sqlite3VdbeCreate(Parse*);\nParse *sqlite3VdbeParser(Vdbe*);\nint sqlite3VdbeAddOp0(Vdbe*,int);\nint sqlite3VdbeAddOp1(Vdbe*,int,int);\nint sqlite3VdbeAddOp2(Vdbe*,int,int,int);\nint sqlite3VdbeGoto(Vdbe*,int);\nint sqlite3VdbeLoadString(Vdbe*,int,const char*);\nvoid sqlite3VdbeMultiLoad(Vdbe*,int,const char*,...);\nint sqlite3VdbeAddOp3(Vdbe*,int,int,int,int);\nint sqlite3VdbeAddOp4(Vdbe*,int,int,int,int,const char *zP4,int);\nint sqlite3VdbeAddOp4Dup8(Vdbe*,int,int,int,int,const u8*,int);\nint sqlite3VdbeAddOp4Int(Vdbe*,int,int,int,int,int);\nint sqlite3VdbeAddFunctionCall(Parse*,int,int,int,int,const FuncDef*,int);\nvoid sqlite3VdbeEndCoroutine(Vdbe*,int);\n#if defined(SQLITE_DEBUG) && !defined(SQLITE_TEST_REALLOC_STRESS)\n  void sqlite3VdbeVerifyNoMallocRequired(Vdbe *p, int N);\n  void sqlite3VdbeVerifyNoResultRow(Vdbe *p);\n#else\n# define sqlite3VdbeVerifyNoMallocRequired(A,B)\n# define sqlite3VdbeVerifyNoResultRow(A)\n#endif\n#if defined(SQLITE_DEBUG)\n  void sqlite3VdbeVerifyAbortable(Vdbe *p, int);\n  void sqlite3VdbeNoJumpsOutsideSubrtn(Vdbe*,int,int,int);\n#else\n# define sqlite3VdbeVerifyAbortable(A,B)\n# define sqlite3VdbeNoJumpsOutsideSubrtn(A,B,C,D)\n#endif\nVdbeOp *sqlite3VdbeAddOpList(Vdbe*, int nOp, VdbeOpList const *aOp,int iLineno);\n#ifndef SQLITE_OMIT_EXPLAIN\n  int sqlite3VdbeExplain(Parse*,u8,const char*,...);\n  void sqlite3VdbeExplainPop(Parse*);\n  int sqlite3VdbeExplainParent(Parse*);\n# define ExplainQueryPlan(P)        sqlite3VdbeExplain P\n# ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n#  define ExplainQueryPlan2(V,P)     (V = sqlite3VdbeExplain P)\n# else\n#  define ExplainQueryPlan2(V,P)     ExplainQueryPlan(P)\n# endif\n# define ExplainQueryPlanPop(P)     sqlite3VdbeExplainPop(P)\n# define ExplainQueryPlanParent(P)  sqlite3VdbeExplainParent(P)\n#else\n# define ExplainQueryPlan(P)\n# define ExplainQueryPlan2(V,P)\n# define ExplainQueryPlanPop(P)\n# define ExplainQueryPlanParent(P) 0\n# define sqlite3ExplainBreakpoint(A,B) /*no-op*/\n#endif\n#if defined(SQLITE_DEBUG) && !defined(SQLITE_OMIT_EXPLAIN)\n  void sqlite3ExplainBreakpoint(const char*,const char*);\n#else\n# define sqlite3ExplainBreakpoint(A,B) /*no-op*/\n#endif\nvoid sqlite3VdbeAddParseSchemaOp(Vdbe*, int, char*, u16);\nvoid sqlite3VdbeChangeOpcode(Vdbe*, int addr, u8);\nvoid sqlite3VdbeChangeP1(Vdbe*, int addr, int P1);\nvoid sqlite3VdbeChangeP2(Vdbe*, int addr, int P2);\nvoid sqlite3VdbeChangeP3(Vdbe*, int addr, int P3);\nvoid sqlite3VdbeChangeP5(Vdbe*, u16 P5);\nvoid sqlite3VdbeTypeofColumn(Vdbe*, int);\nvoid sqlite3VdbeJumpHere(Vdbe*, int addr);\nvoid sqlite3VdbeJumpHereOrPopInst(Vdbe*, int addr);\nint sqlite3VdbeChangeToNoop(Vdbe*, int addr);\nint sqlite3VdbeDeletePriorOpcode(Vdbe*, u8 op);\n#ifdef SQLITE_DEBUG\n  void sqlite3VdbeReleaseRegisters(Parse*,int addr, int n, u32 mask, int);\n#else\n# define sqlite3VdbeReleaseRegisters(P,A,N,M,F)\n#endif\nvoid sqlite3VdbeChangeP4(Vdbe*, int addr, const char *zP4, int N);\nvoid sqlite3VdbeAppendP4(Vdbe*, void *pP4, int p4type);\nvoid sqlite3VdbeSetP4KeyInfo(Parse*, Index*);\nvoid sqlite3VdbeUsesBtree(Vdbe*, int);\nVdbeOp *sqlite3VdbeGetOp(Vdbe*, int);\nVdbeOp *sqlite3VdbeGetLastOp(Vdbe*);\nint sqlite3VdbeMakeLabel(Parse*);\nvoid sqlite3VdbeRunOnlyOnce(Vdbe*);\nvoid sqlite3VdbeReusable(Vdbe*);\nvoid sqlite3VdbeDelete(Vdbe*);\nvoid sqlite3VdbeMakeReady(Vdbe*,Parse*);\nint sqlite3VdbeFinalize(Vdbe*);\nvoid sqlite3VdbeResolveLabel(Vdbe*, int);\nint sqlite3VdbeCurrentAddr(Vdbe*);\n#ifdef SQLITE_DEBUG\n  int sqlite3VdbeAssertMayAbort(Vdbe *, int);\n#endif\nvoid sqlite3VdbeResetStepResult(Vdbe*);\nvoid sqlite3VdbeRewind(Vdbe*);\nint sqlite3VdbeReset(Vdbe*);\nvoid sqlite3VdbeSetNumCols(Vdbe*,int);\nint sqlite3VdbeSetColName(Vdbe*, int, int, const char *, void(*)(void*));\nvoid sqlite3VdbeCountChanges(Vdbe*);\nsqlite3 *sqlite3VdbeDb(Vdbe*);\nu8 sqlite3VdbePrepareFlags(Vdbe*);\nvoid sqlite3VdbeSetSql(Vdbe*, const char *z, int n, u8);\n#ifdef SQLITE_ENABLE_NORMALIZE\nvoid sqlite3VdbeAddDblquoteStr(sqlite3*,Vdbe*,const char*);\nint sqlite3VdbeUsesDoubleQuotedString(Vdbe*,const char*);\n#endif\nvoid sqlite3VdbeSwap(Vdbe*,Vdbe*);\nVdbeOp *sqlite3VdbeTakeOpArray(Vdbe*, int*, int*);\nsqlite3_value *sqlite3VdbeGetBoundValue(Vdbe*, int, u8);\nvoid sqlite3VdbeSetVarmask(Vdbe*, int);\n#ifndef SQLITE_OMIT_TRACE\n  char *sqlite3VdbeExpandSql(Vdbe*, const char*);\n#endif\nint sqlite3MemCompare(const Mem*, const Mem*, const CollSeq*);\nint sqlite3BlobCompare(const Mem*, const Mem*);\n#ifdef SQLITE_ENABLE_PERCENTILE\n  const char *sqlite3VdbeFuncName(const sqlite3_context*);\n#endif\n\nvoid sqlite3VdbeRecordUnpack(int,const void*,UnpackedRecord*);\nint sqlite3VdbeRecordCompare(int,const void*,UnpackedRecord*);\nint sqlite3VdbeRecordCompareWithSkip(int, const void *, UnpackedRecord *, int);\nUnpackedRecord *sqlite3VdbeAllocUnpackedRecord(KeyInfo*);\n\ntypedef int (*RecordCompare)(int,const void*,UnpackedRecord*);\nRecordCompare sqlite3VdbeFindCompare(UnpackedRecord*);\n\nvoid sqlite3VdbeLinkSubProgram(Vdbe *, SubProgram *);\nint sqlite3VdbeHasSubProgram(Vdbe*);\n\nvoid sqlite3MemSetArrayInt64(sqlite3_value *aMem, int iIdx, i64 val);\n\n#ifndef SQLITE_OMIT_DATETIME_FUNCS\nint sqlite3NotPureFunc(sqlite3_context*);\n#endif\n#ifdef SQLITE_ENABLE_BYTECODE_VTAB\nint sqlite3VdbeBytecodeVtabInit(sqlite3*);\n#endif\n\n/* Use SQLITE_ENABLE_EXPLAIN_COMMENTS to enable generation of extra\n** comments on each VDBE opcode.\n**\n** Use the SQLITE_ENABLE_MODULE_COMMENTS macro to see some extra no-op\n** comments in VDBE programs that show key decision points in the code\n** generator.\n*/\n#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS\n  void sqlite3VdbeComment(Vdbe*, const char*, ...);\n# define VdbeComment(X)  sqlite3VdbeComment X\n  void sqlite3VdbeNoopComment(Vdbe*, const char*, ...);\n# define VdbeNoopComment(X)  sqlite3VdbeNoopComment X\n# ifdef SQLITE_ENABLE_MODULE_COMMENTS\n#   define VdbeModuleComment(X)  sqlite3VdbeNoopComment X\n# else\n#   define VdbeModuleComment(X)\n# endif\n#else\n# define VdbeComment(X)\n# define VdbeNoopComment(X)\n# define VdbeModuleComment(X)\n#endif\n\n/*\n** The VdbeCoverage macros are used to set a coverage testing point\n** for VDBE branch instructions.  The coverage testing points are line\n** numbers in the sqlite3.c source file.  VDBE branch coverage testing\n** only works with an amalgamation build.  That's ok since a VDBE branch\n** coverage build designed for testing the test suite only.  No application\n** should ever ship with VDBE branch coverage measuring turned on.\n**\n**    VdbeCoverage(v)                  // Mark the previously coded instruction\n**                                     // as a branch\n**\n**    VdbeCoverageIf(v, conditional)   // Mark previous if conditional true\n**\n**    VdbeCoverageAlwaysTaken(v)       // Previous branch is always taken\n**\n**    VdbeCoverageNeverTaken(v)        // Previous branch is never taken\n**\n**    VdbeCoverageNeverNull(v)         // Previous three-way branch is only\n**                                     // taken on the first two ways.  The\n**                                     // NULL option is not possible\n**\n**    VdbeCoverageEqNe(v)              // Previous OP_Jump is only interested\n**                                     // in distinguishing equal and not-equal.\n**\n** Every VDBE branch operation must be tagged with one of the macros above.\n** If not, then when \"make test\" is run with -DSQLITE_VDBE_COVERAGE and\n** -DSQLITE_DEBUG then an ALWAYS() will fail in the vdbeTakeBranch()\n** routine in vdbe.c, alerting the developer to the missed tag.\n**\n** During testing, the test application will invoke\n** sqlite3_test_control(SQLITE_TESTCTRL_VDBE_COVERAGE,...) to set a callback\n** routine that is invoked as each bytecode branch is taken.  The callback\n** contains the sqlite3.c source line number of the VdbeCoverage macro and\n** flags to indicate whether or not the branch was taken.  The test application\n** is responsible for keeping track of this and reporting byte-code branches\n** that are never taken.\n**\n** See the VdbeBranchTaken() macro and vdbeTakeBranch() function in the\n** vdbe.c source file for additional information.\n*/\n#ifdef SQLITE_VDBE_COVERAGE\n  void sqlite3VdbeSetLineNumber(Vdbe*,int);\n# define VdbeCoverage(v) sqlite3VdbeSetLineNumber(v,__LINE__)\n# define VdbeCoverageIf(v,x) if(x)sqlite3VdbeSetLineNumber(v,__LINE__)\n# define VdbeCoverageAlwaysTaken(v) \\\n         sqlite3VdbeSetLineNumber(v,__LINE__|0x5000000);\n# define VdbeCoverageNeverTaken(v) \\\n         sqlite3VdbeSetLineNumber(v,__LINE__|0x6000000);\n# define VdbeCoverageNeverNull(v) \\\n         sqlite3VdbeSetLineNumber(v,__LINE__|0x4000000);\n# define VdbeCoverageNeverNullIf(v,x) \\\n         if(x)sqlite3VdbeSetLineNumber(v,__LINE__|0x4000000);\n# define VdbeCoverageEqNe(v) \\\n         sqlite3VdbeSetLineNumber(v,__LINE__|0x8000000);\n# define VDBE_OFFSET_LINENO(x) (__LINE__+x)\n#else\n# define VdbeCoverage(v)\n# define VdbeCoverageIf(v,x)\n# define VdbeCoverageAlwaysTaken(v)\n# define VdbeCoverageNeverTaken(v)\n# define VdbeCoverageNeverNull(v)\n# define VdbeCoverageNeverNullIf(v,x)\n# define VdbeCoverageEqNe(v)\n# define VDBE_OFFSET_LINENO(x) 0\n#endif\n\n#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\nvoid sqlite3VdbeScanStatus(Vdbe*, int, int, int, LogEst, const char*);\nvoid sqlite3VdbeScanStatusRange(Vdbe*, int, int, int);\nvoid sqlite3VdbeScanStatusCounters(Vdbe*, int, int, int);\n#else\n# define sqlite3VdbeScanStatus(a,b,c,d,e,f)\n# define sqlite3VdbeScanStatusRange(a,b,c,d)\n# define sqlite3VdbeScanStatusCounters(a,b,c,d)\n#endif\n\n#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)\nvoid sqlite3VdbePrintOp(FILE*, int, VdbeOp*);\n#endif\n\n#if defined(SQLITE_ENABLE_CURSOR_HINTS) && defined(SQLITE_DEBUG)\nint sqlite3CursorRangeHintExprCheck(Walker *pWalker, Expr *pExpr);\n#endif\n\n#endif /* SQLITE_VDBE_H */\n"}
{"repo": "sqlite", "file": "btree.h", "lang": "C++", "code": "/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This header file defines the interface that the sqlite B-Tree file\n** subsystem.  See comments in the source code for a detailed description\n** of what each interface routine does.\n*/\n#ifndef SQLITE_BTREE_H\n#define SQLITE_BTREE_H\n\n/* TODO: This definition is just included so other modules compile. It\n** needs to be revisited.\n*/\n#define SQLITE_N_BTREE_META 16\n\n/*\n** If defined as non-zero, auto-vacuum is enabled by default. Otherwise\n** it must be turned on for each database using \"PRAGMA auto_vacuum = 1\".\n*/\n#ifndef SQLITE_DEFAULT_AUTOVACUUM\n  #define SQLITE_DEFAULT_AUTOVACUUM 0\n#endif\n\n#define BTREE_AUTOVACUUM_NONE 0        /* Do not do auto-vacuum */\n#define BTREE_AUTOVACUUM_FULL 1        /* Do full auto-vacuum */\n#define BTREE_AUTOVACUUM_INCR 2        /* Incremental vacuum */\n\n/*\n** Forward declarations of structure\n*/\ntypedef struct Btree Btree;\ntypedef struct BtCursor BtCursor;\ntypedef struct BtShared BtShared;\ntypedef struct BtreePayload BtreePayload;\n\n\nint sqlite3BtreeOpen(\n  sqlite3_vfs *pVfs,       /* VFS to use with this b-tree */\n  const char *zFilename,   /* Name of database file to open */\n  sqlite3 *db,             /* Associated database connection */\n  Btree **ppBtree,         /* Return open Btree* here */\n  int flags,               /* Flags */\n  int vfsFlags             /* Flags passed through to VFS open */\n);\n\n/* The flags parameter to sqlite3BtreeOpen can be the bitwise or of the\n** following values.\n**\n** NOTE:  These values must match the corresponding PAGER_ values in\n** pager.h.\n*/\n#define BTREE_OMIT_JOURNAL  1  /* Do not create or use a rollback journal */\n#define BTREE_MEMORY        2  /* This is an in-memory DB */\n#define BTREE_SINGLE        4  /* The file contains at most 1 b-tree */\n#define BTREE_UNORDERED     8  /* Use of a hash implementation is OK */\n\nint sqlite3BtreeClose(Btree*);\nint sqlite3BtreeSetCacheSize(Btree*,int);\nint sqlite3BtreeSetSpillSize(Btree*,int);\n#if SQLITE_MAX_MMAP_SIZE>0\n  int sqlite3BtreeSetMmapLimit(Btree*,sqlite3_int64);\n#endif\nint sqlite3BtreeSetPagerFlags(Btree*,unsigned);\nint sqlite3BtreeSetPageSize(Btree *p, int nPagesize, int nReserve, int eFix);\nint sqlite3BtreeGetPageSize(Btree*);\nPgno sqlite3BtreeMaxPageCount(Btree*,Pgno);\nPgno sqlite3BtreeLastPage(Btree*);\nint sqlite3BtreeSecureDelete(Btree*,int);\nint sqlite3BtreeGetRequestedReserve(Btree*);\nint sqlite3BtreeGetReserveNoMutex(Btree *p);\nint sqlite3BtreeSetAutoVacuum(Btree *, int);\nint sqlite3BtreeGetAutoVacuum(Btree *);\nint sqlite3BtreeBeginTrans(Btree*,int,int*);\nint sqlite3BtreeCommitPhaseOne(Btree*, const char*);\nint sqlite3BtreeCommitPhaseTwo(Btree*, int);\nint sqlite3BtreeCommit(Btree*);\nint sqlite3BtreeRollback(Btree*,int,int);\nint sqlite3BtreeBeginStmt(Btree*,int);\nint sqlite3BtreeCreateTable(Btree*, Pgno*, int flags);\nint sqlite3BtreeTxnState(Btree*);\nint sqlite3BtreeIsInBackup(Btree*);\n\nvoid *sqlite3BtreeSchema(Btree *, int, void(*)(void *));\nint sqlite3BtreeSchemaLocked(Btree *pBtree);\n#ifndef SQLITE_OMIT_SHARED_CACHE\nint sqlite3BtreeLockTable(Btree *pBtree, int iTab, u8 isWriteLock);\n#endif\n\n/* Savepoints are named, nestable SQL transactions mostly implemented */ \n/* in vdbe.c and pager.c See https://sqlite.org/lang_savepoint.html */\nint sqlite3BtreeSavepoint(Btree *, int, int);\n\n/* \"Checkpoint\" only refers to WAL. See https://sqlite.org/wal.html#ckpt */\n#ifndef SQLITE_OMIT_WAL\n  int sqlite3BtreeCheckpoint(Btree*, int, int *, int *);  \n#endif\n\nconst char *sqlite3BtreeGetFilename(Btree *);\nconst char *sqlite3BtreeGetJournalname(Btree *);\nint sqlite3BtreeCopyFile(Btree *, Btree *);\n\nint sqlite3BtreeIncrVacuum(Btree *);\n\n/* The flags parameter to sqlite3BtreeCreateTable can be the bitwise OR\n** of the flags shown below.\n**\n** Every SQLite table must have either BTREE_INTKEY or BTREE_BLOBKEY set.\n** With BTREE_INTKEY, the table key is a 64-bit integer and arbitrary data\n** is stored in the leaves.  (BTREE_INTKEY is used for SQL tables.)  With\n** BTREE_BLOBKEY, the key is an arbitrary BLOB and no content is stored\n** anywhere - the key is the content.  (BTREE_BLOBKEY is used for SQL\n** indices.)\n*/\n#define BTREE_INTKEY     1    /* Table has only 64-bit signed integer keys */\n#define BTREE_BLOBKEY    2    /* Table has keys only - no data */\n\nint sqlite3BtreeDropTable(Btree*, int, int*);\nint sqlite3BtreeClearTable(Btree*, int, i64*);\nint sqlite3BtreeClearTableOfCursor(BtCursor*);\nint sqlite3BtreeTripAllCursors(Btree*, int, int);\n\nvoid sqlite3BtreeGetMeta(Btree *pBtree, int idx, u32 *pValue);\nint sqlite3BtreeUpdateMeta(Btree*, int idx, u32 value);\n\nint sqlite3BtreeNewDb(Btree *p);\n\n/*\n** The second parameter to sqlite3BtreeGetMeta or sqlite3BtreeUpdateMeta\n** should be one of the following values. The integer values are assigned \n** to constants so that the offset of the corresponding field in an\n** SQLite database header may be found using the following formula:\n**\n**   offset = 36 + (idx * 4)\n**\n** For example, the free-page-count field is located at byte offset 36 of\n** the database file header. The incr-vacuum-flag field is located at\n** byte offset 64 (== 36+4*7).\n**\n** The BTREE_DATA_VERSION value is not really a value stored in the header.\n** It is a read-only number computed by the pager.  But we merge it with\n** the header value access routines since its access pattern is the same.\n** Call it a \"virtual meta value\".\n*/\n#define BTREE_FREE_PAGE_COUNT     0\n#define BTREE_SCHEMA_VERSION      1\n#define BTREE_FILE_FORMAT         2\n#define BTREE_DEFAULT_CACHE_SIZE  3\n#define BTREE_LARGEST_ROOT_PAGE   4\n#define BTREE_TEXT_ENCODING       5\n#define BTREE_USER_VERSION        6\n#define BTREE_INCR_VACUUM         7\n#define BTREE_APPLICATION_ID      8\n#define BTREE_DATA_VERSION        15  /* A virtual meta-value */\n\n/*\n** Kinds of hints that can be passed into the sqlite3BtreeCursorHint()\n** interface.\n**\n** BTREE_HINT_RANGE  (arguments: Expr*, Mem*)\n**\n**     The first argument is an Expr* (which is guaranteed to be constant for\n**     the lifetime of the cursor) that defines constraints on which rows\n**     might be fetched with this cursor.  The Expr* tree may contain\n**     TK_REGISTER nodes that refer to values stored in the array of registers\n**     passed as the second parameter.  In other words, if Expr.op==TK_REGISTER\n**     then the value of the node is the value in Mem[pExpr.iTable].  Any\n**     TK_COLUMN node in the expression tree refers to the Expr.iColumn-th\n**     column of the b-tree of the cursor.  The Expr tree will not contain\n**     any function calls nor subqueries nor references to b-trees other than\n**     the cursor being hinted.\n**\n**     The design of the _RANGE hint is aid b-tree implementations that try\n**     to prefetch content from remote machines - to provide those\n**     implementations with limits on what needs to be prefetched and thereby\n**     reduce network bandwidth.\n**\n** Note that BTREE_HINT_FLAGS with BTREE_BULKLOAD is the only hint used by\n** standard SQLite.  The other hints are provided for extensions that use\n** the SQLite parser and code generator but substitute their own storage\n** engine.\n*/\n#define BTREE_HINT_RANGE 0       /* Range constraints on queries */\n\n/*\n** Values that may be OR'd together to form the argument to the\n** BTREE_HINT_FLAGS hint for sqlite3BtreeCursorHint():\n**\n** The BTREE_BULKLOAD flag is set on index cursors when the index is going\n** to be filled with content that is already in sorted order.\n**\n** The BTREE_SEEK_EQ flag is set on cursors that will get OP_SeekGE or\n** OP_SeekLE opcodes for a range search, but where the range of entries\n** selected will all have the same key.  In other words, the cursor will\n** be used only for equality key searches.\n**\n*/\n#define BTREE_BULKLOAD 0x00000001  /* Used to full index in sorted order */\n#define BTREE_SEEK_EQ  0x00000002  /* EQ seeks only - no range seeks */\n\n/* \n** Flags passed as the third argument to sqlite3BtreeCursor().\n**\n** For read-only cursors the wrFlag argument is always zero. For read-write\n** cursors it may be set to either (BTREE_WRCSR|BTREE_FORDELETE) or just\n** (BTREE_WRCSR). If the BTREE_FORDELETE bit is set, then the cursor will\n** only be used by SQLite for the following:\n**\n**   * to seek to and then delete specific entries, and/or\n**\n**   * to read values that will be used to create keys that other\n**     BTREE_FORDELETE cursors will seek to and delete.\n**\n** The BTREE_FORDELETE flag is an optimization hint.  It is not used by\n** by this, the native b-tree engine of SQLite, but it is available to\n** alternative storage engines that might be substituted in place of this\n** b-tree system.  For alternative storage engines in which a delete of\n** the main table row automatically deletes corresponding index rows,\n** the FORDELETE flag hint allows those alternative storage engines to\n** skip a lot of work.  Namely:  FORDELETE cursors may treat all SEEK\n** and DELETE operations as no-ops, and any READ operation against a\n** FORDELETE cursor may return a null row: 0x01 0x00.\n*/\n#define BTREE_WRCSR     0x00000004     /* read-write cursor */\n#define BTREE_FORDELETE 0x00000008     /* Cursor is for seek/delete only */\n\nint sqlite3BtreeCursor(\n  Btree*,                              /* BTree containing table to open */\n  Pgno iTable,                         /* Index of root page */\n  int wrFlag,                          /* 1 for writing.  0 for read-only */\n  struct KeyInfo*,                     /* First argument to compare function */\n  BtCursor *pCursor                    /* Space to write cursor structure */\n);\nBtCursor *sqlite3BtreeFakeValidCursor(void);\nint sqlite3BtreeCursorSize(void);\n#ifdef SQLITE_DEBUG\nint sqlite3BtreeClosesWithCursor(Btree*,BtCursor*);\n#endif\nvoid sqlite3BtreeCursorZero(BtCursor*);\nvoid sqlite3BtreeCursorHintFlags(BtCursor*, unsigned);\n#ifdef SQLITE_ENABLE_CURSOR_HINTS\nvoid sqlite3BtreeCursorHint(BtCursor*, int, ...);\n#endif\n\nint sqlite3BtreeCloseCursor(BtCursor*);\nint sqlite3BtreeTableMoveto(\n  BtCursor*,\n  i64 intKey,\n  int bias,\n  int *pRes\n);\nint sqlite3BtreeIndexMoveto(\n  BtCursor*,\n  UnpackedRecord *pUnKey,\n  int *pRes\n);\nint sqlite3BtreeCursorHasMoved(BtCursor*);\nint sqlite3BtreeCursorRestore(BtCursor*, int*);\nint sqlite3BtreeDelete(BtCursor*, u8 flags);\n\n/* Allowed flags for sqlite3BtreeDelete() and sqlite3BtreeInsert() */\n#define BTREE_SAVEPOSITION 0x02  /* Leave cursor pointing at NEXT or PREV */\n#define BTREE_AUXDELETE    0x04  /* not the primary delete operation */\n#define BTREE_APPEND       0x08  /* Insert is likely an append */\n#define BTREE_PREFORMAT    0x80  /* Inserted data is a preformated cell */\n\n/* An instance of the BtreePayload object describes the content of a single\n** entry in either an index or table btree.\n**\n** Index btrees (used for indexes and also WITHOUT ROWID tables) contain\n** an arbitrary key and no data.  These btrees have pKey,nKey set to the\n** key and the pData,nData,nZero fields are uninitialized.  The aMem,nMem\n** fields give an array of Mem objects that are a decomposition of the key.\n** The nMem field might be zero, indicating that no decomposition is available.\n**\n** Table btrees (used for rowid tables) contain an integer rowid used as\n** the key and passed in the nKey field.  The pKey field is zero.  \n** pData,nData hold the content of the new entry.  nZero extra zero bytes\n** are appended to the end of the content when constructing the entry.\n** The aMem,nMem fields are uninitialized for table btrees.\n**\n** Field usage summary:\n**\n**               Table BTrees                   Index Btrees\n**\n**   pKey        always NULL                    encoded key\n**   nKey        the ROWID                      length of pKey\n**   pData       data                           not used\n**   aMem        not used                       decomposed key value\n**   nMem        not used                       entries in aMem\n**   nData       length of pData                not used\n**   nZero       extra zeros after pData        not used\n**\n** This object is used to pass information into sqlite3BtreeInsert().  The\n** same information used to be passed as five separate parameters.  But placing\n** the information into this object helps to keep the interface more \n** organized and understandable, and it also helps the resulting code to\n** run a little faster by using fewer registers for parameter passing.\n*/\nstruct BtreePayload {\n  const void *pKey;       /* Key content for indexes.  NULL for tables */\n  sqlite3_int64 nKey;     /* Size of pKey for indexes.  PRIMARY KEY for tabs */\n  const void *pData;      /* Data for tables. */\n  sqlite3_value *aMem;    /* First of nMem value in the unpacked pKey */\n  u16 nMem;               /* Number of aMem[] value.  Might be zero */\n  int nData;              /* Size of pData.  0 if none. */\n  int nZero;              /* Extra zero data appended after pData,nData */\n};\n\nint sqlite3BtreeInsert(BtCursor*, const BtreePayload *pPayload,\n                       int flags, int seekResult);\nint sqlite3BtreeFirst(BtCursor*, int *pRes);\nint sqlite3BtreeIsEmpty(BtCursor *pCur, int *pRes);\nint sqlite3BtreeLast(BtCursor*, int *pRes);\nint sqlite3BtreeNext(BtCursor*, int flags);\nint sqlite3BtreeEof(BtCursor*);\nint sqlite3BtreePrevious(BtCursor*, int flags);\ni64 sqlite3BtreeIntegerKey(BtCursor*);\nvoid sqlite3BtreeCursorPin(BtCursor*);\nvoid sqlite3BtreeCursorUnpin(BtCursor*);\ni64 sqlite3BtreeOffset(BtCursor*);\nint sqlite3BtreePayload(BtCursor*, u32 offset, u32 amt, void*);\nconst void *sqlite3BtreePayloadFetch(BtCursor*, u32 *pAmt);\nu32 sqlite3BtreePayloadSize(BtCursor*);\nsqlite3_int64 sqlite3BtreeMaxRecordSize(BtCursor*);\n\nint sqlite3BtreeIntegrityCheck(\n  sqlite3 *db,  /* Database connection that is running the check */\n  Btree *p,     /* The btree to be checked */\n  Pgno *aRoot,  /* An array of root pages numbers for individual trees */\n  sqlite3_value *aCnt,  /* OUT: entry counts for each btree in aRoot[] */\n  int nRoot,    /* Number of entries in aRoot[] */\n  int mxErr,    /* Stop reporting errors after this many */\n  int *pnErr,   /* OUT: Write number of errors seen to this variable */\n  char **pzOut  /* OUT: Write the error message string here */\n);\nstruct Pager *sqlite3BtreePager(Btree*);\ni64 sqlite3BtreeRowCountEst(BtCursor*);\n\n#ifndef SQLITE_OMIT_INCRBLOB\nint sqlite3BtreePayloadChecked(BtCursor*, u32 offset, u32 amt, void*);\nint sqlite3BtreePutData(BtCursor*, u32 offset, u32 amt, void*);\nvoid sqlite3BtreeIncrblobCursor(BtCursor *);\n#endif\nvoid sqlite3BtreeClearCursor(BtCursor *);\nint sqlite3BtreeSetVersion(Btree *pBt, int iVersion);\nint sqlite3BtreeCursorHasHint(BtCursor*, unsigned int mask);\nint sqlite3BtreeIsReadonly(Btree *pBt);\nint sqlite3HeaderSizeBtree(void);\n\n#ifdef SQLITE_DEBUG\nsqlite3_uint64 sqlite3BtreeSeekCount(Btree*);\n#else\n# define sqlite3BtreeSeekCount(X) 0\n#endif\n\n#ifndef NDEBUG\nint sqlite3BtreeCursorIsValid(BtCursor*);\n#endif\nint sqlite3BtreeCursorIsValidNN(BtCursor*);\n\nint sqlite3BtreeCount(sqlite3*, BtCursor*, i64*);\n\n#ifdef SQLITE_TEST\nint sqlite3BtreeCursorInfo(BtCursor*, int*, int);\nvoid sqlite3BtreeCursorList(Btree*);\n#endif\n\n#ifndef SQLITE_OMIT_WAL\n  int sqlite3BtreeCheckpoint(Btree*, int, int *, int *);\n#endif\n\nint sqlite3BtreeTransferRow(BtCursor*, BtCursor*, i64);\n\nvoid sqlite3BtreeClearCache(Btree*);\n\n/*\n** If we are not using shared cache, then there is no need to\n** use mutexes to access the BtShared structures.  So make the\n** Enter and Leave procedures no-ops.\n*/\n#ifndef SQLITE_OMIT_SHARED_CACHE\n  void sqlite3BtreeEnter(Btree*);\n  void sqlite3BtreeEnterAll(sqlite3*);\n  int sqlite3BtreeSharable(Btree*);\n  void sqlite3BtreeEnterCursor(BtCursor*);\n  int sqlite3BtreeConnectionCount(Btree*);\n#else\n# define sqlite3BtreeEnter(X) \n# define sqlite3BtreeEnterAll(X)\n# define sqlite3BtreeSharable(X) 0\n# define sqlite3BtreeEnterCursor(X)\n# define sqlite3BtreeConnectionCount(X) 1\n#endif\n\n#if !defined(SQLITE_OMIT_SHARED_CACHE) && SQLITE_THREADSAFE\n  void sqlite3BtreeLeave(Btree*);\n  void sqlite3BtreeLeaveCursor(BtCursor*);\n  void sqlite3BtreeLeaveAll(sqlite3*);\n#ifndef NDEBUG\n  /* These routines are used inside assert() statements only. */\n  int sqlite3BtreeHoldsMutex(Btree*);\n  int sqlite3BtreeHoldsAllMutexes(sqlite3*);\n  int sqlite3SchemaMutexHeld(sqlite3*,int,Schema*);\n#endif\n#else\n\n# define sqlite3BtreeLeave(X)\n# define sqlite3BtreeLeaveCursor(X)\n# define sqlite3BtreeLeaveAll(X)\n\n# define sqlite3BtreeHoldsMutex(X) 1\n# define sqlite3BtreeHoldsAllMutexes(X) 1\n# define sqlite3SchemaMutexHeld(X,Y,Z) 1\n#endif\n\n\n#endif /* SQLITE_BTREE_H */\n"}
{"repo": "sqlite", "file": "test_quota.c", "lang": "C++", "code": "/*\n** 2010 September 31\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains a VFS \"shim\" - a layer that sits in between the\n** pager and the real VFS.\n**\n** This particular shim enforces a quota system on files.  One or more\n** database files are in a \"quota group\" that is defined by a GLOB\n** pattern.  A quota is set for the combined size of all files in the\n** the group.  A quota of zero means \"no limit\".  If the total size\n** of all files in the quota group is greater than the limit, then\n** write requests that attempt to enlarge a file fail with SQLITE_FULL.\n**\n** However, before returning SQLITE_FULL, the write requests invoke\n** a callback function that is configurable for each quota group.\n** This callback has the opportunity to enlarge the quota.  If the\n** callback does enlarge the quota such that the total size of all\n** files within the group is less than the new quota, then the write\n** continues as if nothing had happened.\n*/\n#include \"test_quota.h\"\n#include <string.h>\n#include <assert.h>\n\n/*\n** For an build without mutexes, no-op the mutex calls.\n*/\n#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE==0\n#define sqlite3_mutex_alloc(X)    ((sqlite3_mutex*)8)\n#define sqlite3_mutex_free(X)\n#define sqlite3_mutex_enter(X)\n#define sqlite3_mutex_try(X)      SQLITE_OK\n#define sqlite3_mutex_leave(X)\n#define sqlite3_mutex_held(X)     ((void)(X),1)\n#define sqlite3_mutex_notheld(X)  ((void)(X),1)\n#endif /* SQLITE_THREADSAFE==0 */\n\n\n#ifdef _WIN32\n# include <windows.h>\n# include <io.h>\n#else\n# include <unistd.h>\n#endif\n\n\n/************************ Object Definitions ******************************/\n\n/* Forward declaration of all object types */\ntypedef struct quotaGroup quotaGroup;\ntypedef struct quotaConn quotaConn;\ntypedef struct quotaFile quotaFile;\n\n/*\n** A \"quota group\" is a collection of files whose collective size we want\n** to limit.  Each quota group is defined by a GLOB pattern.\n**\n** There is an instance of the following object for each defined quota\n** group.  This object records the GLOB pattern that defines which files\n** belong to the quota group.  The object also remembers the size limit\n** for the group (the quota) and the callback to be invoked when the\n** sum of the sizes of the files within the group goes over the limit.\n**\n** A quota group must be established (using sqlite3_quota_set(...))\n** prior to opening any of the database connections that access files\n** within the quota group.\n*/\nstruct quotaGroup {\n  const char *zPattern;          /* Filename pattern to be quotaed */\n  sqlite3_int64 iLimit;          /* Upper bound on total file size */\n  sqlite3_int64 iSize;           /* Current size of all files */\n  void (*xCallback)(             /* Callback invoked when going over quota */\n     const char *zFilename,         /* Name of file whose size increases */\n     sqlite3_int64 *piLimit,        /* IN/OUT: The current limit */\n     sqlite3_int64 iSize,           /* Total size of all files in the group */\n     void *pArg                     /* Client data */\n  );\n  void *pArg;                    /* Third argument to the xCallback() */\n  void (*xDestroy)(void*);       /* Optional destructor for pArg */\n  quotaGroup *pNext, **ppPrev;   /* Doubly linked list of all quota objects */\n  quotaFile *pFiles;             /* Files within this group */\n};\n\n/*\n** An instance of this structure represents a single file that is part\n** of a quota group.  A single file can be opened multiple times.  In\n** order keep multiple openings of the same file from causing the size\n** of the file to count against the quota multiple times, each file\n** has a unique instance of this object and multiple open connections\n** to the same file each point to a single instance of this object.\n*/\nstruct quotaFile {\n  char *zFilename;                /* Name of this file */\n  quotaGroup *pGroup;             /* Quota group to which this file belongs */\n  sqlite3_int64 iSize;            /* Current size of this file */\n  int nRef;                       /* Number of times this file is open */\n  int deleteOnClose;              /* True to delete this file when it closes */\n  quotaFile *pNext, **ppPrev;     /* Linked list of files in the same group */\n};\n\n/*\n** An instance of the following object represents each open connection\n** to a file that participates in quota tracking.  This object is a\n** subclass of sqlite3_file.  The sqlite3_file object for the underlying\n** VFS is appended to this structure.\n*/\nstruct quotaConn {\n  sqlite3_file base;              /* Base class - must be first */\n  quotaFile *pFile;               /* The underlying file */\n  /* The underlying VFS sqlite3_file is appended to this object */\n};\n\n/*\n** An instance of the following object records the state of an\n** open file.  This object is opaque to all users - the internal\n** structure is only visible to the functions below.\n*/\nstruct quota_FILE {\n  FILE *f;                /* Open stdio file pointer */\n  sqlite3_int64 iOfst;    /* Current offset into the file */\n  quotaFile *pFile;       /* The file record in the quota system */\n#ifdef _WIN32\n  char *zMbcsName;        /* Full MBCS pathname of the file */\n#endif\n};\n\n\n/************************* Global Variables **********************************/\n/*\n** All global variables used by this file are containing within the following\n** gQuota structure.\n*/\nstatic struct {\n  /* The pOrigVfs is the real, original underlying VFS implementation.\n  ** Most operations pass-through to the real VFS.  This value is read-only\n  ** during operation.  It is only modified at start-time and thus does not\n  ** require a mutex.\n  */\n  sqlite3_vfs *pOrigVfs;\n\n  /* The sThisVfs is the VFS structure used by this shim.  It is initialized\n  ** at start-time and thus does not require a mutex\n  */\n  sqlite3_vfs sThisVfs;\n\n  /* The sIoMethods defines the methods used by sqlite3_file objects\n  ** associated with this shim.  It is initialized at start-time and does\n  ** not require a mutex.\n  **\n  ** When the underlying VFS is called to open a file, it might return\n  ** either a version 1 or a version 2 sqlite3_file object.  This shim\n  ** has to create a wrapper sqlite3_file of the same version.  Hence\n  ** there are two I/O method structures, one for version 1 and the other\n  ** for version 2.\n  */\n  sqlite3_io_methods sIoMethodsV1;\n  sqlite3_io_methods sIoMethodsV2;\n\n  /* True when this shim as been initialized.\n  */\n  int isInitialized;\n\n  /* For run-time access any of the other global data structures in this\n  ** shim, the following mutex must be held.\n  */\n  sqlite3_mutex *pMutex;\n\n  /* List of quotaGroup objects.\n  */\n  quotaGroup *pGroup;\n\n} gQuota;\n\n/************************* Utility Routines *********************************/\n/*\n** Acquire and release the mutex used to serialize access to the\n** list of quotaGroups.\n*/\nstatic void quotaEnter(void){ sqlite3_mutex_enter(gQuota.pMutex); }\nstatic void quotaLeave(void){ sqlite3_mutex_leave(gQuota.pMutex); }\n\n/* Count the number of open files in a quotaGroup\n*/\nstatic int quotaGroupOpenFileCount(quotaGroup *pGroup){\n  int N = 0;\n  quotaFile *pFile = pGroup->pFiles;\n  while( pFile ){\n    if( pFile->nRef ) N++;\n    pFile = pFile->pNext;\n  }\n  return N;\n}\n\n/* Remove a file from a quota group.\n*/\nstatic void quotaRemoveFile(quotaFile *pFile){\n  quotaGroup *pGroup = pFile->pGroup;\n  pGroup->iSize -= pFile->iSize;\n  *pFile->ppPrev = pFile->pNext;\n  if( pFile->pNext ) pFile->pNext->ppPrev = pFile->ppPrev;\n  sqlite3_free(pFile);\n}\n\n/* Remove all files from a quota group.  It is always the case that\n** all files will be closed when this routine is called.\n*/\nstatic void quotaRemoveAllFiles(quotaGroup *pGroup){\n  while( pGroup->pFiles ){\n    assert( pGroup->pFiles->nRef==0 );\n    quotaRemoveFile(pGroup->pFiles);\n  }\n}\n\n\n/* If the reference count and threshold for a quotaGroup are both\n** zero, then destroy the quotaGroup.\n*/\nstatic void quotaGroupDeref(quotaGroup *pGroup){\n  if( pGroup->iLimit==0 && quotaGroupOpenFileCount(pGroup)==0 ){\n    quotaRemoveAllFiles(pGroup);\n    *pGroup->ppPrev = pGroup->pNext;\n    if( pGroup->pNext ) pGroup->pNext->ppPrev = pGroup->ppPrev;\n    if( pGroup->xDestroy ) pGroup->xDestroy(pGroup->pArg);\n    sqlite3_free(pGroup);\n  }\n}\n\n/*\n** Return TRUE if string z matches glob pattern zGlob.\n**\n** Globbing rules:\n**\n**      '*'       Matches any sequence of zero or more characters.\n**\n**      '?'       Matches exactly one character.\n**\n**     [...]      Matches one character from the enclosed list of\n**                characters.\n**\n**     [^...]     Matches one character not in the enclosed list.\n**\n**     /          Matches \"/\" or \"\\\\\"\n**\n*/\nstatic int quotaStrglob(const char *zGlob, const char *z){\n  int c, c2, cx;\n  int invert;\n  int seen;\n\n  while( (c = (*(zGlob++)))!=0 ){\n    if( c=='*' ){\n      while( (c=(*(zGlob++))) == '*' || c=='?' ){\n        if( c=='?' && (*(z++))==0 ) return 0;\n      }\n      if( c==0 ){\n        return 1;\n      }else if( c=='[' ){\n        while( *z && quotaStrglob(zGlob-1,z)==0 ){\n          z++;\n        }\n        return (*z)!=0;\n      }\n      cx = (c=='/') ? '\\\\' : c;\n      while( (c2 = (*(z++)))!=0 ){\n        while( c2!=c && c2!=cx ){\n          c2 = *(z++);\n          if( c2==0 ) return 0;\n        }\n        if( quotaStrglob(zGlob,z) ) return 1;\n      }\n      return 0;\n    }else if( c=='?' ){\n      if( (*(z++))==0 ) return 0;\n    }else if( c=='[' ){\n      int prior_c = 0;\n      seen = 0;\n      invert = 0;\n      c = *(z++);\n      if( c==0 ) return 0;\n      c2 = *(zGlob++);\n      if( c2=='^' ){\n        invert = 1;\n        c2 = *(zGlob++);\n      }\n      if( c2==']' ){\n        if( c==']' ) seen = 1;\n        c2 = *(zGlob++);\n      }\n      while( c2 && c2!=']' ){\n        if( c2=='-' && zGlob[0]!=']' && zGlob[0]!=0 && prior_c>0 ){\n          c2 = *(zGlob++);\n          if( c>=prior_c && c<=c2 ) seen = 1;\n          prior_c = 0;\n        }else{\n          if( c==c2 ){\n            seen = 1;\n          }\n          prior_c = c2;\n        }\n        c2 = *(zGlob++);\n      }\n      if( c2==0 || (seen ^ invert)==0 ) return 0;\n    }else if( c=='/' ){\n      if( z[0]!='/' && z[0]!='\\\\' ) return 0;\n      z++;\n    }else{\n      if( c!=(*(z++)) ) return 0;\n    }\n  }\n  return *z==0;\n}\n\n\n/* Find a quotaGroup given the filename.\n**\n** Return a pointer to the quotaGroup object. Return NULL if not found.\n*/\nstatic quotaGroup *quotaGroupFind(const char *zFilename){\n  quotaGroup *p;\n  for(p=gQuota.pGroup; p && quotaStrglob(p->zPattern, zFilename)==0;\n      p=p->pNext){}\n  return p;\n}\n\n/* Translate an sqlite3_file* that is really a quotaConn* into\n** the sqlite3_file* for the underlying original VFS.\n*/\nstatic sqlite3_file *quotaSubOpen(sqlite3_file *pConn){\n  quotaConn *p = (quotaConn*)pConn;\n  return (sqlite3_file*)&p[1];\n}\n\n/* Find a file in a quota group and return a pointer to that file.\n** Return NULL if the file is not in the group.\n*/\nstatic quotaFile *quotaFindFile(\n  quotaGroup *pGroup,     /* Group in which to look for the file */\n  const char *zName,      /* Full pathname of the file */\n  int createFlag          /* Try to create the file if not found */\n){\n  quotaFile *pFile = pGroup->pFiles;\n  while( pFile && strcmp(pFile->zFilename, zName)!=0 ){\n    pFile = pFile->pNext;\n  }\n  if( pFile==0 && createFlag ){\n    int nName = (int)(strlen(zName) & 0x3fffffff);\n    pFile = (quotaFile *)sqlite3_malloc( sizeof(*pFile) + nName + 1 );\n    if( pFile ){\n      memset(pFile, 0, sizeof(*pFile));\n      pFile->zFilename = (char*)&pFile[1];\n      memcpy(pFile->zFilename, zName, nName+1);\n      pFile->pNext = pGroup->pFiles;\n      if( pGroup->pFiles ) pGroup->pFiles->ppPrev = &pFile->pNext;\n      pFile->ppPrev = &pGroup->pFiles;\n      pGroup->pFiles = pFile;\n      pFile->pGroup = pGroup;\n    }\n  }\n  return pFile;\n}\n/*\n** Translate UTF8 to MBCS for use in fopen() calls.  Return a pointer to the\n** translated text..  Call quota_mbcs_free() to deallocate any memory\n** used to store the returned pointer when done.\n*/\nstatic char *quota_utf8_to_mbcs(const char *zUtf8){\n#ifdef _WIN32\n  size_t n;          /* Bytes in zUtf8 */\n  int nWide;         /* number of UTF-16 characters */\n  int nMbcs;         /* Bytes of MBCS */\n  LPWSTR zTmpWide;   /* The UTF16 text */\n  char *zMbcs;       /* The MBCS text */\n  int codepage;      /* Code page used by fopen() */\n\n  n = strlen(zUtf8);\n  nWide = MultiByteToWideChar(CP_UTF8, 0, zUtf8, -1, NULL, 0);\n  if( nWide==0 ) return 0;\n  zTmpWide = (LPWSTR)sqlite3_malloc( (nWide+1)*sizeof(zTmpWide[0]) );\n  if( zTmpWide==0 ) return 0;\n  MultiByteToWideChar(CP_UTF8, 0, zUtf8, -1, zTmpWide, nWide);\n  codepage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;\n  nMbcs = WideCharToMultiByte(codepage, 0, zTmpWide, nWide, 0, 0, 0, 0);\n  zMbcs = nMbcs ? (char*)sqlite3_malloc( nMbcs+1 ) : 0;\n  if( zMbcs ){\n    WideCharToMultiByte(codepage, 0, zTmpWide, nWide, zMbcs, nMbcs, 0, 0);\n  }\n  sqlite3_free(zTmpWide);\n  return zMbcs;\n#else\n  return (char*)zUtf8;  /* No-op on unix */\n#endif\n}\n\n/*\n** Deallocate any memory allocated by quota_utf8_to_mbcs().\n*/\nstatic void quota_mbcs_free(char *zOld){\n#ifdef _WIN32\n  sqlite3_free(zOld);\n#else\n  /* No-op on unix */\n#endif\n}\n\n/************************* VFS Method Wrappers *****************************/\n/*\n** This is the xOpen method used for the \"quota\" VFS.\n**\n** Most of the work is done by the underlying original VFS.  This method\n** simply links the new file into the appropriate quota group if it is a\n** file that needs to be tracked.\n*/\nstatic int quotaOpen(\n  sqlite3_vfs *pVfs,          /* The quota VFS */\n  const char *zName,          /* Name of file to be opened */\n  sqlite3_file *pConn,        /* Fill in this file descriptor */\n  int flags,                  /* Flags to control the opening */\n  int *pOutFlags              /* Flags showing results of opening */\n){\n  int rc;                                    /* Result code */\n  quotaConn *pQuotaOpen;                     /* The new quota file descriptor */\n  quotaFile *pFile;                          /* Corresponding quotaFile obj */\n  quotaGroup *pGroup;                        /* The group file belongs to */\n  sqlite3_file *pSubOpen;                    /* Real file descriptor */\n  sqlite3_vfs *pOrigVfs = gQuota.pOrigVfs;   /* Real VFS */\n\n  /* If the file is not a main database file or a WAL, then use the\n  ** normal xOpen method.\n  */\n  if( (flags & (SQLITE_OPEN_MAIN_DB|SQLITE_OPEN_WAL))==0 ){\n    return pOrigVfs->xOpen(pOrigVfs, zName, pConn, flags, pOutFlags);\n  }\n\n  /* If the name of the file does not match any quota group, then\n  ** use the normal xOpen method.\n  */\n  quotaEnter();\n  pGroup = quotaGroupFind(zName);\n  if( pGroup==0 ){\n    rc = pOrigVfs->xOpen(pOrigVfs, zName, pConn, flags, pOutFlags);\n  }else{\n    /* If we get to this point, it means the file needs to be quota tracked.\n    */\n    pQuotaOpen = (quotaConn*)pConn;\n    pSubOpen = quotaSubOpen(pConn);\n    rc = pOrigVfs->xOpen(pOrigVfs, zName, pSubOpen, flags, pOutFlags);\n    if( rc==SQLITE_OK ){\n      pFile = quotaFindFile(pGroup, zName, 1);\n      if( pFile==0 ){\n        quotaLeave();\n        pSubOpen->pMethods->xClose(pSubOpen);\n        return SQLITE_NOMEM;\n      }\n      pFile->deleteOnClose = (flags & SQLITE_OPEN_DELETEONCLOSE)!=0;\n      pFile->nRef++;\n      pQuotaOpen->pFile = pFile;\n      if( pSubOpen->pMethods->iVersion==1 ){\n        pQuotaOpen->base.pMethods = &gQuota.sIoMethodsV1;\n      }else{\n        pQuotaOpen->base.pMethods = &gQuota.sIoMethodsV2;\n      }\n    }\n  }\n  quotaLeave();\n  return rc;\n}\n\n/*\n** This is the xDelete method used for the \"quota\" VFS.\n**\n** If the file being deleted is part of the quota group, then reduce\n** the size of the quota group accordingly.  And remove the file from\n** the set of files in the quota group.\n*/\nstatic int quotaDelete(\n  sqlite3_vfs *pVfs,          /* The quota VFS */\n  const char *zName,          /* Name of file to be deleted */\n  int syncDir                 /* Do a directory sync after deleting */\n){\n  int rc;                                    /* Result code */\n  quotaFile *pFile;                          /* Files in the quota */\n  quotaGroup *pGroup;                        /* The group file belongs to */\n  sqlite3_vfs *pOrigVfs = gQuota.pOrigVfs;   /* Real VFS */\n\n  /* Do the actual file delete */\n  rc = pOrigVfs->xDelete(pOrigVfs, zName, syncDir);\n\n  /* If the file just deleted is a member of a quota group, then remove\n  ** it from that quota group.\n  */\n  if( rc==SQLITE_OK ){\n    quotaEnter();\n    pGroup = quotaGroupFind(zName);\n    if( pGroup ){\n      pFile = quotaFindFile(pGroup, zName, 0);\n      if( pFile ){\n        if( pFile->nRef ){\n          pFile->deleteOnClose = 1;\n        }else{\n          quotaRemoveFile(pFile);\n          quotaGroupDeref(pGroup);\n        }\n      }\n    }\n    quotaLeave();\n  }\n  return rc;\n}\n\n\n/************************ I/O Method Wrappers *******************************/\n\n/* xClose requests get passed through to the original VFS.  But we\n** also have to unlink the quotaConn from the quotaFile and quotaGroup.\n** The quotaFile and/or quotaGroup are freed if they are no longer in use.\n*/\nstatic int quotaClose(sqlite3_file *pConn){\n  quotaConn *p = (quotaConn*)pConn;\n  quotaFile *pFile = p->pFile;\n  sqlite3_file *pSubOpen = quotaSubOpen(pConn);\n  int rc;\n  rc = pSubOpen->pMethods->xClose(pSubOpen);\n  quotaEnter();\n  pFile->nRef--;\n  if( pFile->nRef==0 ){\n    quotaGroup *pGroup = pFile->pGroup;\n    if( pFile->deleteOnClose ){\n      gQuota.pOrigVfs->xDelete(gQuota.pOrigVfs, pFile->zFilename, 0);\n      quotaRemoveFile(pFile);\n    }\n    quotaGroupDeref(pGroup);\n  }\n  quotaLeave();\n  return rc;\n}\n\n/* Pass xRead requests directory thru to the original VFS without\n** further processing.\n*/\nstatic int quotaRead(\n  sqlite3_file *pConn,\n  void *pBuf,\n  int iAmt,\n  sqlite3_int64 iOfst\n){\n  sqlite3_file *pSubOpen = quotaSubOpen(pConn);\n  return pSubOpen->pMethods->xRead(pSubOpen, pBuf, iAmt, iOfst);\n}\n\n/* Check xWrite requests to see if they expand the file.  If they do,\n** the perform a quota check before passing them through to the\n** original VFS.\n*/\nstatic int quotaWrite(\n  sqlite3_file *pConn,\n  const void *pBuf,\n  int iAmt,\n  sqlite3_int64 iOfst\n){\n  quotaConn *p = (quotaConn*)pConn;\n  sqlite3_file *pSubOpen = quotaSubOpen(pConn);\n  sqlite3_int64 iEnd = iOfst+iAmt;\n  quotaGroup *pGroup;\n  quotaFile *pFile = p->pFile;\n  sqlite3_int64 szNew;\n\n  if( pFile->iSize<iEnd ){\n    pGroup = pFile->pGroup;\n    quotaEnter();\n    szNew = pGroup->iSize - pFile->iSize + iEnd;\n    if( szNew>pGroup->iLimit && pGroup->iLimit>0 ){\n      if( pGroup->xCallback ){\n        pGroup->xCallback(pFile->zFilename, &pGroup->iLimit, szNew,\n                          pGroup->pArg);\n      }\n      if( szNew>pGroup->iLimit && pGroup->iLimit>0 ){\n        quotaLeave();\n        return SQLITE_FULL;\n      }\n    }\n    pGroup->iSize = szNew;\n    pFile->iSize = iEnd;\n    quotaLeave();\n  }\n  return pSubOpen->pMethods->xWrite(pSubOpen, pBuf, iAmt, iOfst);\n}\n\n/* Pass xTruncate requests thru to the original VFS.  If the\n** success, update the file size.\n*/\nstatic int quotaTruncate(sqlite3_file *pConn, sqlite3_int64 size){\n  quotaConn *p = (quotaConn*)pConn;\n  sqlite3_file *pSubOpen = quotaSubOpen(pConn);\n  int rc = pSubOpen->pMethods->xTruncate(pSubOpen, size);\n  quotaFile *pFile = p->pFile;\n  quotaGroup *pGroup;\n  if( rc==SQLITE_OK ){\n    quotaEnter();\n    pGroup = pFile->pGroup;\n    pGroup->iSize -= pFile->iSize;\n    pFile->iSize = size;\n    pGroup->iSize += size;\n    quotaLeave();\n  }\n  return rc;\n}\n\n/* Pass xSync requests through to the original VFS without change\n*/\nstatic int quotaSync(sqlite3_file *pConn, int flags){\n  sqlite3_file *pSubOpen = quotaSubOpen(pConn);\n  return pSubOpen->pMethods->xSync(pSubOpen, flags);\n}\n\n/* Pass xFileSize requests through to the original VFS but then\n** update the quotaGroup with the new size before returning.\n*/\nstatic int quotaFileSize(sqlite3_file *pConn, sqlite3_int64 *pSize){\n  quotaConn *p = (quotaConn*)pConn;\n  sqlite3_file *pSubOpen = quotaSubOpen(pConn);\n  quotaFile *pFile = p->pFile;\n  quotaGroup *pGroup;\n  sqlite3_int64 sz;\n  int rc;\n\n  rc = pSubOpen->pMethods->xFileSize(pSubOpen, &sz);\n  if( rc==SQLITE_OK ){\n    quotaEnter();\n    pGroup = pFile->pGroup;\n    pGroup->iSize -= pFile->iSize;\n    pFile->iSize = sz;\n    pGroup->iSize += sz;\n    quotaLeave();\n    *pSize = sz;\n  }\n  return rc;\n}\n\n/* Pass xLock requests through to the original VFS unchanged.\n*/\nstatic int quotaLock(sqlite3_file *pConn, int lock){\n  sqlite3_file *pSubOpen = quotaSubOpen(pConn);\n  return pSubOpen->pMethods->xLock(pSubOpen, lock);\n}\n\n/* Pass xUnlock requests through to the original VFS unchanged.\n*/\nstatic int quotaUnlock(sqlite3_file *pConn, int lock){\n  sqlite3_file *pSubOpen = quotaSubOpen(pConn);\n  return pSubOpen->pMethods->xUnlock(pSubOpen, lock);\n}\n\n/* Pass xCheckReservedLock requests through to the original VFS unchanged.\n*/\nstatic int quotaCheckReservedLock(sqlite3_file *pConn, int *pResOut){\n  sqlite3_file *pSubOpen = quotaSubOpen(pConn);\n  return pSubOpen->pMethods->xCheckReservedLock(pSubOpen, pResOut);\n}\n\n/* Pass xFileControl requests through to the original VFS unchanged.\n*/\nstatic int quotaFileControl(sqlite3_file *pConn, int op, void *pArg){\n  sqlite3_file *pSubOpen = quotaSubOpen(pConn);\n  int rc = pSubOpen->pMethods->xFileControl(pSubOpen, op, pArg);\n#if defined(SQLITE_FCNTL_VFSNAME)\n  if( op==SQLITE_FCNTL_VFSNAME && rc==SQLITE_OK ){\n    *(char**)pArg = sqlite3_mprintf(\"quota/%z\", *(char**)pArg);\n  }\n#endif\n  return rc;\n}\n\n/* Pass xSectorSize requests through to the original VFS unchanged.\n*/\nstatic int quotaSectorSize(sqlite3_file *pConn){\n  sqlite3_file *pSubOpen = quotaSubOpen(pConn);\n  return pSubOpen->pMethods->xSectorSize(pSubOpen);\n}\n\n/* Pass xDeviceCharacteristics requests through to the original VFS unchanged.\n*/\nstatic int quotaDeviceCharacteristics(sqlite3_file *pConn){\n  sqlite3_file *pSubOpen = quotaSubOpen(pConn);\n  return pSubOpen->pMethods->xDeviceCharacteristics(pSubOpen);\n}\n\n/* Pass xShmMap requests through to the original VFS unchanged.\n*/\nstatic int quotaShmMap(\n  sqlite3_file *pConn,            /* Handle open on database file */\n  int iRegion,                    /* Region to retrieve */\n  int szRegion,                   /* Size of regions */\n  int bExtend,                    /* True to extend file if necessary */\n  void volatile **pp              /* OUT: Mapped memory */\n){\n  sqlite3_file *pSubOpen = quotaSubOpen(pConn);\n  return pSubOpen->pMethods->xShmMap(pSubOpen, iRegion, szRegion, bExtend, pp);\n}\n\n/* Pass xShmLock requests through to the original VFS unchanged.\n*/\nstatic int quotaShmLock(\n  sqlite3_file *pConn,       /* Database file holding the shared memory */\n  int ofst,                  /* First lock to acquire or release */\n  int n,                     /* Number of locks to acquire or release */\n  int flags                  /* What to do with the lock */\n){\n  sqlite3_file *pSubOpen = quotaSubOpen(pConn);\n  return pSubOpen->pMethods->xShmLock(pSubOpen, ofst, n, flags);\n}\n\n/* Pass xShmBarrier requests through to the original VFS unchanged.\n*/\nstatic void quotaShmBarrier(sqlite3_file *pConn){\n  sqlite3_file *pSubOpen = quotaSubOpen(pConn);\n  pSubOpen->pMethods->xShmBarrier(pSubOpen);\n}\n\n/* Pass xShmUnmap requests through to the original VFS unchanged.\n*/\nstatic int quotaShmUnmap(sqlite3_file *pConn, int deleteFlag){\n  sqlite3_file *pSubOpen = quotaSubOpen(pConn);\n  return pSubOpen->pMethods->xShmUnmap(pSubOpen, deleteFlag);\n}\n\n/************************** Public Interfaces *****************************/\n/*\n** Initialize the quota VFS shim.  Use the VFS named zOrigVfsName\n** as the VFS that does the actual work.  Use the default if\n** zOrigVfsName==NULL.\n**\n** The quota VFS shim is named \"quota\".  It will become the default\n** VFS if makeDefault is non-zero.\n**\n** THIS ROUTINE IS NOT THREADSAFE.  Call this routine exactly once\n** during start-up.\n*/\nint sqlite3_quota_initialize(const char *zOrigVfsName, int makeDefault){\n  sqlite3_vfs *pOrigVfs;\n  if( gQuota.isInitialized ) return SQLITE_MISUSE;\n  pOrigVfs = sqlite3_vfs_find(zOrigVfsName);\n  if( pOrigVfs==0 ) return SQLITE_ERROR;\n  assert( pOrigVfs!=&gQuota.sThisVfs );\n  gQuota.pMutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);\n  if( !gQuota.pMutex ){\n    return SQLITE_NOMEM;\n  }\n  gQuota.isInitialized = 1;\n  gQuota.pOrigVfs = pOrigVfs;\n  gQuota.sThisVfs = *pOrigVfs;\n  gQuota.sThisVfs.xOpen = quotaOpen;\n  gQuota.sThisVfs.xDelete = quotaDelete;\n  gQuota.sThisVfs.szOsFile += sizeof(quotaConn);\n  gQuota.sThisVfs.zName = \"quota\";\n  gQuota.sIoMethodsV1.iVersion = 1;\n  gQuota.sIoMethodsV1.xClose = quotaClose;\n  gQuota.sIoMethodsV1.xRead = quotaRead;\n  gQuota.sIoMethodsV1.xWrite = quotaWrite;\n  gQuota.sIoMethodsV1.xTruncate = quotaTruncate;\n  gQuota.sIoMethodsV1.xSync = quotaSync;\n  gQuota.sIoMethodsV1.xFileSize = quotaFileSize;\n  gQuota.sIoMethodsV1.xLock = quotaLock;\n  gQuota.sIoMethodsV1.xUnlock = quotaUnlock;\n  gQuota.sIoMethodsV1.xCheckReservedLock = quotaCheckReservedLock;\n  gQuota.sIoMethodsV1.xFileControl = quotaFileControl;\n  gQuota.sIoMethodsV1.xSectorSize = quotaSectorSize;\n  gQuota.sIoMethodsV1.xDeviceCharacteristics = quotaDeviceCharacteristics;\n  gQuota.sIoMethodsV2 = gQuota.sIoMethodsV1;\n  gQuota.sIoMethodsV2.iVersion = 2;\n  gQuota.sIoMethodsV2.xShmMap = quotaShmMap;\n  gQuota.sIoMethodsV2.xShmLock = quotaShmLock;\n  gQuota.sIoMethodsV2.xShmBarrier = quotaShmBarrier;\n  gQuota.sIoMethodsV2.xShmUnmap = quotaShmUnmap;\n  sqlite3_vfs_register(&gQuota.sThisVfs, makeDefault);\n  return SQLITE_OK;\n}\n\n/*\n** Shutdown the quota system.\n**\n** All SQLite database connections must be closed before calling this\n** routine.\n**\n** THIS ROUTINE IS NOT THREADSAFE.  Call this routine exactly once while\n** shutting down in order to free all remaining quota groups.\n*/\nint sqlite3_quota_shutdown(void){\n  quotaGroup *pGroup;\n  if( gQuota.isInitialized==0 ) return SQLITE_MISUSE;\n  for(pGroup=gQuota.pGroup; pGroup; pGroup=pGroup->pNext){\n    if( quotaGroupOpenFileCount(pGroup)>0 ) return SQLITE_MISUSE;\n  }\n  while( gQuota.pGroup ){\n    pGroup = gQuota.pGroup;\n    gQuota.pGroup = pGroup->pNext;\n    pGroup->iLimit = 0;\n    assert( quotaGroupOpenFileCount(pGroup)==0 );\n    quotaGroupDeref(pGroup);\n  }\n  gQuota.isInitialized = 0;\n  sqlite3_mutex_free(gQuota.pMutex);\n  sqlite3_vfs_unregister(&gQuota.sThisVfs);\n  memset(&gQuota, 0, sizeof(gQuota));\n  return SQLITE_OK;\n}\n\n/*\n** Create or destroy a quota group.\n**\n** The quota group is defined by the zPattern.  When calling this routine\n** with a zPattern for a quota group that already exists, this routine\n** merely updates the iLimit, xCallback, and pArg values for that quota\n** group.  If zPattern is new, then a new quota group is created.\n**\n** If the iLimit for a quota group is set to zero, then the quota group\n** is disabled and will be deleted when the last database connection using\n** the quota group is closed.\n**\n** Calling this routine on a zPattern that does not exist and with a\n** zero iLimit is a no-op.\n**\n** A quota group must exist with a non-zero iLimit prior to opening\n** database connections if those connections are to participate in the\n** quota group.  Creating a quota group does not affect database connections\n** that are already open.\n*/\nint sqlite3_quota_set(\n  const char *zPattern,           /* The filename pattern */\n  sqlite3_int64 iLimit,           /* New quota to set for this quota group */\n  void (*xCallback)(              /* Callback invoked when going over quota */\n     const char *zFilename,         /* Name of file whose size increases */\n     sqlite3_int64 *piLimit,        /* IN/OUT: The current limit */\n     sqlite3_int64 iSize,           /* Total size of all files in the group */\n     void *pArg                     /* Client data */\n  ),\n  void *pArg,                     /* client data passed thru to callback */\n  void (*xDestroy)(void*)         /* Optional destructor for pArg */\n){\n  quotaGroup *pGroup;\n  quotaEnter();\n  pGroup = gQuota.pGroup;\n  while( pGroup && strcmp(pGroup->zPattern, zPattern)!=0 ){\n    pGroup = pGroup->pNext;\n  }\n  if( pGroup==0 ){\n    int nPattern = (int)(strlen(zPattern) & 0x3fffffff);\n    if( iLimit<=0 ){\n      quotaLeave();\n      return SQLITE_OK;\n    }\n    pGroup = (quotaGroup *)sqlite3_malloc( sizeof(*pGroup) + nPattern + 1 );\n    if( pGroup==0 ){\n      quotaLeave();\n      return SQLITE_NOMEM;\n    }\n    memset(pGroup, 0, sizeof(*pGroup));\n    pGroup->zPattern = (char*)&pGroup[1];\n    memcpy((char *)pGroup->zPattern, zPattern, nPattern+1);\n    if( gQuota.pGroup ) gQuota.pGroup->ppPrev = &pGroup->pNext;\n    pGroup->pNext = gQuota.pGroup;\n    pGroup->ppPrev = &gQuota.pGroup;\n    gQuota.pGroup = pGroup;\n  }\n  pGroup->iLimit = iLimit;\n  pGroup->xCallback = xCallback;\n  if( pGroup->xDestroy && pGroup->pArg!=pArg ){\n    pGroup->xDestroy(pGroup->pArg);\n  }\n  pGroup->pArg = pArg;\n  pGroup->xDestroy = xDestroy;\n  quotaGroupDeref(pGroup);\n  quotaLeave();\n  return SQLITE_OK;\n}\n\n/*\n** Bring the named file under quota management.  Or if it is already under\n** management, update its size.\n*/\nint sqlite3_quota_file(const char *zFilename){\n  char *zFull = 0;\n  sqlite3_file *fd;\n  int rc;\n  int outFlags = 0;\n  sqlite3_int64 iSize;\n  int nAlloc = gQuota.sThisVfs.szOsFile + gQuota.sThisVfs.mxPathname+2;\n\n  /* Allocate space for a file-handle and the full path for file zFilename */\n  fd = (sqlite3_file *)sqlite3_malloc(nAlloc);\n  if( fd==0 ){\n    rc = SQLITE_NOMEM;\n  }else{\n    zFull = &((char *)fd)[gQuota.sThisVfs.szOsFile];\n    rc = gQuota.pOrigVfs->xFullPathname(gQuota.pOrigVfs, zFilename,\n        gQuota.sThisVfs.mxPathname+1, zFull);\n  }\n\n  if( rc==SQLITE_OK ){\n    zFull[strlen(zFull)+1] = '\\0';\n    rc = quotaOpen(&gQuota.sThisVfs, zFull, fd,\n                   SQLITE_OPEN_READONLY | SQLITE_OPEN_MAIN_DB, &outFlags);\n    if( rc==SQLITE_OK ){\n      fd->pMethods->xFileSize(fd, &iSize);\n      fd->pMethods->xClose(fd);\n    }else if( rc==SQLITE_CANTOPEN ){\n      quotaGroup *pGroup;\n      quotaFile *pFile;\n      quotaEnter();\n      pGroup = quotaGroupFind(zFull);\n      if( pGroup ){\n        pFile = quotaFindFile(pGroup, zFull, 0);\n        if( pFile ) quotaRemoveFile(pFile);\n      }\n      quotaLeave();\n    }\n  }\n\n  sqlite3_free(fd);\n  return rc;\n}\n\n/*\n** Open a potentially quotaed file for I/O.\n*/\nquota_FILE *sqlite3_quota_fopen(const char *zFilename, const char *zMode){\n  quota_FILE *p = 0;\n  char *zFull = 0;\n  char *zFullTranslated = 0;\n  int rc;\n  quotaGroup *pGroup;\n  quotaFile *pFile;\n\n  zFull = (char*)sqlite3_malloc(gQuota.sThisVfs.mxPathname + 1);\n  if( zFull==0 ) return 0;\n  rc = gQuota.pOrigVfs->xFullPathname(gQuota.pOrigVfs, zFilename,\n                                      gQuota.sThisVfs.mxPathname+1, zFull);\n  if( rc ) goto quota_fopen_error;\n  p = (quota_FILE*)sqlite3_malloc(sizeof(*p));\n  if( p==0 ) goto quota_fopen_error;\n  memset(p, 0, sizeof(*p));\n  zFullTranslated = quota_utf8_to_mbcs(zFull);\n  if( zFullTranslated==0 ) goto quota_fopen_error;\n  p->f = fopen(zFullTranslated, zMode);\n  if( p->f==0 ) goto quota_fopen_error;\n  quotaEnter();\n  pGroup = quotaGroupFind(zFull);\n  if( pGroup ){\n    pFile = quotaFindFile(pGroup, zFull, 1);\n    if( pFile==0 ){\n      quotaLeave();\n      goto quota_fopen_error;\n    }\n    pFile->nRef++;\n    p->pFile = pFile;\n  }\n  quotaLeave();\n  sqlite3_free(zFull);\n#ifdef _WIN32\n  p->zMbcsName = zFullTranslated;\n#endif\n  return p;\n\nquota_fopen_error:\n  quota_mbcs_free(zFullTranslated);\n  sqlite3_free(zFull);\n  if( p && p->f ) fclose(p->f);\n  sqlite3_free(p);\n  return 0;\n}\n\n/*\n** Read content from a quota_FILE\n*/\nsize_t sqlite3_quota_fread(\n  void *pBuf,            /* Store the content here */\n  size_t size,           /* Size of each element */\n  size_t nmemb,          /* Number of elements to read */\n  quota_FILE *p          /* Read from this quota_FILE object */\n){\n  return fread(pBuf, size, nmemb, p->f);\n}\n\n/*\n** Write content into a quota_FILE.  Invoke the quota callback and block\n** the write if we exceed quota.\n*/\nsize_t sqlite3_quota_fwrite(\n  const void *pBuf,      /* Take content to write from here */\n  size_t size,           /* Size of each element */\n  size_t nmemb,          /* Number of elements */\n  quota_FILE *p          /* Write to this quota_FILE object */\n){\n  sqlite3_int64 iOfst;\n  sqlite3_int64 iEnd;\n  sqlite3_int64 szNew;\n  quotaFile *pFile;\n  size_t rc;\n\n  iOfst = ftell(p->f);\n  iEnd = iOfst + size*nmemb;\n  pFile = p->pFile;\n  if( pFile && pFile->iSize<iEnd ){\n    quotaGroup *pGroup = pFile->pGroup;\n    quotaEnter();\n    szNew = pGroup->iSize - pFile->iSize + iEnd;\n    if( szNew>pGroup->iLimit && pGroup->iLimit>0 ){\n      if( pGroup->xCallback ){\n        pGroup->xCallback(pFile->zFilename, &pGroup->iLimit, szNew,\n                          pGroup->pArg);\n      }\n      if( szNew>pGroup->iLimit && pGroup->iLimit>0 ){\n        iEnd = pGroup->iLimit - pGroup->iSize + pFile->iSize;\n        nmemb = (size_t)((iEnd - iOfst)/size);\n        iEnd = iOfst + size*nmemb;\n        szNew = pGroup->iSize - pFile->iSize + iEnd;\n      }\n    }\n    pGroup->iSize = szNew;\n    pFile->iSize = iEnd;\n    quotaLeave();\n  }else{\n    pFile = 0;\n  }\n  rc = fwrite(pBuf, size, nmemb, p->f);\n\n  /* If the write was incomplete, adjust the file size and group size\n  ** downward */\n  if( rc<nmemb && pFile ){\n    size_t nWritten = rc;\n    sqlite3_int64 iNewEnd = iOfst + size*nWritten;\n    if( iNewEnd<iEnd ) iNewEnd = iEnd;\n    quotaEnter();\n    pFile->pGroup->iSize += iNewEnd - pFile->iSize;\n    pFile->iSize = iNewEnd;\n    quotaLeave();\n  }\n  return rc;\n}\n\n/*\n** Close an open quota_FILE stream.\n*/\nint sqlite3_quota_fclose(quota_FILE *p){\n  int rc;\n  quotaFile *pFile;\n  rc = fclose(p->f);\n  pFile = p->pFile;\n  if( pFile ){\n    quotaEnter();\n    pFile->nRef--;\n    if( pFile->nRef==0 ){\n      quotaGroup *pGroup = pFile->pGroup;\n      if( pFile->deleteOnClose ){\n        gQuota.pOrigVfs->xDelete(gQuota.pOrigVfs, pFile->zFilename, 0);\n        quotaRemoveFile(pFile);\n      }\n      quotaGroupDeref(pGroup);\n    }\n    quotaLeave();\n  }\n#ifdef _WIN32\n  quota_mbcs_free(p->zMbcsName);\n#endif\n  sqlite3_free(p);\n  return rc;\n}\n\n/*\n** Flush memory buffers for a quota_FILE to disk.\n*/\nint sqlite3_quota_fflush(quota_FILE *p, int doFsync){\n  int rc;\n  rc = fflush(p->f);\n  if( rc==0 && doFsync ){\n#ifdef _WIN32\n    rc = _commit(_fileno(p->f));\n#else\n    rc = fsync(fileno(p->f));\n#endif\n  }\n  return rc!=0;\n}\n\n/*\n** Seek on a quota_FILE stream.\n*/\nint sqlite3_quota_fseek(quota_FILE *p, long offset, int whence){\n  return fseek(p->f, offset, whence);\n}\n\n/*\n** rewind a quota_FILE stream.\n*/\nvoid sqlite3_quota_rewind(quota_FILE *p){\n  rewind(p->f);\n}\n\n/*\n** Tell the current location of a quota_FILE stream.\n*/\nlong sqlite3_quota_ftell(quota_FILE *p){\n  return ftell(p->f);\n}\n\n/*\n** Test the error indicator for the given file.\n*/\nint sqlite3_quota_ferror(quota_FILE *p){\n  return ferror(p->f);\n}\n\n/*\n** Truncate a file to szNew bytes.\n*/\nint sqlite3_quota_ftruncate(quota_FILE *p, sqlite3_int64 szNew){\n  quotaFile *pFile = p->pFile;\n  int rc;\n  if( (pFile = p->pFile)!=0 && pFile->iSize<szNew ){\n    quotaGroup *pGroup;\n    if( pFile->iSize<szNew ){\n      /* This routine cannot be used to extend a file that is under\n      ** quota management.  Only true truncation is allowed. */\n      return -1;\n    }\n    pGroup = pFile->pGroup;\n    quotaEnter();\n    pGroup->iSize += szNew - pFile->iSize;\n    quotaLeave();\n  }\n#ifdef _WIN32\n#  if defined(__MSVCRT__) && defined(SQLITE_TEST)\n     /* _chsize_s() is missing from MingW (as of 2012-11-06).  Use\n     ** _chsize() as a work-around for testing purposes. */\n     rc = _chsize(_fileno(p->f), (long)szNew);\n#  else\n     rc = _chsize_s(_fileno(p->f), szNew);\n#  endif\n#else\n  rc = ftruncate(fileno(p->f), szNew);\n#endif\n  if( pFile && rc==0 ){\n    quotaGroup *pGroup = pFile->pGroup;\n    quotaEnter();\n    pGroup->iSize += szNew - pFile->iSize;\n    pFile->iSize = szNew;\n    quotaLeave();\n  }\n  return rc;\n}\n\n/*\n** Determine the time that the given file was last modified, in\n** seconds size 1970.  Write the result into *pTime.  Return 0 on\n** success and non-zero on any kind of error.\n*/\nint sqlite3_quota_file_mtime(quota_FILE *p, time_t *pTime){\n  int rc;\n#ifdef _WIN32\n  struct _stati64 buf;\n  rc = _stati64(p->zMbcsName, &buf);\n#else\n  struct stat buf;\n  rc = fstat(fileno(p->f), &buf);\n#endif\n  if( rc==0 ) *pTime = buf.st_mtime;\n  return rc;\n}\n\n/*\n** Return the true size of the file, as reported by the operating\n** system.\n*/\nsqlite3_int64 sqlite3_quota_file_truesize(quota_FILE *p){\n  int rc;\n#ifdef _WIN32\n  struct _stati64 buf;\n  rc = _stati64(p->zMbcsName, &buf);\n#else\n  struct stat buf;\n  rc = fstat(fileno(p->f), &buf);\n#endif\n  return rc==0 ? buf.st_size : -1;\n}\n\n/*\n** Return the size of the file, as it is known to the quota subsystem.\n*/\nsqlite3_int64 sqlite3_quota_file_size(quota_FILE *p){\n  return p->pFile ? p->pFile->iSize : -1;\n}\n\n/*\n** Determine the amount of data in bytes available for reading\n** in the given file.\n*/\nlong sqlite3_quota_file_available(quota_FILE *p){\n  FILE* f = p->f;\n  long pos1, pos2;\n  int rc;\n  pos1 = ftell(f);\n  if ( pos1 < 0 ) return -1;\n  rc = fseek(f, 0, SEEK_END);\n  if ( rc != 0 ) return -1;\n  pos2 = ftell(f);\n  if ( pos2 < 0 ) return -1;\n  rc = fseek(f, pos1, SEEK_SET);\n  if ( rc != 0 ) return -1;\n  return pos2 - pos1;\n}\n\n/*\n** Remove a managed file.  Update quotas accordingly.\n*/\nint sqlite3_quota_remove(const char *zFilename){\n  char *zFull;            /* Full pathname for zFilename */\n  size_t nFull;           /* Number of bytes in zFilename */\n  int rc;                 /* Result code */\n  quotaGroup *pGroup;     /* Group containing zFilename */\n  quotaFile *pFile;       /* A file in the group */\n  quotaFile *pNextFile;   /* next file in the group */\n  int diff;               /* Difference between filenames */\n  char c;                 /* First character past end of pattern */\n\n  zFull = (char*)sqlite3_malloc(gQuota.sThisVfs.mxPathname + 1);\n  if( zFull==0 ) return SQLITE_NOMEM;\n  rc = gQuota.pOrigVfs->xFullPathname(gQuota.pOrigVfs, zFilename,\n                                      gQuota.sThisVfs.mxPathname+1, zFull);\n  if( rc ){\n    sqlite3_free(zFull);\n    return rc;\n  }\n\n  /* Figure out the length of the full pathname.  If the name ends with\n  ** / (or \\ on windows) then remove the trailing /.\n  */\n  nFull = strlen(zFull);\n  if( nFull>0 && (zFull[nFull-1]=='/' || zFull[nFull-1]=='\\\\') ){\n    nFull--;\n    zFull[nFull] = 0;\n  }\n\n  quotaEnter();\n  pGroup = quotaGroupFind(zFull);\n  if( pGroup ){\n    for(pFile=pGroup->pFiles; pFile && rc==SQLITE_OK; pFile=pNextFile){\n      pNextFile = pFile->pNext;\n      diff = strncmp(zFull, pFile->zFilename, nFull);\n      if( diff==0 && ((c = pFile->zFilename[nFull])==0 || c=='/' || c=='\\\\') ){\n        if( pFile->nRef ){\n          pFile->deleteOnClose = 1;\n        }else{\n          rc = gQuota.pOrigVfs->xDelete(gQuota.pOrigVfs, pFile->zFilename, 0);\n          quotaRemoveFile(pFile);\n          quotaGroupDeref(pGroup);\n        }\n      }\n    }\n  }\n  quotaLeave();\n  sqlite3_free(zFull);\n  return rc;\n}\n\n/***************************** Test Code ***********************************/\n#ifdef SQLITE_TEST\n#include \"tclsqlite.h\"\n\n/*\n** Argument passed to a TCL quota-over-limit callback.\n*/\ntypedef struct TclQuotaCallback TclQuotaCallback;\nstruct TclQuotaCallback {\n  Tcl_Interp *interp;    /* Interpreter in which to run the script */\n  Tcl_Obj *pScript;      /* Script to be run */\n};\n\nextern const char *sqlite3ErrName(int);\n\n\n/*\n** This is the callback from a quota-over-limit.\n*/\nstatic void tclQuotaCallback(\n  const char *zFilename,          /* Name of file whose size increases */\n  sqlite3_int64 *piLimit,         /* IN/OUT: The current limit */\n  sqlite3_int64 iSize,            /* Total size of all files in the group */\n  void *pArg                      /* Client data */\n){\n  TclQuotaCallback *p;            /* Callback script object */\n  Tcl_Obj *pEval;                 /* Script to evaluate */\n  Tcl_Obj *pVarname;              /* Name of variable to pass as 2nd arg */\n  unsigned int rnd;               /* Random part of pVarname */\n  int rc;                         /* Tcl error code */\n\n  p = (TclQuotaCallback *)pArg;\n  if( p==0 ) return;\n\n  pVarname = Tcl_NewStringObj(\"::piLimit_\", -1);\n  Tcl_IncrRefCount(pVarname);\n  sqlite3_randomness(sizeof(rnd), (void *)&rnd);\n  Tcl_AppendObjToObj(pVarname, Tcl_NewIntObj((int)(rnd&0x7FFFFFFF)));\n  Tcl_ObjSetVar2(p->interp, pVarname, 0, Tcl_NewWideIntObj(*piLimit), 0);\n\n  pEval = Tcl_DuplicateObj(p->pScript);\n  Tcl_IncrRefCount(pEval);\n  Tcl_ListObjAppendElement(0, pEval, Tcl_NewStringObj(zFilename, -1));\n  Tcl_ListObjAppendElement(0, pEval, pVarname);\n  Tcl_ListObjAppendElement(0, pEval, Tcl_NewWideIntObj(iSize));\n  rc = Tcl_EvalObjEx(p->interp, pEval, TCL_EVAL_GLOBAL);\n\n  if( rc==TCL_OK ){\n    Tcl_WideInt x;\n    Tcl_Obj *pLimit = Tcl_ObjGetVar2(p->interp, pVarname, 0, 0);\n    rc = Tcl_GetWideIntFromObj(p->interp, pLimit, &x);\n    *piLimit = x;\n    Tcl_UnsetVar(p->interp, Tcl_GetString(pVarname), 0);\n  }\n\n  Tcl_DecrRefCount(pEval);\n  Tcl_DecrRefCount(pVarname);\n  if( rc!=TCL_OK ) Tcl_BackgroundError(p->interp);\n}\n\n/*\n** Destructor for a TCL quota-over-limit callback.\n*/\nstatic void tclCallbackDestructor(void *pObj){\n  TclQuotaCallback *p = (TclQuotaCallback*)pObj;\n  if( p ){\n    Tcl_DecrRefCount(p->pScript);\n    sqlite3_free((char *)p);\n  }\n}\n\n/*\n** tclcmd: sqlite3_quota_initialize NAME MAKEDEFAULT\n*/\nstatic int SQLITE_TCLAPI test_quota_initialize(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  const char *zName;              /* Name of new quota VFS */\n  int makeDefault;                /* True to make the new VFS the default */\n  int rc;                         /* Value returned by quota_initialize() */\n\n  /* Process arguments */\n  if( objc!=3 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"NAME MAKEDEFAULT\");\n    return TCL_ERROR;\n  }\n  zName = Tcl_GetString(objv[1]);\n  if( Tcl_GetBooleanFromObj(interp, objv[2], &makeDefault) ) return TCL_ERROR;\n  if( zName[0]=='\\0' ) zName = 0;\n\n  /* Call sqlite3_quota_initialize() */\n  rc = sqlite3_quota_initialize(zName, makeDefault);\n  Tcl_SetResult(interp, (char *)sqlite3ErrName(rc), TCL_STATIC);\n\n  return TCL_OK;\n}\n\n/*\n** tclcmd: sqlite3_quota_shutdown\n*/\nstatic int SQLITE_TCLAPI test_quota_shutdown(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  int rc;                         /* Value returned by quota_shutdown() */\n\n  if( objc!=1 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"\");\n    return TCL_ERROR;\n  }\n\n  /* Call sqlite3_quota_shutdown() */\n  rc = sqlite3_quota_shutdown();\n  Tcl_SetResult(interp, (char *)sqlite3ErrName(rc), TCL_STATIC);\n\n  return TCL_OK;\n}\n\n/*\n** tclcmd: sqlite3_quota_set PATTERN LIMIT SCRIPT\n*/\nstatic int SQLITE_TCLAPI test_quota_set(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  const char *zPattern;           /* File pattern to configure */\n  Tcl_WideInt iLimit;             /* Initial quota in bytes */\n  Tcl_Obj *pScript;               /* Tcl script to invoke to increase quota */\n  int rc;                         /* Value returned by quota_set() */\n  TclQuotaCallback *p;            /* Callback object */\n  Tcl_Size nScript;               /* Length of callback script */\n  void (*xDestroy)(void*);        /* Optional destructor for pArg */\n  void (*xCallback)(const char *, sqlite3_int64 *, sqlite3_int64, void *);\n\n  /* Process arguments */\n  if( objc!=4 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"PATTERN LIMIT SCRIPT\");\n    return TCL_ERROR;\n  }\n  zPattern = Tcl_GetString(objv[1]);\n  if( Tcl_GetWideIntFromObj(interp, objv[2], &iLimit) ) return TCL_ERROR;\n  pScript = objv[3];\n  Tcl_GetStringFromObj(pScript, &nScript);\n\n  if( nScript>0 ){\n    /* Allocate a TclQuotaCallback object */\n    p = (TclQuotaCallback *)sqlite3_malloc(sizeof(TclQuotaCallback));\n    if( !p ){\n      Tcl_SetResult(interp, (char *)\"SQLITE_NOMEM\", TCL_STATIC);\n      return TCL_OK;\n    }\n    memset(p, 0, sizeof(TclQuotaCallback));\n    p->interp = interp;\n    Tcl_IncrRefCount(pScript);\n    p->pScript = pScript;\n    xDestroy = tclCallbackDestructor;\n    xCallback = tclQuotaCallback;\n  }else{\n    p = 0;\n    xDestroy = 0;\n    xCallback = 0;\n  }\n\n  /* Invoke sqlite3_quota_set() */\n  rc = sqlite3_quota_set(zPattern, iLimit, xCallback, (void*)p, xDestroy);\n\n  Tcl_SetResult(interp, (char *)sqlite3ErrName(rc), TCL_STATIC);\n  return TCL_OK;\n}\n\n/*\n** tclcmd: sqlite3_quota_file FILENAME\n*/\nstatic int SQLITE_TCLAPI test_quota_file(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  const char *zFilename;          /* File pattern to configure */\n  int rc;                         /* Value returned by quota_file() */\n\n  /* Process arguments */\n  if( objc!=2 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"FILENAME\");\n    return TCL_ERROR;\n  }\n  zFilename = Tcl_GetString(objv[1]);\n\n  /* Invoke sqlite3_quota_file() */\n  rc = sqlite3_quota_file(zFilename);\n\n  Tcl_SetResult(interp, (char *)sqlite3ErrName(rc), TCL_STATIC);\n  return TCL_OK;\n}\n\n/*\n** tclcmd:  sqlite3_quota_dump\n*/\nstatic int SQLITE_TCLAPI test_quota_dump(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  Tcl_Obj *pResult;\n  Tcl_Obj *pGroupTerm;\n  Tcl_Obj *pFileTerm;\n  quotaGroup *pGroup;\n  quotaFile *pFile;\n\n  pResult = Tcl_NewObj();\n  quotaEnter();\n  for(pGroup=gQuota.pGroup; pGroup; pGroup=pGroup->pNext){\n    pGroupTerm = Tcl_NewObj();\n    Tcl_ListObjAppendElement(interp, pGroupTerm,\n          Tcl_NewStringObj(pGroup->zPattern, -1));\n    Tcl_ListObjAppendElement(interp, pGroupTerm,\n          Tcl_NewWideIntObj(pGroup->iLimit));\n    Tcl_ListObjAppendElement(interp, pGroupTerm,\n          Tcl_NewWideIntObj(pGroup->iSize));\n    for(pFile=pGroup->pFiles; pFile; pFile=pFile->pNext){\n      int i;\n      char zTemp[1000];\n      pFileTerm = Tcl_NewObj();\n      sqlite3_snprintf(sizeof(zTemp), zTemp, \"%s\", pFile->zFilename);\n      for(i=0; zTemp[i]; i++){ if( zTemp[i]=='\\\\' ) zTemp[i] = '/'; }\n      Tcl_ListObjAppendElement(interp, pFileTerm,\n            Tcl_NewStringObj(zTemp, -1));\n      Tcl_ListObjAppendElement(interp, pFileTerm,\n            Tcl_NewWideIntObj(pFile->iSize));\n      Tcl_ListObjAppendElement(interp, pFileTerm,\n            Tcl_NewWideIntObj(pFile->nRef));\n      Tcl_ListObjAppendElement(interp, pFileTerm,\n            Tcl_NewWideIntObj(pFile->deleteOnClose));\n      Tcl_ListObjAppendElement(interp, pGroupTerm, pFileTerm);\n    }\n    Tcl_ListObjAppendElement(interp, pResult, pGroupTerm);\n  }\n  quotaLeave();\n  Tcl_SetObjResult(interp, pResult);\n  return TCL_OK;\n}\n\n/*\n** tclcmd: sqlite3_quota_fopen FILENAME MODE\n*/\nstatic int SQLITE_TCLAPI test_quota_fopen(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  const char *zFilename;          /* File pattern to configure */\n  const char *zMode;              /* Mode string */\n  quota_FILE *p;                  /* Open string object */\n  char zReturn[50];               /* Name of pointer to return */\n\n  /* Process arguments */\n  if( objc!=3 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"FILENAME MODE\");\n    return TCL_ERROR;\n  }\n  zFilename = Tcl_GetString(objv[1]);\n  zMode = Tcl_GetString(objv[2]);\n  p = sqlite3_quota_fopen(zFilename, zMode);\n  sqlite3_snprintf(sizeof(zReturn), zReturn, \"%p\", p);\n  Tcl_SetResult(interp, zReturn, TCL_VOLATILE);\n  return TCL_OK;\n}\n\n/* Defined in test1.c */\nextern void *sqlite3TestTextToPtr(const char*);\n\n/*\n** tclcmd: sqlite3_quota_fread HANDLE SIZE NELEM\n*/\nstatic int SQLITE_TCLAPI test_quota_fread(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  quota_FILE *p;\n  char *zBuf;\n  int sz;\n  int nElem;\n  size_t got;\n\n  if( objc!=4 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"HANDLE SIZE NELEM\");\n    return TCL_ERROR;\n  }\n  p = sqlite3TestTextToPtr(Tcl_GetString(objv[1]));\n  if( Tcl_GetIntFromObj(interp, objv[2], &sz) ) return TCL_ERROR;\n  if( Tcl_GetIntFromObj(interp, objv[3], &nElem) ) return TCL_ERROR;\n  zBuf = (char*)sqlite3_malloc( sz*nElem + 1 );\n  if( zBuf==0 ){\n    Tcl_SetResult(interp, \"out of memory\", TCL_STATIC);\n    return TCL_ERROR;\n  }\n  got = sqlite3_quota_fread(zBuf, sz, nElem, p);\n  zBuf[got*sz] = 0;\n  Tcl_SetResult(interp, zBuf, TCL_VOLATILE);\n  sqlite3_free(zBuf);\n  return TCL_OK;\n}\n\n/*\n** tclcmd: sqlite3_quota_fwrite HANDLE SIZE NELEM CONTENT\n*/\nstatic int SQLITE_TCLAPI test_quota_fwrite(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  quota_FILE *p;\n  char *zBuf;\n  int sz;\n  int nElem;\n  size_t got;\n\n  if( objc!=5 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"HANDLE SIZE NELEM CONTENT\");\n    return TCL_ERROR;\n  }\n  p = sqlite3TestTextToPtr(Tcl_GetString(objv[1]));\n  if( Tcl_GetIntFromObj(interp, objv[2], &sz) ) return TCL_ERROR;\n  if( Tcl_GetIntFromObj(interp, objv[3], &nElem) ) return TCL_ERROR;\n  zBuf = Tcl_GetString(objv[4]);\n  got = sqlite3_quota_fwrite(zBuf, sz, nElem, p);\n  Tcl_SetObjResult(interp, Tcl_NewWideIntObj(got));\n  return TCL_OK;\n}\n\n/*\n** tclcmd: sqlite3_quota_fclose HANDLE\n*/\nstatic int SQLITE_TCLAPI test_quota_fclose(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  quota_FILE *p;\n  int rc;\n\n  if( objc!=2 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"HANDLE\");\n    return TCL_ERROR;\n  }\n  p = sqlite3TestTextToPtr(Tcl_GetString(objv[1]));\n  rc = sqlite3_quota_fclose(p);\n  Tcl_SetObjResult(interp, Tcl_NewIntObj(rc));\n  return TCL_OK;\n}\n\n/*\n** tclcmd: sqlite3_quota_fflush HANDLE ?HARDSYNC?\n*/\nstatic int SQLITE_TCLAPI test_quota_fflush(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  quota_FILE *p;\n  int rc;\n  int doSync = 0;\n\n  if( objc!=2 && objc!=3 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"HANDLE ?HARDSYNC?\");\n    return TCL_ERROR;\n  }\n  p = sqlite3TestTextToPtr(Tcl_GetString(objv[1]));\n  if( objc==3 ){\n    if( Tcl_GetBooleanFromObj(interp, objv[2], &doSync) ) return TCL_ERROR;\n  }\n  rc = sqlite3_quota_fflush(p, doSync);\n  Tcl_SetObjResult(interp, Tcl_NewIntObj(rc));\n  return TCL_OK;\n}\n\n/*\n** tclcmd: sqlite3_quota_fseek HANDLE OFFSET WHENCE\n*/\nstatic int SQLITE_TCLAPI test_quota_fseek(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  quota_FILE *p;\n  int ofst;\n  const char *zWhence;\n  int whence;\n  int rc;\n\n  if( objc!=4 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"HANDLE OFFSET WHENCE\");\n    return TCL_ERROR;\n  }\n  p = sqlite3TestTextToPtr(Tcl_GetString(objv[1]));\n  if( Tcl_GetIntFromObj(interp, objv[2], &ofst) ) return TCL_ERROR;\n  zWhence = Tcl_GetString(objv[3]);\n  if( strcmp(zWhence, \"SEEK_SET\")==0 ){\n    whence = SEEK_SET;\n  }else if( strcmp(zWhence, \"SEEK_CUR\")==0 ){\n    whence = SEEK_CUR;\n  }else if( strcmp(zWhence, \"SEEK_END\")==0 ){\n    whence = SEEK_END;\n  }else{\n    Tcl_AppendResult(interp,\n           \"WHENCE should be SEEK_SET, SEEK_CUR, or SEEK_END\", (char*)0);\n    return TCL_ERROR;\n  }\n  rc = sqlite3_quota_fseek(p, ofst, whence);\n  Tcl_SetObjResult(interp, Tcl_NewIntObj(rc));\n  return TCL_OK;\n}\n\n/*\n** tclcmd: sqlite3_quota_rewind HANDLE\n*/\nstatic int SQLITE_TCLAPI test_quota_rewind(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  quota_FILE *p;\n  if( objc!=2 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"HANDLE\");\n    return TCL_ERROR;\n  }\n  p = sqlite3TestTextToPtr(Tcl_GetString(objv[1]));\n  sqlite3_quota_rewind(p);\n  return TCL_OK;\n}\n\n/*\n** tclcmd: sqlite3_quota_ftell HANDLE\n*/\nstatic int SQLITE_TCLAPI test_quota_ftell(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  quota_FILE *p;\n  sqlite3_int64 x;\n  if( objc!=2 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"HANDLE\");\n    return TCL_ERROR;\n  }\n  p = sqlite3TestTextToPtr(Tcl_GetString(objv[1]));\n  x = sqlite3_quota_ftell(p);\n  Tcl_SetObjResult(interp, Tcl_NewWideIntObj(x));\n  return TCL_OK;\n}\n\n/*\n** tclcmd: sqlite3_quota_ftruncate HANDLE SIZE\n*/\nstatic int SQLITE_TCLAPI test_quota_ftruncate(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  quota_FILE *p;\n  sqlite3_int64 x;\n  Tcl_WideInt w;\n  int rc;\n  if( objc!=3 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"HANDLE SIZE\");\n    return TCL_ERROR;\n  }\n  p = sqlite3TestTextToPtr(Tcl_GetString(objv[1]));\n  if( Tcl_GetWideIntFromObj(interp, objv[2], &w) ) return TCL_ERROR;\n  x = (sqlite3_int64)w;\n  rc = sqlite3_quota_ftruncate(p, x);\n  Tcl_SetObjResult(interp, Tcl_NewIntObj(rc));\n  return TCL_OK;\n}\n\n/*\n** tclcmd: sqlite3_quota_file_size HANDLE\n*/\nstatic int SQLITE_TCLAPI test_quota_file_size(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  quota_FILE *p;\n  sqlite3_int64 x;\n  if( objc!=2 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"HANDLE\");\n    return TCL_ERROR;\n  }\n  p = sqlite3TestTextToPtr(Tcl_GetString(objv[1]));\n  x = sqlite3_quota_file_size(p);\n  Tcl_SetObjResult(interp, Tcl_NewWideIntObj(x));\n  return TCL_OK;\n}\n\n/*\n** tclcmd: sqlite3_quota_file_truesize HANDLE\n*/\nstatic int SQLITE_TCLAPI test_quota_file_truesize(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  quota_FILE *p;\n  sqlite3_int64 x;\n  if( objc!=2 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"HANDLE\");\n    return TCL_ERROR;\n  }\n  p = sqlite3TestTextToPtr(Tcl_GetString(objv[1]));\n  x = sqlite3_quota_file_truesize(p);\n  Tcl_SetObjResult(interp, Tcl_NewWideIntObj(x));\n  return TCL_OK;\n}\n\n/*\n** tclcmd: sqlite3_quota_file_mtime HANDLE\n*/\nstatic int SQLITE_TCLAPI test_quota_file_mtime(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  quota_FILE *p;\n  time_t t;\n  if( objc!=2 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"HANDLE\");\n    return TCL_ERROR;\n  }\n  p = sqlite3TestTextToPtr(Tcl_GetString(objv[1]));\n  t = 0;\n  sqlite3_quota_file_mtime(p, &t);\n  Tcl_SetObjResult(interp, Tcl_NewWideIntObj(t));\n  return TCL_OK;\n}\n\n\n/*\n** tclcmd: sqlite3_quota_remove FILENAME\n*/\nstatic int SQLITE_TCLAPI test_quota_remove(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  const char *zFilename;          /* File pattern to configure */\n  int rc;\n  if( objc!=2 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"FILENAME\");\n    return TCL_ERROR;\n  }\n  zFilename = Tcl_GetString(objv[1]);\n  rc = sqlite3_quota_remove(zFilename);\n  Tcl_SetObjResult(interp, Tcl_NewIntObj(rc));\n  return TCL_OK;\n}\n\n/*\n** tclcmd: sqlite3_quota_glob PATTERN TEXT\n**\n** Test the glob pattern matching.  Return 1 if TEXT matches PATTERN\n** and return 0 if it does not.\n*/\nstatic int SQLITE_TCLAPI test_quota_glob(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  const char *zPattern;          /* The glob pattern */\n  const char *zText;             /* Text to compare against the pattern */\n  int rc;\n  if( objc!=3 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"PATTERN TEXT\");\n    return TCL_ERROR;\n  }\n  zPattern = Tcl_GetString(objv[1]);\n  zText = Tcl_GetString(objv[2]);\n  rc = quotaStrglob(zPattern, zText);\n  Tcl_SetObjResult(interp, Tcl_NewIntObj(rc));\n  return TCL_OK;\n}\n\n/*\n** tclcmd: sqlite3_quota_file_available HANDLE\n**\n** Return the number of bytes from the current file point to the end of\n** the file.\n*/\nstatic int SQLITE_TCLAPI test_quota_file_available(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  quota_FILE *p;\n  sqlite3_int64 x;\n  if( objc!=2 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"HANDLE\");\n    return TCL_ERROR;\n  }\n  p = sqlite3TestTextToPtr(Tcl_GetString(objv[1]));\n  x = sqlite3_quota_file_available(p);\n  Tcl_SetObjResult(interp, Tcl_NewWideIntObj(x));\n  return TCL_OK;\n}\n\n/*\n** tclcmd: sqlite3_quota_ferror HANDLE\n**\n** Return true if the file handle is in the error state.\n*/\nstatic int SQLITE_TCLAPI test_quota_ferror(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  quota_FILE *p;\n  int x;\n  if( objc!=2 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"HANDLE\");\n    return TCL_ERROR;\n  }\n  p = sqlite3TestTextToPtr(Tcl_GetString(objv[1]));\n  x = sqlite3_quota_ferror(p);\n  Tcl_SetObjResult(interp, Tcl_NewIntObj(x));\n  return TCL_OK;\n}\n\n/*\n** This routine registers the custom TCL commands defined in this\n** module.  This should be the only procedure visible from outside\n** of this module.\n*/\nint Sqlitequota_Init(Tcl_Interp *interp){\n  static struct {\n     char *zName;\n     Tcl_ObjCmdProc *xProc;\n  } aCmd[] = {\n    { \"sqlite3_quota_initialize\",    test_quota_initialize },\n    { \"sqlite3_quota_shutdown\",      test_quota_shutdown },\n    { \"sqlite3_quota_set\",           test_quota_set },\n    { \"sqlite3_quota_file\",          test_quota_file },\n    { \"sqlite3_quota_dump\",          test_quota_dump },\n    { \"sqlite3_quota_fopen\",         test_quota_fopen },\n    { \"sqlite3_quota_fread\",         test_quota_fread },\n    { \"sqlite3_quota_fwrite\",        test_quota_fwrite },\n    { \"sqlite3_quota_fclose\",        test_quota_fclose },\n    { \"sqlite3_quota_fflush\",        test_quota_fflush },\n    { \"sqlite3_quota_fseek\",         test_quota_fseek },\n    { \"sqlite3_quota_rewind\",        test_quota_rewind },\n    { \"sqlite3_quota_ftell\",         test_quota_ftell },\n    { \"sqlite3_quota_ftruncate\",     test_quota_ftruncate },\n    { \"sqlite3_quota_file_size\",     test_quota_file_size },\n    { \"sqlite3_quota_file_truesize\", test_quota_file_truesize },\n    { \"sqlite3_quota_file_mtime\",    test_quota_file_mtime },\n    { \"sqlite3_quota_remove\",        test_quota_remove },\n    { \"sqlite3_quota_glob\",          test_quota_glob },\n    { \"sqlite3_quota_file_available\",test_quota_file_available },\n    { \"sqlite3_quota_ferror\",        test_quota_ferror },\n  };\n  int i;\n\n  for(i=0; i<sizeof(aCmd)/sizeof(aCmd[0]); i++){\n    Tcl_CreateObjCommand(interp, aCmd[i].zName, aCmd[i].xProc, 0, 0);\n  }\n\n  return TCL_OK;\n}\n#endif\n"}
{"repo": "sqlite", "file": "test_init.c", "lang": "C++", "code": "/*\n** 2009 August 17\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** The code in this file is used for testing SQLite. It is not part of\n** the source code used in production systems.\n**\n** Specifically, this file tests the effect of errors while initializing\n** the various pluggable sub-systems from within sqlite3_initialize().\n** If an error occurs in sqlite3_initialize() the following should be\n** true:\n**\n**   1) An error code is returned to the user, and\n**   2) A subsequent call to sqlite3_shutdown() calls the shutdown method\n**      of those subsystems that were initialized, and\n**   3) A subsequent call to sqlite3_initialize() attempts to initialize\n**      the remaining, uninitialized, subsystems.\n*/\n\n#include \"sqliteInt.h\"\n#include <string.h>\n#include \"tclsqlite.h\"\n\nstatic struct Wrapped {\n  sqlite3_pcache_methods2 pcache;\n  sqlite3_mem_methods     mem;\n  sqlite3_mutex_methods   mutex;\n\n  int mem_init;              /* True if mem subsystem is initialized */\n  int mem_fail;              /* True to fail mem subsystem initialization */\n  int mutex_init;            /* True if mutex subsystem is initialized */\n  int mutex_fail;            /* True to fail mutex subsystem initialization */\n  int pcache_init;           /* True if pcache subsystem is initialized */\n  int pcache_fail;           /* True to fail pcache subsystem initialization */\n} wrapped;\n\nstatic int wrMemInit(void *pAppData){\n  int rc;\n  if( wrapped.mem_fail ){\n    rc = SQLITE_ERROR;\n  }else{\n    rc = wrapped.mem.xInit(wrapped.mem.pAppData);\n  }\n  if( rc==SQLITE_OK ){\n    wrapped.mem_init = 1;\n  }\n  return rc;\n}\nstatic void wrMemShutdown(void *pAppData){\n  wrapped.mem.xShutdown(wrapped.mem.pAppData);\n  wrapped.mem_init = 0;\n}\nstatic void *wrMemMalloc(int n)           {return wrapped.mem.xMalloc(n);}\nstatic void wrMemFree(void *p)            {wrapped.mem.xFree(p);}\nstatic void *wrMemRealloc(void *p, int n) {return wrapped.mem.xRealloc(p, n);}\nstatic int wrMemSize(void *p)             {return wrapped.mem.xSize(p);}\nstatic int wrMemRoundup(int n)            {return wrapped.mem.xRoundup(n);}\n\n\nstatic int wrMutexInit(void){\n  int rc;\n  if( wrapped.mutex_fail ){\n    rc = SQLITE_ERROR;\n  }else{\n    rc = wrapped.mutex.xMutexInit();\n  }\n  if( rc==SQLITE_OK ){\n    wrapped.mutex_init = 1;\n  }\n  return rc;\n}\nstatic int wrMutexEnd(void){\n  wrapped.mutex.xMutexEnd();\n  wrapped.mutex_init = 0;\n  return SQLITE_OK;\n}\nstatic sqlite3_mutex *wrMutexAlloc(int e){\n  return wrapped.mutex.xMutexAlloc(e);\n}\nstatic void wrMutexFree(sqlite3_mutex *p){\n  wrapped.mutex.xMutexFree(p);\n}\nstatic void wrMutexEnter(sqlite3_mutex *p){\n  wrapped.mutex.xMutexEnter(p);\n}\nstatic int wrMutexTry(sqlite3_mutex *p){\n  return wrapped.mutex.xMutexTry(p);\n}\nstatic void wrMutexLeave(sqlite3_mutex *p){\n  wrapped.mutex.xMutexLeave(p);\n}\nstatic int wrMutexHeld(sqlite3_mutex *p){\n  return wrapped.mutex.xMutexHeld(p);\n}\nstatic int wrMutexNotheld(sqlite3_mutex *p){\n  return wrapped.mutex.xMutexNotheld(p);\n}\n\n\n\nstatic int wrPCacheInit(void *pArg){\n  int rc;\n  if( wrapped.pcache_fail ){\n    rc = SQLITE_ERROR;\n  }else{\n    rc = wrapped.pcache.xInit(wrapped.pcache.pArg);\n  }\n  if( rc==SQLITE_OK ){\n    wrapped.pcache_init = 1;\n  }\n  return rc;\n}\nstatic void wrPCacheShutdown(void *pArg){\n  wrapped.pcache.xShutdown(wrapped.pcache.pArg);\n  wrapped.pcache_init = 0;\n}\n\nstatic sqlite3_pcache *wrPCacheCreate(int a, int b, int c){\n  return wrapped.pcache.xCreate(a, b, c);\n}  \nstatic void wrPCacheCachesize(sqlite3_pcache *p, int n){\n  wrapped.pcache.xCachesize(p, n);\n}  \nstatic int wrPCachePagecount(sqlite3_pcache *p){\n  return wrapped.pcache.xPagecount(p);\n}  \nstatic sqlite3_pcache_page *wrPCacheFetch(sqlite3_pcache *p, unsigned a, int b){\n  return wrapped.pcache.xFetch(p, a, b);\n}  \nstatic void wrPCacheUnpin(sqlite3_pcache *p, sqlite3_pcache_page *a, int b){\n  wrapped.pcache.xUnpin(p, a, b);\n}  \nstatic void wrPCacheRekey(\n  sqlite3_pcache *p, \n  sqlite3_pcache_page *a, \n  unsigned b, \n  unsigned c\n){\n  wrapped.pcache.xRekey(p, a, b, c);\n}  \nstatic void wrPCacheTruncate(sqlite3_pcache *p, unsigned a){\n  wrapped.pcache.xTruncate(p, a);\n}  \nstatic void wrPCacheDestroy(sqlite3_pcache *p){\n  wrapped.pcache.xDestroy(p);\n}  \n\nstatic void installInitWrappers(void){\n  sqlite3_mutex_methods mutexmethods = {\n    wrMutexInit,  wrMutexEnd,   wrMutexAlloc,\n    wrMutexFree,  wrMutexEnter, wrMutexTry,\n    wrMutexLeave, wrMutexHeld,  wrMutexNotheld\n  };\n  sqlite3_pcache_methods2 pcachemethods = {\n    1, 0,\n    wrPCacheInit,      wrPCacheShutdown,  wrPCacheCreate, \n    wrPCacheCachesize, wrPCachePagecount, wrPCacheFetch,\n    wrPCacheUnpin,     wrPCacheRekey,     wrPCacheTruncate,  \n    wrPCacheDestroy\n  };\n  sqlite3_mem_methods memmethods = {\n    wrMemMalloc,   wrMemFree,    wrMemRealloc,\n    wrMemSize,     wrMemRoundup, wrMemInit,\n    wrMemShutdown,\n    0\n  };\n\n  memset(&wrapped, 0, sizeof(wrapped));\n\n  sqlite3_shutdown();\n  sqlite3_config(SQLITE_CONFIG_GETMUTEX, &wrapped.mutex);\n  sqlite3_config(SQLITE_CONFIG_GETMALLOC, &wrapped.mem);\n  sqlite3_config(SQLITE_CONFIG_GETPCACHE2, &wrapped.pcache);\n  sqlite3_config(SQLITE_CONFIG_MUTEX, &mutexmethods);\n  sqlite3_config(SQLITE_CONFIG_MALLOC, &memmethods);\n  sqlite3_config(SQLITE_CONFIG_PCACHE2, &pcachemethods);\n}\n\nstatic int SQLITE_TCLAPI init_wrapper_install(\n  ClientData clientData, /* Unused */\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int objc,              /* Number of arguments */\n  Tcl_Obj *CONST objv[]  /* Command arguments */\n){\n  int i;\n  installInitWrappers();\n  for(i=1; i<objc; i++){\n    char *z = Tcl_GetString(objv[i]);\n    if( strcmp(z, \"mem\")==0 ){\n      wrapped.mem_fail = 1;\n    }else if( strcmp(z, \"mutex\")==0 ){\n      wrapped.mutex_fail = 1;\n    }else if( strcmp(z, \"pcache\")==0 ){\n      wrapped.pcache_fail = 1;\n    }else{\n      Tcl_AppendResult(interp, \"Unknown argument: \\\"\", z, \"\\\"\", NULL);\n      return TCL_ERROR;\n    }\n  }\n  return TCL_OK;\n}\n\nstatic int SQLITE_TCLAPI init_wrapper_uninstall(\n  ClientData clientData, /* Unused */\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int objc,              /* Number of arguments */\n  Tcl_Obj *CONST objv[]  /* Command arguments */\n){\n  if( objc!=1 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"\");\n    return TCL_ERROR;\n  }\n\n  sqlite3_shutdown();\n  sqlite3_config(SQLITE_CONFIG_MUTEX, &wrapped.mutex);\n  sqlite3_config(SQLITE_CONFIG_MALLOC, &wrapped.mem);\n  sqlite3_config(SQLITE_CONFIG_PCACHE2, &wrapped.pcache);\n  return TCL_OK;\n}\n\nstatic int SQLITE_TCLAPI init_wrapper_clear(\n  ClientData clientData, /* Unused */\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int objc,              /* Number of arguments */\n  Tcl_Obj *CONST objv[]  /* Command arguments */\n){\n  if( objc!=1 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"\");\n    return TCL_ERROR;\n  }\n\n  wrapped.mem_fail = 0;\n  wrapped.mutex_fail = 0;\n  wrapped.pcache_fail = 0;\n  return TCL_OK;\n}\n\nstatic int SQLITE_TCLAPI init_wrapper_query(\n  ClientData clientData, /* Unused */\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int objc,              /* Number of arguments */\n  Tcl_Obj *CONST objv[]  /* Command arguments */\n){\n  Tcl_Obj *pRet;\n\n  if( objc!=1 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"\");\n    return TCL_ERROR;\n  }\n\n  pRet = Tcl_NewObj();\n  if( wrapped.mutex_init ){\n    Tcl_ListObjAppendElement(interp, pRet, Tcl_NewStringObj(\"mutex\", -1));\n  }\n  if( wrapped.mem_init ){\n    Tcl_ListObjAppendElement(interp, pRet, Tcl_NewStringObj(\"mem\", -1));\n  }\n  if( wrapped.pcache_init ){\n    Tcl_ListObjAppendElement(interp, pRet, Tcl_NewStringObj(\"pcache\", -1));\n  }\n\n  Tcl_SetObjResult(interp, pRet);\n  return TCL_OK;\n}\n\nint Sqlitetest_init_Init(Tcl_Interp *interp){\n  static struct {\n     char *zName;\n     Tcl_ObjCmdProc *xProc;\n  } aObjCmd[] = {\n    {\"init_wrapper_install\",   init_wrapper_install},\n    {\"init_wrapper_query\",     init_wrapper_query  },\n    {\"init_wrapper_uninstall\", init_wrapper_uninstall},\n    {\"init_wrapper_clear\",     init_wrapper_clear}\n  };\n  int i;\n\n  for(i=0; i<sizeof(aObjCmd)/sizeof(aObjCmd[0]); i++){\n    Tcl_CreateObjCommand(interp, aObjCmd[i].zName, aObjCmd[i].xProc, 0, 0);\n  }\n\n  return TCL_OK;\n}\n"}
{"repo": "sqlite", "file": "random.c", "lang": "C++", "code": "/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains code to implement a pseudo-random number\n** generator (PRNG) for SQLite.\n**\n** Random numbers are used by some of the database backends in order\n** to generate random integer keys for tables or random filenames.\n*/\n#include \"sqliteInt.h\"\n\n\n/* All threads share a single random number generator.\n** This structure is the current state of the generator.\n*/\nstatic SQLITE_WSD struct sqlite3PrngType {\n  u32 s[16];                 /* 64 bytes of chacha20 state */\n  u8 out[64];                /* Output bytes */\n  u8 n;                      /* Output bytes remaining */\n} sqlite3Prng;\n\n\n/* The RFC-7539 ChaCha20 block function\n*/\n#define ROTL(a,b) (((a) << (b)) | ((a) >> (32 - (b))))\n#define QR(a, b, c, d) ( \\\n    a += b, d ^= a, d = ROTL(d,16), \\\n    c += d, b ^= c, b = ROTL(b,12), \\\n    a += b, d ^= a, d = ROTL(d, 8), \\\n    c += d, b ^= c, b = ROTL(b, 7))\nstatic void chacha_block(u32 *out, const u32 *in){\n  int i;\n  u32 x[16];\n  memcpy(x, in, 64);\n  for(i=0; i<10; i++){\n    QR(x[0], x[4], x[ 8], x[12]);\n    QR(x[1], x[5], x[ 9], x[13]);\n    QR(x[2], x[6], x[10], x[14]);\n    QR(x[3], x[7], x[11], x[15]);\n    QR(x[0], x[5], x[10], x[15]);\n    QR(x[1], x[6], x[11], x[12]);\n    QR(x[2], x[7], x[ 8], x[13]);\n    QR(x[3], x[4], x[ 9], x[14]);\n  }\n  for(i=0; i<16; i++) out[i] = x[i]+in[i];\n}\n\n/*\n** Return N random bytes.\n*/\nvoid sqlite3_randomness(int N, void *pBuf){\n  unsigned char *zBuf = pBuf;\n\n  /* The \"wsdPrng\" macro will resolve to the pseudo-random number generator\n  ** state vector.  If writable static data is unsupported on the target,\n  ** we have to locate the state vector at run-time.  In the more common\n  ** case where writable static data is supported, wsdPrng can refer directly\n  ** to the \"sqlite3Prng\" state vector declared above.\n  */\n#ifdef SQLITE_OMIT_WSD\n  struct sqlite3PrngType *p = &GLOBAL(struct sqlite3PrngType, sqlite3Prng);\n# define wsdPrng p[0]\n#else\n# define wsdPrng sqlite3Prng\n#endif\n\n#if SQLITE_THREADSAFE\n  sqlite3_mutex *mutex;\n#endif\n\n#ifndef SQLITE_OMIT_AUTOINIT\n  if( sqlite3_initialize() ) return;\n#endif\n\n#if SQLITE_THREADSAFE\n  mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_PRNG);\n#endif\n\n  sqlite3_mutex_enter(mutex);\n  if( N<=0 || pBuf==0 ){\n    wsdPrng.s[0] = 0;\n    sqlite3_mutex_leave(mutex);\n    return;\n  }\n\n  /* Initialize the state of the random number generator once,\n  ** the first time this routine is called.\n  */\n  if( wsdPrng.s[0]==0 ){\n    sqlite3_vfs *pVfs = sqlite3_vfs_find(0);\n    static const u32 chacha20_init[] = {\n      0x61707865, 0x3320646e, 0x79622d32, 0x6b206574\n    };\n    memcpy(&wsdPrng.s[0], chacha20_init, 16);\n    if( NEVER(pVfs==0) ){\n      memset(&wsdPrng.s[4], 0, 44);\n    }else{\n      sqlite3OsRandomness(pVfs, 44, (char*)&wsdPrng.s[4]);\n    }\n    wsdPrng.s[15] = wsdPrng.s[12];\n    wsdPrng.s[12] = 0;\n    wsdPrng.n = 0;\n  }\n\n  assert( N>0 );\n  while( 1 /* exit by break */ ){\n    if( N<=wsdPrng.n ){\n      memcpy(zBuf, &wsdPrng.out[wsdPrng.n-N], N);\n      wsdPrng.n -= N;\n      break;\n    }\n    if( wsdPrng.n>0 ){\n      memcpy(zBuf, wsdPrng.out, wsdPrng.n);\n      N -= wsdPrng.n;\n      zBuf += wsdPrng.n;\n    }\n    wsdPrng.s[12]++;\n    chacha_block((u32*)wsdPrng.out, wsdPrng.s);\n    wsdPrng.n = 64;\n  }\n  sqlite3_mutex_leave(mutex);\n}\n\n#ifndef SQLITE_UNTESTABLE\n/*\n** For testing purposes, we sometimes want to preserve the state of\n** PRNG and restore the PRNG to its saved state at a later time, or\n** to reset the PRNG to its initial state.  These routines accomplish\n** those tasks.\n**\n** The sqlite3_test_control() interface calls these routines to\n** control the PRNG.\n*/\nstatic SQLITE_WSD struct sqlite3PrngType sqlite3SavedPrng;\nvoid sqlite3PrngSaveState(void){\n  memcpy(\n    &GLOBAL(struct sqlite3PrngType, sqlite3SavedPrng),\n    &GLOBAL(struct sqlite3PrngType, sqlite3Prng),\n    sizeof(sqlite3Prng)\n  );\n}\nvoid sqlite3PrngRestoreState(void){\n  memcpy(\n    &GLOBAL(struct sqlite3PrngType, sqlite3Prng),\n    &GLOBAL(struct sqlite3PrngType, sqlite3SavedPrng),\n    sizeof(sqlite3Prng)\n  );\n}\n#endif /* SQLITE_UNTESTABLE */\n"}
{"repo": "sqlite", "file": "printf.c", "lang": "C++", "code": "/*\n** The \"printf\" code that follows dates from the 1980's.  It is in\n** the public domain. \n**\n**************************************************************************\n**\n** This file contains code for a set of \"printf\"-like routines.  These\n** routines format strings much like the printf() from the standard C\n** library, though the implementation here has enhancements to support\n** SQLite.\n*/\n#include \"sqliteInt.h\"\n\n/*\n** Conversion types fall into various categories as defined by the\n** following enumeration.\n*/\n#define etRADIX       0 /* non-decimal integer types.  %x %o */\n#define etFLOAT       1 /* Floating point.  %f */\n#define etEXP         2 /* Exponentional notation. %e and %E */\n#define etGENERIC     3 /* Floating or exponential, depending on exponent. %g */\n#define etSIZE        4 /* Return number of characters processed so far. %n */\n#define etSTRING      5 /* Strings. %s */\n#define etDYNSTRING   6 /* Dynamically allocated strings. %z */\n#define etPERCENT     7 /* Percent symbol. %% */\n#define etCHARX       8 /* Characters. %c */\n/* The rest are extensions, not normally found in printf() */\n#define etESCAPE_q    9  /* Strings with '\\'' doubled.  %q */\n#define etESCAPE_Q    10 /* Strings with '\\'' doubled and enclosed in '',\n                            NULL pointers replaced by SQL NULL.  %Q */\n#define etTOKEN       11 /* a pointer to a Token structure */\n#define etSRCITEM     12 /* a pointer to a SrcItem */\n#define etPOINTER     13 /* The %p conversion */\n#define etESCAPE_w    14 /* %w -> Strings with '\\\"' doubled */\n#define etORDINAL     15 /* %r -> 1st, 2nd, 3rd, 4th, etc.  English only */\n#define etDECIMAL     16 /* %d or %u, but not %x, %o */\n\n#define etINVALID     17 /* Any unrecognized conversion type */\n\n\n/*\n** An \"etByte\" is an 8-bit unsigned value.\n*/\ntypedef unsigned char etByte;\n\n/*\n** Each builtin conversion character (ex: the 'd' in \"%d\") is described\n** by an instance of the following structure\n*/\ntypedef struct et_info {   /* Information about each format field */\n  char fmttype;            /* The format field code letter */\n  etByte base;             /* The base for radix conversion */\n  etByte flags;            /* One or more of FLAG_ constants below */\n  etByte type;             /* Conversion paradigm */\n  etByte charset;          /* Offset into aDigits[] of the digits string */\n  etByte prefix;           /* Offset into aPrefix[] of the prefix string */\n  char iNxt;               /* Next with same hash, or 0 for end of chain */\n} et_info;\n\n/*\n** Allowed values for et_info.flags\n*/\n#define FLAG_SIGNED    1     /* True if the value to convert is signed */\n#define FLAG_STRING    4     /* Allow infinite precision */\n\n/*\n** The table is searched by hash.  In the case of %C where C is the character\n** and that character has ASCII value j, then the hash is j%23.\n**\n** The order of the entries in fmtinfo[] and the hash chain was entered\n** manually, but based on the output of the following TCL script:\n*/\n#if 0  /*****  Beginning of script ******/\nforeach c {d s g z q Q w c o u x X f e E G i n % p T S r} {\n  scan $c %c x\n  set n($c) $x\n}\nset mx [llength [array names n]]\nputs \"count: $mx\"\n\nset mx 27\nputs \"*********** mx=$mx ************\"\nfor {set r 0} {$r<$mx} {incr r} {\n  puts -nonewline [format %2d: $r]\n  foreach c [array names n] {\n    if {($n($c))%$mx==$r} {puts -nonewline \" $c\"}\n  }\n  puts \"\"\n}\n#endif /***** End of script ********/\n\nstatic const char aDigits[] = \"0123456789ABCDEF0123456789abcdef\";\nstatic const char aPrefix[] = \"-x0\\000X0\";\nstatic const et_info fmtinfo[23] = {\n  /*  0 */  {  's',  0, 4, etSTRING,     0,  0,  1 },\n  /*  1 */  {  'E',  0, 1, etEXP,        14, 0,  0 },  /* Hash: 0 */\n  /*  2 */  {  'u', 10, 0, etDECIMAL,    0,  0,  3 },\n  /*  3 */  {  'G',  0, 1, etGENERIC,    14, 0,  0 },  /* Hash: 2 */\n  /*  4 */  {  'w',  0, 4, etESCAPE_w,   0,  0,  0 },\n  /*  5 */  {  'x', 16, 0, etRADIX,      16, 1,  0 },\n  /*  6 */  {  'c',  0, 0, etCHARX,      0,  0,  0 },  /* Hash: 7 */\n  /*  7 */  {  'z',  0, 4, etDYNSTRING,  0,  0,  6 },\n  /*  8 */  {  'd', 10, 1, etDECIMAL,    0,  0,  0 },\n  /*  9 */  {  'e',  0, 1, etEXP,        30, 0,  0 },\n  /* 10 */  {  'f',  0, 1, etFLOAT,      0,  0,  0 },\n  /* 11 */  {  'g',  0, 1, etGENERIC,    30, 0,  0 },\n  /* 12 */  {  'Q',  0, 4, etESCAPE_Q,   0,  0,  0 },\n  /* 13 */  {  'i', 10, 1, etDECIMAL,    0,  0,  0 },\n  /* 14 */  {  '%',  0, 0, etPERCENT,    0,  0, 16 },\n  /* 15 */  {  'T',  0, 0, etTOKEN,      0,  0,  0 },\n  /* 16 */  {  'S',  0, 0, etSRCITEM,    0,  0,  0 },  /* Hash: 14 */\n  /* 17 */  {  'X', 16, 0, etRADIX,      0,  4,  0 },  /* Hash: 19 */\n  /* 18 */  {  'n',  0, 0, etSIZE,       0,  0,  0 },\n  /* 19 */  {  'o',  8, 0, etRADIX,      0,  2, 17 },\n  /* 20 */  {  'p', 16, 0, etPOINTER,    0,  1,  0 },\n  /* 21 */  {  'q',  0, 4, etESCAPE_q,   0,  0,  0 },\n  /* 22 */  {  'r', 10, 1, etORDINAL,    0,  0,  0 }\n};\n\n/* Additional Notes:\n**\n**    %S    Takes a pointer to SrcItem.  Shows name or database.name\n**    %!S   Like %S but prefer the zName over the zAlias\n*/\n\n/*\n** Set the StrAccum object to an error mode.\n*/\nvoid sqlite3StrAccumSetError(StrAccum *p, u8 eError){\n  assert( eError==SQLITE_NOMEM || eError==SQLITE_TOOBIG );\n  p->accError = eError;\n  if( p->mxAlloc ) sqlite3_str_reset(p);\n  if( eError==SQLITE_TOOBIG ) sqlite3ErrorToParser(p->db, eError);\n}\n\n/*\n** Extra argument values from a PrintfArguments object\n*/\nstatic sqlite3_int64 getIntArg(PrintfArguments *p){\n  if( p->nArg<=p->nUsed ) return 0;\n  return sqlite3_value_int64(p->apArg[p->nUsed++]);\n}\nstatic double getDoubleArg(PrintfArguments *p){\n  if( p->nArg<=p->nUsed ) return 0.0;\n  return sqlite3_value_double(p->apArg[p->nUsed++]);\n}\nstatic char *getTextArg(PrintfArguments *p){\n  if( p->nArg<=p->nUsed ) return 0;\n  return (char*)sqlite3_value_text(p->apArg[p->nUsed++]);\n}\n\n/*\n** Allocate memory for a temporary buffer needed for printf rendering.\n**\n** If the requested size of the temp buffer is larger than the size\n** of the output buffer in pAccum, then cause an SQLITE_TOOBIG error.\n** Do the size check before the memory allocation to prevent rogue\n** SQL from requesting large allocations using the precision or width\n** field of the printf() function.\n*/\nstatic char *printfTempBuf(sqlite3_str *pAccum, sqlite3_int64 n){\n  char *z;\n  if( pAccum->accError ) return 0;\n  if( n>pAccum->nAlloc && n>pAccum->mxAlloc ){\n    sqlite3StrAccumSetError(pAccum, SQLITE_TOOBIG);\n    return 0;\n  }\n  z = sqlite3DbMallocRaw(pAccum->db, n);\n  if( z==0 ){\n    sqlite3StrAccumSetError(pAccum, SQLITE_NOMEM);\n  }\n  return z;\n}\n\n/*\n** On machines with a small stack size, you can redefine the\n** SQLITE_PRINT_BUF_SIZE to be something smaller, if desired.\n*/\n#ifndef SQLITE_PRINT_BUF_SIZE\n# define SQLITE_PRINT_BUF_SIZE 70\n#endif\n#define etBUFSIZE SQLITE_PRINT_BUF_SIZE  /* Size of the output buffer */\n\n/*\n** Hard limit on the precision of floating-point conversions.\n*/\n#ifndef SQLITE_PRINTF_PRECISION_LIMIT\n# define SQLITE_FP_PRECISION_LIMIT 100000000\n#endif\n\n/*\n** Render a string given by \"fmt\" into the StrAccum object.\n*/\nvoid sqlite3_str_vappendf(\n  sqlite3_str *pAccum,       /* Accumulate results here */\n  const char *fmt,           /* Format string */\n  va_list ap                 /* arguments */\n){\n  int c;                     /* Next character in the format string */\n  char *bufpt;               /* Pointer to the conversion buffer */\n  int precision;             /* Precision of the current field */\n  int length;                /* Length of the field */\n  int idx;                   /* A general purpose loop counter */\n  int width;                 /* Width of the current field */\n  etByte flag_leftjustify;   /* True if \"-\" flag is present */\n  etByte flag_prefix;        /* '+' or ' ' or 0 for prefix */\n  etByte flag_alternateform; /* True if \"#\" flag is present */\n  etByte flag_altform2;      /* True if \"!\" flag is present */\n  etByte flag_zeropad;       /* True if field width constant starts with zero */\n  etByte flag_long;          /* 1 for the \"l\" flag, 2 for \"ll\", 0 by default */\n  etByte done;               /* Loop termination flag */\n  etByte cThousand;          /* Thousands separator for %d and %u */\n  etByte xtype = etINVALID;  /* Conversion paradigm */\n  u8 bArgList;               /* True for SQLITE_PRINTF_SQLFUNC */\n  char prefix;               /* Prefix character.  \"+\" or \"-\" or \" \" or '\\0'. */\n  sqlite_uint64 longvalue;   /* Value for integer types */\n  double realvalue;          /* Value for real types */\n  const et_info *infop;      /* Pointer to the appropriate info structure */\n  char *zOut;                /* Rendering buffer */\n  int nOut;                  /* Size of the rendering buffer */\n  char *zExtra = 0;          /* Malloced memory used by some conversion */\n  int exp, e2;               /* exponent of real numbers */\n  etByte flag_dp;            /* True if decimal point should be shown */\n  etByte flag_rtz;           /* True if trailing zeros should be removed */\n\n  PrintfArguments *pArgList = 0; /* Arguments for SQLITE_PRINTF_SQLFUNC */\n  char buf[etBUFSIZE];       /* Conversion buffer */\n\n  /* pAccum never starts out with an empty buffer that was obtained from \n  ** malloc().  This precondition is required by the mprintf(\"%z...\")\n  ** optimization. */\n  assert( pAccum->nChar>0 || (pAccum->printfFlags&SQLITE_PRINTF_MALLOCED)==0 );\n\n  bufpt = 0;\n  if( (pAccum->printfFlags & SQLITE_PRINTF_SQLFUNC)!=0 ){\n    pArgList = va_arg(ap, PrintfArguments*);\n    bArgList = 1;\n  }else{\n    bArgList = 0;\n  }\n  for(; (c=(*fmt))!=0; ++fmt){\n    if( c!='%' ){\n      bufpt = (char *)fmt;\n#if HAVE_STRCHRNUL\n      fmt = strchrnul(fmt, '%');\n#else\n      fmt = strchr(fmt, '%');\n      if( fmt==0 ){\n        fmt = bufpt + strlen(bufpt);\n      }\n#endif\n      sqlite3_str_append(pAccum, bufpt, (int)(fmt - bufpt));\n      if( *fmt==0 ) break;\n    }\n    if( (c=(*++fmt))==0 ){\n      sqlite3_str_append(pAccum, \"%\", 1);\n      break;\n    }\n    /* Find out what flags are present */\n    flag_leftjustify = flag_prefix = cThousand =\n     flag_alternateform = flag_altform2 = flag_zeropad = 0;\n    done = 0;\n    width = 0;\n    flag_long = 0;\n    precision = -1;\n    do{\n      switch( c ){\n        case '-':   flag_leftjustify = 1;     break;\n        case '+':   flag_prefix = '+';        break;\n        case ' ':   flag_prefix = ' ';        break;\n        case '#':   flag_alternateform = 1;   break;\n        case '!':   flag_altform2 = 1;        break;\n        case '0':   flag_zeropad = 1;         break;\n        case ',':   cThousand = ',';          break;\n        default:    done = 1;                 break;\n        case 'l': {\n          flag_long = 1;\n          c = *++fmt;\n          if( c=='l' ){\n            c = *++fmt;\n            flag_long = 2;\n          }\n          done = 1;\n          break;\n        }\n        case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9': {\n          unsigned wx = c - '0';\n          while( (c = *++fmt)>='0' && c<='9' ){\n            wx = wx*10 + c - '0';\n          }\n          testcase( wx>0x7fffffff );\n          width = wx & 0x7fffffff;\n#ifdef SQLITE_PRINTF_PRECISION_LIMIT\n          if( width>SQLITE_PRINTF_PRECISION_LIMIT ){\n            width = SQLITE_PRINTF_PRECISION_LIMIT;\n          }\n#endif\n          if( c!='.' && c!='l' ){\n            done = 1;\n          }else{\n            fmt--;\n          }\n          break;\n        }\n        case '*': {\n          if( bArgList ){\n            width = (int)getIntArg(pArgList);\n          }else{\n            width = va_arg(ap,int);\n          }\n          if( width<0 ){\n            flag_leftjustify = 1;\n            width = width >= -2147483647 ? -width : 0;\n          }\n#ifdef SQLITE_PRINTF_PRECISION_LIMIT\n          if( width>SQLITE_PRINTF_PRECISION_LIMIT ){\n            width = SQLITE_PRINTF_PRECISION_LIMIT;\n          }\n#endif\n          if( (c = fmt[1])!='.' && c!='l' ){\n            c = *++fmt;\n            done = 1;\n          }\n          break;\n        }\n        case '.': {\n          c = *++fmt;\n          if( c=='*' ){\n            if( bArgList ){\n              precision = (int)getIntArg(pArgList);\n            }else{\n              precision = va_arg(ap,int);\n            }\n            if( precision<0 ){\n              precision = precision >= -2147483647 ? -precision : -1;\n            }\n            c = *++fmt;\n          }else{\n            unsigned px = 0;\n            while( c>='0' && c<='9' ){\n              px = px*10 + c - '0';\n              c = *++fmt;\n            }\n            testcase( px>0x7fffffff );\n            precision = px & 0x7fffffff;\n          }\n#ifdef SQLITE_PRINTF_PRECISION_LIMIT\n          if( precision>SQLITE_PRINTF_PRECISION_LIMIT ){\n            precision = SQLITE_PRINTF_PRECISION_LIMIT;\n          }\n#endif\n          if( c=='l' ){\n            --fmt;\n          }else{\n            done = 1;\n          }\n          break;\n        }\n      }\n    }while( !done && (c=(*++fmt))!=0 );\n\n    /* Fetch the info entry for the field */\n#ifdef SQLITE_EBCDIC\n    /* The hash table only works for ASCII.  For EBCDIC, we need to do\n    ** a linear search of the table */\n    infop = &fmtinfo[0];\n    xtype = etINVALID;\n    for(idx=0; idx<ArraySize(fmtinfo); idx++){\n      if( c==fmtinfo[idx].fmttype ){\n        infop = &fmtinfo[idx];\n        xtype = infop->type;\n        break;\n      }\n    }\n#else\n    /* Fast hash-table lookup */\n    assert( ArraySize(fmtinfo)==23 );\n    idx = ((unsigned)c) % 23;\n    if( fmtinfo[idx].fmttype==c\n     || fmtinfo[idx = fmtinfo[idx].iNxt].fmttype==c\n    ){\n      infop = &fmtinfo[idx];\n      xtype = infop->type;\n    }else{\n      infop = &fmtinfo[0];\n      xtype = etINVALID;\n    }\n#endif\n\n    /*\n    ** At this point, variables are initialized as follows:\n    **\n    **   flag_alternateform          TRUE if a '#' is present.\n    **   flag_altform2               TRUE if a '!' is present.\n    **   flag_prefix                 '+' or ' ' or zero\n    **   flag_leftjustify            TRUE if a '-' is present or if the\n    **                               field width was negative.\n    **   flag_zeropad                TRUE if the width began with 0.\n    **   flag_long                   1 for \"l\", 2 for \"ll\"\n    **   width                       The specified field width.  This is\n    **                               always non-negative.  Zero is the default.\n    **   precision                   The specified precision.  The default\n    **                               is -1.\n    **   xtype                       The class of the conversion.\n    **   infop                       Pointer to the appropriate info struct.\n    */\n    assert( width>=0 );\n    assert( precision>=(-1) );\n    switch( xtype ){\n      case etPOINTER:\n        flag_long = sizeof(char*)==sizeof(i64) ? 2 :\n                     sizeof(char*)==sizeof(long int) ? 1 : 0;\n        /* no break */ deliberate_fall_through\n      case etORDINAL:\n      case etRADIX:      \n        cThousand = 0;\n        /* no break */ deliberate_fall_through\n      case etDECIMAL:\n        if( infop->flags & FLAG_SIGNED ){\n          i64 v;\n          if( bArgList ){\n            v = getIntArg(pArgList);\n          }else if( flag_long ){\n            if( flag_long==2 ){\n              v = va_arg(ap,i64) ;\n            }else{\n              v = va_arg(ap,long int);\n            }\n          }else{\n            v = va_arg(ap,int);\n          }\n          if( v<0 ){\n            testcase( v==SMALLEST_INT64 );\n            testcase( v==(-1) );\n            longvalue = ~v;\n            longvalue++;\n            prefix = '-';\n          }else{\n            longvalue = v;\n            prefix = flag_prefix;\n          }\n        }else{\n          if( bArgList ){\n            longvalue = (u64)getIntArg(pArgList);\n          }else if( flag_long ){\n            if( flag_long==2 ){\n              longvalue = va_arg(ap,u64);\n            }else{\n              longvalue = va_arg(ap,unsigned long int);\n            }\n          }else{\n            longvalue = va_arg(ap,unsigned int);\n          }\n          prefix = 0;\n        }\n\n#if WHERETRACE_ENABLED\n        if( xtype==etPOINTER && sqlite3WhereTrace & 0x100000 ) longvalue = 0;\n#endif\n#if TREETRACE_ENABLED\n        if( xtype==etPOINTER && sqlite3TreeTrace & 0x100000 ) longvalue = 0;\n#endif\n\n        if( longvalue==0 ) flag_alternateform = 0;\n        if( flag_zeropad && precision<width-(prefix!=0) ){\n          precision = width-(prefix!=0);\n        }\n        if( precision<etBUFSIZE-10-etBUFSIZE/3 ){\n          nOut = etBUFSIZE;\n          zOut = buf;\n        }else{\n          u64 n;\n          n = (u64)precision + 10;\n          if( cThousand ) n += precision/3;\n          zOut = zExtra = printfTempBuf(pAccum, n);\n          if( zOut==0 ) return;\n          nOut = (int)n;\n        }\n        bufpt = &zOut[nOut-1];\n        if( xtype==etORDINAL ){\n          static const char zOrd[] = \"thstndrd\";\n          int x = (int)(longvalue % 10);\n          if( x>=4 || (longvalue/10)%10==1 ){\n            x = 0;\n          }\n          *(--bufpt) = zOrd[x*2+1];\n          *(--bufpt) = zOrd[x*2];\n        }\n        {\n          const char *cset = &aDigits[infop->charset];\n          u8 base = infop->base;\n          do{                                           /* Convert to ascii */\n            *(--bufpt) = cset[longvalue%base];\n            longvalue = longvalue/base;\n          }while( longvalue>0 );\n        }\n        length = (int)(&zOut[nOut-1]-bufpt);\n        while( precision>length ){\n          *(--bufpt) = '0';                             /* Zero pad */\n          length++;\n        }\n        if( cThousand ){\n          int nn = (length - 1)/3;  /* Number of \",\" to insert */\n          int ix = (length - 1)%3 + 1;\n          bufpt -= nn;\n          for(idx=0; nn>0; idx++){\n            bufpt[idx] = bufpt[idx+nn];\n            ix--;\n            if( ix==0 ){\n              bufpt[++idx] = cThousand;\n              nn--;\n              ix = 3;\n            }\n          }\n        }\n        if( prefix ) *(--bufpt) = prefix;               /* Add sign */\n        if( flag_alternateform && infop->prefix ){      /* Add \"0\" or \"0x\" */\n          const char *pre;\n          char x;\n          pre = &aPrefix[infop->prefix];\n          for(; (x=(*pre))!=0; pre++) *(--bufpt) = x;\n        }\n        length = (int)(&zOut[nOut-1]-bufpt);\n        break;\n      case etFLOAT:\n      case etEXP:\n      case etGENERIC: {\n        FpDecode s;\n        int iRound;\n        int j;\n\n        if( bArgList ){\n          realvalue = getDoubleArg(pArgList);\n        }else{\n          realvalue = va_arg(ap,double);\n        }\n        if( precision<0 ) precision = 6;         /* Set default precision */\n#ifdef SQLITE_FP_PRECISION_LIMIT\n        if( precision>SQLITE_FP_PRECISION_LIMIT ){\n          precision = SQLITE_FP_PRECISION_LIMIT;\n        }\n#endif\n        if( xtype==etFLOAT ){\n          iRound = -precision;\n        }else if( xtype==etGENERIC ){\n          if( precision==0 ) precision = 1;\n          iRound = precision;\n        }else{\n          iRound = precision+1;\n        }\n        sqlite3FpDecode(&s, realvalue, iRound, flag_altform2 ? 26 : 16);\n        if( s.isSpecial ){\n          if( s.isSpecial==2 ){\n            bufpt = flag_zeropad ? \"null\" : \"NaN\";\n            length = sqlite3Strlen30(bufpt);\n            break;\n          }else if( flag_zeropad ){\n            s.z[0] = '9';\n            s.iDP = 1000;\n            s.n = 1;\n          }else{\n            memcpy(buf, \"-Inf\", 5);\n            bufpt = buf;\n            if( s.sign=='-' ){\n              /* no-op */\n            }else if( flag_prefix ){\n              buf[0] = flag_prefix;\n            }else{\n              bufpt++;\n            }\n            length = sqlite3Strlen30(bufpt);\n            break;\n          }\n        }\n        if( s.sign=='-' ){\n          if( flag_alternateform\n           && !flag_prefix\n           && xtype==etFLOAT\n           && s.iDP<=iRound\n          ){\n            /* Suppress the minus sign if all of the following are true:\n            **   *  The value displayed is zero\n            **   *  The '#' flag is used\n            **   *  The '+' flag is not used, and\n            **   *  The format is %f\n            */\n            prefix = 0;\n          }else{\n            prefix = '-';\n          }\n        }else{\n          prefix = flag_prefix;\n        }\n\n        exp = s.iDP-1;\n\n        /*\n        ** If the field type is etGENERIC, then convert to either etEXP\n        ** or etFLOAT, as appropriate.\n        */\n        if( xtype==etGENERIC ){\n          assert( precision>0 );\n          precision--;\n          flag_rtz = !flag_alternateform;\n          if( exp<-4 || exp>precision ){\n            xtype = etEXP;\n          }else{\n            precision = precision - exp;\n            xtype = etFLOAT;\n          }\n        }else{\n          flag_rtz = flag_altform2;\n        }\n        if( xtype==etEXP ){\n          e2 = 0;\n        }else{\n          e2 = s.iDP - 1;\n        }\n        bufpt = buf;\n        {\n          i64 szBufNeeded;           /* Size of a temporary buffer needed */\n          szBufNeeded = MAX(e2,0)+(i64)precision+(i64)width+15;\n          if( cThousand && e2>0 ) szBufNeeded += (e2+2)/3;\n          if( szBufNeeded > etBUFSIZE ){\n            bufpt = zExtra = printfTempBuf(pAccum, szBufNeeded);\n            if( bufpt==0 ) return;\n          }\n        }\n        zOut = bufpt;\n        flag_dp = (precision>0 ?1:0) | flag_alternateform | flag_altform2;\n        /* The sign in front of the number */\n        if( prefix ){\n          *(bufpt++) = prefix;\n        }\n        /* Digits prior to the decimal point */\n        j = 0;\n        if( e2<0 ){\n          *(bufpt++) = '0';\n        }else{\n          for(; e2>=0; e2--){\n            *(bufpt++) = j<s.n ? s.z[j++] : '0';\n            if( cThousand && (e2%3)==0 && e2>1 ) *(bufpt++) = ',';\n          }\n        }\n        /* The decimal point */\n        if( flag_dp ){\n          *(bufpt++) = '.';\n        }\n        /* \"0\" digits after the decimal point but before the first\n        ** significant digit of the number */\n        for(e2++; e2<0 && precision>0; precision--, e2++){\n          *(bufpt++) = '0';\n        }\n        /* Significant digits after the decimal point */\n        while( (precision--)>0 ){\n          *(bufpt++) = j<s.n ? s.z[j++] : '0';\n        }\n        /* Remove trailing zeros and the \".\" if no digits follow the \".\" */\n        if( flag_rtz && flag_dp ){\n          while( bufpt[-1]=='0' ) *(--bufpt) = 0;\n          assert( bufpt>zOut );\n          if( bufpt[-1]=='.' ){\n            if( flag_altform2 ){\n              *(bufpt++) = '0';\n            }else{\n              *(--bufpt) = 0;\n            }\n          }\n        }\n        /* Add the \"eNNN\" suffix */\n        if( xtype==etEXP ){\n          exp = s.iDP - 1;\n          *(bufpt++) = aDigits[infop->charset];\n          if( exp<0 ){\n            *(bufpt++) = '-'; exp = -exp;\n          }else{\n            *(bufpt++) = '+';\n          }\n          if( exp>=100 ){\n            *(bufpt++) = (char)((exp/100)+'0');        /* 100's digit */\n            exp %= 100;\n          }\n          *(bufpt++) = (char)(exp/10+'0');             /* 10's digit */\n          *(bufpt++) = (char)(exp%10+'0');             /* 1's digit */\n        }\n        *bufpt = 0;\n\n        /* The converted number is in buf[] and zero terminated. Output it.\n        ** Note that the number is in the usual order, not reversed as with\n        ** integer conversions. */\n        length = (int)(bufpt-zOut);\n        bufpt = zOut;\n\n        /* Special case:  Add leading zeros if the flag_zeropad flag is\n        ** set and we are not left justified */\n        if( flag_zeropad && !flag_leftjustify && length < width){\n          int i;\n          int nPad = width - length;\n          for(i=width; i>=nPad; i--){\n            bufpt[i] = bufpt[i-nPad];\n          }\n          i = prefix!=0;\n          while( nPad-- ) bufpt[i++] = '0';\n          length = width;\n        }\n        break;\n      }\n      case etSIZE:\n        if( !bArgList ){\n          *(va_arg(ap,int*)) = pAccum->nChar;\n        }\n        length = width = 0;\n        break;\n      case etPERCENT:\n        buf[0] = '%';\n        bufpt = buf;\n        length = 1;\n        break;\n      case etCHARX:\n        if( bArgList ){\n          bufpt = getTextArg(pArgList);\n          length = 1;\n          if( bufpt ){\n            buf[0] = c = *(bufpt++);\n            if( (c&0xc0)==0xc0 ){\n              while( length<4 && (bufpt[0]&0xc0)==0x80 ){\n                buf[length++] = *(bufpt++);\n              }\n            }\n          }else{\n            buf[0] = 0;\n          }\n        }else{\n          unsigned int ch = va_arg(ap,unsigned int);\n          length = sqlite3AppendOneUtf8Character(buf, ch);\n        }\n        if( precision>1 ){\n          i64 nPrior = 1;\n          width -= precision-1;\n          if( width>1 && !flag_leftjustify ){\n            sqlite3_str_appendchar(pAccum, width-1, ' ');\n            width = 0;\n          }\n          sqlite3_str_append(pAccum, buf, length);\n          precision--;\n          while( precision > 1 ){\n            i64 nCopyBytes;\n            if( nPrior > precision-1 ) nPrior = precision - 1;\n            nCopyBytes = length*nPrior;\n            if( nCopyBytes + pAccum->nChar >= pAccum->nAlloc ){\n              sqlite3StrAccumEnlarge(pAccum, nCopyBytes);\n            }\n            if( pAccum->accError ) break;\n            sqlite3_str_append(pAccum,\n                 &pAccum->zText[pAccum->nChar-nCopyBytes], nCopyBytes);\n            precision -= nPrior;\n            nPrior *= 2;\n          }\n        }\n        bufpt = buf;\n        flag_altform2 = 1;\n        goto adjust_width_for_utf8;\n      case etSTRING:\n      case etDYNSTRING:\n        if( bArgList ){\n          bufpt = getTextArg(pArgList);\n          xtype = etSTRING;\n        }else{\n          bufpt = va_arg(ap,char*);\n        }\n        if( bufpt==0 ){\n          bufpt = \"\";\n        }else if( xtype==etDYNSTRING ){\n          if( pAccum->nChar==0\n           && pAccum->mxAlloc\n           && width==0\n           && precision<0\n           && pAccum->accError==0\n          ){\n            /* Special optimization for sqlite3_mprintf(\"%z...\"):\n            ** Extend an existing memory allocation rather than creating\n            ** a new one. */\n            assert( (pAccum->printfFlags&SQLITE_PRINTF_MALLOCED)==0 );\n            pAccum->zText = bufpt;\n            pAccum->nAlloc = sqlite3DbMallocSize(pAccum->db, bufpt);\n            pAccum->nChar = 0x7fffffff & (int)strlen(bufpt);\n            pAccum->printfFlags |= SQLITE_PRINTF_MALLOCED;\n            length = 0;\n            break;\n          }\n          zExtra = bufpt;\n        }\n        if( precision>=0 ){\n          if( flag_altform2 ){\n            /* Set length to the number of bytes needed in order to display\n            ** precision characters */\n            unsigned char *z = (unsigned char*)bufpt;\n            while( precision-- > 0 && z[0] ){\n              SQLITE_SKIP_UTF8(z);\n            }\n            length = (int)(z - (unsigned char*)bufpt);\n          }else{\n            for(length=0; length<precision && bufpt[length]; length++){}\n          }\n        }else{\n          length = 0x7fffffff & (int)strlen(bufpt);\n        }\n      adjust_width_for_utf8:\n        if( flag_altform2 && width>0 ){\n          /* Adjust width to account for extra bytes in UTF-8 characters */\n          int ii = length - 1;\n          while( ii>=0 ) if( (bufpt[ii--] & 0xc0)==0x80 ) width++;\n        }\n        break;\n      case etESCAPE_q:          /* %q: Escape ' characters */\n      case etESCAPE_Q:          /* %Q: Escape ' and enclose in '...' */\n      case etESCAPE_w: {        /* %w: Escape \" characters */\n        i64 i, j, k, n;\n        int needQuote = 0;\n        char ch;\n        char *escarg;\n        char q;\n\n        if( bArgList ){\n          escarg = getTextArg(pArgList);\n        }else{\n          escarg = va_arg(ap,char*);\n        }\n        if( escarg==0 ){\n          escarg = (xtype==etESCAPE_Q ? \"NULL\" : \"(NULL)\");\n        }else if( xtype==etESCAPE_Q ){\n          needQuote = 1;\n        }\n        if( xtype==etESCAPE_w ){\n          q = '\"';\n          flag_alternateform = 0;\n        }else{\n          q = '\\'';\n        }\n        /* For %q, %Q, and %w, the precision is the number of bytes (or\n        ** characters if the ! flags is present) to use from the input.\n        ** Because of the extra quoting characters inserted, the number\n        ** of output characters may be larger than the precision.\n        */\n        k = precision;\n        for(i=n=0; k!=0 && (ch=escarg[i])!=0; i++, k--){\n          if( ch==q )  n++;\n          if( flag_altform2 && (ch&0xc0)==0xc0 ){\n            while( (escarg[i+1]&0xc0)==0x80 ){ i++; }\n          }\n        }\n        if( flag_alternateform ){\n          /* For %#q, do unistr()-style backslash escapes for\n          ** all control characters, and for backslash itself.\n          ** For %#Q, do the same but only if there is at least\n          ** one control character. */\n          u32 nBack = 0;\n          u32 nCtrl = 0;\n          for(k=0; k<i; k++){\n            if( escarg[k]=='\\\\' ){\n              nBack++;\n            }else if( ((u8*)escarg)[k]<=0x1f ){\n              nCtrl++;\n            }\n          }\n          if( nCtrl || xtype==etESCAPE_q ){\n            n += nBack + 5*nCtrl;\n            if( xtype==etESCAPE_Q ){\n              n += 10;\n              needQuote = 2;\n            }\n          }else{\n            flag_alternateform = 0;\n          }\n        }\n        n += i + 3;\n        if( n>etBUFSIZE ){\n          bufpt = zExtra = printfTempBuf(pAccum, n);\n          if( bufpt==0 ) return;\n        }else{\n          bufpt = buf;\n        }\n        j = 0;\n        if( needQuote ){\n          if( needQuote==2 ){\n            memcpy(&bufpt[j], \"unistr('\", 8);\n            j += 8;\n          }else{\n            bufpt[j++] = '\\'';\n          }\n        }\n        k = i;\n        if( flag_alternateform ){\n          for(i=0; i<k; i++){\n            bufpt[j++] = ch = escarg[i];\n            if( ch==q ){\n              bufpt[j++] = ch;\n            }else if( ch=='\\\\' ){\n              bufpt[j++] = '\\\\';\n            }else if( ((unsigned char)ch)<=0x1f ){\n              bufpt[j-1] = '\\\\';\n              bufpt[j++] = 'u';\n              bufpt[j++] = '0';\n              bufpt[j++] = '0';\n              bufpt[j++] = ch>=0x10 ? '1' : '0';\n              bufpt[j++] = \"0123456789abcdef\"[ch&0xf];\n            }\n          }\n        }else{\n          for(i=0; i<k; i++){\n            bufpt[j++] = ch = escarg[i];\n            if( ch==q ) bufpt[j++] = ch;\n          }\n        }\n        if( needQuote ){\n          bufpt[j++] = '\\'';\n          if( needQuote==2 ) bufpt[j++] = ')';\n        }\n        bufpt[j] = 0;\n        length = j;\n        goto adjust_width_for_utf8;\n      }\n      case etTOKEN: {\n        if( (pAccum->printfFlags & SQLITE_PRINTF_INTERNAL)==0 ) return;\n        if( flag_alternateform ){\n          /* %#T means an Expr pointer that uses Expr.u.zToken */\n          Expr *pExpr = va_arg(ap,Expr*);\n          if( ALWAYS(pExpr) && ALWAYS(!ExprHasProperty(pExpr,EP_IntValue)) ){\n            sqlite3_str_appendall(pAccum, (const char*)pExpr->u.zToken);\n            sqlite3RecordErrorOffsetOfExpr(pAccum->db, pExpr);\n          }\n        }else{\n          /* %T means a Token pointer */\n          Token *pToken = va_arg(ap, Token*);\n          assert( bArgList==0 );\n          if( pToken && pToken->n ){\n            sqlite3_str_append(pAccum, (const char*)pToken->z, pToken->n);\n            sqlite3RecordErrorByteOffset(pAccum->db, pToken->z);\n          }\n        }\n        length = width = 0;\n        break;\n      }\n      case etSRCITEM: {\n        SrcItem *pItem;\n        if( (pAccum->printfFlags & SQLITE_PRINTF_INTERNAL)==0 ) return;\n        pItem = va_arg(ap, SrcItem*);\n        assert( bArgList==0 );\n        if( pItem->zAlias && !flag_altform2 ){\n          sqlite3_str_appendall(pAccum, pItem->zAlias);\n        }else if( pItem->zName ){\n          if( pItem->fg.fixedSchema==0\n           && pItem->fg.isSubquery==0\n           && pItem->u4.zDatabase!=0\n          ){\n            sqlite3_str_appendall(pAccum, pItem->u4.zDatabase);\n            sqlite3_str_append(pAccum, \".\", 1);\n          }\n          sqlite3_str_appendall(pAccum, pItem->zName);\n        }else if( pItem->zAlias ){\n          sqlite3_str_appendall(pAccum, pItem->zAlias);\n        }else if( ALWAYS(pItem->fg.isSubquery) ){/* Because of tag-20240424-1 */\n          Select *pSel = pItem->u4.pSubq->pSelect;\n          assert( pSel!=0 ); \n          if( pSel->selFlags & SF_NestedFrom ){\n            sqlite3_str_appendf(pAccum, \"(join-%u)\", pSel->selId);\n          }else if( pSel->selFlags & SF_MultiValue ){\n            assert( !pItem->fg.isTabFunc && !pItem->fg.isIndexedBy );\n            sqlite3_str_appendf(pAccum, \"%u-ROW VALUES CLAUSE\",\n                                pItem->u1.nRow);\n          }else{\n            sqlite3_str_appendf(pAccum, \"(subquery-%u)\", pSel->selId);\n          }\n        }\n        length = width = 0;\n        break;\n      }\n      default: {\n        assert( xtype==etINVALID );\n        return;\n      }\n    }/* End switch over the format type */\n    /*\n    ** The text of the conversion is pointed to by \"bufpt\" and is\n    ** \"length\" characters long.  The field width is \"width\".  Do\n    ** the output.  Both length and width are in bytes, not characters,\n    ** at this point.  If the \"!\" flag was present on string conversions\n    ** indicating that width and precision should be expressed in characters,\n    ** then the values have been translated prior to reaching this point.\n    */\n    width -= length;\n    if( width>0 ){\n      if( !flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, ' ');\n      sqlite3_str_append(pAccum, bufpt, length);\n      if( flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, ' ');\n    }else{\n      sqlite3_str_append(pAccum, bufpt, length);\n    }\n\n    if( zExtra ){\n      sqlite3DbFree(pAccum->db, zExtra);\n      zExtra = 0;\n    }\n  }/* End for loop over the format string */\n} /* End of function */\n\n\n/*\n** The z string points to the first character of a token that is\n** associated with an error.  If db does not already have an error\n** byte offset recorded, try to compute the error byte offset for\n** z and set the error byte offset in db.\n*/\nvoid sqlite3RecordErrorByteOffset(sqlite3 *db, const char *z){\n  const Parse *pParse;\n  const char *zText;\n  const char *zEnd;\n  assert( z!=0 );\n  if( NEVER(db==0) ) return;\n  if( db->errByteOffset!=(-2) ) return;\n  pParse = db->pParse;\n  if( NEVER(pParse==0) ) return;\n  zText =pParse->zTail;\n  if( NEVER(zText==0) ) return;\n  zEnd = &zText[strlen(zText)];\n  if( SQLITE_WITHIN(z,zText,zEnd) ){\n    db->errByteOffset = (int)(z-zText);\n  }\n}\n\n/*\n** If pExpr has a byte offset for the start of a token, record that as\n** as the error offset.\n*/\nvoid sqlite3RecordErrorOffsetOfExpr(sqlite3 *db, const Expr *pExpr){\n  while( pExpr\n     && (ExprHasProperty(pExpr,EP_OuterON|EP_InnerON) || pExpr->w.iOfst<=0)\n  ){\n    pExpr = pExpr->pLeft;\n  }\n  if( pExpr==0 ) return;\n  if( ExprHasProperty(pExpr, EP_FromDDL) ) return;\n  db->errByteOffset = pExpr->w.iOfst;\n}\n\n/*\n** Enlarge the memory allocation on a StrAccum object so that it is\n** able to accept at least N more bytes of text.\n**\n** Return the number of bytes of text that StrAccum is able to accept\n** after the attempted enlargement.  The value returned might be zero.\n*/\nint sqlite3StrAccumEnlarge(StrAccum *p, i64 N){\n  char *zNew;\n  assert( p->nChar+N >= p->nAlloc ); /* Only called if really needed */\n  if( p->accError ){\n    testcase(p->accError==SQLITE_TOOBIG);\n    testcase(p->accError==SQLITE_NOMEM);\n    return 0;\n  }\n  if( p->mxAlloc==0 ){\n    sqlite3StrAccumSetError(p, SQLITE_TOOBIG);\n    return p->nAlloc - p->nChar - 1;\n  }else{\n    char *zOld = isMalloced(p) ? p->zText : 0;\n    i64 szNew = p->nChar + N + 1;\n    if( szNew+p->nChar<=p->mxAlloc ){\n      /* Force exponential buffer size growth as long as it does not overflow,\n      ** to avoid having to call this routine too often */\n      szNew += p->nChar;\n    }\n    if( szNew > p->mxAlloc ){\n      sqlite3_str_reset(p);\n      sqlite3StrAccumSetError(p, SQLITE_TOOBIG);\n      return 0;\n    }else{\n      p->nAlloc = (int)szNew;\n    }\n    if( p->db ){\n      zNew = sqlite3DbRealloc(p->db, zOld, p->nAlloc);\n    }else{\n      zNew = sqlite3Realloc(zOld, p->nAlloc);\n    }\n    if( zNew ){\n      assert( p->zText!=0 || p->nChar==0 );\n      if( !isMalloced(p) && p->nChar>0 ) memcpy(zNew, p->zText, p->nChar);\n      p->zText = zNew;\n      p->nAlloc = sqlite3DbMallocSize(p->db, zNew);\n      p->printfFlags |= SQLITE_PRINTF_MALLOCED;\n    }else{\n      sqlite3_str_reset(p);\n      sqlite3StrAccumSetError(p, SQLITE_NOMEM);\n      return 0;\n    }\n  }\n  assert( N>=0 && N<=0x7fffffff );\n  return (int)N;\n}\n\n/*\n** Append N copies of character c to the given string buffer.\n*/\nvoid sqlite3_str_appendchar(sqlite3_str *p, int N, char c){\n  testcase( p->nChar + (i64)N > 0x7fffffff );\n  if( p->nChar+(i64)N >= p->nAlloc && (N = sqlite3StrAccumEnlarge(p, N))<=0 ){\n    return;\n  }\n  while( (N--)>0 ) p->zText[p->nChar++] = c;\n}\n\n/*\n** The StrAccum \"p\" is not large enough to accept N new bytes of z[].\n** So enlarge if first, then do the append.\n**\n** This is a helper routine to sqlite3_str_append() that does special-case\n** work (enlarging the buffer) using tail recursion, so that the\n** sqlite3_str_append() routine can use fast calling semantics.\n*/\nstatic void SQLITE_NOINLINE enlargeAndAppend(StrAccum *p, const char *z, int N){\n  N = sqlite3StrAccumEnlarge(p, N);\n  if( N>0 ){\n    memcpy(&p->zText[p->nChar], z, N);\n    p->nChar += N;\n  }\n}\n\n/*\n** Append N bytes of text from z to the StrAccum object.  Increase the\n** size of the memory allocation for StrAccum if necessary.\n*/\nvoid sqlite3_str_append(sqlite3_str *p, const char *z, int N){\n  assert( z!=0 || N==0 );\n  assert( p->zText!=0 || p->nChar==0 || p->accError );\n  assert( N>=0 );\n  assert( p->accError==0 || p->nAlloc==0 || p->mxAlloc==0 );\n  if( p->nChar+N >= p->nAlloc ){\n    enlargeAndAppend(p,z,N);\n  }else if( N ){\n    assert( p->zText );\n    p->nChar += N;\n    memcpy(&p->zText[p->nChar-N], z, N);\n  }\n}\n\n/*\n** Append the complete text of zero-terminated string z[] to the p string.\n*/\nvoid sqlite3_str_appendall(sqlite3_str *p, const char *z){\n  sqlite3_str_append(p, z, sqlite3Strlen30(z));\n}\n\n\n/*\n** Finish off a string by making sure it is zero-terminated.\n** Return a pointer to the resulting string.  Return a NULL\n** pointer if any kind of error was encountered.\n*/\nstatic SQLITE_NOINLINE char *strAccumFinishRealloc(StrAccum *p){\n  char *zText;\n  assert( p->mxAlloc>0 && !isMalloced(p) );\n  zText = sqlite3DbMallocRaw(p->db, 1+(u64)p->nChar );\n  if( zText ){\n    memcpy(zText, p->zText, p->nChar+1);\n    p->printfFlags |= SQLITE_PRINTF_MALLOCED;\n  }else{\n    sqlite3StrAccumSetError(p, SQLITE_NOMEM);\n  }\n  p->zText = zText;\n  return zText;\n}\nchar *sqlite3StrAccumFinish(StrAccum *p){\n  if( p->zText ){\n    p->zText[p->nChar] = 0;\n    if( p->mxAlloc>0 && !isMalloced(p) ){\n      return strAccumFinishRealloc(p);\n    }\n  }\n  return p->zText;\n}\n\n/*\n** Use the content of the StrAccum passed as the second argument\n** as the result of an SQL function.\n*/\nvoid sqlite3ResultStrAccum(sqlite3_context *pCtx, StrAccum *p){\n  if( p->accError ){\n    sqlite3_result_error_code(pCtx, p->accError);\n    sqlite3_str_reset(p);\n  }else if( isMalloced(p) ){\n    sqlite3_result_text(pCtx, p->zText, p->nChar, SQLITE_DYNAMIC);\n  }else{\n    sqlite3_result_text(pCtx, \"\", 0, SQLITE_STATIC);\n    sqlite3_str_reset(p);\n  }\n}\n\n/*\n** This singleton is an sqlite3_str object that is returned if\n** sqlite3_malloc() fails to provide space for a real one.  This\n** sqlite3_str object accepts no new text and always returns\n** an SQLITE_NOMEM error.\n*/\nstatic sqlite3_str sqlite3OomStr = {\n   0, 0, 0, 0, 0, SQLITE_NOMEM, 0\n};\n\n/* Finalize a string created using sqlite3_str_new().\n*/\nchar *sqlite3_str_finish(sqlite3_str *p){\n  char *z;\n  if( p!=0 && p!=&sqlite3OomStr ){\n    z = sqlite3StrAccumFinish(p);\n    sqlite3_free(p);\n  }else{\n    z = 0;\n  }\n  return z;\n}\n\n/* Return any error code associated with p */\nint sqlite3_str_errcode(sqlite3_str *p){\n  return p ? p->accError : SQLITE_NOMEM;\n}\n\n/* Return the current length of p in bytes */\nint sqlite3_str_length(sqlite3_str *p){\n  return p ? p->nChar : 0;\n}\n\n/* Truncate the text of the string to be no more than N bytes. */\nvoid sqlite3_str_truncate(sqlite3_str *p, int N){\n  if( p!=0 && N>=0 && (u32)N<p->nChar ){\n    p->nChar = N;\n    p->zText[p->nChar] = 0;\n  }\n}\n\n/* Return the current value for p */\nchar *sqlite3_str_value(sqlite3_str *p){\n  if( p==0 || p->nChar==0 ) return 0;\n  p->zText[p->nChar] = 0;\n  return p->zText;\n}\n\n/*\n** Reset an StrAccum string.  Reclaim all malloced memory.\n*/\nvoid sqlite3_str_reset(StrAccum *p){\n  if( isMalloced(p) ){\n    sqlite3DbFree(p->db, p->zText);\n    p->printfFlags &= ~SQLITE_PRINTF_MALLOCED;\n  }\n  p->nAlloc = 0;\n  p->nChar = 0;\n  p->zText = 0;\n}\n\n/*\n** Destroy a dynamically allocate sqlite3_str object and all\n** of its content, all in one call.\n*/\nvoid sqlite3_str_free(sqlite3_str *p){\n  if( p ){\n    sqlite3_str_reset(p);\n    sqlite3_free(p);\n  }\n}\n\n/*\n** Initialize a string accumulator.\n**\n** p:     The accumulator to be initialized.\n** db:    Pointer to a database connection.  May be NULL.  Lookaside\n**        memory is used if not NULL. db->mallocFailed is set appropriately\n**        when not NULL.\n** zBase: An initial buffer.  May be NULL in which case the initial buffer\n**        is malloced.\n** n:     Size of zBase in bytes.  If total space requirements never exceed\n**        n then no memory allocations ever occur.\n** mx:    Maximum number of bytes to accumulate.  If mx==0 then no memory\n**        allocations will ever occur.\n*/\nvoid sqlite3StrAccumInit(StrAccum *p, sqlite3 *db, char *zBase, int n, int mx){\n  p->zText = zBase;\n  p->db = db;\n  p->nAlloc = n;\n  p->mxAlloc = mx;\n  p->nChar = 0;\n  p->accError = 0;\n  p->printfFlags = 0;\n}\n\n/* Allocate and initialize a new dynamic string object */\nsqlite3_str *sqlite3_str_new(sqlite3 *db){\n  sqlite3_str *p = sqlite3_malloc64(sizeof(*p));\n  if( p ){\n    sqlite3StrAccumInit(p, 0, 0, 0,\n            db ? db->aLimit[SQLITE_LIMIT_LENGTH] : SQLITE_MAX_LENGTH);\n  }else{\n    p = &sqlite3OomStr;\n  }\n  return p;\n}\n\n/*\n** Print into memory obtained from sqliteMalloc().  Use the internal\n** %-conversion extensions.\n*/\nchar *sqlite3VMPrintf(sqlite3 *db, const char *zFormat, va_list ap){\n  char *z;\n  char zBase[SQLITE_PRINT_BUF_SIZE];\n  StrAccum acc;\n  assert( db!=0 );\n  sqlite3StrAccumInit(&acc, db, zBase, sizeof(zBase),\n                      db->aLimit[SQLITE_LIMIT_LENGTH]);\n  acc.printfFlags = SQLITE_PRINTF_INTERNAL;\n  sqlite3_str_vappendf(&acc, zFormat, ap);\n  z = sqlite3StrAccumFinish(&acc);\n  if( acc.accError==SQLITE_NOMEM ){\n    sqlite3OomFault(db);\n  }\n  return z;\n}\n\n/*\n** Print into memory obtained from sqliteMalloc().  Use the internal\n** %-conversion extensions.\n*/\nchar *sqlite3MPrintf(sqlite3 *db, const char *zFormat, ...){\n  va_list ap;\n  char *z;\n  va_start(ap, zFormat);\n  z = sqlite3VMPrintf(db, zFormat, ap);\n  va_end(ap);\n  return z;\n}\n\n/*\n** Print into memory obtained from sqlite3_malloc().  Omit the internal\n** %-conversion extensions.\n*/\nchar *sqlite3_vmprintf(const char *zFormat, va_list ap){\n  char *z;\n  char zBase[SQLITE_PRINT_BUF_SIZE];\n  StrAccum acc;\n\n#ifdef SQLITE_ENABLE_API_ARMOR  \n  if( zFormat==0 ){\n    (void)SQLITE_MISUSE_BKPT;\n    return 0;\n  }\n#endif\n#ifndef SQLITE_OMIT_AUTOINIT\n  if( sqlite3_initialize() ) return 0;\n#endif\n  sqlite3StrAccumInit(&acc, 0, zBase, sizeof(zBase), SQLITE_MAX_LENGTH);\n  sqlite3_str_vappendf(&acc, zFormat, ap);\n  z = sqlite3StrAccumFinish(&acc);\n  return z;\n}\n\n/*\n** Print into memory obtained from sqlite3_malloc()().  Omit the internal\n** %-conversion extensions.\n*/\nchar *sqlite3_mprintf(const char *zFormat, ...){\n  va_list ap;\n  char *z;\n#ifndef SQLITE_OMIT_AUTOINIT\n  if( sqlite3_initialize() ) return 0;\n#endif\n  va_start(ap, zFormat);\n  z = sqlite3_vmprintf(zFormat, ap);\n  va_end(ap);\n  return z;\n}\n\n/*\n** sqlite3_snprintf() works like snprintf() except that it ignores the\n** current locale settings.  This is important for SQLite because we\n** are not able to use a \",\" as the decimal point in place of \".\" as\n** specified by some locales.\n**\n** Oops:  The first two arguments of sqlite3_snprintf() are backwards\n** from the snprintf() standard.  Unfortunately, it is too late to change\n** this without breaking compatibility, so we just have to live with the\n** mistake.\n**\n** sqlite3_vsnprintf() is the varargs version.\n*/\nchar *sqlite3_vsnprintf(int n, char *zBuf, const char *zFormat, va_list ap){\n  StrAccum acc;\n  if( n<=0 ) return zBuf;\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( zBuf==0 || zFormat==0 ) {\n    (void)SQLITE_MISUSE_BKPT;\n    if( zBuf ) zBuf[0] = 0;\n    return zBuf;\n  }\n#endif\n  sqlite3StrAccumInit(&acc, 0, zBuf, n, 0);\n  sqlite3_str_vappendf(&acc, zFormat, ap);\n  zBuf[acc.nChar] = 0;\n  return zBuf;\n}\nchar *sqlite3_snprintf(int n, char *zBuf, const char *zFormat, ...){\n  StrAccum acc;\n  va_list ap;\n  if( n<=0 ) return zBuf;\n#ifdef SQLITE_ENABLE_API_ARMOR\n  if( zBuf==0 || zFormat==0 ) {\n    (void)SQLITE_MISUSE_BKPT;\n    if( zBuf ) zBuf[0] = 0;\n    return zBuf;\n  }\n#endif\n  sqlite3StrAccumInit(&acc, 0, zBuf, n, 0);\n  va_start(ap,zFormat);\n  sqlite3_str_vappendf(&acc, zFormat, ap);\n  va_end(ap);\n  zBuf[acc.nChar] = 0;\n  return zBuf;\n}\n\n/* Maximum size of an sqlite3_log() message. */\n#if defined(SQLITE_MAX_LOG_MESSAGE) \n  /* Leave the definition as supplied */\n#elif SQLITE_PRINT_BUF_SIZE*10>10000\n# define SQLITE_MAX_LOG_MESSAGE 10000\n#else\n# define SQLITE_MAX_LOG_MESSAGE (SQLITE_PRINT_BUF_SIZE*10)\n#endif\n\n/*\n** This is the routine that actually formats the sqlite3_log() message.\n** We house it in a separate routine from sqlite3_log() to avoid using\n** stack space on small-stack systems when logging is disabled.\n**\n** sqlite3_log() must render into a static buffer.  It cannot dynamically\n** allocate memory because it might be called while the memory allocator\n** mutex is held.\n**\n** sqlite3_str_vappendf() might ask for *temporary* memory allocations for\n** certain format characters (%q) or for very large precisions or widths.\n** Care must be taken that any sqlite3_log() calls that occur while the\n** memory mutex is held do not use these mechanisms.\n*/\nstatic void renderLogMsg(int iErrCode, const char *zFormat, va_list ap){\n  StrAccum acc;                          /* String accumulator */\n  char zMsg[SQLITE_MAX_LOG_MESSAGE];     /* Complete log message */\n\n  sqlite3StrAccumInit(&acc, 0, zMsg, sizeof(zMsg), 0);\n  sqlite3_str_vappendf(&acc, zFormat, ap);\n  sqlite3GlobalConfig.xLog(sqlite3GlobalConfig.pLogArg, iErrCode,\n                           sqlite3StrAccumFinish(&acc));\n}\n\n/*\n** Format and write a message to the log if logging is enabled.\n*/\nvoid sqlite3_log(int iErrCode, const char *zFormat, ...){\n  va_list ap;                             /* Vararg list */\n  if( sqlite3GlobalConfig.xLog ){\n    va_start(ap, zFormat);\n    renderLogMsg(iErrCode, zFormat, ap);\n    va_end(ap);\n  }\n}\n\n#if defined(SQLITE_DEBUG) || defined(SQLITE_HAVE_OS_TRACE)\n/*\n** A version of printf() that understands %lld.  Used for debugging.\n** The printf() built into some versions of windows does not understand %lld\n** and segfaults if you give it a long long int.\n*/\nvoid sqlite3DebugPrintf(const char *zFormat, ...){\n  va_list ap;\n  StrAccum acc;\n  char zBuf[SQLITE_PRINT_BUF_SIZE*10];\n  sqlite3StrAccumInit(&acc, 0, zBuf, sizeof(zBuf), 0);\n  va_start(ap,zFormat);\n  sqlite3_str_vappendf(&acc, zFormat, ap);\n  va_end(ap);\n  sqlite3StrAccumFinish(&acc);\n#ifdef SQLITE_OS_TRACE_PROC\n  {\n    extern void SQLITE_OS_TRACE_PROC(const char *zBuf, int nBuf);\n    SQLITE_OS_TRACE_PROC(zBuf, sizeof(zBuf));\n  }\n#else\n  fprintf(stdout,\"%s\", zBuf);\n  fflush(stdout);\n#endif\n}\n#endif\n\n\n/*\n** variable-argument wrapper around sqlite3_str_vappendf(). The bFlags argument\n** can contain the bit SQLITE_PRINTF_INTERNAL enable internal formats.\n*/\nvoid sqlite3_str_appendf(StrAccum *p, const char *zFormat, ...){\n  va_list ap;\n  va_start(ap,zFormat);\n  sqlite3_str_vappendf(p, zFormat, ap);\n  va_end(ap);\n}\n\n\n/*****************************************************************************\n** Reference counted string/blob storage\n*****************************************************************************/\n\n/*\n** Increase the reference count of the string by one.\n**\n** The input parameter is returned.\n*/\nchar *sqlite3RCStrRef(char *z){\n  RCStr *p = (RCStr*)z;\n  assert( p!=0 );\n  p--;\n  p->nRCRef++;\n  return z;\n}\n\n/*\n** Decrease the reference count by one.  Free the string when the\n** reference count reaches zero.\n*/\nvoid sqlite3RCStrUnref(void *z){\n  RCStr *p = (RCStr*)z;\n  assert( p!=0 );\n  p--;\n  assert( p->nRCRef>0 );\n  if( p->nRCRef>=2 ){\n    p->nRCRef--;\n  }else{\n    sqlite3_free(p);\n  }\n}\n\n/*\n** Create a new string that is capable of holding N bytes of text, not counting\n** the zero byte at the end.  The string is uninitialized.\n**\n** The reference count is initially 1.  Call sqlite3RCStrUnref() to free the\n** newly allocated string.\n**\n** This routine returns 0 on an OOM.\n*/\nchar *sqlite3RCStrNew(u64 N){\n  RCStr *p = sqlite3_malloc64( N + sizeof(*p) + 1 );\n  if( p==0 ) return 0;\n  p->nRCRef = 1;\n  return (char*)&p[1];\n}\n\n/*\n** Change the size of the string so that it is able to hold N bytes.\n** The string might be reallocated, so return the new allocation.\n*/\nchar *sqlite3RCStrResize(char *z, u64 N){\n  RCStr *p = (RCStr*)z;\n  RCStr *pNew;\n  assert( p!=0 );\n  p--;\n  assert( p->nRCRef==1 );\n  pNew = sqlite3_realloc64(p, N+sizeof(RCStr)+1);\n  if( pNew==0 ){\n    sqlite3_free(p);\n    return 0;\n  }else{\n    return (char*)&pNew[1];\n  }\n}\n"}
{"repo": "sqlite", "file": "tclsqlite.h", "lang": "C++", "code": "/*\n** 2024-07-30\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This header file defines the interface to TCL as used by SQLite.\n** SQLite subcomponents that use TCL (the libsqlite3.c interface library\n** and various test*.c pieces) should #include this file rather than\n** including tcl.h directly.\n*/\n/******  Any edits to this file must mirrored in tclsqlite.c ***********/\n\n/* When compiling for Windows using STDCALL instead of CDECL calling\n** conventions, the MSVC makefile has to build a customized version of\n** the \"tcl.h\" header that specifies the calling conventions for each\n** interface.  That customized \"tcl.h\" is named \"sqlite_tcl.h\".\n*/\n#if defined(INCLUDE_SQLITE_TCL_H)\n# include \"sqlite_tcl.h\"   /* Special case for Windows using STDCALL */\n#else\n# include <tcl.h>          /* All normal cases */\n# ifndef SQLITE_TCLAPI\n#   define SQLITE_TCLAPI\n# endif\n#endif\n\n/******  Any edits to this file must mirrored in tclsqlite.c ***********/\n\n/* Compatibility between Tcl8.6 and Tcl9.0 */\n#if TCL_MAJOR_VERSION==9\n# define CONST const\n#elif !defined(Tcl_Size)\n# define Tcl_Size int\n#endif\n\n/******  Any edits to this file must mirrored in tclsqlite.c ***********/\n"}
{"repo": "sqlite", "file": "test_bestindex.c", "lang": "C++", "code": "/*\n** 2016-03-01\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** Code for testing the virtual table xBestIndex method and the query\n** planner.\n*/\n\n\n/*\n** INSTRUCTIONS\n**\n** This module exports a single tcl command - [register_tcl_module]. When\n** invoked, it registers a special virtual table module with a database\n** connection.\n**\n** The virtual table is currently read-only. And always returns zero rows.\n** It is created with a single argument - the name of a Tcl command - as\n** follows:\n**\n**   CREATE VIRTUAL TABLE x1 USING tcl(tcl_command);\n**\n** The command [tcl_command] is invoked when the table is first created (or\n** connected), when the xBestIndex() method is invoked and when the xFilter()\n** method is called. When it is created (or connected), it is invoked as\n** follows:\n**\n**   tcl_command xConnect\n**\n** In this case the return value of the script is passed to the\n** sqlite3_declare_vtab() function to create the virtual table schema.\n**\n** When the xBestIndex() method is called by SQLite, the Tcl command is\n** invoked as:\n**\n**   tcl_command xBestIndex CONSTRAINTS ORDERBY MASK\n**\n** where CONSTRAINTS is a tcl representation of the aConstraints[] array,\n** ORDERBY is a representation of the contents of the aOrderBy[] array and\n** MASK is a copy of sqlite3_index_info.colUsed. For example if the virtual\n** table is declared as:\n**\n**   CREATE TABLE x1(a, b, c)\n**\n** and the query is:\n**\n**   SELECT * FROM x1 WHERE a=? AND c<? ORDER BY b, c;\n**\n** then the Tcl command is:\n**\n**   tcl_command xBestIndex                                  \\\n**     {{op eq column 0 usable 1} {op lt column 2 usable 1}} \\\n**     {{column 1 desc 0} {column 2 desc 0}}                 \\\n**     7\n**\n** The return value of the script is a list of key-value pairs used to\n** populate the output fields of the sqlite3_index_info structure. Possible\n** keys and the usage of the accompanying values are:\n** \n**   \"orderby\"          (value of orderByConsumed flag)\n**   \"cost\"             (value of estimatedCost field)\n**   \"rows\"             (value of estimatedRows field)\n**   \"use\"              (index of used constraint in aConstraint[])\n**   \"omit\"             (like \"use\", but also sets omit flag)\n**   \"idxnum\"           (value of idxNum field)\n**   \"idxstr\"           (value of idxStr field)\n**\n** Refer to code below for further details.\n**\n** When SQLite calls the xFilter() method, this module invokes the following\n** Tcl script:\n**\n**   tcl_command xFilter IDXNUM IDXSTR ARGLIST\n**\n** IDXNUM and IDXSTR are the values of the idxNum and idxStr parameters\n** passed to xFilter. ARGLIST is a Tcl list containing each of the arguments\n** passed to xFilter in text form.\n**\n** As with xBestIndex(), the return value of the script is interpreted as a\n** list of key-value pairs. There is currently only one key defined - \"sql\".\n** The value must be the full text of an SQL statement that returns the data\n** for the current scan. The leftmost column returned by the SELECT is assumed\n** to contain the rowid. Other columns must follow, in order from left to\n** right.\n*/\n\n\n#include \"sqliteInt.h\"\n#include \"tclsqlite.h\"\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n\n\ntypedef struct tcl_vtab tcl_vtab;\ntypedef struct tcl_cursor tcl_cursor;\ntypedef struct TestFindFunction TestFindFunction;\ntypedef struct TestVtabContext TestVtabContext;\n\n/* \n** A fs virtual-table object \n*/\nstruct tcl_vtab {\n  sqlite3_vtab base;\n  Tcl_Interp *interp;\n  Tcl_Obj *pCmd;\n  TestFindFunction *pFindFunctionList;\n  sqlite3 *db;\n};\n\n/* A tcl cursor object */\nstruct tcl_cursor {\n  sqlite3_vtab_cursor base;\n  sqlite3_stmt *pStmt;            /* Read data from here */\n};\n\nstruct TestFindFunction {\n  tcl_vtab *pTab;\n  const char *zName;\n  TestFindFunction *pNext;\n};\n\nstruct TestVtabContext {\n  Tcl_Interp *interp;\n  Tcl_Obj *pDefault;\n};\n\n/*\n** Dequote string z in place.\n*/\nstatic void tclDequote(char *z){\n  char q = z[0];\n\n  /* Set stack variable q to the close-quote character */\n  if( q=='[' || q=='\\'' || q=='\"' || q=='`' ){\n    int iIn = 1;\n    int iOut = 0;\n    if( q=='[' ) q = ']';  \n\n    while( ALWAYS(z[iIn]) ){\n      if( z[iIn]==q ){\n        if( z[iIn+1]!=q ){\n          /* Character iIn was the close quote. */\n          iIn++;\n          break;\n        }else{\n          /* Character iIn and iIn+1 form an escaped quote character. Skip\n          ** the input cursor past both and copy a single quote character \n          ** to the output buffer. */\n          iIn += 2;\n          z[iOut++] = q;\n        }\n      }else{\n        z[iOut++] = z[iIn++];\n      }\n    }\n\n    z[iOut] = '\\0';\n  }\n}\n\n/*\n** This function is the implementation of both the xConnect and xCreate\n** methods of the fs virtual table.\n**\n** The argv[] array contains the following:\n**\n**   argv[0]   -> module name  (\"fs\")\n**   argv[1]   -> database name\n**   argv[2]   -> table name\n**   argv[...] -> other module argument fields.\n*/\nstatic int tclConnect(\n  sqlite3 *db,\n  void *pAux,\n  int argc, const char *const*argv,\n  sqlite3_vtab **ppVtab,\n  char **pzErr\n){\n  TestVtabContext *pCtx = (TestVtabContext*)pAux;\n  Tcl_Interp *interp = pCtx->interp;\n  tcl_vtab *pTab = 0;\n  char *zCmd = 0;\n  Tcl_Obj *pScript = 0;\n  int rc = SQLITE_OK;\n\n  if( argc!=4 && (argc!=3 || pCtx->pDefault==0) ){\n    *pzErr = sqlite3_mprintf(\"wrong number of arguments\");\n    return SQLITE_ERROR;\n  }\n\n  if( argc==4 ){\n    zCmd = sqlite3_malloc64(strlen(argv[3])+1);\n  }\n  pTab = (tcl_vtab*)sqlite3_malloc64(sizeof(tcl_vtab));\n  if( (zCmd || argc==3) && pTab ){\n    memset(pTab, 0, sizeof(tcl_vtab));\n\n    if( zCmd ){\n      memcpy(zCmd, argv[3], strlen(argv[3])+1);\n      tclDequote(zCmd);\n      pTab->pCmd = Tcl_NewStringObj(zCmd, -1);\n    }else{\n      pTab->pCmd = Tcl_DuplicateObj(pCtx->pDefault);\n    }\n\n    pTab->interp = interp;\n    pTab->db = db;\n    Tcl_IncrRefCount(pTab->pCmd);\n\n    pScript = Tcl_DuplicateObj(pTab->pCmd);\n    Tcl_IncrRefCount(pScript);\n    Tcl_ListObjAppendElement(interp, pScript, Tcl_NewStringObj(\"xConnect\", -1));\n\n    rc = Tcl_EvalObjEx(interp, pScript, TCL_EVAL_GLOBAL);\n    if( rc!=TCL_OK ){\n      *pzErr = sqlite3_mprintf(\"%s\", Tcl_GetStringResult(interp));\n      if( sqlite3_stricmp(*pzErr, \"database schema has changed\")==0 ){\n        rc = SQLITE_SCHEMA;\n      }else{\n        rc = SQLITE_ERROR;\n      }\n    }else{\n      rc = sqlite3_declare_vtab(db, Tcl_GetStringResult(interp));\n      if( rc!=SQLITE_OK ){\n        *pzErr = sqlite3_mprintf(\"declare_vtab: %s\", sqlite3_errmsg(db));\n      }\n    }\n\n    if( rc!=SQLITE_OK ){\n      sqlite3_free(pTab);\n      pTab = 0;\n    }\n  }else{\n    rc = SQLITE_NOMEM;\n  }\n\n  sqlite3_free(zCmd);\n  *ppVtab = pTab ? &pTab->base : 0;\n  return rc;\n}\n\n/* The xDisconnect and xDestroy methods are also the same */\nstatic int tclDisconnect(sqlite3_vtab *pVtab){\n  tcl_vtab *pTab = (tcl_vtab*)pVtab;\n  while( pTab->pFindFunctionList ){\n    TestFindFunction *p = pTab->pFindFunctionList;\n    pTab->pFindFunctionList = p->pNext;\n    sqlite3_free(p);\n  }\n  Tcl_DecrRefCount(pTab->pCmd);\n  sqlite3_free(pTab);\n  return SQLITE_OK;\n}\n\n/*\n** Open a new tcl cursor.\n*/\nstatic int tclOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){\n  tcl_cursor *pCur;\n  pCur = sqlite3_malloc(sizeof(tcl_cursor));\n  if( pCur==0 ) return SQLITE_NOMEM;\n  memset(pCur, 0, sizeof(tcl_cursor));\n  *ppCursor = &pCur->base;\n  return SQLITE_OK;\n}\n\n/*\n** Close a tcl cursor.\n*/\nstatic int tclClose(sqlite3_vtab_cursor *cur){\n  tcl_cursor *pCur = (tcl_cursor *)cur;\n  if( pCur ){\n    sqlite3_finalize(pCur->pStmt);\n    sqlite3_free(pCur);\n  }\n  return SQLITE_OK;\n}\n\nstatic int tclNext(sqlite3_vtab_cursor *pVtabCursor){\n  tcl_cursor *pCsr = (tcl_cursor*)pVtabCursor;\n  if( pCsr->pStmt ){\n    tcl_vtab *pTab = (tcl_vtab*)(pVtabCursor->pVtab);\n    int rc = sqlite3_step(pCsr->pStmt);\n    if( rc!=SQLITE_ROW ){\n      const char *zErr;\n      rc = sqlite3_finalize(pCsr->pStmt);\n      pCsr->pStmt = 0;\n      if( rc!=SQLITE_OK ){\n        zErr = sqlite3_errmsg(pTab->db);\n        pTab->base.zErrMsg = sqlite3_mprintf(\"%s\", zErr);\n      }\n    }\n  }\n  return SQLITE_OK;\n}\n\nstatic int tclFilter(\n  sqlite3_vtab_cursor *pVtabCursor, \n  int idxNum, const char *idxStr,\n  int argc, sqlite3_value **argv\n){\n  tcl_cursor *pCsr = (tcl_cursor*)pVtabCursor;\n  tcl_vtab *pTab = (tcl_vtab*)(pVtabCursor->pVtab);\n  Tcl_Interp *interp = pTab->interp;\n  Tcl_Obj *pScript;\n  Tcl_Obj *pArg;\n  int ii;\n  int rc;\n\n  pScript = Tcl_DuplicateObj(pTab->pCmd);\n  Tcl_IncrRefCount(pScript);\n  Tcl_ListObjAppendElement(interp, pScript, Tcl_NewStringObj(\"xFilter\", -1));\n  Tcl_ListObjAppendElement(interp, pScript, Tcl_NewIntObj(idxNum));\n  Tcl_ListObjAppendElement(\n      interp, pScript, Tcl_NewStringObj(idxStr ? idxStr : \"\", -1)\n  );\n\n  pArg = Tcl_NewObj();\n  Tcl_IncrRefCount(pArg);\n  for(ii=0; ii<argc; ii++){\n    const char *zVal = (const char*)sqlite3_value_text(argv[ii]);\n    Tcl_Obj *pVal;\n    if( zVal==0 ){\n      sqlite3_value *pMem;\n      pVal = Tcl_NewObj();\n      for(rc=sqlite3_vtab_in_first(argv[ii], &pMem); \n          rc==SQLITE_OK && pMem;\n          rc=sqlite3_vtab_in_next(argv[ii], &pMem)\n      ){\n        Tcl_Obj *pVal2 = 0;\n        zVal = (const char*)sqlite3_value_text(pMem);\n        if( zVal ){\n          pVal2 = Tcl_NewStringObj(zVal, -1);\n        }else{\n          pVal2 = Tcl_NewObj();\n        }\n        Tcl_ListObjAppendElement(interp, pVal, pVal2);\n      }\n    }else{\n      pVal = Tcl_NewStringObj(zVal, -1);\n    }\n    Tcl_ListObjAppendElement(interp, pArg, pVal);\n  }\n  Tcl_ListObjAppendElement(interp, pScript, pArg);\n  Tcl_DecrRefCount(pArg);\n\n  rc = Tcl_EvalObjEx(interp, pScript, TCL_EVAL_GLOBAL);\n  if( rc!=TCL_OK ){\n    const char *zErr = Tcl_GetStringResult(interp);\n    rc = SQLITE_ERROR;\n    pTab->base.zErrMsg = sqlite3_mprintf(\"%s\", zErr);\n  }else{\n    /* Analyze the scripts return value. The return value should be a tcl \n    ** list object with an even number of elements. The first element of each\n    ** pair must be one of:\n    ** \n    **   \"sql\"          (SQL statement to return data)\n    */\n    Tcl_Obj *pRes = Tcl_GetObjResult(interp);\n    Tcl_Obj **apElem = 0;\n    Tcl_Size nElem;\n    rc = Tcl_ListObjGetElements(interp, pRes, &nElem, &apElem);\n    if( rc!=TCL_OK ){\n      const char *zErr = Tcl_GetStringResult(interp);\n      rc = SQLITE_ERROR;\n      pTab->base.zErrMsg = sqlite3_mprintf(\"%s\", zErr);\n    }else{\n      for(ii=0; rc==SQLITE_OK && ii<(int)nElem; ii+=2){\n        const char *zCmd = Tcl_GetString(apElem[ii]);\n        Tcl_Obj *p = apElem[ii+1];\n        if( sqlite3_stricmp(\"sql\", zCmd)==0 ){\n          const char *zSql = Tcl_GetString(p);\n          rc = sqlite3_prepare_v2(pTab->db, zSql, -1, &pCsr->pStmt, 0);\n          if( rc!=SQLITE_OK ){\n            const char *zErr = sqlite3_errmsg(pTab->db);\n            pTab->base.zErrMsg = sqlite3_mprintf(\"unexpected: %s\", zErr);\n          }\n        }else{\n          rc = SQLITE_ERROR;\n          pTab->base.zErrMsg = sqlite3_mprintf(\"unexpected: %s\", zCmd);\n        }\n      }\n    }\n  }\n\n  if( rc==SQLITE_OK ){\n    rc = tclNext(pVtabCursor);\n  }\n  return rc;\n}\n\nstatic int tclColumn(\n  sqlite3_vtab_cursor *pVtabCursor, \n  sqlite3_context *ctx, \n  int i\n){\n  tcl_cursor *pCsr = (tcl_cursor*)pVtabCursor;\n  sqlite3_result_value(ctx, sqlite3_column_value(pCsr->pStmt, i+1));\n  return SQLITE_OK;\n}\n\nstatic int tclRowid(sqlite3_vtab_cursor *pVtabCursor, sqlite_int64 *pRowid){\n  tcl_cursor *pCsr = (tcl_cursor*)pVtabCursor;\n  *pRowid = sqlite3_column_int64(pCsr->pStmt, 0);\n  return SQLITE_OK;\n}\n\nstatic int tclEof(sqlite3_vtab_cursor *pVtabCursor){\n  tcl_cursor *pCsr = (tcl_cursor*)pVtabCursor;\n  return (pCsr->pStmt==0);\n}\n\nstatic void testBestIndexObjConstraints(\n  Tcl_Interp *interp, \n  sqlite3_index_info *pIdxInfo\n){\n  int ii;\n  Tcl_Obj *pRes = Tcl_NewObj();\n  Tcl_IncrRefCount(pRes);\n  for(ii=0; ii<pIdxInfo->nConstraint; ii++){\n    struct sqlite3_index_constraint const *pCons = &pIdxInfo->aConstraint[ii];\n    Tcl_Obj *pElem = Tcl_NewObj();\n    const char *zOp = 0;\n\n    Tcl_IncrRefCount(pElem);\n\n    switch( pCons->op ){\n      case SQLITE_INDEX_CONSTRAINT_EQ:\n        zOp = \"eq\"; break;\n      case SQLITE_INDEX_CONSTRAINT_GT:\n        zOp = \"gt\"; break;\n      case SQLITE_INDEX_CONSTRAINT_LE:\n        zOp = \"le\"; break;\n      case SQLITE_INDEX_CONSTRAINT_LT:\n        zOp = \"lt\"; break;\n      case SQLITE_INDEX_CONSTRAINT_GE:\n        zOp = \"ge\"; break;\n      case SQLITE_INDEX_CONSTRAINT_MATCH:\n        zOp = \"match\"; break;\n      case SQLITE_INDEX_CONSTRAINT_LIKE:\n        zOp = \"like\"; break;\n      case SQLITE_INDEX_CONSTRAINT_GLOB:\n        zOp = \"glob\"; break;\n      case SQLITE_INDEX_CONSTRAINT_REGEXP:\n        zOp = \"regexp\"; break;\n      case SQLITE_INDEX_CONSTRAINT_NE:\n        zOp = \"ne\"; break;\n      case SQLITE_INDEX_CONSTRAINT_ISNOT:\n        zOp = \"isnot\"; break;\n      case SQLITE_INDEX_CONSTRAINT_ISNOTNULL:\n        zOp = \"isnotnull\"; break;\n      case SQLITE_INDEX_CONSTRAINT_ISNULL:\n        zOp = \"isnull\"; break;\n      case SQLITE_INDEX_CONSTRAINT_IS:\n        zOp = \"is\"; break;\n      case SQLITE_INDEX_CONSTRAINT_LIMIT:\n        zOp = \"limit\"; break;\n      case SQLITE_INDEX_CONSTRAINT_OFFSET:\n        zOp = \"offset\"; break;\n    }\n\n    Tcl_ListObjAppendElement(0, pElem, Tcl_NewStringObj(\"op\", -1));\n    if( zOp ){\n      Tcl_ListObjAppendElement(0, pElem, Tcl_NewStringObj(zOp, -1));\n    }else{\n      Tcl_ListObjAppendElement(0, pElem, Tcl_NewIntObj(pCons->op));\n    }\n    Tcl_ListObjAppendElement(0, pElem, Tcl_NewStringObj(\"column\", -1));\n    Tcl_ListObjAppendElement(0, pElem, Tcl_NewIntObj(pCons->iColumn));\n    Tcl_ListObjAppendElement(0, pElem, Tcl_NewStringObj(\"usable\", -1));\n    Tcl_ListObjAppendElement(0, pElem, Tcl_NewIntObj(pCons->usable));\n\n    Tcl_ListObjAppendElement(0, pRes, pElem);\n    Tcl_DecrRefCount(pElem);\n  }\n\n  Tcl_SetObjResult(interp, pRes);\n  Tcl_DecrRefCount(pRes);\n}\n\nstatic void testBestIndexObjOrderby(\n  Tcl_Interp *interp, \n  sqlite3_index_info *pIdxInfo\n){\n  int ii;\n  Tcl_Obj *pRes = Tcl_NewObj();\n  Tcl_IncrRefCount(pRes);\n  for(ii=0; ii<pIdxInfo->nOrderBy; ii++){\n    struct sqlite3_index_orderby const *pOrder = &pIdxInfo->aOrderBy[ii];\n    Tcl_Obj *pElem = Tcl_NewObj();\n    Tcl_IncrRefCount(pElem);\n\n    Tcl_ListObjAppendElement(0, pElem, Tcl_NewStringObj(\"column\", -1));\n    Tcl_ListObjAppendElement(0, pElem, Tcl_NewIntObj(pOrder->iColumn));\n    Tcl_ListObjAppendElement(0, pElem, Tcl_NewStringObj(\"desc\", -1));\n    Tcl_ListObjAppendElement(0, pElem, Tcl_NewIntObj(pOrder->desc));\n\n    Tcl_ListObjAppendElement(0, pRes, pElem);\n    Tcl_DecrRefCount(pElem);\n  }\n\n  Tcl_SetObjResult(interp, pRes);\n  Tcl_DecrRefCount(pRes);\n}\n\n/*\n** Implementation of the handle passed to each xBestIndex callback. This\n** object features the following sub-commands:\n**\n**    $hdl constraints\n**    $hdl orderby\n**    $hdl mask\n**\n**    $hdl distinct\n**      Return the result (an integer) of calling sqlite3_vtab_distinct()\n**      on the index-info structure.\n**\n**    $hdl in IDX BOOLEAN\n**      Wrapper around sqlite3_vtab_in(). Returns an integer.\n**\n**    $hdl rhs_value IDX ?DEFAULT?\n**      Wrapper around sqlite3_vtab_rhs_value().\n*/\nstatic int SQLITE_TCLAPI testBestIndexObj(\n  ClientData clientData, /* Pointer to sqlite3_enable_XXX function */\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int objc,              /* Number of arguments */\n  Tcl_Obj *CONST objv[]  /* Command arguments */\n){\n  const char *azSub[] = {\n    \"constraints\",                /* 0 */\n    \"orderby\",                    /* 1 */\n    \"mask\",                       /* 2 */\n    \"distinct\",                   /* 3 */\n    \"in\",                         /* 4 */\n    \"rhs_value\",                  /* 5 */\n    \"collation\",                  /* 6 */\n    0\n  };\n  int ii;\n  sqlite3_index_info *pIdxInfo = (sqlite3_index_info*)clientData;\n\n  if( objc<2 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"SUB-COMMAND\");\n    return TCL_ERROR;\n  }\n  if( Tcl_GetIndexFromObj(interp, objv[1], azSub, \"sub-command\", 0, &ii) ){\n    return TCL_ERROR;\n  }\n\n  if( ii<4 && objc!=2 ){\n    Tcl_WrongNumArgs(interp, 2, objv, \"\");\n    return TCL_ERROR;\n  }\n  if( ii==4 && objc!=4 ){\n    Tcl_WrongNumArgs(interp, 2, objv, \"INDEX BOOLEAN\");\n    return TCL_ERROR;\n  }\n  if( ii==5 && objc!=3 && objc!=4 ){\n    Tcl_WrongNumArgs(interp, 2, objv, \"INDEX ?DEFAULT?\");\n    return TCL_ERROR;\n  }\n\n  switch( ii ){\n    case 0: assert( sqlite3_stricmp(azSub[ii], \"constraints\")==0 );\n      testBestIndexObjConstraints(interp, pIdxInfo);\n      break;\n\n    case 1: assert( sqlite3_stricmp(azSub[ii], \"orderby\")==0 );\n      testBestIndexObjOrderby(interp, pIdxInfo);\n      break;\n\n    case 2: assert( sqlite3_stricmp(azSub[ii], \"mask\")==0 );\n      Tcl_SetObjResult(interp, Tcl_NewWideIntObj(pIdxInfo->colUsed));\n      break;\n\n    case 3: assert( sqlite3_stricmp(azSub[ii], \"distinct\")==0 ); {\n      int bDistinct = sqlite3_vtab_distinct(pIdxInfo);\n      Tcl_SetObjResult(interp, Tcl_NewIntObj(bDistinct));\n      break;\n    }\n\n    case 4: assert( sqlite3_stricmp(azSub[ii], \"in\")==0 ); {\n      int iCons;\n      int bHandle;\n      if( Tcl_GetIntFromObj(interp, objv[2], &iCons) \n       || Tcl_GetBooleanFromObj(interp, objv[3], &bHandle) \n      ){\n        return TCL_ERROR;\n      }\n      Tcl_SetObjResult(interp, \n          Tcl_NewIntObj(sqlite3_vtab_in(pIdxInfo, iCons, bHandle))\n      );\n      break;\n    }\n\n    case 5: assert( sqlite3_stricmp(azSub[ii], \"rhs_value\")==0 ); {\n      int iCons = 0;\n      int rc;\n      sqlite3_value *pVal = 0;\n      const char *zVal = \"\";\n      if( Tcl_GetIntFromObj(interp, objv[2], &iCons) ){\n        return TCL_ERROR;\n      }\n      rc = sqlite3_vtab_rhs_value(pIdxInfo, iCons, &pVal);\n      if( rc!=SQLITE_OK && rc!=SQLITE_NOTFOUND ){\n        Tcl_SetResult(interp, (char *)sqlite3ErrName(rc), TCL_VOLATILE);\n        return TCL_ERROR;\n      }\n      if( pVal ){\n        zVal = (const char*)sqlite3_value_text(pVal);\n      }else if( objc==4 ){\n        zVal = Tcl_GetString(objv[3]);\n      }\n      Tcl_SetObjResult(interp, Tcl_NewStringObj(zVal, -1));\n      break;\n    }\n\n    case 6: assert( sqlite3_stricmp(azSub[ii], \"collation\")==0 ); {\n      int iCons = 0;\n      const char *zColl = \"\";\n      if( Tcl_GetIntFromObj(interp, objv[2], &iCons) ){\n        return TCL_ERROR;\n      }\n      zColl = sqlite3_vtab_collation(pIdxInfo, iCons);\n      Tcl_SetObjResult(interp, Tcl_NewStringObj(zColl, -1));\n      break;\n    }\n  }\n\n  return TCL_OK;\n}\n\nstatic int tclBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){\n  tcl_vtab *pTab = (tcl_vtab*)tab;\n  Tcl_Interp *interp = pTab->interp;\n  int rc = SQLITE_OK;\n\n  static int iNext = 43;\n  char zHdl[24];\n  Tcl_Obj *pScript;\n\n  pScript = Tcl_DuplicateObj(pTab->pCmd);\n  Tcl_IncrRefCount(pScript);\n  Tcl_ListObjAppendElement(interp, pScript, Tcl_NewStringObj(\"xBestIndex\", -1));\n\n  sqlite3_snprintf(sizeof(zHdl), zHdl, \"bestindex%d\", iNext++);\n  Tcl_CreateObjCommand(interp, zHdl, testBestIndexObj, pIdxInfo, 0);\n  Tcl_ListObjAppendElement(interp, pScript, Tcl_NewStringObj(zHdl, -1));\n  rc = Tcl_EvalObjEx(interp, pScript, TCL_EVAL_GLOBAL);\n  Tcl_DeleteCommand(interp, zHdl);\n  Tcl_DecrRefCount(pScript);\n\n  if( rc!=TCL_OK ){\n    const char *zErr = Tcl_GetStringResult(interp);\n    rc = SQLITE_ERROR;\n    pTab->base.zErrMsg = sqlite3_mprintf(\"%s\", zErr);\n  }else{\n    /* Analyze the scripts return value. The return value should be a tcl \n    ** list object with an even number of elements. The first element of each\n    ** pair must be one of:\n    ** \n    **   \"orderby\"          (value of orderByConsumed flag)\n    **   \"cost\"             (value of estimatedCost field)\n    **   \"rows\"             (value of estimatedRows field)\n    **   \"use\"              (index of used constraint in aConstraint[])\n    **   \"idxnum\"           (value of idxNum field)\n    **   \"idxstr\"           (value of idxStr field)\n    **   \"omit\"             (index of omitted constraint in aConstraint[])\n    */\n    Tcl_Obj *pRes = Tcl_GetObjResult(interp);\n    Tcl_Obj **apElem = 0;\n    Tcl_Size nElem;\n    rc = Tcl_ListObjGetElements(interp, pRes, &nElem, &apElem);\n    if( rc!=TCL_OK ){\n      const char *zErr = Tcl_GetStringResult(interp);\n      rc = SQLITE_ERROR;\n      pTab->base.zErrMsg = sqlite3_mprintf(\"%s\", zErr);\n    }else{\n      int ii;\n      int iArgv = 1;\n      for(ii=0; rc==SQLITE_OK && ii<(int)nElem; ii+=2){\n        const char *zCmd = Tcl_GetString(apElem[ii]);\n        Tcl_Obj *p = apElem[ii+1];\n        if( sqlite3_stricmp(\"cost\", zCmd)==0 ){\n          rc = Tcl_GetDoubleFromObj(interp, p, &pIdxInfo->estimatedCost);\n        }else\n        if( sqlite3_stricmp(\"orderby\", zCmd)==0 ){\n          rc = Tcl_GetIntFromObj(interp, p, &pIdxInfo->orderByConsumed);\n        }else\n        if( sqlite3_stricmp(\"idxnum\", zCmd)==0 ){\n          rc = Tcl_GetIntFromObj(interp, p, &pIdxInfo->idxNum);\n        }else\n        if( sqlite3_stricmp(\"idxstr\", zCmd)==0 ){\n          sqlite3_free(pIdxInfo->idxStr);\n          pIdxInfo->idxStr = sqlite3_mprintf(\"%s\", Tcl_GetString(p));\n          pIdxInfo->needToFreeIdxStr = 1;\n        }else\n        if( sqlite3_stricmp(\"rows\", zCmd)==0 ){\n          Tcl_WideInt x = 0;\n          rc = Tcl_GetWideIntFromObj(interp, p, &x);\n          pIdxInfo->estimatedRows = (tRowcnt)x;\n        }else\n        if( sqlite3_stricmp(\"use\", zCmd)==0 \n         || sqlite3_stricmp(\"omit\", zCmd)==0 \n        ){\n          int iCons;\n          rc = Tcl_GetIntFromObj(interp, p, &iCons);\n          if( rc==SQLITE_OK ){\n            if( iCons<0 || iCons>=pIdxInfo->nConstraint ){\n              rc = SQLITE_ERROR;\n              pTab->base.zErrMsg = sqlite3_mprintf(\"unexpected: %d\", iCons);\n            }else{\n              int bOmit = (zCmd[0]=='o' || zCmd[0]=='O');\n              pIdxInfo->aConstraintUsage[iCons].argvIndex = iArgv++;\n              pIdxInfo->aConstraintUsage[iCons].omit = bOmit;\n            }\n          }\n        }else\n        if( sqlite3_stricmp(\"constraint\", zCmd)==0 ){\n          rc = SQLITE_CONSTRAINT;\n          pTab->base.zErrMsg = sqlite3_mprintf(\"%s\", Tcl_GetString(p));\n        }else{\n          rc = SQLITE_ERROR;\n          pTab->base.zErrMsg = sqlite3_mprintf(\"unexpected: %s\", zCmd);\n        }\n        if( rc!=SQLITE_OK && pTab->base.zErrMsg==0 ){\n          const char *zErr = Tcl_GetStringResult(interp);\n          pTab->base.zErrMsg = sqlite3_mprintf(\"%s\", zErr);\n        }\n      }\n    }\n  }\n\n  return rc;\n}\n\nstatic void tclFunction(sqlite3_context *pCtx, int nArg, sqlite3_value **apArg){\n  TestFindFunction *p = (TestFindFunction*)sqlite3_user_data(pCtx);\n  Tcl_Interp *interp = p->pTab->interp;\n  Tcl_Obj *pScript = 0;\n  Tcl_Obj *pRet = 0;\n  int ii;\n\n  pScript = Tcl_DuplicateObj(p->pTab->pCmd);\n  Tcl_IncrRefCount(pScript);\n  Tcl_ListObjAppendElement(interp, pScript, Tcl_NewStringObj(\"function\", -1));\n  Tcl_ListObjAppendElement(interp, pScript, Tcl_NewStringObj(p->zName, -1));\n\n  for(ii=0; ii<nArg; ii++){\n    const char *zArg = (const char*)sqlite3_value_text(apArg[ii]);\n    Tcl_ListObjAppendElement(interp, pScript,\n        (zArg ? Tcl_NewStringObj(zArg, -1) : Tcl_NewObj())\n    );\n  }\n  Tcl_EvalObjEx(interp, pScript, TCL_EVAL_GLOBAL);\n  Tcl_DecrRefCount(pScript);\n\n  pRet = Tcl_GetObjResult(interp);\n  sqlite3_result_text(pCtx, Tcl_GetString(pRet), -1, SQLITE_TRANSIENT);\n}\n\nstatic int tclFindFunction(\n  sqlite3_vtab *tab, \n  int nArg, \n  const char *zName,\n  void (**pxFunc)(sqlite3_context*,int,sqlite3_value**),   /* OUT */\n  void **ppArg                                             /* OUT */\n){\n  int iRet = 0;\n  tcl_vtab *pTab = (tcl_vtab*)tab;\n  Tcl_Interp *interp = pTab->interp;\n  Tcl_Obj *pScript = 0;\n  int rc = SQLITE_OK;\n\n  pScript = Tcl_DuplicateObj(pTab->pCmd);\n  Tcl_IncrRefCount(pScript);\n  Tcl_ListObjAppendElement(\n      interp, pScript, Tcl_NewStringObj(\"xFindFunction\", -1)\n  );\n  Tcl_ListObjAppendElement(interp, pScript, Tcl_NewIntObj(nArg));\n  Tcl_ListObjAppendElement(interp, pScript, Tcl_NewStringObj(zName, -1));\n  rc = Tcl_EvalObjEx(interp, pScript, TCL_EVAL_GLOBAL);\n  Tcl_DecrRefCount(pScript);\n\n  if( rc==SQLITE_OK ){\n    Tcl_Obj *pObj = Tcl_GetObjResult(interp);\n\n    if( Tcl_GetIntFromObj(interp, pObj, &iRet) ){\n      rc = SQLITE_ERROR;\n    }else if( iRet>0 ){\n      sqlite3_int64 nName = strlen(zName);\n      sqlite3_int64 nByte = nName + 1 + sizeof(TestFindFunction);\n      TestFindFunction *pNew = 0;\n\n      pNew = (TestFindFunction*)sqlite3_malloc64(nByte);\n      if( pNew==0 ){\n        iRet = 0;\n      }else{\n        memset(pNew, 0, nByte);\n        pNew->zName = (const char*)&pNew[1];\n        memcpy((char*)pNew->zName, zName, nName);\n        pNew->pTab = pTab;\n        pNew->pNext = pTab->pFindFunctionList;\n        pTab->pFindFunctionList = pNew;\n        *ppArg = (void*)pNew;\n        *pxFunc = tclFunction;\n      }\n    }\n  }\n\n  return iRet;\n}\n\nstatic int tclUpdate(\n  sqlite3_vtab *tab, \n  int nArg, \n  sqlite3_value **apVal, \n  sqlite3_int64 *piRowid\n){\n  tcl_vtab *pTab = (tcl_vtab*)tab;\n  Tcl_Interp *interp = pTab->interp; \n  Tcl_Obj *pEval = Tcl_DuplicateObj(pTab->pCmd);\n  int rc = TCL_OK;\n\n  Tcl_IncrRefCount(pEval);\n  Tcl_ListObjAppendElement(interp, pEval, Tcl_NewStringObj(\"xUpdate\",-1));\n\n  rc = Tcl_EvalObjEx(interp, pEval, TCL_EVAL_GLOBAL);\n  Tcl_DecrRefCount(pEval);\n\n  if( rc==TCL_OK ){\n    Tcl_Obj *pRes = Tcl_GetObjResult(interp);\n    Tcl_WideInt v;\n    rc = Tcl_GetWideIntFromObj(interp, pRes, &v);\n    *piRowid = (sqlite3_int64)v;\n  }\n\n  if( rc!=TCL_OK ){\n    tab->zErrMsg = sqlite3_mprintf(\"%s\", Tcl_GetStringResult(pTab->interp));\n    return rc;\n  }\n\n  return SQLITE_OK;\n}\n\n/*\n** A virtual table module that provides read-only access to a\n** Tcl global variable namespace.\n*/\nstatic sqlite3_module tclModule = {\n  0,                         /* iVersion */\n  tclConnect,\n  tclConnect,\n  tclBestIndex,\n  tclDisconnect, \n  tclDisconnect,\n  tclOpen,                      /* xOpen - open a cursor */\n  tclClose,                     /* xClose - close a cursor */\n  tclFilter,                    /* xFilter - configure scan constraints */\n  tclNext,                      /* xNext - advance a cursor */\n  tclEof,                       /* xEof - check for end of scan */\n  tclColumn,                    /* xColumn - read data */\n  tclRowid,                     /* xRowid - read data */\n  0,                           /* xUpdate */\n  0,                           /* xBegin */\n  0,                           /* xSync */\n  0,                           /* xCommit */\n  0,                           /* xRollback */\n  tclFindFunction,             /* xFindFunction */\n  0,                           /* xRename */\n  0,                           /* xSavepoint */\n  0,                           /* xRelease */\n  0,                           /* xRollbackTo */\n  0,                           /* xShadowName */\n  0                            /* xIntegrity */\n};\nstatic sqlite3_module tclModuleUpdate = {\n  0,                         /* iVersion */\n  tclConnect,\n  tclConnect,\n  tclBestIndex,\n  tclDisconnect, \n  tclDisconnect,\n  tclOpen,                      /* xOpen - open a cursor */\n  tclClose,                     /* xClose - close a cursor */\n  tclFilter,                    /* xFilter - configure scan constraints */\n  tclNext,                      /* xNext - advance a cursor */\n  tclEof,                       /* xEof - check for end of scan */\n  tclColumn,                    /* xColumn - read data */\n  tclRowid,                     /* xRowid - read data */\n  tclUpdate,                   /* xUpdate */\n  0,                           /* xBegin */\n  0,                           /* xSync */\n  0,                           /* xCommit */\n  0,                           /* xRollback */\n  tclFindFunction,             /* xFindFunction */\n  0,                           /* xRename */\n  0,                           /* xSavepoint */\n  0,                           /* xRelease */\n  0,                           /* xRollbackTo */\n  0,                           /* xShadowName */\n  0                            /* xIntegrity */\n};\n\n/*\n** Decode a pointer to an sqlite3 object.\n*/\nextern int getDbPointer(Tcl_Interp *interp, const char *zA, sqlite3 **ppDb);\n\nstatic void delTestVtabCtx(void *p){\n  TestVtabContext *pCtx = (TestVtabContext*)p;\n  if( pCtx->pDefault ){\n    Tcl_DecrRefCount(pCtx->pDefault);\n  }\n  ckfree(pCtx);\n}\n\n/*\n** Register the echo virtual table module.\n*/\nstatic int SQLITE_TCLAPI register_tcl_module(\n  ClientData clientData, /* Pointer to sqlite3_enable_XXX function */\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int objc,              /* Number of arguments */\n  Tcl_Obj *CONST objv[]  /* Command arguments */\n){\n  sqlite3 *db;\n  if( objc!=2 && objc!=3 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"DB ?DEFAULT-CMD?\");\n    return TCL_ERROR;\n  }\n  if( getDbPointer(interp, Tcl_GetString(objv[1]), &db) ) return TCL_ERROR;\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  {\n    sqlite3_module *pMod = &tclModule;\n    TestVtabContext *pCtx = (TestVtabContext*)ckalloc(sizeof(TestVtabContext));\n    pCtx->interp = interp;\n    pCtx->pDefault = 0;\n    if( objc==3 ){\n      pCtx->pDefault = objv[2];\n      Tcl_IncrRefCount(pCtx->pDefault);\n    }\n\n    if( objc==3 ){ pMod = &tclModuleUpdate; }\n    sqlite3_create_module_v2(db, \"tcl\", pMod, (void*)pCtx, delTestVtabCtx);\n  }\n#endif\n  return TCL_OK;\n}\n\n#endif\n\n\n/*\n** Register commands with the TCL interpreter.\n*/\nint Sqlitetesttcl_Init(Tcl_Interp *interp){\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  static struct {\n     char *zName;\n     Tcl_ObjCmdProc *xProc;\n     void *clientData;\n  } aObjCmd[] = {\n     { \"register_tcl_module\",   register_tcl_module, 0 },\n  };\n  int i;\n  for(i=0; i<sizeof(aObjCmd)/sizeof(aObjCmd[0]); i++){\n    Tcl_CreateObjCommand(interp, aObjCmd[i].zName, \n        aObjCmd[i].xProc, aObjCmd[i].clientData, 0);\n  }\n#endif\n  return TCL_OK;\n}\n"}
{"repo": "sqlite", "file": "os_setup.h", "lang": "C++", "code": "/*\n** 2013 November 25\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This file contains pre-processor directives related to operating system\n** detection and/or setup.\n*/\n#ifndef SQLITE_OS_SETUP_H\n#define SQLITE_OS_SETUP_H\n\n/*\n** Figure out if we are dealing with Unix, Windows, or some other operating\n** system.\n**\n** After the following block of preprocess macros, all of \n**\n**    SQLITE_OS_KV\n**    SQLITE_OS_OTHER\n**    SQLITE_OS_UNIX\n**    SQLITE_OS_WIN\n**\n** will defined to either 1 or 0. One of them will be 1. The others will be 0.\n** If none of the macros are initially defined, then select either\n** SQLITE_OS_UNIX or SQLITE_OS_WIN depending on the target platform.\n**\n** If SQLITE_OS_OTHER=1 is specified at compile-time, then the application\n** must provide its own VFS implementation together with sqlite3_os_init()\n** and sqlite3_os_end() routines.\n*/\n#if SQLITE_OS_KV+1<=1  && SQLITE_OS_OTHER+1<=1 &&  \\\n    SQLITE_OS_WIN+1<=1 && SQLITE_OS_UNIX+1<=1 \n#  if defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) || \\\n          defined(__MINGW32__) || defined(__BORLANDC__)\n#    define SQLITE_OS_WIN 1\n#    define SQLITE_OS_UNIX 0\n#  else\n#    define SQLITE_OS_WIN 0\n#    define SQLITE_OS_UNIX 1\n#  endif\n#endif\n#if SQLITE_OS_OTHER+1>1\n#  undef SQLITE_OS_KV\n#  define SQLITE_OS_KV 0\n#  undef SQLITE_OS_UNIX\n#  define SQLITE_OS_UNIX 0\n#  undef SQLITE_OS_WIN\n#  define SQLITE_OS_WIN 0\n#endif\n#if SQLITE_OS_KV+1>1\n#  undef SQLITE_OS_OTHER\n#  define SQLITE_OS_OTHER 0\n#  undef SQLITE_OS_UNIX\n#  define SQLITE_OS_UNIX 0\n#  undef SQLITE_OS_WIN\n#  define SQLITE_OS_WIN 0\n#  define SQLITE_OMIT_LOAD_EXTENSION 1\n#  define SQLITE_OMIT_WAL 1\n#  define SQLITE_OMIT_DEPRECATED 1\n#  undef SQLITE_TEMP_STORE\n#  define SQLITE_TEMP_STORE 3  /* Always use memory for temporary storage */\n#  define SQLITE_DQS 0\n#  define SQLITE_OMIT_SHARED_CACHE 1\n#  define SQLITE_OMIT_AUTOINIT 1\n#endif\n#if SQLITE_OS_UNIX+1>1\n#  undef SQLITE_OS_KV\n#  define SQLITE_OS_KV 0\n#  undef SQLITE_OS_OTHER\n#  define SQLITE_OS_OTHER 0\n#  undef SQLITE_OS_WIN\n#  define SQLITE_OS_WIN 0\n#endif\n#if SQLITE_OS_WIN+1>1\n#  undef SQLITE_OS_KV\n#  define SQLITE_OS_KV 0\n#  undef SQLITE_OS_OTHER\n#  define SQLITE_OS_OTHER 0\n#  undef SQLITE_OS_UNIX\n#  define SQLITE_OS_UNIX 0\n#endif\n\n\n#endif /* SQLITE_OS_SETUP_H */\n"}
{"repo": "sqlite", "file": "hash.h", "lang": "C++", "code": "/*\n** 2001 September 22\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This is the header file for the generic hash-table implementation\n** used in SQLite.\n*/\n#ifndef SQLITE_HASH_H\n#define SQLITE_HASH_H\n\n/* Forward declarations of structures. */\ntypedef struct Hash Hash;\ntypedef struct HashElem HashElem;\n\n/* A complete hash table is an instance of the following structure.\n** The internals of this structure are intended to be opaque -- client\n** code should not attempt to access or modify the fields of this structure\n** directly.  Change this structure only by using the routines below.\n** However, some of the \"procedures\" and \"functions\" for modifying and\n** accessing this structure are really macros, so we can't really make\n** this structure opaque.\n**\n** All elements of the hash table are on a single doubly-linked list.\n** Hash.first points to the head of this list.\n**\n** There are Hash.htsize buckets.  Each bucket points to a spot in\n** the global doubly-linked list.  The contents of the bucket are the\n** element pointed to plus the next _ht.count-1 elements in the list.\n**\n** Hash.htsize and Hash.ht may be zero.  In that case lookup is done\n** by a linear search of the global list.  For small tables, the \n** Hash.ht table is never allocated because if there are few elements\n** in the table, it is faster to do a linear search than to manage\n** the hash table.\n*/\nstruct Hash {\n  unsigned int htsize;      /* Number of buckets in the hash table */\n  unsigned int count;       /* Number of entries in this table */\n  HashElem *first;          /* The first element of the array */\n  struct _ht {              /* the hash table */\n    unsigned int count;        /* Number of entries with this hash */\n    HashElem *chain;           /* Pointer to first entry with this hash */\n  } *ht;\n};\n\n/* Each element in the hash table is an instance of the following \n** structure.  All elements are stored on a single doubly-linked list.\n**\n** Again, this structure is intended to be opaque, but it can't really\n** be opaque because it is used by macros.\n*/\nstruct HashElem {\n  HashElem *next, *prev;       /* Next and previous elements in the table */\n  void *data;                  /* Data associated with this element */\n  const char *pKey;            /* Key associated with this element */\n  unsigned int h;              /* hash for pKey */\n};\n\n/*\n** Access routines.  To delete, insert a NULL pointer.\n*/\nvoid sqlite3HashInit(Hash*);\nvoid *sqlite3HashInsert(Hash*, const char *pKey, void *pData);\nvoid *sqlite3HashFind(const Hash*, const char *pKey);\nvoid sqlite3HashClear(Hash*);\n\n/*\n** Macros for looping over all elements of a hash table.  The idiom is\n** like this:\n**\n**   Hash h;\n**   HashElem *p;\n**   ...\n**   for(p=sqliteHashFirst(&h); p; p=sqliteHashNext(p)){\n**     SomeStructure *pData = sqliteHashData(p);\n**     // do something with pData\n**   }\n*/\n#define sqliteHashFirst(H)  ((H)->first)\n#define sqliteHashNext(E)   ((E)->next)\n#define sqliteHashData(E)   ((E)->data)\n/* #define sqliteHashKey(E)    ((E)->pKey) // NOT USED */\n/* #define sqliteHashKeysize(E) ((E)->nKey)  // NOT USED */\n\n/*\n** Number of entries in a hash table\n*/\n#define sqliteHashCount(H)  ((H)->count)\n\n#endif /* SQLITE_HASH_H */\n"}
{"repo": "sqlite", "file": "carray.c", "lang": "C++", "code": "/*\n** 2016-06-29\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file implements a table-valued-function that\n** returns the values in a C-language array.\n** Examples:\n**\n**      SELECT * FROM carray($ptr,5)\n**\n** The query above returns 5 integers contained in a C-language array\n** at the address $ptr.  $ptr is a pointer to the array of integers.\n** The pointer value must be assigned to $ptr using the\n** sqlite3_bind_pointer() interface with a pointer type of \"carray\".\n** For example:\n**\n**    static int aX[] = { 53, 9, 17, 2231, 4, 99 };\n**    int i = sqlite3_bind_parameter_index(pStmt, \"$ptr\");\n**    sqlite3_bind_pointer(pStmt, i, aX, \"carray\", 0);\n**\n** There is an optional third parameter to determine the datatype of\n** the C-language array.  Allowed values of the third parameter are\n** 'int32', 'int64', 'double', 'char*', 'struct iovec'.  Example:\n**\n**      SELECT * FROM carray($ptr,10,'char*');\n**\n** The default value of the third parameter is 'int32'.\n**\n** HOW IT WORKS\n**\n** The carray \"function\" is really a virtual table with the\n** following schema:\n**\n**     CREATE TABLE carray(\n**       value,\n**       pointer HIDDEN,\n**       count HIDDEN,\n**       ctype TEXT HIDDEN\n**     );\n**\n** If the hidden columns \"pointer\" and \"count\" are unconstrained, then \n** the virtual table has no rows.  Otherwise, the virtual table interprets\n** the integer value of \"pointer\" as a pointer to the array and \"count\"\n** as the number of elements in the array.  The virtual table steps through\n** the array, element by element.\n*/\n#if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_CARRAY)\n#include \"sqliteInt.h\"\n#if defined(_WIN32) || defined(__RTP__) || defined(_WRS_KERNEL)\n  struct iovec {\n    void *iov_base;\n    size_t iov_len;\n  };\n#else\n# include <sys/uio.h>\n#endif\n\n/*\n** Names of allowed datatypes\n*/\nstatic const char *azCarrayType[] = {\n  \"int32\", \"int64\", \"double\", \"char*\", \"struct iovec\"\n};\n\n/*\n** Structure used to hold the sqlite3_carray_bind() information\n*/\ntypedef struct carray_bind carray_bind;\nstruct carray_bind {\n  void *aData;                /* The data */\n  int nData;                  /* Number of elements */\n  int mFlags;                 /* Control flags */\n  void (*xDel)(void*);        /* Destructor for aData */\n  void *pDel;                 /* Alternative argument to xDel() */\n};\n\n\n/* carray_cursor is a subclass of sqlite3_vtab_cursor which will\n** serve as the underlying representation of a cursor that scans\n** over rows of the result\n*/\ntypedef struct carray_cursor carray_cursor;\nstruct carray_cursor {\n  sqlite3_vtab_cursor base;  /* Base class - must be first */\n  sqlite3_int64 iRowid;      /* The rowid */\n  void *pPtr;                /* Pointer to the array of values */\n  sqlite3_int64 iCnt;        /* Number of integers in the array */\n  unsigned char eType;       /* One of the CARRAY_type values */\n};\n\n/*\n** The carrayConnect() method is invoked to create a new\n** carray_vtab that describes the carray virtual table.\n**\n** Think of this routine as the constructor for carray_vtab objects.\n**\n** All this routine needs to do is:\n**\n**    (1) Allocate the carray_vtab object and initialize all fields.\n**\n**    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the\n**        result set of queries against carray will look like.\n*/\nstatic int carrayConnect(\n  sqlite3 *db,\n  void *pAux,\n  int argc, const char *const*argv,\n  sqlite3_vtab **ppVtab,\n  char **pzErr\n){\n  sqlite3_vtab *pNew;\n  int rc;\n\n/* Column numbers */\n#define CARRAY_COLUMN_VALUE   0\n#define CARRAY_COLUMN_POINTER 1\n#define CARRAY_COLUMN_COUNT   2\n#define CARRAY_COLUMN_CTYPE   3\n\n  rc = sqlite3_declare_vtab(db,\n     \"CREATE TABLE x(value,pointer hidden,count hidden,ctype hidden)\");\n  if( rc==SQLITE_OK ){\n    pNew = *ppVtab = sqlite3_malloc( sizeof(*pNew) );\n    if( pNew==0 ) return SQLITE_NOMEM;\n    memset(pNew, 0, sizeof(*pNew));\n  }\n  return rc;\n}\n\n/*\n** This method is the destructor for carray_cursor objects.\n*/\nstatic int carrayDisconnect(sqlite3_vtab *pVtab){\n  sqlite3_free(pVtab);\n  return SQLITE_OK;\n}\n\n/*\n** Constructor for a new carray_cursor object.\n*/\nstatic int carrayOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){\n  carray_cursor *pCur;\n  pCur = sqlite3_malloc( sizeof(*pCur) );\n  if( pCur==0 ) return SQLITE_NOMEM;\n  memset(pCur, 0, sizeof(*pCur));\n  *ppCursor = &pCur->base;\n  return SQLITE_OK;\n}\n\n/*\n** Destructor for a carray_cursor.\n*/\nstatic int carrayClose(sqlite3_vtab_cursor *cur){\n  sqlite3_free(cur);\n  return SQLITE_OK;\n}\n\n\n/*\n** Advance a carray_cursor to its next row of output.\n*/\nstatic int carrayNext(sqlite3_vtab_cursor *cur){\n  carray_cursor *pCur = (carray_cursor*)cur;\n  pCur->iRowid++;\n  return SQLITE_OK;\n}\n\n/*\n** Return values of columns for the row at which the carray_cursor\n** is currently pointing.\n*/\nstatic int carrayColumn(\n  sqlite3_vtab_cursor *cur,   /* The cursor */\n  sqlite3_context *ctx,       /* First argument to sqlite3_result_...() */\n  int i                       /* Which column to return */\n){\n  carray_cursor *pCur = (carray_cursor*)cur;\n  sqlite3_int64 x = 0;\n  switch( i ){\n    case CARRAY_COLUMN_POINTER:   return SQLITE_OK;\n    case CARRAY_COLUMN_COUNT:     x = pCur->iCnt;   break;\n    case CARRAY_COLUMN_CTYPE: {\n      sqlite3_result_text(ctx, azCarrayType[pCur->eType], -1, SQLITE_STATIC);\n      return SQLITE_OK;\n    }\n    default: {\n      switch( pCur->eType ){\n        case CARRAY_INT32: {\n          int *p = (int*)pCur->pPtr;\n          sqlite3_result_int(ctx, p[pCur->iRowid-1]);\n          return SQLITE_OK;\n        }\n        case CARRAY_INT64: {\n          sqlite3_int64 *p = (sqlite3_int64*)pCur->pPtr;\n          sqlite3_result_int64(ctx, p[pCur->iRowid-1]);\n          return SQLITE_OK;\n        }\n        case CARRAY_DOUBLE: {\n          double *p = (double*)pCur->pPtr;\n          sqlite3_result_double(ctx, p[pCur->iRowid-1]);\n          return SQLITE_OK;\n        }\n        case CARRAY_TEXT: {\n          const char **p = (const char**)pCur->pPtr;\n          sqlite3_result_text(ctx, p[pCur->iRowid-1], -1, SQLITE_TRANSIENT);\n          return SQLITE_OK;\n        }\n        default: {\n          const struct iovec *p = (struct iovec*)pCur->pPtr;\n          assert( pCur->eType==CARRAY_BLOB );\n          sqlite3_result_blob(ctx, p[pCur->iRowid-1].iov_base,\n                              (int)p[pCur->iRowid-1].iov_len, SQLITE_TRANSIENT);\n          return SQLITE_OK;\n        }\n      }\n    }\n  }\n  sqlite3_result_int64(ctx, x);\n  return SQLITE_OK;\n}\n\n/*\n** Return the rowid for the current row.  In this implementation, the\n** rowid is the same as the output value.\n*/\nstatic int carrayRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){\n  carray_cursor *pCur = (carray_cursor*)cur;\n  *pRowid = pCur->iRowid;\n  return SQLITE_OK;\n}\n\n/*\n** Return TRUE if the cursor has been moved off of the last\n** row of output.\n*/\nstatic int carrayEof(sqlite3_vtab_cursor *cur){\n  carray_cursor *pCur = (carray_cursor*)cur;\n  return pCur->iRowid>pCur->iCnt;\n}\n\n/*\n** This method is called to \"rewind\" the carray_cursor object back\n** to the first row of output.\n*/\nstatic int carrayFilter(\n  sqlite3_vtab_cursor *pVtabCursor, \n  int idxNum, const char *idxStr,\n  int argc, sqlite3_value **argv\n){\n  carray_cursor *pCur = (carray_cursor *)pVtabCursor;\n  pCur->pPtr = 0;\n  pCur->iCnt = 0;\n  switch( idxNum ){\n    case 1: {\n      carray_bind *pBind = sqlite3_value_pointer(argv[0], \"carray-bind\");\n      if( pBind==0 ) break;\n      pCur->pPtr = pBind->aData;\n      pCur->iCnt = pBind->nData;\n      pCur->eType = pBind->mFlags & 0x07;\n      break;\n    }\n    case 2:\n    case 3: {\n      pCur->pPtr = sqlite3_value_pointer(argv[0], \"carray\");\n      pCur->iCnt = pCur->pPtr ? sqlite3_value_int64(argv[1]) : 0;\n      if( idxNum<3 ){\n        pCur->eType = CARRAY_INT32;\n      }else{\n        unsigned char i;\n        const char *zType = (const char*)sqlite3_value_text(argv[2]);\n        for(i=0; i<sizeof(azCarrayType)/sizeof(azCarrayType[0]); i++){\n          if( sqlite3_stricmp(zType, azCarrayType[i])==0 ) break;\n        }\n        if( i>=sizeof(azCarrayType)/sizeof(azCarrayType[0]) ){\n          pVtabCursor->pVtab->zErrMsg = sqlite3_mprintf(\n            \"unknown datatype: %Q\", zType);\n          return SQLITE_ERROR;\n        }else{\n          pCur->eType = i;\n        }\n      }\n      break;\n    }\n  }\n  pCur->iRowid = 1;\n  return SQLITE_OK;\n}\n\n/*\n** SQLite will invoke this method one or more times while planning a query\n** that uses the carray virtual table.  This routine needs to create\n** a query plan for each invocation and compute an estimated cost for that\n** plan.\n**\n** In this implementation idxNum is used to represent the\n** query plan.  idxStr is unused.\n**\n** idxNum is:\n**\n**    1    If only the pointer= constraint exists.  In this case, the\n**         parameter must be bound using sqlite3_carray_bind().\n**\n**    2    if the pointer= and count= constraints exist.\n**\n**    3    if the ctype= constraint also exists.\n**\n** idxNum is 0 otherwise and carray becomes an empty table.\n*/\nstatic int carrayBestIndex(\n  sqlite3_vtab *tab,\n  sqlite3_index_info *pIdxInfo\n){\n  int i;                 /* Loop over constraints */\n  int ptrIdx = -1;       /* Index of the pointer= constraint, or -1 if none */\n  int cntIdx = -1;       /* Index of the count= constraint, or -1 if none */\n  int ctypeIdx = -1;     /* Index of the ctype= constraint, or -1 if none */\n  unsigned seen = 0;     /* Bitmask of == constrainted columns */\n\n  const struct sqlite3_index_constraint *pConstraint;\n  pConstraint = pIdxInfo->aConstraint;\n  for(i=0; i<pIdxInfo->nConstraint; i++, pConstraint++){\n    if( pConstraint->op!=SQLITE_INDEX_CONSTRAINT_EQ ) continue;\n    if( pConstraint->iColumn>=0 ) seen |= 1 << pConstraint->iColumn;\n    if( pConstraint->usable==0 ) continue;\n    switch( pConstraint->iColumn ){\n      case CARRAY_COLUMN_POINTER:\n        ptrIdx = i;\n        break;\n      case CARRAY_COLUMN_COUNT:\n        cntIdx = i;\n        break;\n      case CARRAY_COLUMN_CTYPE:\n        ctypeIdx = i;\n        break;\n    }\n  }\n  if( ptrIdx>=0 ){\n    pIdxInfo->aConstraintUsage[ptrIdx].argvIndex = 1;\n    pIdxInfo->aConstraintUsage[ptrIdx].omit = 1;\n    pIdxInfo->estimatedCost = (double)1;\n    pIdxInfo->estimatedRows = 100;\n    pIdxInfo->idxNum = 1;\n    if( cntIdx>=0 ){\n      pIdxInfo->aConstraintUsage[cntIdx].argvIndex = 2;\n      pIdxInfo->aConstraintUsage[cntIdx].omit = 1;\n      pIdxInfo->idxNum = 2;\n      if( ctypeIdx>=0 ){\n        pIdxInfo->aConstraintUsage[ctypeIdx].argvIndex = 3;\n        pIdxInfo->aConstraintUsage[ctypeIdx].omit = 1;\n        pIdxInfo->idxNum = 3;\n      }else if( seen & (1<<CARRAY_COLUMN_CTYPE) ){\n        /* In a three-argument carray(), we need to know the value of all\n        ** three arguments */\n        return SQLITE_CONSTRAINT;\n      }\n    }else if( seen & (1<<CARRAY_COLUMN_COUNT) ){\n      /* In a two-argument carray(), we need to know the value of both\n      ** arguments */\n      return SQLITE_CONSTRAINT;\n    }\n  }else{\n    pIdxInfo->estimatedCost = (double)2147483647;\n    pIdxInfo->estimatedRows = 2147483647;\n    pIdxInfo->idxNum = 0;\n  }\n  return SQLITE_OK;\n}\n\n/*\n** This following structure defines all the methods for the \n** carray virtual table.\n*/\nstatic sqlite3_module carrayModule = {\n  0,                         /* iVersion */\n  0,                         /* xCreate */\n  carrayConnect,             /* xConnect */\n  carrayBestIndex,           /* xBestIndex */\n  carrayDisconnect,          /* xDisconnect */\n  0,                         /* xDestroy */\n  carrayOpen,                /* xOpen - open a cursor */\n  carrayClose,               /* xClose - close a cursor */\n  carrayFilter,              /* xFilter - configure scan constraints */\n  carrayNext,                /* xNext - advance a cursor */\n  carrayEof,                 /* xEof - check for end of scan */\n  carrayColumn,              /* xColumn - read data */\n  carrayRowid,               /* xRowid - read data */\n  0,                         /* xUpdate */\n  0,                         /* xBegin */\n  0,                         /* xSync */\n  0,                         /* xCommit */\n  0,                         /* xRollback */\n  0,                         /* xFindMethod */\n  0,                         /* xRename */\n  0,                         /* xSavepoint */\n  0,                         /* xRelease */\n  0,                         /* xRollbackTo */\n  0,                         /* xShadow */\n  0                          /* xIntegrity */\n};\n\n/*\n** Destructor for the carray_bind object\n*/\nstatic void carrayBindDel(void *pPtr){\n  carray_bind *p = (carray_bind*)pPtr;\n  if( p->xDel!=SQLITE_STATIC ){\n    p->xDel(p->pDel);\n  }\n  sqlite3_free(p);\n}\n\n/*\n** Invoke this interface in order to bind to the single-argument\n** version of CARRAY().\n**\n**    pStmt        The prepared statement to which to bind\n**    idx          The index of the parameter of pStmt to which to bind\n**    aData        The data to be bound\n**    nData        The number of elements in aData\n**    mFlags       One of SQLITE_CARRAY_xxxx indicating datatype of aData\n**    xDestroy     Destructor for pDestroy or aData if pDestroy==NULL.\n**    pDestroy     Invoke xDestroy on this pointer if not NULL\n**\n** The destructor is called pDestroy if pDestroy!=NULL, or against\n** aData if pDestroy==NULL.\n*/\nSQLITE_API int sqlite3_carray_bind_v2(\n  sqlite3_stmt *pStmt,\n  int idx,\n  void *aData,\n  int nData,\n  int mFlags,\n  void (*xDestroy)(void*),\n  void *pDestroy\n){\n  carray_bind *pNew = 0;\n  int i;\n  int rc = SQLITE_OK;\n  \n  /* Ensure that the mFlags value is acceptable. */\n  assert( CARRAY_INT32==0 && CARRAY_INT64==1 && CARRAY_DOUBLE==2 );\n  assert( CARRAY_TEXT==3 && CARRAY_BLOB==4 );\n  if( mFlags<CARRAY_INT32 || mFlags>CARRAY_BLOB ){\n    rc = SQLITE_ERROR;\n    goto carray_bind_error;\n  }\n\n  pNew = sqlite3_malloc64(sizeof(*pNew));\n  if( pNew==0 ){\n    rc = SQLITE_NOMEM;\n    goto carray_bind_error;\n  }\n\n  pNew->nData = nData;\n  pNew->mFlags = mFlags;\n  if( xDestroy==SQLITE_TRANSIENT ){\n    sqlite3_int64 sz = nData;\n    switch( mFlags ){\n      case CARRAY_INT32:   sz *= 4;                     break;\n      case CARRAY_INT64:   sz *= 8;                     break;\n      case CARRAY_DOUBLE:  sz *= 8;                     break;\n      case CARRAY_TEXT:    sz *= sizeof(char*);         break;\n      default:             sz *= sizeof(struct iovec);  break;\n    }\n    if( mFlags==CARRAY_TEXT ){\n      for(i=0; i<nData; i++){\n        const char *z = ((char**)aData)[i];\n        if( z ) sz += strlen(z) + 1;\n      }\n    }else if( mFlags==CARRAY_BLOB ){\n      for(i=0; i<nData; i++){\n        sz += ((struct iovec*)aData)[i].iov_len;\n      }\n    } \n\n    pNew->aData = sqlite3_malloc64( sz );\n    if( pNew->aData==0 ){\n      rc = SQLITE_NOMEM;\n      goto carray_bind_error;\n    }\n\n    if( mFlags==CARRAY_TEXT ){\n      char **az = (char**)pNew->aData;\n      char *z = (char*)&az[nData];\n      for(i=0; i<nData; i++){\n        const char *zData = ((char**)aData)[i];\n        sqlite3_int64 n;\n        if( zData==0 ){\n          az[i] = 0;\n          continue;\n        }\n        az[i] = z;\n        n = strlen(zData);\n        memcpy(z, zData, n+1);\n        z += n+1;\n      }\n    }else if( mFlags==CARRAY_BLOB ){\n      struct iovec *p = (struct iovec*)pNew->aData;\n      unsigned char *z = (unsigned char*)&p[nData];\n      for(i=0; i<nData; i++){\n        size_t n = ((struct iovec*)aData)[i].iov_len;\n        p[i].iov_len = n;\n        p[i].iov_base = z;\n        z += n;\n        memcpy(p[i].iov_base, ((struct iovec*)aData)[i].iov_base, n);\n      }\n    }else{\n      memcpy(pNew->aData, aData, sz);\n    }\n    pNew->xDel = sqlite3_free;\n    pNew->pDel = pNew->aData;\n  }else{\n    pNew->aData = aData;\n    pNew->xDel = xDestroy;\n    pNew->pDel = pDestroy;\n  }\n  return sqlite3_bind_pointer(pStmt, idx, pNew, \"carray-bind\", carrayBindDel);\n \n carray_bind_error:\n  if( xDestroy!=SQLITE_STATIC && xDestroy!=SQLITE_TRANSIENT ){\n    xDestroy(pDestroy);\n  }\n  sqlite3_free(pNew);\n  return rc;\n}\n\n/*\n** Invoke this interface in order to bind to the single-argument\n** version of CARRAY().  Same as sqlite3_carray_bind_v2() with the\n** pDestroy parameter set to NULL.\n*/\nSQLITE_API int sqlite3_carray_bind(\n  sqlite3_stmt *pStmt,\n  int idx,\n  void *aData,\n  int nData,\n  int mFlags,\n  void (*xDestroy)(void*)\n){\n  return sqlite3_carray_bind_v2(pStmt,idx,aData,nData,mFlags,xDestroy,aData);\n}\n\n/*\n** Invoke this routine to register the carray() function.\n*/\nModule *sqlite3CarrayRegister(sqlite3 *db){\n  return sqlite3VtabCreateModule(db, \"carray\", &carrayModule, 0, 0);\n}\n\n#endif /* !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_CARRAY) */\n"}
